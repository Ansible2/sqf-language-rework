import { IJSON, SQFGrammarType } from "../SQFParser.namespace";

export const SQFGrammarTypeMap: IJSON<SQFGrammarType> = {
	'if': SQFGrammarType.ConrolStatement,
	apply: SQFGrammarType.ConrolStatement,
	foreach: SQFGrammarType.ConrolStatement,
	or: SQFGrammarType.ConditionOperator,
	private: SQFGrammarType.AccessModifier,
	'%': SQFGrammarType.ManipulativeOperator,
	'==': SQFGrammarType.ComparisonOperator,
	'!': SQFGrammarType.ConditionOperator,
	not: SQFGrammarType.ConditionOperator,
	controlnull: SQFGrammarType.NullLiteral,
	displaynull: SQFGrammarType.NullLiteral,
	diaryrecordnull: SQFGrammarType.NullLiteral,
	netobjnull: SQFGrammarType.NullLiteral,
	grpnull: SQFGrammarType.NullLiteral,
	locationnull: SQFGrammarType.NullLiteral,
	nil: SQFGrammarType.NullLiteral,
	objnull: SQFGrammarType.NullLiteral,
	scriptnull: SQFGrammarType.NullLiteral,
	tasknull: SQFGrammarType.NullLiteral,
	teammembernull: SQFGrammarType.NullLiteral,
	confignull: SQFGrammarType.NullLiteral,
	switch: SQFGrammarType.ConrolStatement,
	try: SQFGrammarType.ConrolStatement,
	catch: SQFGrammarType.ConrolStatement,
	case: SQFGrammarType.ConrolStatement,
	for: SQFGrammarType.ConrolStatement,
	step: SQFGrammarType.ConrolStatement,
	break: SQFGrammarType.ConrolStatement,
	default: SQFGrammarType.ConrolStatement,
	breakOut: SQFGrammarType.ConrolStatement,
	breakTo: SQFGrammarType.ConrolStatement,
	breakWith: SQFGrammarType.ConrolStatement,
	continue: SQFGrammarType.ConrolStatement,
	continueWith: SQFGrammarType.ConrolStatement,
	else: SQFGrammarType.ConrolStatement,
	exit: SQFGrammarType.ConrolStatement,
	forEachMemberTeam: SQFGrammarType.ConrolStatement,
	exitWith: SQFGrammarType.ConrolStatement,
	sleep: SQFGrammarType.ConrolStatement,
	uisleep: SQFGrammarType.ConrolStatement,
	then: SQFGrammarType.ConrolStatement,
	throw: SQFGrammarType.ConrolStatement,
	to: SQFGrammarType.ConrolStatement,
	waitUntil: SQFGrammarType.ConrolStatement,
	with: SQFGrammarType.ConrolStatement,
	halt: SQFGrammarType.ConrolStatement,
	while: SQFGrammarType.ConrolStatement,
	goto: SQFGrammarType.ConrolStatement,
	assert: SQFGrammarType.ConrolStatement,
	do: SQFGrammarType.ConrolStatement,
	terminate: SQFGrammarType.ConrolStatement,
	forEachMemberAgent: SQFGrammarType.ConrolStatement,
	from: SQFGrammarType.ConrolStatement,
	get: SQFGrammarType.PropertyAccessor,
	set: SQFGrammarType.PropertyAccessor,
	select: SQFGrammarType.PropertyAccessor,
	getordefault: SQFGrammarType.PropertyAccessor,
	getordefaultcall: SQFGrammarType.PropertyAccessor,
	'#': SQFGrammarType.PropertyAccessor,
	insert: SQFGrammarType.PropertyAccessor,
	this: SQFGrammarType.ReservedLiteral,
	_this: SQFGrammarType.ReservedLiteral,
	_x: SQFGrammarType.ReservedLiteral,
	_forEachIndex: SQFGrammarType.ReservedLiteral,
	_exception: SQFGrammarType.ReservedLiteral,
	_thisScript: SQFGrammarType.ReservedLiteral,
	_thisFSM: SQFGrammarType.ReservedLiteral,
	thisList: SQFGrammarType.ReservedLiteral,
	thisTrigger: SQFGrammarType.ReservedLiteral,
	west: SQFGrammarType.ReservedLiteral,
	east: SQFGrammarType.ReservedLiteral,
	resistance: SQFGrammarType.ReservedLiteral,
	civilian: SQFGrammarType.ReservedLiteral,
	independent: SQFGrammarType.ReservedLiteral,
	blufor: SQFGrammarType.ReservedLiteral,
	opfor: SQFGrammarType.ReservedLiteral,
	compile: SQFGrammarType.StringCompiler,
	compilescript: SQFGrammarType.FileCompiler,
	compilefinal: SQFGrammarType.StringCompiler,
	exec: SQFGrammarType.FileExecutor,
	execFSM: SQFGrammarType.FileExecutor,
	execVM: SQFGrammarType.FileExecutor,
	preprocessFile: SQFGrammarType.FileCompiler,
	loadfile: SQFGrammarType.FileCompiler,
	preprocessFileLineNumbers: SQFGrammarType.FileCompiler,
}