[
  {
    "text": "#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_addIcon\n\nDescription:\n    Adds and icon to the compass\n\nParameters:\n    0: _iconId <STRING> - A unique id for referencing the compass marker\n    1: _iconText <STRING> - The icon's image path or text\n    2: _iconPos <ARRAY, OBJECT, MARKER, or LOCATION> - The position of the icon\n    3: _color <ARRAY> - The RGBa of the icon\n    4: _isActive <BOOL> - Icon will use \"active\" scale of icon\n\nReturns:\n    <BOOL> - false if new iconId, true if overwriting the icon id\n\nExamples:\n    (begin example)\n        [\n            \"myMarkerID\"\n            \"images\\info_icon.paa\"\n        ] call KISKA_fnc_compass_addIcon;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_addIcon\";\n\nparams [\n    [\"_iconId\",\"\",[\"\"]],\n    [\"_iconText\",\"\",[\"\"]],\n    [\"_iconPos\",[0,0,0],[[],objNull,\"\",locationNull]],\n    [\"_color\",[1,1,1,1],[[]],4],\n    [\"_isActive\",true,[true]]\n];\n\n\nprivate _hashMap = GET_COMPASS_ICON_MAP_DEFAULT;\nprivate _overWritten = _hashMap set [_iconId,\n    [\n        _iconText,\n        _iconPos,\n        _color,\n        _isActive,\n        controlNull\n    ]\n];\n\nif (isNil {GET_COMPASS_ICON_MAP}) then {\n    localNamespace setVariable [COMPASS_ICON_MAP_VAR_STR,_hashMap];\n};\n\n\n_overWritten\n",
    "fileName": "fn_compass_addIcon.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Compass/Functions/fn_compass_addIcon.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass IDCs.hpp\"\n#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_configure\n\nDescription:\n    Initializes several display namespace variables for the compass and sets\n     up their images for the compass.\n\nParameters:\n    0: _display <DISPLAY> - The display of the compass\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_configure;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_configure\";\n\nif (!hasInterface) exitWith {};\n\ndisableSerialization;\n\nparams [\n    [\"_display\",displayNull]\n];\n\nif (isNull _display) exitWith {};\n\n\nlocalNamespace setVariable [COMPASS_DISPLAY_VAR_STR,_display];\n\nprivate _mainCompassCtrlGroup = _display displayCtrl COMPASS_GRP_IDC;\n_display setVariable [COMPASS_MAIN_CTRL_GRP_VAR_STR,_mainCompassCtrlGroup];\n\nprivate _compassImageCtrl = _mainCompassCtrlGroup controlsGroupCtrl COMPASS_IMG_IDC;\n_display setVariable [COMPASS_IMAGE_CTRL_VAR_STR,_compassImageCtrl];\n\nprivate _compassBackgroundCtrl = _mainCompassCtrlGroup controlsGroupCtrl COMPASS_BACK_IDC;\n_display setVariable [COMPASS_BACKGROUND_CTRL_VAR_STR,_compassBackgroundCtrl];\n\nprivate _compassCenterMarkersCtrl = _mainCompassCtrlGroup controlsGroupCtrl COMPASS_CENTER_IDC;\n_display setVariable [COMPASS_CENTER_MARKERS_CTRL_VAR_STR,_compassCenterMarkersCtrl];\n\n\n\n[\n    [ _mainCompassCtrlGroup, true ],\n    [ _compassImageCtrl, false, KISKA_compass_mainColor, KISKA_compass_image ],\n    [ _compassBackgroundCtrl, false, KISKA_compass_backgroundColor, \"#(rgb,8,8,3)color(1,1,1,1)\" ],\n    [ _compassCenterMarkersCtrl, false, KISKA_compass_centerColor, KISKA_compass_center_image ]\n] apply {\n    _x params [\n        \"_ctrl\",\n        \"_changePos\",\n        [ \"_color\", [1,1,1,1] ],\n        [ \"_image\", \"\" ]\n    ];\n\n\n    (ctrlPosition _ctrl) params[ \"_ctrlX\", \"_ctrlY\", \"_ctrlW\", \"_ctrlH\" ];\n    if (_ctrlW isEqualTo 0) then {\n        _ctrlW = KISKA_compass_widthScale * pixelW;\n    };\n\n\n    // ctrlSetScale cuts off the image (I don't know why for now, so using this scaling instead)\n    // ctrlSetScale also scales in such a way that is not ideal for the compass\n    _ctrlW = _ctrlW * KISKA_compass_scale;\n    _ctrlH = _ctrlH * KISKA_compass_scale;\n    if ( _changePos ) then {\n        _ctrlX = ( safeZoneX + ( safeZoneW / 2 ) - ( _ctrlW / 2 ) );\n        _ctrlY = safeZoneY + ((pixelH * pixelGrid) * KISKA_compass_y_offset)\n    };\n\n    // using ctrlSetPosition instead of individual commands because setting them with those causes the compass to be offset from center\n    _ctrl ctrlSetPosition [_ctrlX,_ctrlY,_ctrlW,_ctrlH];\n    _ctrl ctrlCommit 0;\n\n\n    if ( _image isNotEqualTo \"\" ) then {\n        _ctrl ctrlSetText _image;\n        _ctrl ctrlSetTextColor _color;\n    };\n\n};\n\n\nprivate _mainCtrlGrp_pos = ctrlPosition _mainCompassCtrlGroup;\n_display setVariable [COMPASS_MAIN_CTRL_GRP_POS_VAR_STR,_mainCtrlGrp_pos];\n\n\n// position center marker at the center of the control group\nprivate _mainCtrlGrp_posX_by2 = (_mainCtrlGrp_pos select 2) / 2;\n(ctrlPosition _compassCenterMarkersCtrl) params[ \"\", \"_ctrlY\", \"_ctrlW\", \"\" ];\n_compassCenterMarkersCtrl ctrlSetPosition[ _mainCtrlGrp_posX_by2 - ( _ctrlW / 2 ), _ctrlY  ];\n_compassCenterMarkersCtrl ctrlCommit 0;\n\n\n_display setVariable [COMPASS_CONFIGED_VAR_STR,true];\n",
    "fileName": "fn_compass_configure.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Compass/Functions/fn_compass_configure.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass IDCs.hpp\"\n#include \"..\\Headers\\Icon Info Indexes.hpp\"\n#include \"..\\Headers\\Compass Globals.hpp\"\n#include \"..\\Headers\\Compass Image Resolutions.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_mainLoop\n\nDescription:\n    Creates and then continues to execute a loop controlling the compass.\n\nParameters:\n    0: _display <DISPLAY> - The display the compass will be on\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [findDisplay 46] spawn KISKA_fnc_compass_mainLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_mainLoop\";\n\n#define INACTIVE_IDC -1\n#define SIMPLIFY_ANGLE(angle) (((angle) % 360) + 360) % 360;\n\nif (!hasInterface) exitWith {};\n\n// check if main menu\nif (call KISKA_fnc_isMainMenu) exitWith {};\n\ndisableSerialization;\n\nparams [\n    [\"_display\",displayNull,[displayNull]]\n];\n\n\n_display displayAddEventHandler [\"Unload\", {\n    localNamespace setVariable [COMPASS_DISPLAY_VAR_STR,displayNull];\n}];\n\nprivate [\n    \"_ctrlGrp\",\n    \"_compass\",\n    \"_cameraVectorDir\",\n    \"_cameraHeading\",\n    \"_posX\",\n    \"_grpW\",\n    \"_grpWDivided\",\n    \"_ctrlPos\",\n    \"_iconMap\",\n    \"_iconWidth\",\n    \"_iconHeight\",\n    \"_iconControl\",\n    \"_iconColor\",\n    \"_iconText\",\n    \"_iconPos\",\n    \"_iconWidthDivided\",\n    \"_camDirTo\",\n    \"_opposite\"\n];\n\n\nwaitUntil {\n    if (!KISKA_compass_show OR (isNull _display)) exitWith {true};\n\n    if !( _display getVariable [COMPASS_CONFIGED_VAR_STR,false] ) then {\n        [ _display ] call KISKA_fnc_compass_configure;\n    };\n\n    _ctrlGrp = _display getVariable COMPASS_MAIN_CTRL_GRP_VAR_STR;\n    _compass = _display getVariable COMPASS_IMAGE_CTRL_VAR_STR;\n\n    _cameraVectorDir = getCameraViewDirection player;\n    _cameraHeading = SIMPLIFY_ANGLE((_cameraVectorDir select 0) atan2 (_cameraVectorDir select 1));\n    // convert heading to actual pixel position of compass control\n    _posX = linearConversion[ 0, 360, _cameraHeading, KISKA_compass_pixelX_min, KISKA_compass_pixelX_max, true ];\n\n    _compass ctrlSetPositionX -( _posX * pixelW ); // scroll the compass\n    _compass ctrlCommit 0;\n\n\n\n    // draw icons\n    _iconMap = localNamespace getVariable [COMPASS_ICON_MAP_VAR_STR,[]];\n    if (KISKA_compass_showIcons AND {(count _iconMap) > 0}) then {\n        _ctrlPos = _display getVariable COMPASS_MAIN_CTRL_GRP_POS_VAR_STR;\n        _grpW = _ctrlPos select 2;\n        _grpWDivided = _grpW / 2;\n\n\n        _iconMap apply {\n\n            _iconPos = _y select ICON_POS;\n            call {\n                if (_iconPos isEqualType []) exitWith {\n                    _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _iconPos));\n                };\n\n                if (_iconPos isEqualType objNull AND {!( isNull _iconPos )}) exitWith {\n                    _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _iconPos));\n                };\n\n                if (_iconPos isEqualType locationNull AND {!( isNull _iconPos )}) exitWith {\n                    private _locationPos = locationPosition _iconPos;\n                    _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _locationPos));\n                };\n\n                if (_iconPos isEqualType \"\") exitWith {\n                    private _markerPos = getMarkerPos _iconPos;\n                    if ( _markerPos isNotEqualTo [0,0,0] ) then {\n                        _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _markerPos));\n                    };\n                };\n\n                _camDirTo = nil;\n            };\n\n            _iconControl = _y select ICON_CTRL;\n            // only update if actually visible on compass range\n            if (\n                !(isNil \"_camDirTo\") AND\n                {\n                    (_camDirTo >= KISKA_compass_iconAngle_max) OR\n                    {_camDirTo <= KISKA_compass_iconAngle_min}\n                }\n            ) then {\n                private _iconActive = _y select ICON_ACTIVE;\n                _iconWidth = [KISKA_compass_iconWidth_inactive,KISKA_compass_iconWidth_active] select _iconActive;\n\n                _iconWidthDivided = _iconWidth / 2;\n                _iconText = _y select ICON_TEXT; // this is the icon's picture path\n                _iconColor = _y select ICON_COLOR;\n\n\n                if (isNull _iconControl) then {\n                    _iconControl = _display ctrlCreate [ \"ctrlActivePicture\", INACTIVE_IDC, _ctrlGrp ];\n\n                    _iconHeight = [KISKA_compass_iconHeight_inactive,KISKA_compass_iconHeight_active] select _iconActive;\n                    private _grpH = _ctrlPos select 3;\n                    _iconControl ctrlSetPosition [_grpWDivided - _iconWidthDivided, _grpH - _iconHeight, _iconWidth, _iconHeight];\n\n                    _iconControl ctrlSetText _iconText;\n                    _iconControl ctrlSetTextColor _iconColor;\n\n                    _iconControl ctrlCommit 0;\n                    _y set [ ICON_CTRL, _iconControl ];\n\n                } else {\n                    if !(ctrlShown _iconControl) then {\n                        _iconControl ctrlShow true;\n                    };\n\n                    if ( (ctrlText _iconControl) isNotEqualTo _iconText) then {\n                        _iconControl ctrlSetText _iconText;\n                    };\n\n                    if ( (ctrlTextColor _iconControl) isNotEqualTo _iconColor) then {\n                        _iconControl ctrlSetTextColor _iconColor;\n                    };\n\n                    // get the opposite angle\n                    _opposite = SIMPLIFY_ANGLE(-_camDirTo + 180);\n                    _posX = linearConversion[ KISKA_compass_shownAngle_min, KISKA_compass_shownAngle_max, _opposite, 0, _grpW, true ];\n                //    hintSilent ([_camDirTo,_opposite,KISKA_compass_shownAngle_max,KISKA_compass_shownAngle_min] joinString \"\\n\");\n                    _iconControl ctrlSetPositionX (_posX - _iconWidthDivided);\n                    _iconControl ctrlCommit 0;\n\n                };\n            } else {\n                if (ctrlShown _iconControl) then {\n                    _iconControl ctrlShow false;\n                };\n\n            };\n\n        };\n    };\n\n\n    false\n};\n",
    "fileName": "fn_compass_mainLoop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Compass/Functions/fn_compass_mainLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_parseConfig\n\nDescription:\n    Returns an array formatted for CBA settings menu lists.\n\nParameters:\n    0: _config <CONFIG> - The config to parse\n    1: _varName <STRING> - uiNamespace variable to save to and to check\n\nReturns:\n    <ARRAY> - An array formatted as [[title name strings],[image path strings],0]\n\nExamples:\n    (begin example)\n        private _array = [\n            configFile >> \"KISKA_compass\" >> \"compass\",\n            \"KISKA_compass_configs\"\n        ] call KISKA_fnc_compass_parseConfig;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_parseConfig\";\n\nparams [\"_config\",\"_varName\"];\n\nprivate _return = uiNamespace getVariable _varName;\nif (!isNil \"_return\") exitWith {\n    _return\n};\n\nif (isNull _config) exitWith {\n    [\"_config is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _nameArray = [];\nprivate _imagePathArray = [];\n(\"true\" configClasses _config) apply {\n    private _title = getText(_x >> \"title\");\n    private _imagePath = getText(_x >> \"image\");\n\n    if ((_title isNotEqualTo \"\") AND (_imagePath isNotEqualTo \"\")) then {\n        _nameArray pushBack _title;\n        _imagePathArray pushBack _imagePath;\n    };\n};\n\n_return = [_imagePathArray,_nameArray,0];\nuiNamespace setVariable [_varName,_return];\n\n\n_return\n",
    "fileName": "fn_compass_parseConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Compass/Functions/fn_compass_parseConfig.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_refresh\n\nDescription:\n    Resets the config global of the compass and then restarts the cutRSC for it.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - true if compass restarted\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_refresh;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_refresh\";\n\nif (!hasInterface) exitWith {\n    [\"Run on a machine without an interface, exiting...\",false] call KISKA_fnc_log;\n    false\n};\n\nprivate _display = GET_COMPASS_DISPLAY;\nif (isNull _display) exitWith {\n    [\"The display is null\",false] call KISKA_fnc_log;\n    false;\n};\n\n\nif (_display getVariable [COMPASS_CONFIGED_VAR_STR,false]) then {\n    _display setVariable [COMPASS_CONFIGED_VAR_STR,false];\n\n    (COMPASS_LAYER_NAME call BIS_fnc_rscLayer) cutText [ \"\", \"PLAIN\", -1, false ];\n    (COMPASS_LAYER_NAME call BIS_fnc_rscLayer) cutRsc [ \"KISKA_compass_rsc\", \"PLAIN\", -1, false ];\n\n    true\n\n} else {\n    [\"KISKA Compass has already been stopped\",true] call KISKA_fnc_log;\n    false\n\n};\n",
    "fileName": "fn_compass_refresh.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Compass/Functions/fn_compass_refresh.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_updateColors\n\nDescription:\n    Updates the color of the ctrls for the KISKA compass.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_updateColors;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_updateColors\";\n\nprivate _display = GET_COMPASS_DISPLAY;\nif (isNull _display) exitWith {};\n\nprivate _compassImageCtrl = _display getVariable [COMPASS_IMAGE_CTRL_VAR_STR,controlNull];\nif !(isNull _compassImageCtrl) then {\n    _compassImageCtrl ctrlSetTextColor KISKA_compass_mainColor;\n};\n\nprivate _compassBackgroundCtrl = _display getVariable [COMPASS_BACKGROUND_CTRL_VAR_STR,controlNull];\nif !(isNull _compassBackgroundCtrl) then {\n    _compassBackgroundCtrl ctrlSetTextColor KISKA_compass_backgroundColor;\n};\n\nprivate _compassCenterMarkersCtrl = _display getVariable [COMPASS_CENTER_MARKERS_CTRL_VAR_STR,controlNull];\nif !(isNull _compassCenterMarkersCtrl) then {\n    _compassCenterMarkersCtrl ctrlSetTextColor KISKA_compass_centerColor;\n};\n",
    "fileName": "fn_compass_updateColors.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Compass/Functions/fn_compass_updateColors.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass Image Resolutions.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_updateConstants\n\nDescription:\n    Updates a number of constant global variables used for the KISKA compass.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_updateConstants;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_updateConstants\";\n\nprivate _pixelOffset = ((COMPASS_USEABLE_WIDTH / 2) - KISKA_compass_widthScale) / 2;\nmissionNamespace setVariable [\"KISKA_compass_pixelX_min\",(MIN_COMPASS_WIDTH + _pixelOffset) * KISKA_compass_scale];\nmissionNamespace setVariable [\"KISKA_compass_pixelX_max\",(MAX_COMPASS_WIDTH + _pixelOffset) * KISKA_compass_scale];\n\nprivate _offset = linearConversion[ 630, 1260, KISKA_compass_widthScale, 0, 45, true ];\nmissionNamespace setVariable [\"KISKA_compass_shownAngle_min\",135 - _offset];\nmissionNamespace setVariable [\"KISKA_compass_shownAngle_max\",225 + _offset];\nmissionNamespace setVariable [\"KISKA_compass_iconAngle_min\",45 + _offset];\nmissionNamespace setVariable [\"KISKA_compass_iconAngle_max\",315 - _offset];\n\n\nmissionNamespace setVariable [\"KISKA_compass_iconW\",KISKA_compass_iconPixelSize * pixelW * KISKA_compass_scale];\nmissionNamespace setVariable [\"KISKA_compass_iconH\",KISKA_compass_iconPixelSize * pixelH * KISKA_compass_scale];\n\nmissionNamespace setVariable [\"KISKA_compass_iconWidth_active\",KISKA_compass_iconW * KISKA_compass_activeIconMultiplier];\nmissionNamespace setVariable [\"KISKA_compass_iconHeight_active\",KISKA_compass_iconH * KISKA_compass_activeIconMultiplier];\n\nmissionNamespace setVariable [\"KISKA_compass_iconWidth_inactive\",KISKA_compass_iconW * KISKA_compass_inactiveIconMultiplier];\nmissionNamespace setVariable [\"KISKA_compass_iconHeight_inactive\",KISKA_compass_iconH * KISKA_compass_inactiveIconMultiplier];\n",
    "fileName": "fn_compass_updateConstants.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Compass/Functions/fn_compass_updateConstants.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convo_close\n\nDescription:\n    Cleans up the conversation system and closes the response dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_convo_close;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convo_open\";\nprivate _display = localNamespace getVariable [\"KISKA_converstationResponse_display\",displayNull];\n_display closeDisplay 2;\n\nlocalNamespace setVariable [\"KISKA_convo_speakingTo\",nil];\n\n\nnil\n",
    "fileName": "fn_convo_close.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Conversations/Functions/fn_convo_close.sqf"
  },
  {
    "text": "#include \"..\\..\\Headers\\ConversationDialogCommonDefines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convo_createResponseDialog\n\nDescription:\n    Creates or shows the response dialog to be able to selecte a response during\n     a KISKA conversation.\n\nParameters:\n    0: _speakingTo <OBJECT> - The NPC \"person\" the player is supposed to be speaking to.\n        Can also be something like a game logic.\n    1: _conversationConfig <CONFIG> - The config of the opened conversation in\n        `_topicConfig >> \"conversations\"` class to open a dialog for.\n    2: _topicConfig <CONFIG> - A config path to the *conversation* topic config.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convo_createResponseDialog\";\ndisableSerialization;\n\nparams [\"_speakingTo\",\"_conversationConfig\",\"_topicConfig\"];\n\nprivate _optionsConfigClass = _conversationConfig >> \"Options\";\nprivate _optionConfigs = configProperties [_optionsConfigClass,\"isClass _x\"];\nif (_optionConfigs isEqualTo []) exitWith {\n    [\n        [\n            \"No Options found in conversation config \",\n            _conversationConfig\n        ],\n        true\n    ] call KISKA_fnc_log;\n    call KISKA_fnc_convo_close;\n    nil\n};\n\nprivate _display = localNamespace getVariable [\"KISKA_converstationResponse_display\",displayNull];\nprivate _eventArgs = [_optionConfigs,_topicConfig,_speakingTo];\nprivate \"_listBoxControl\";\nif !(isNull _display) then {\n    _display setVariable [\"KISKA_convo_eventArgs\",_eventArgs];\n    (allControls _display) apply { \n        _x ctrlShow true;\n        _x ctrlEnable true;\n    };\n\n} else {\n    _display = createDialog [\"KISKA_converstationResponse_dialog\",true];\n    _display setVariable [\"KISKA_convo_eventArgs\",_eventArgs];\n    localNamespace setVariable [\"KISKA_converstationResponse_display\",_display];\n\n    (_display displayCtrl CONVERSATION_DIALOG_HEADER_TEXT_IDC) ctrlSetText (name _speakingTo);\n    _listBoxControl = _display displayCtrl CONVERSATION_DIALOG_OPTIONS_LISTBOX_IDC;\n    _listBoxControl ctrlAddEventHandler [\"LBDblClick\", {\n        params [\"_control\", \"_selectedIndex\"];\n\n        private _display = ctrlParent _control;\n        (_display getVariable \"KISKA_convo_eventArgs\") params [\n            \"_optionConfigs\",\n            \"_topicConfig\",\n            \"_speakingTo\"\n        ];\n\n        [\n            _optionConfigs select _selectedIndex,\n            _speakingTo,\n            _topicConfig\n        ] call KISKA_fnc_convo_onOptionSelected;\n        _display setVariable [\"KISKA_convo_selectedOptionIndex\",nil];\n    }];\n\n    _listBoxControl ctrlAddEventHandler [\"LbSelChanged\",{\n        params [\"_control\",\"_selectedIndex\"];\n        private _display = ctrlParent _control;\n        _display setVariable [\"KISKA_convo_selectedOptionIndex\",_selectedIndex];\n    }];\n\n    _display displayAddEventHandler [\"KeyDown\", {\n        #define ESCAPE_KEY 1\n        params [\"\", \"_key\"];\n        \n        private _dontCloseDialog = _key isEqualTo ESCAPE_KEY;\n        _dontCloseDialog\n    }];\n\n    private _selectButton = _display displayCtrl CONVERSATION_DIALOG_OPTIONS_SELECT_IDC;\n    _selectButton ctrlAddEventHandler [\"ButtonClick\",{\n        params [\"_control\"];\n\n        private _display = ctrlParent _control;\n        private _selectedIndex = _display getVariable [\"KISKA_convo_selectedOptionIndex\",-1];\n        if (_selectedIndex >= 0) then {\n            (_display getVariable \"KISKA_convo_eventArgs\") params [\n                \"_optionConfigs\",\n                \"_topicConfig\",\n                \"_speakingTo\"\n            ];\n\n            [\n                _optionConfigs select _selectedIndex,\n                _speakingTo,\n                _topicConfig\n            ] call KISKA_fnc_convo_onOptionSelected;\n            _display setVariable [\"KISKA_convo_selectedOptionIndex\",nil];\n        };\n    }];\n};\n\n\nif (isNil \"_listBoxControl\") then {\n    _listBoxControl = _display displayCtrl CONVERSATION_DIALOG_OPTIONS_LISTBOX_IDC;\n};\nlbClear _listBoxControl;\n_optionConfigs apply {\n    private _text = getText(_x >> \"text\");\n    if (_text isEqualTo \"\") then {\n        private _lineName = getText(_x >> \"line\");\n        private _subtitleText = getText(_topicConfig >> \"lines\" >> \"Sentences\" >> _lineName >> \"subtitle\");\n        if (_subtitleText isNotEqualTo \"\") then {\n            _text = _subtitleText;\n        } else {\n            _text = configName _x;\n        };\n    };\n\n    if (_x call KISKA_fnc_convo_hasOptionBeenSelected) then {\n        _text = [\"<SELECTED>\",_text] joinString \" \";\n    };\n\n    _listBoxControl lbAdd _text;\n};\n\n\nnil\n",
    "fileName": "fn_convo_createResponseDialog.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Conversations/Functions/fn_convo_createResponseDialog.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convo_hasOptionBeenSelected\n\nDescription:\n    Determines whether or not the local player has selected a given dialogue option.\n\nParameters:\n    0: _selectedOptionConfig <CONFIG> - The config of the selected option\n        (`TOPIC_CONFIG >> \"conversations\" >> \"MyConvo\" >> \"Options\" >> \"MyOption\"`) \n        config to check.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _optionConfig = \n            missionConfigFile >> \n            \"KISKA_speech\" >> \n            \"MyTopic\" >> \n            \"conversations\" >> \n            \"MyOptions\" >> \n            \"Option_1\";\n        private _wasSelected = _optionConfig call KISKA_fnc_convo_hasOptionBeenSelected;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convo_hasOptionBeenSelected\";\n\nparams [\n    [\"_optionConfig\",configNull,[configNull]]\n];\n\nif (isNull _optionConfig) exitWith {};\n\nprivate _selectedOptionsSet = localNamespace getVariable \"KISKA_convo_selectedOptionsSet\";\nif (isNil \"_selectedOptionsSet\") then {\n    _selectedOptionsSet = createHashMap;\n    localNamespace setVariable [\"KISKA_convo_selectedOptionsSet\",_selectedOptionsSet];\n};\n\n\n_optionConfig in _selectedOptionsSet\n",
    "fileName": "fn_convo_hasOptionBeenSelected.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Conversations/Functions/fn_convo_hasOptionBeenSelected.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convo_markOptionAsSelected\n\nDescription:\n    Handles the logic of when an option is selected during a conversation.\n\nParameters:\n    0: _selectedOptionConfig <CONFIG> - The config of the selected option\n        (`TOPIC_CONFIG >> \"conversations\" >> \"MyConvo\" >> \"Options\" >> \"MyOption\"`) \n        config to use.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _optionConfig = \n            missionConfigFile >> \n            \"KISKA_speech\" >> \n            \"MyTopic\" >> \n            \"conversations\" >> \n            \"MyOptions\" >> \n            \"Option_1\";\n        _optionConfig call KISKA_fnc_convo_markOptionAsSelected;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convo_markOptionAsSelected\";\n\nparams [\n    [\"_optionConfig\",configNull,[configNull]]\n];\n\nif (isNull _optionConfig) exitWith {};\n\nprivate _selectedOptionsSet = localNamespace getVariable \"KISKA_convo_selectedOptionsSet\";\nif (isNil \"_selectedOptionsSet\") then {\n    _selectedOptionsSet = createHashMap;\n    localNamespace setVariable [\"KISKA_convo_selectedOptionsSet\",_selectedOptionsSet];\n};\n\n_selectedOptionsSet set [_optionConfig,_optionConfig];\n\nnil\n",
    "fileName": "fn_convo_markOptionAsSelected.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Conversations/Functions/fn_convo_markOptionAsSelected.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convo_onOptionSelected\n\nDescription:\n    Handles the logic of when an option is selected during a conversation.\n\nParameters:\n    0: _selectedOptionConfig <CONFIG> - The config of the selected option\n        (`_topicConfig >> \"conversations\" >> \"MyConvo\" >> \"Options\" >> \"MyOption\"`) \n        config to use.\n    1: _speakingTo <OBJECT> - The NPC \"person\" the player is supposed to be speaking to.\n        Can also be something like a game logic.\n    2: _topicConfig <CONFIG> - A config path to the *conversation* topic config.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convo_onOptionSelected\";\ndisableSerialization;\n\nparams [\n    [\"_selectedOptionConfig\",configNull,[configNull]],\n    \"_speakingTo\",\n    \"_topicConfig\"\n];\n\nif (isNull _selectedOptionConfig) exitWith {\n    [\"null selected option config passed!\",true] call KISKA_fnc_log;\n    call KISKA_fnc_convo_close;\n    nil\n};\n\nprivate _display = localNamespace getVariable [\"KISKA_converstationResponse_display\",displayNull];\n(allControls _display) apply { \n    _x ctrlShow false;\n    _x ctrlEnable false;\n};\n\nprivate _selectedOptionConfig = _optionConfigs select _selectedIndex;\nprivate _fn_afterLineSelected = [\n    [_topicConfig,_selectedOptionConfig,_speakingTo],\n    {\n        private _fn_openNextConversation = [_thisArgs, {\n            _thisArgs params [\"_topicConfig\",\"_selectedOptionConfig\",\"_speakingTo\"];\n            private _nextConvo = getText(_selectedOptionConfig >> \"nextConvo\");\n            if (_nextConvo isEqualTo \"\") exitWith { call KISKA_fnc_convo_close };\n\n            [\n                _topicConfig,\n                _nextConvo,\n                _speakingTo,\n                [_selectedOptionConfig >> \"playNextPreamble\",true,true] call KISKA_fnc_getConfigData\n            ] call KISKA_fnc_convo_open;\n        }];\n\n        _thisArgs params [\"_topicConfig\",\"_selectedOptionConfig\",\"_speakingTo\"];\n        private _postLines = [_selectedOptionConfig >> \"postLine\"] call KISKA_fnc_getConfigData;\n        if (\n            !(isNil \"_postLines\") AND\n            {_postLines isNotEqualTo \"\"} AND\n            {_postLines isNotEqualTo []}\n        ) exitWith {\n            [\n                _topicConfig,\n                _postLines,\n                _speakingTo,\n                player,\n                nil,\n                _fn_openNextConversation\n            ] call KISKA_fnc_speech_say;\n\n            nil\n        };\n        \n        [[],_fn_openNextConversation] call KISKA_fnc_callBack;\n    }\n];\n\nprivate _line = (_selectedOptionConfig >> \"line\") call KISKA_fnc_getConfigData;\nif (isNil \"_line\") exitWith {\n    [[],_fn_afterLineSelected] call KISKA_fnc_callBack;\n    nil\n};\n\n[\n    _topicConfig,\n    _line,\n    player,\n    _speakingTo,\n    nil,\n    _fn_afterLineSelected\n] call KISKA_fnc_speech_say;\n_selectedOptionConfig call KISKA_fnc_convo_markOptionAsSelected;\n\n\nnil\n",
    "fileName": "fn_convo_onOptionSelected.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Conversations/Functions/fn_convo_onOptionSelected.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convo_open\n\nDescription:\n    Initializes a converstaion sequence. This is the entry point to start a conversation\n     between the local player and a given NPC that is a configured KISKA conversation.\n     A KISKA conversation is an RPG like communication system.\n\nParameters:\n    0: _topicConfig <CONFIG or STRING> - A config path to the *conversation* topic \n        config or if a string the class name of a topic config located in the \n        default root KISKA config (see `KISKA_fnc_speech_getDefaultConfigRoot`).\n    1: _conversationName <STRING> - the class name of the line in the \n        `_topicConfig >> \"conversations\"` class to open a dialog for.\n    2: _speakingTo <OBJECT> - The NPC \"person\" the player is supposed to be speaking to.\n        Can also be something like a game logic.\n    3. _playPreamble <BOOL> - Default: `false` - Whether or not the configured `preambleLine`s \n        should be spoken by the `_speakingTo` entity.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"MyTopicConfigClass\",\n            \"MyConversationConfigClass\",\n            BIS_HQ\n        ] call KISKA_fnc_convo_open;\n    (end)\n\n    (begin example)\n        [\n            missionConfigFile >> \"MySpeechConfig\" >> \"MyTopicConfigClass\",\n            \"MyConversationConfigClass\",\n            Miller,\n            false\n        ] call KISKA_fnc_convo_open;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convo_open\";\n\nif !(hasInterface) exitWith {};\n\nparams [\n    [\"_topicConfig\",configNull,[configNull,\"\"]],\n    [\"_conversationName\",\"\",[\"\"]],\n    [\"_speakingTo\",objNull,[objNull]],\n    [\"_playPreamble\",true,[false]]\n];\n\n\nif (_topicConfig isEqualType \"\") then {\n    private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    _topicConfig = _defaultConfig >> _topicConfig;\n};\n\nif (isNull _topicConfig) exitWith {\n    [\"null topic config passed\",true] call KISKA_fnc_log;\n    call KISKA_fnc_convo_close;\n    nil\n};\n\nprivate _conversationConfig = _topicConfig >> \"conversations\" >> _conversationName;\nif (isNull _conversationConfig) exitWith {\n    [\n        [\n            \"Conversation config does not exist for \",\n            _conversationName,\n            \" in \",\n            _topicConfig\n        ],\n        true\n    ] call KISKA_fnc_log;\n    call KISKA_fnc_convo_close;\n    nil\n};\n\nif (isNull _speakingTo) exitWith {\n    [\"null object to speak to passed\",true] call KISKA_fnc_log;\n    call KISKA_fnc_convo_close;\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    Handle Player\n---------------------------------------------------------------------------- */\nif (isNil {localNamespace getVariable \"KISKA_convo_playerKilledEventId\"}) then {\n    private _eventId = player addEventHandler [\"KILLED\", {\n        call KISKA_fnc_convo_close;\n        localNamespace setVariable [\"KISKA_convo_playerKilledEventId\",nil];\n        player removeEventHandler [_thisEvent,_thisEventHandler];\n    }];\n\n    localNamespace setVariable [\"KISKA_convo_playerKilledEventId\",_eventId];\n};\n\n/* ----------------------------------------------------------------------------\n    Handle Speaker\n---------------------------------------------------------------------------- */\nlocalNamespace setVariable [\"KISKA_convo_speakingTo\",_speakingTo];\nif (isNil {_speakingTo getVariable \"KISKA_convo_killedEventId\"}) then {\n    private _eventId = _speakingTo addEventHandler [\"KILLED\", {\n        params [\"_unit\"];\n\n        private _speakingTo = localNamespace getVariable [\"KISKA_convo_speakingTo\",objNull];\n        if (_speakingTo isEqualTo _unit) then {\n            call KISKA_fnc_convo_close;\n        };\n    }];\n\n    _speakingTo setVariable [\"KISKA_convo_killedEventId\",_eventId];\n};\n\n/* ----------------------------------------------------------------------------\n    Handle Preamble\n---------------------------------------------------------------------------- */\nprivate \"_preambleLines\";\nif (\n    !(_playPreamble) OR\n    {\n        _preambleLines = [_conversationConfig >> \"preambleLine\"] call KISKA_fnc_getConfigData;\n        (isNil \"_preambleLines\") OR\n        {_preambleLines isEqualTo \"\"} OR \n        {_preambleLines isEqualTo []}\n    }\n) exitWith {\n    [\n        _speakingTo,\n        _conversationConfig,\n        _topicConfig\n    ] call KISKA_fnc_convo_createResponseDialog;\n\n    nil\n};\n\n[\n    _topicConfig,\n    _preambleLines,\n    _speakingTo,\n    player,\n    nil,\n    [[_speakingTo,_conversationConfig,_topicConfig], {\n        _thisArgs call KISKA_fnc_convo_createResponseDialog;\n    }]\n] call KISKA_fnc_speech_say;\n\n\nnil\n",
    "fileName": "fn_convo_open.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_Conversations/Functions/fn_convo_open.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRopeEvent_onDropEndedDefault\n\nDescription:\n    The default behaviour for when a fastroping vehicle has either completed its\n     dropping off of units or the vehicle has encountered something that caused\n     the fastrope to end.\n    \n    The default behaviour is to attempt to close any doors of the vehicle and\n     retract the hooks of the fries system. This is targetted at vanilla vehicles.\n\nParameters:\n    0: _fastRopeInfoMap <HASHMAP> - The hashmap that contains various pieces\n        of information pertaining to the given fastrope instance.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        _fastRopeInfoMap call KISKA_fnc_fastRopeEvent_onDropEndedDefault;\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRopeEvent_onDropEndedDefault\";\n\nparams [\"_fastRopeInfoMap\"];\n\nprivate _vehicle = _fastRopeInfoMap getOrDefaultCall [\"_vehicle\",{objNull}];\nif !(alive _vehicle) exitWith {};\n\nprivate _fries = _fastRopeInfoMap getOrDefaultCall [\"_fries\",{objNull}];\nif (!(isNull _fries) AND {_fries isNotEqualTo _vehicle}) exitWith {\n    [\"extendHookRight\", \"extendHookLeft\"] apply {\n        _fries animateSource [_x, 0];\n    };\n\n    [\n        {\n            params [\"_vehicle\"];\n\n            [\n                \"door_R\", \n                \"door_L\", \n                \"CargoRamp_Open\", \n                \"Door_rear_source\", \n                \"Door_6_source\", \n                \"CargoDoorR\", \n                \"CargoDoorL\"\n            ] apply { _vehicle animateDoor [_x, 0]; };\n\n            [\"dvere1_posunZ\", \"dvere2_posunZ\", \"doors\"] apply {\n                _vehicle animateSource [_x, 0];\n            };\n        }, \n        _vehicle, \n        2\n    ] call CBA_fnc_waitAndExecute;\n};\n\n[\n    \"door_R\", \n    \"door_L\", \n    \"CargoRamp_Open\", \n    \"Door_rear_source\", \n    \"Door_6_source\", \n    \"CargoDoorR\", \n    \"CargoDoorL\"\n] apply { _vehicle animateDoor [_x, 0]; };\n\n[\"dvere1_posunZ\", \"dvere2_posunZ\", \"doors\"] apply {\n    _vehicle animateSource [_x, 0];\n};\n\n\nnil\n",
    "fileName": "fn_fastRopeEvent_onDropEndedDefault.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/CommonEvents/fn_fastRopeEvent_onDropEndedDefault.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRopeEvent_onHoverStartedDefault\n\nDescription:\n    The default behaviour for when a fastroping vehicle begins hovering over the\n     drop zone. Most of this logic is pulled from ACE.\n    \n    The default behaviour is to not allow the helicopter to deploy ropes until\n     the doors are open and the FRIES hooks are extended. This is designed to\n     work primarily with vanilla helicopters. The idea is to manage animations\n     that should be conducted before the ropes are deployed.\n\nParameters:\n    0: _fastRopeInfoMap <HASHMAP> - The hashmap that contains various pieces\n        of information pertaining to the given fastrope instance.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        _fastRopeInfoMap call KISKA_fnc_fastRopeEvent_onHoverStartedDefault;\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRopeEvent_onHoverStartedDefault\";\n\nparams [\"_fastRopeInfoMap\"];\n\nprivate _vehicle = _fastRopeInfoMap getOrDefaultCall [\"_vehicle\",{objNull}];\nif !(alive _vehicle) exitWith {};\n\n[\n    \"door_R\", \n    \"door_L\", \n    \"CargoRamp_Open\", \n    \"Door_rear_source\", \n    \"Door_6_source\", \n    \"CargoDoorR\", \n    \"CargoDoorL\"\n] apply { _vehicle animateDoor [_x, 1]; };\n\n[\"dvere1_posunZ\", \"dvere2_posunZ\", \"doors\"] apply {\n    _vehicle animateSource [_x, 1];\n};\n\nprivate _fries = _fastRopeInfoMap getOrDefaultCall [\"_fries\",{objNull}];\nprivate _waitTime = 2;\nif (!(isNull _fries) AND {_fries isNotEqualTo _vehicle}) then {\n    [\n        {\n            params [\"_fries\"];\n            [\"extendHookRight\", \"extendHookLeft\"] apply {\n                _fries animateSource [_x, 1];\n            };\n        },\n        [_fries],\n        2\n    ] call CBA_fnc_waitAndExecute;\n    \n    _waitTime = 4;\n};\n\n[\n    { _this set [\"_canDeployRopes\",true] },\n    _fastRopeInfoMap,\n    _waitTime\n] call CBA_fnc_waitAndExecute;\n\n\nnil\n",
    "fileName": "fn_fastRopeEvent_onHoverStartedDefault.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/CommonEvents/fn_fastRopeEvent_onHoverStartedDefault.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_createRope\n\nDescription:\n    Creates the rope segments of what appears to be a single rope for a fast rope.\n\n    Also assigns eventhandlers for ropes breaking and adds references to the\n     `_ropeInfoMap` under `\"_ropeTop\"` and `\"_ropeBottom\"` keys.\n\nParameters:\n    0: _ropeInfoMap <HASMAP> - The info map for the specific rope that is being created.\n    1: _bottomLength <NUMBER> - Default: `1` - The length of the bottom segment of\n        the rope which is effectively the rope itself for most purposes.\n\nReturns:\n    <OBJECT[]> - The top and bottom rope segments.\n\nExamples:\n    (begin example)\n        private _newRopeSegments = [\n            _ropeInfoMap,\n            18                    \n        ] call KISKA_fnc_fastRope_createRope;\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_createRope\";\n\nparams [\n    \"_ropeInfoMap\",\n    [\"_bottomLength\",1,[123]]\n];\n\nprivate _unitAttachmentDummy = _ropeInfoMap get \"_unitAttachmentDummy\";\nprivate _hook = _ropeInfoMap get \"_hook\";\nprivate _ropeTop = ropeCreate [_unitAttachmentDummy, [0, 0, 0], _hook, [0, 0, 0], 0.5];\n_ropeInfoMap set [\"_ropeTop\",_ropeTop];\nprivate _ropeBottom = ropeCreate [_unitAttachmentDummy, [0, 0, 0], _bottomLength];\n_ropeInfoMap set [\"_ropeBottom\",_ropeBottom];\n\n\n#define ON_ROPE_BROKEN \\\n    _thisArgs params [\"_ropeInfoMap\"]; \\\n    if !(_ropeInfoMap getOrDefaultCall [\"_isBroken\",{false}]) then { \\\n        _ropeInfoMap set [\"_isBroken\",true]; \\\n        private _fastRopeInfoMap = _ropeInfoMap get \"_fastRopeInfoMap\"; \\\n        private _numberOfBrokenRopes = _fastRopeInfoMap getOrDefaultCall [\"_numberOfBrokenRopes\",{0},true]; \\\n        _numberOfBrokenRopes = _numberOfBrokenRopes + 1; \\\n        _fastRopeInfoMap set [\"_numberOfBrokenRopes\",_numberOfBrokenRopes]; \\\n        private _totalNumberOfRopes = count (_fastRopeInfoMap getOrDefaultCall [\"_ropeInfoMaps\",{[]}]); \\\n        if (_numberOfBrokenRopes >= _totalNumberOfRopes) then { \\\n            _fastRopeInfoMap set [\"_allRopesBroken\",true]; \\\n        }; \\\n    };\n\n[\n    _ropeTop,\n    \"RopeBreak\",\n    {\n        ON_ROPE_BROKEN\n        [_ropeInfoMap] call KISKA_fnc_fastRope_ropeAttachedUnit;\n    },\n    [_ropeInfoMap]\n] call CBA_fnc_addBISEventHandler;\n\n[\n    _ropeBottom,\n    \"RopeBreak\",\n    {\n        ON_ROPE_BROKEN\n    },\n    [_ropeInfoMap]\n] call CBA_fnc_addBISEventHandler;\n\n\n[_ropeTop,_ropeBottom]\n",
    "fileName": "fn_fastRope_createRope.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_createRope.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_deployRopes\n\nDescription:\n    Creates ropes and deploys them from either the FRIES system or the vehicle\n     from the given `_ropeOrigins`.\n    \n    A HASHMAP[] of information about each rope deployed from all origins (in order)\n     will be placed into the `_ropeInfoMaps` key of the `_fastRopeInfoMap`.\n\nParameters:\n    0: _fastRopeInfoMap <HASHMAP> - The hashmap that contains various pieces\n        of information pertaining to the given fastrope instance.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_deployRopes\";\n\n#define ROPE_HOOK_OBJECT_CLASS \"KISKA_FastRope_helper\"\n#define HELPER_OBJECT_CLASS \"KISKA_FastRope_helper\"\n#define ROPE_UNWIND_SPEED 30\n#define ROPE_LENGTH_BUFFER 5\n\nparams [\"_fastRopeInfoMap\"];\n\nprivate _fries = _fastRopeInfoMap get \"_fries\";\nprivate _ropeLength = (_fastRopeInfoMap get \"_hoverHeight\") + ROPE_LENGTH_BUFFER;\n_fastRopeInfoMap set [\"_ropeLength\",_ropeLength];\nprivate _vehicle = _fastRopeInfoMap get \"_vehicle\";\n\nprivate _ropeInfoMaps = (_fastRopeInfoMap get \"_ropeOrigins\") apply {\n    private _hook = ROPE_HOOK_OBJECT_CLASS createVehicle [0,0,0];\n    _hook allowDamage false;\n    if (_x isEqualType []) then {\n        _hook attachTo [_fries,_x];\n    } else {\n        _hook attachTo [_fries,[0,0,0],_x];\n    };\n\n    // using dummy objects with the hooks so that the ropes\n    // can unwind. Otherwise, they'd need to be attached to\n    // something on the ground instantly at the time of creation\n    // and be their full length.\n    private _unitAttachmentDummy = createVehicle [\n        HELPER_OBJECT_CLASS,\n        ((getPosATL _hook) vectorAdd [0,0,-1]),\n        [],\n        0,\n        \"CAN_COLLIDE\"\n    ];\n    _unitAttachmentDummy allowDamage false;\n    [\n        _unitAttachmentDummy,\n        _vehicle\n    ] remoteExec [\"disableCollisionWith\",[_vehicle,_unitAttachmentDummy]];\n    \n    private _ropeInfoMap = createHashMapFromArray [\n        [\"_hook\",_hook],\n        [\"_unitAttachmentDummy\",_unitAttachmentDummy],\n        [\"_isOccupied\",false],\n        [\"_isBroken\",false],\n        [\"_fastRopeInfoMap\",_fastRopeInfoMap]\n    ];\n    private _ropes = [_ropeInfoMap] call KISKA_fnc_fastRope_createRope;\n    private _ropeBottom = _ropes select 1;\n    ropeUnwind [_ropeBottom, ROPE_UNWIND_SPEED, _ropeLength, false];\n\n\n    _ropeInfoMap\n};\n\n_fastRopeInfoMap set [\"_ropeInfoMaps\",_ropeInfoMaps];\n\n\nnil\n",
    "fileName": "fn_fastRope_deployRopes.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_deployRopes.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_do\n\nDescription:\n    Sends a vehicle to a given point and fastropes the given units from the helicopter.\n\n    Pilots should ideally be placed in \"CARELESS\" behaviour when around enemies.\n\nParameters:\n    0: _argsMap <HASHMAP> - A hashmap of various parameters for the fastrope.\n        - `vehicle`: <OBJECT> - The vehicle to fastrope units from.\n        - `dropPosition`: <PositionsASL[] | OBJECT> - The position to drop units off.\n        - `hoverHeight`: <NUMBER> - The height above the drop position that the helicopter\n            will hover. Defaults to `20`, min is `5`, max is `28`.\n        - `unitsToDeploy`: <CODE, STRING, [ARRAY,CODE], [ARRAY,STRING], OBJECT[], GROUP, or OBJECT> - \n            An array of units to drop from the `_vehicle` or code that will run once the helicopter \n            has reached the drop point that must return an OBJECT[].\n            (see `KISKA_fnc_callBack` for examples).\n\n            Parameters:\n\n                - 0: <OBJECT> - The fastrope vehicle.\n\n        - `onDropEnded`: <CODE, STRING, [ARRAY,CODE]> - Code that will be executed once\n            all the units have been dropped off, the vehicle's engine is no longer on,\n            or the vehicle is no longer alive. The default behaviour can be found\n            in `KISKA_fnc_fastRopeEvent_onDropEndedDefault`. However, the vehicle's config\n            will also be searched for the event first (see `KISKA_fnc_fastRope_getConfigData`).\n            (see `KISKA_fnc_callBack` for type examples).\n\n            Parameters:\n\n                - 0: <HASHMAP> - A hashmap containing various pieces of information\n                    pertaining to the drop.\n\n        - `onDropComplete`: <CODE, STRING, [ARRAY,CODE]> - Code that will be executed once\n            all the units have been dropped off, the vehicle's engine is no longer on,\n            or the vehicle is no longer alive, AND the `onDropEnded` has run. This\n            defaults to empty code and is used in case a user does not want to overwrite\n            `onDropEnded`'s behaviour.\n            (see `KISKA_fnc_callBack` for type examples).\n\n            Parameters:\n\n                - 0: <HASHMAP> - A hashmap containing various pieces of information\n                    pertaining to the drop.\n\n        - `onHoverStarted`: <CODE, STRING, [ARRAY,CODE]> - Code that will be executed once\n            the vehicle has approixmately reached its hover position. The default behaviour can be found\n            in `KISKA_fnc_fastRopeEvent_onHoverStartedDefault`. However, the vehicle's config\n            will also be searched for the event first (see `KISKA_fnc_fastRope_getConfigData`).\n            (see `KISKA_fnc_callBack` for type examples).\n\n            Parameters:\n\n                - 0: <HASHMAP> - A hashmap containing various pieces of information\n                    pertaining to the drop.\n\n        - `getRopeOrigins`: <CODE, STRING, [ARRAY,CODE]> - Code that will be executed once\n            in and must return a type of `(STRING | PostiionRelative[])[]`. These will be where ropes\n            will hang from relative to either String entries are memory points. The default \n            behaviour is to get the rope origins from the vehicle's config using\n            `KISKA_fnc_fastRope_getConfigData`.\n            (see `KISKA_fnc_callBack` for type examples).\n\n            Parameters:\n            \n                - 0: <OBJECT> - The fastrope vehicle.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _paramsMap = createHashMapFromArray [\n            [\"vehicle\",MyHelicopter],\n            [\"dropPosition\",MyDropPosition],\n            [\n                \"unitsToDeploy\",\n                (fullCrew [_vehicle,\"cargo\"]) apply {\n                    _x select 0\n                }\n            ],\n            [\n                \"onDropComplete\",\n                {\n                    hint \"fastrope done\"\n                }\n            ]\n        ];\n        _paramsMap call KISKA_fnc_fastRope_do;\n    (end)\n\n    (begin example)\n        // using code instead to defer the list of units to drop\n        // until the helicopter is over the drop point\n        private _paramsMap = createHashMapFromArray [\n            [\"vehicle\",MyHelicopter],\n            [\"dropPosition\",MyDropPosition],\n            [\n                \"unitsToDeploy\",\n                {\n                    params [\"_vehicle\"];\n                    (fullCrew [_vehicle,\"cargo\"]) apply {\n                        _x select 0\n                    }\n                }\n            ],\n            [\n                \"onDropComplete\",\n                {\n                    hint \"fastrope done\"\n                }\n            ],\n            [\n                \"getRopeOrigins\",\n                { [[0,0,0]] }\n            ]\n        ];\n        _paramsMap call KISKA_fnc_fastRope_do;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_do\";\n\n#define MIN_HOVER_HEIGHT 5\n#define MAX_HOVER_HEIGHT 28\n#define CALL_BACK_TYPES [{},\"\",[]]\n\nprivate _defaultMap = createHashMap;\nparams [\n    [\"_argsMap\",_defaultMap,[_defaultMap]]\n];\n\nprivate _paramDetails = [\n    [\"vehicle\",{objNull},[objNull]],\n    [\"dropPosition\",{[]},[[],objNull]],\n    [\"unitsToDeploy\",{[]},[[],grpNull,objNull,{},\"\"]],\n    [\"hoverHeight\",{20},[123]],\n    [\n        \"onDropEnded\",\n        {{\n            params [\"_fastRopeInfoMap\"];\n            private _vehicleConfig = _fastRopeInfoMap getOrDefaultCall [\"_vehicleConfig\",{configNull}];\n\n            private _onDropEnded = [_vehicleConfig,\"onDropEnded\"] call KISKA_fnc_fastRope_getConfigData;\n            if (_onDropEnded isNotEqualTo {}) exitWith { _fastRopeInfoMap call _onDropEnded };\n\n            _fastRopeInfoMap call KISKA_fnc_fastRopeEvent_onDropEndedDefault;\n        }},\n        CALL_BACK_TYPES\n    ],\n    [\n        \"onDropComplete\",\n        {{}},\n        CALL_BACK_TYPES\n    ],\n    [\n        \"getRopeOrigins\",\n        {{\n            params [\"_vehicle\"];\n            [_vehicle,\"ropeOrigins\"] call KISKA_fnc_fastRope_getConfigData\n        }},\n        CALL_BACK_TYPES\n    ],\n    [\n        \"onHoverStarted\",\n        {{\n            params [\"_fastRopeInfoMap\"];\n            private _vehicleConfig = _fastRopeInfoMap getOrDefaultCall [\"_vehicleConfig\",{configNull}];\n            \n            private _onHoverStarted = [_vehicleConfig,\"onHoverStarted\"] call KISKA_fnc_fastRope_getConfigData;\n            if (_onHoverStarted isNotEqualTo {}) exitWith { _fastRopeInfoMap call _onHoverStarted };\n            \n            _fastRopeInfoMap call KISKA_fnc_fastRopeEvent_onHoverStartedDefault;\n        }},\n        CALL_BACK_TYPES\n    ]\n];\nprivate _paramValidationResult = [_argsMap,_paramDetails] call KISKA_fnc_hashMapParams;\nif (_paramValidationResult isEqualType \"\") exitWith {\n    [_paramValidationResult,true] call KISKA_fnc_log;\n    nil\n};\n(_paramValidationResult select 0) params (_paramValidationResult select 1);\n\n\n/* ----------------------------------------------------------------------------\n    Verify Params\n---------------------------------------------------------------------------- */\nif !(alive _vehicle) exitWith {\n    [\"_vehicle is not alive!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _ropeOrigins = [_vehicle,_getRopeOrigins] call KISKA_fnc_callBack;\nif (\n    !(_ropeOrigins isEqualType []) OR\n    {_ropeOrigins isEqualTo []}\n) exitWith {\n    [\"No rope origins were provided for the vehicle!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    Verify _unitsToDeploy\n---------------------------------------------------------------------------- */\nprivate _unitsToDeployFiltered = [];\nprivate _unitsToDeployIsCode = false;\ncall {\n    if (_unitsToDeploy isEqualType grpNull) exitWith {\n        (units _unitsToDeploy) apply {\n            if !(alive _x) then { continue };\n            _unitsToDeployFiltered pushBack _x;\n        };\n    };\n\n    if (\n        (_unitsToDeploy isEqualType objNull) AND \n        { alive _unitsToDeploy }\n    ) exitWith {\n        _unitsToDeployFiltered = [_unitsToDeploy];\n    };\n\n    if (_unitsToDeploy isEqualType []) exitWith {\n        _unitsToDeployIsCode = \n            (_unitsToDeploy isEqualTypeParams [[],{}]) OR \n            {_unitsToDeploy isEqualTypeParams [[],\"\"]} OR\n            {_unitsToDeploy isEqualType \"\"} OR \n            {_unitsToDeploy isEqualType {}};\n\n        if (_unitsToDeployIsCode) exitWith {\n            _unitsToDeployFiltered = _unitsToDeploy\n        };\n\n        _unitsToDeploy apply {\n            if (_x isEqualType grpNull) then {\n                _unitsToDeployFiltered append (units _x);\n                continue;\n            };\n\n            if ((_x isEqualType objNull) AND {alive _x}) then {\n                _unitsToDeployFiltered pushBackUnique _x;\n                continue;\n            };\n        };\n    };\n};\n\n\nif (_unitsToDeployFiltered isEqualTo []) exitWith {\n    [\"Could not find any units to deploy\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _fastRopeInfoMap = createHashMapFromArray [\n    [\"_unitsToDeploy\",_unitsToDeployFiltered],\n    [\"_unitsToDeployIsCode\",_unitsToDeployIsCode],\n    [\"_ropeOrigins\",_ropeOrigins],\n    [\"_fastRopeEnded\",false],\n    [\"_canDeployRopes\",false],\n    [\"_vehicle\",_vehicle],\n    [\"_vehicleConfig\",configOf _vehicle]\n];\n\n[\n    {\n        params [\"_vehicle\",\"_fastRopeInfoMap\"];\n\n        if !(alive _vehicle) exitWith {};\n\n        private _vehicleConfig = _fastRopeInfoMap getOrDefaultCall [\"_vehicleConfig\",{configNull}];\n        private _friesType = [_vehicleConfig,\"friesType\"] call KISKA_fnc_fastRope_getConfigData;\n\n        if (_friesType isEqualTo \"\") exitWith {\n            _fastRopeInfoMap set [\"_fries\",_vehicle];\n        };\n\n        private _friesAttachmentPoint = [_vehicleConfig,\"friesAttachmentPoint\"] call KISKA_fnc_fastRope_getConfigData;\n        private _fries = _friesType createVehicle [0,0,0];\n        _fries attachTo [_vehicle,_friesAttachmentPoint];\n\n        _fastRopeInfoMap set [\"_fries\",_fries];\n    },\n    [_vehicle,_fastRopeInfoMap]\n] call CBA_fnc_execNextFrame;\n\n\n/* ----------------------------------------------------------------------------\n    Move to target and hover\n---------------------------------------------------------------------------- */\n_hoverHeight = _hoverHeight max MIN_HOVER_HEIGHT;\n_hoverHeight = _hoverHeight min MAX_HOVER_HEIGHT;\n_fastRopeInfoMap set [\"_hoverHeight\",_hoverHeight];\n\nif (_dropPosition isEqualType objNull) then {\n    _dropPosition = getPosASL _dropPosition;\n};\nprivate _hoverPosition_ASL = _dropPosition vectorAdd [0,0,_hoverHeight];\n\nprivate _fastRopeInfoMap_var = [\"KISKA_fastRope_infoMap\"] call KISKA_fnc_generateUniqueId;\nlocalNamespace setVariable [_fastRopeInfoMap_var,_fastRopeInfoMap];\n[\n    _vehicle,\n    _hoverPosition_ASL,\n    createHashMapFromArray [\n        [\n            \"_shouldHoverStop\",\n            compileFinal (format ['(localNamespace getVariable \"%1\") getOrDefaultCall [\"_fastRopeEnded\",{true}]',_fastRopeInfoMap_var])\n        ],\n        [\n            \"_onHoverStart\",\n            [[_fastRopeInfoMap,_onHoverStarted], {\n                _thisArgs call KISKA_fnc_callBack;\n                (_thisArgs select 0) call KISKA_fnc_fastRope_startDeploymentProcess;\n            }]\n        ],\n        [\n            \"_onHoverEnd\",\n            [[_fastRopeInfoMap,_onDropEnded,_fastRopeInfoMap_var,_onDropComplete], {\n                _thisArgs params [\"_fastRopeInfoMap\",\"_onDropEnded\",\"_fastRopeInfoMap_var\",\"_onDropComplete\"];\n                localNamespace setVariable [_fastRopeInfoMap_var,nil];\n                [_fastRopeInfoMap, _onDropEnded] call KISKA_fnc_callBack;\n                [_fastRopeInfoMap, _onDropComplete] call KISKA_fnc_callBack;\n            }]\n        ]\n    ]\n] call KISKA_fnc_hover;\n\n\nnil\n",
    "fileName": "fn_fastRope_do.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_do.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_dropUnits\n\nDescription:\n    Drops the units from the aircraft using fastropes. Will recursively call\n     itself until all the units are dropped.\n\nParameters:\n    0: _fastRopeInfoMap <HASHMAP> - The hashmap that contains various pieces\n        of information pertaining to the given fastrope instance.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_dropUnits\";\n\n#define ON_GROUND_BUFFER 0.2\n\nparams [\n    \"_fastRopeInfoMap\",\n    [\"_isRecursiveCall\",false,[true]]\n];\n\nif (\n    !(_fastRopeInfoMap call KISKA_fnc_fastRope_isVehicleStillCapable)\n) exitWith {\n    _fastRopeInfoMap call KISKA_fnc_fastRope_end;\n    nil\n};\n\nprivate _vehicle = _fastRopeInfoMap getOrDefaultCall [\"_vehicle\",{objNull}];\nprivate _ropeInfoMaps = _fastRopeInfoMap get \"_ropeInfoMaps\";\nif !(_isRecursiveCall) exitWith {\n    private _pilot = currentPilot _vehicle;\n    [_pilot,\"MOVE\"] remoteExec [\"disableAI\",_pilot];\n    _fastRopeInfoMap set [\"_pilot\",_pilot];\n    _fastRopeInfoMap set [\"_unoccupiedRopeInfoMap\",_ropeInfoMaps select 0];\n    [_fastRopeInfoMap, true] call KISKA_fnc_fastRope_dropUnits;\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    Drop Unit\n---------------------------------------------------------------------------- */\nprivate _unoccupiedRopeInfoMap = _fastRopeInfoMap get \"_unoccupiedRopeInfoMap\";\nprivate _unitsToDeploy = _fastRopeInfoMap getOrDefaultCall [\"_unitsToDeploy\",{[]}];\nprivate _unit = _unitsToDeploy deleteAt 0;\nif ((alive _unit) AND {_unit in _vehicle}) then {\n    _unoccupiedRopeInfoMap set [\"_isOccupied\",true];\n    unassignVehicle _unit;\n    [_unit] allowGetIn false;\n\n    [\n        {\n            #define PER_FRAME_HANDLER_ID _this select 1\n\n            params [\"_args\"];\n            private _unit = _args select 0;\n            // wait for unit to be outside of vehicle\n            if !(isNull (objectParent _unit)) exitWith {};\n            \n            private _ropeInfoMap = _args select 1;\n            // for reasons I don't understand, if _hook is not assigned to a variable when checking\n            // isNull, the function will silently fail... \n            // cant use `(isNull (_ropeInfoMap getOrDefaultCall [\"_hook\",{objNull}]))\n            private _hook = _ropeInfoMap getOrDefaultCall [\"_hook\",{objNull}];\n            private _unitWasAttachedToRope = _unit getVariable [\"KISKA_fastRope_attachedToRope\",false];\n            // Prevent teleport if hook has been deleted due to rope cut\n            if (\n                (isNull _hook) OR\n                {(_args select 4) getOrDefaultCall [\"_queuedEnd\", {false}]} OR\n                {_unitWasAttachedToRope AND {isNull (attachedTo _unit)}}\n            ) exitWith {\n                [_ropeInfoMap] call KISKA_fnc_fastRope_ropeAttachedUnit;\n                [PER_FRAME_HANDLER_ID] call CBA_fnc_removePerFrameHandler;\n            };\n\n            if !(_unitWasAttachedToRope) exitWith {\n                [_ropeInfoMap,_unit] call KISKA_fnc_fastRope_ropeAttachedUnit;\n            };\n\n            private _ropeTop = _ropeInfoMap get \"_ropeTop\";\n            private _reachedGround = ((getPosVisual _unit) select 2) < ON_GROUND_BUFFER;\n            private _ropeLength = _args select 3;\n            private _vehicle = _args select 2;\n            if (\n                _reachedGround OR\n                { (ropeLength _ropeTop) isEqualTo _ropeLength } OR\n                { vectorMagnitude (velocity _vehicle) > 5 } OR\n                { !((lifeState _unit) in [\"HEALTHY\", \"INJURED\"]) }\n            ) exitWith {\n                [_ropeInfoMap] call KISKA_fnc_fastRope_ropeAttachedUnit;\n\n                deleteVehicle [\n                    _ropeTop,\n                    (_ropeInfoMap get \"_ropeBottom\")\n                ];\n                [_ropeInfoMap,_ropeLength] call KISKA_fnc_fastRope_createRope;\n                \n                [PER_FRAME_HANDLER_ID] call CBA_fnc_removePerFrameHandler;\n            };\n        }, \n        0, \n        [\n            _unit, \n            _unoccupiedRopeInfoMap, \n            _vehicle, \n            _fastRopeInfoMap get \"_ropeLength\", \n            _fastRopeInfoMap\n        ]\n    ] call CBA_fnc_addPerFrameHandler;\n    moveOut _unit;\n};\n\n/* ----------------------------------------------------------------------------\n    Check for recursion end\n---------------------------------------------------------------------------- */\n_fastRopeInfoMap set [\"_unoccupiedRopeInfoMap\",nil];\nif (_unitsToDeploy isEqualTo []) exitWith {\n    [\n        {\n            if (\n                !((_this select 2) call KISKA_fnc_fastRope_isVehicleStillCapable)\n            ) exitWith { true };\n\n            private _indexOfOccupiedRope = (_this select 1) findIf { \n                _x getOrDefaultCall [\"_isOccupied\",{false}] \n            };\n            _indexOfOccupiedRope isEqualTo -1 // no ropes occupied\n        },\n        {\n            (_this select 2) call KISKA_fnc_fastRope_end;\n        },\n        0.25,\n        [_vehicle,_ropeInfoMaps,_fastRopeInfoMap]\n    ] call KISKA_fnc_waitUntil;\n\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    Wait to drop next unit\n---------------------------------------------------------------------------- */\n[\n    {\n        private _fastRopeInfoMap = _this select 2;\n        if (\n            !(_fastRopeInfoMap call KISKA_fnc_fastRope_isVehicleStillCapable)\n        ) exitWith { true };\n        \n        private _continue = false;\n        (_this select 1) apply {\n            if (\n                !(_x getOrDefaultCall [\"_isOccupied\", {false}]) AND \n                { !(_x getOrDefaultCall [\"_isBroken\", {false}]) }\n            ) then {\n                _fastRopeInfoMap set [\"_unoccupiedRopeInfoMap\",_x];\n                _continue = true;\n                break;\n            };\n        };\n\n        _continue\n    },\n    {\n        private _fastRopeInfoMap = _this select 2;\n        private _unoccupiedRopeInfoMap = _fastRopeInfoMap get \"_unoccupiedRopeInfoMap\";\n        private _cantProceed = isNil \"_unoccupiedRopeInfoMap\";\n        if (_cantProceed) exitWith {\n            _fastRopeInfoMap call KISKA_fnc_fastRope_end;\n            nil\n        };\n\n        // using this buffer so that if there are multiple ropes\n        // units don't look so much like they are dropping in perfect unison\n        private _deployBuffer = random [0, 0.5, 1];\n        [\n            { _this call KISKA_fnc_fastRope_dropUnits },\n            [_fastRopeInfoMap, true],\n            _deployBuffer\n        ] call CBA_fnc_waitAndExecute;\n    },\n    0.25,\n    [_vehicle,_ropeInfoMaps,_fastRopeInfoMap]\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_fastRope_dropUnits.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_dropUnits.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_end\n\nDescription:\n    Handles much of the cleanup of a fastrope in the event that the helicopter\n     should cease the fastrope or has dropped off all the units.\n    \n    Important note: FRIES objects are deleted ten seconds after this function is\n     called so it can be used in the `onDropEnd` event.\n\nParameters:\n    0: _fastRopeInfoMap <HASHMAP> - The hashmap that contains various pieces\n        of information pertaining to the given fastrope instance.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_end\";\n\n#define TIME_TILL_FRIES_DELETED 10\n#define TIME_TILL_NORMAL_END 2\n#define FALLING_ROPE_MASS 1000\n#define TIME_UNTIL_ROPE_DELETION 20\n\nparams [\"_fastRopeInfoMap\"];\n\nif (_fastRopeInfoMap getOrDefaultCall [\"_queuedEnd\", {false}]) exitWith {};\n\nprivate _pilot = _fastRopeInfoMap getOrDefaultCall [\"_pilot\", {objNull}];\nif (alive _pilot) then {\n    [_pilot,\"MOVE\"] remoteExecCall [\"enableAI\",_pilot];\n};\n\n/* ----------------------------------------------------------------------------\n    Disconnect ropes\n---------------------------------------------------------------------------- */\nprivate _ropeInfoMaps = _fastRopeInfoMap getOrDefaultCall [\"_ropeInfoMaps\", {[]}];\n_ropeInfoMaps apply {\n    if (_x getOrDefaultCall [\"_isDisconnected\",{false}]) then { continue };\n\n    [_x] call KISKA_fnc_fastRope_ropeAttachedUnit;\n    // Delete hook and top so rope falls\n    deleteVehicle [\n        _x getOrDefaultCall [\"_hook\",{objNull}],\n        _x getOrDefaultCall [\"_ropeTop\",{objNull}]\n    ];\n                    \n    // Give rope some extra mass to fall quick\n    private _unitAttachmentDummy = _x getOrDefaultCall [\"_unitAttachmentDummy\",{objNull}];\n    [_unitAttachmentDummy, FALLING_ROPE_MASS] remoteExec [\"setMass\",_unitAttachmentDummy];\n\n    [\n        {deleteVehicle _this}, \n        [\n            _x getOrDefaultCall [\"_ropeBottom\",{objNull}], \n            _unitAttachmentDummy\n        ], \n        TIME_UNTIL_ROPE_DELETION\n    ] call CBA_fnc_waitAndExecute;\n    \n    _x set [\"_isDisconnected\",true];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Delete Fries\n---------------------------------------------------------------------------- */\nprivate _vehicle = _fastRopeInfoMap getOrDefaultCall [\"_vehicle\", {objNull}];\nprivate _fries = _fastRopeInfoMap getOrDefaultCall [\"_fries\", {objNull}];\nif (\n    !(isNull _fries) AND \n    {_fries isNotEqualTo _vehicle}\n) then {\n    [\n        { deleteVehicle _this },\n        [_fries],\n        TIME_TILL_FRIES_DELETED\n    ] call CBA_fnc_waitAndExecute;\n};\n\n_fastRopeInfoMap set [\"_queuedEnd\",true];\n\n/* ----------------------------------------------------------------------------\n    Mark fast rope as ended\n---------------------------------------------------------------------------- */\nif !(alive _vehicle) exitWith {\n    _fastRopeInfoMap set [\"_fastRopeEnded\",true];\n};\n// waiting to say the drop is over to give the cut ropes time\n// to fall. In tome cases, the rope might clip with the helicopter\n// while moving and cause damage and/or get stuck to the helicopter and clip\n[\n    {\n        (_this select 0) set [\"_fastRopeEnded\",true];\n    },\n    [_fastRopeInfoMap],\n    TIME_TILL_NORMAL_END\n] call CBA_fnc_waitAndExecute;\n\n",
    "fileName": "fn_fastRope_end.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_end.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_executeRemoteEvent\n\nDescription:\n    Meant to execute a piece of code on a (potentially) remote machine during fastroping.\n\n    Events:\n    - `\"UpdateAttachmentDummyMass\"` - Adjusts the given attachment dummy's mass\n        and position to prepare it for a unit to fastrope down. Arguments:\n        - _ropeUnitAttachmentDummy <OBJECT> - The unit attachment dummy to adjust.\n        - _hookPosition <PositionASL[]> - The position of the hook the rope is hangning from.\n    - `\"StartAttachmentDescentLoop\"` - Adds a perframe handler to the local machine\n        that will continuously push the attachment dummy down to give the appearance of\n        sliding down the rope. Arguments:\n        - _ropeUnitAttachmentDummy <OBJECT> - The unit attachment dummy to descend.\n    - `\"EndAttachmentDescentLoop\"` - Ends the loop added with `\"StartAttachmentDescentLoop\"`\n        and returns the attachment dummy's mass to normal. Arguments:\n        - _ropeUnitAttachmentDummy <OBJECT> - The unit attachment dummy to stop descending.\n        - _hookPosition <PositionASL[]> - The position of the hook the rope is hangning from.\n    - `\"StartFastRopeAnimation\"` - Changes the given unit's animation to be that of fastroping\n        and if that unit is a player, will start a loop to continuously play a sliding-down\n        sound. Arguments:\n        - _unit <OBJECT> - The unit fastroping.\n    - `\"EndFastRopeAnimation\"` - Ends the sound loop made in `\"StartFastRopeAnimation\"`,\n        resets the unit's animations, and will play a (local 2D) thud sound if the \n        unit is a player. Arguments: \n        - _unit <OBJECT> - The unit fastroping.\n\nParameters:\n    0: _event <STRING> - The remote event to execute. Case Insensitive.\n    1: _args <ANY> - The arguments for the given event.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"UpdateAttachmentDummyMass\",\n            [_ropeUnitAttachmentDummy,getPosASLVisual _hook]\n        ] remoteExecCall [\"KISKA_fnc_fastRope_executeRemoteEvent\",_ropeUnitAttachmentDummy];\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_executeRemoteEvent\";\n\n#define DESCENT_SOUND_VAR \"KISKA_fastrope_descendingSoundHandlerId\"\n#define ATTACHMENT_DESCENT_LOOP_VAR \"KISKA_fastrope_descentAttachmentHandlerId\"\n\n#define DUMMY_FAST_ROPE_DESCENT_VELOCITY [0,0,-6]\n\n#define ATTACHMENT_DUMMY_ORIGINAL_MASS 40\n#define ATTACHMENT_DUMMY_ORIGINAL_CENTER_OF_MASS [0.000143227,0.00105986,-0.246147]\n#define ATTACHMENT_DUMMY_DOWNWARD_MASS 80\n#define ATTACHMENT_DUMMY_DOWNWARD_CENTER_OF_MASS [0, 0, -2]\n\nparams [\n    [\"_event\",\"\",[\"\"]],\n    [\"_args\",[],[]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    UpdateAttachmentDummyMass\n---------------------------------------------------------------------------- */\nif (_event == \"UpdateAttachmentDummyMass\") exitWith {\n    _args params [\n        [\"_ropeUnitAttachmentDummy\",objNull,[objNull]],\n        [\"_hookPosition\",[],[[]],[3]]\n    ];\n\n    _ropeUnitAttachmentDummy setMass ATTACHMENT_DUMMY_DOWNWARD_MASS;\n    _ropeUnitAttachmentDummy setCenterOfMass ATTACHMENT_DUMMY_DOWNWARD_CENTER_OF_MASS;\n    _ropeUnitAttachmentDummy setPosASL (_hookPosition vectorAdd [0, 0, -2]);\n    _ropeUnitAttachmentDummy setVectorUp [0, 0, 1];\n\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    StartAttachmentDescentLoop\n---------------------------------------------------------------------------- */\nif (_event == \"StartAttachmentDescentLoop\") exitWith {\n    _args params [\n        [\"_ropeUnitAttachmentDummy\",objNull,[objNull]]\n    ];\n\n    private _attachmentLoopId = [\n        {\n            // Setting the velocity manually to reduce twitching\n            (_this select 0) setVelocity DUMMY_FAST_ROPE_DESCENT_VELOCITY;\n        },\n        0,\n        _ropeUnitAttachmentDummy\n    ] call CBA_fnc_addPerFrameHandler;\n    _ropeUnitAttachmentDummy setVariable [ATTACHMENT_DESCENT_LOOP_VAR,_attachmentLoopId];\n\n\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    EndAttachmentDescentLoop\n---------------------------------------------------------------------------- */\nif (_event == \"EndAttachmentDescentLoop\") exitWith {\n    _args params [\n        [\"_ropeUnitAttachmentDummy\",objNull,[objNull]],\n        [\"_hookPosition\",[],[[]],[3]]\n    ];\n\n    private _attachmentLoopId = _ropeUnitAttachmentDummy getVariable ATTACHMENT_DESCENT_LOOP_VAR;\n    if !(isNil \"_attachmentLoopId\") then {\n        _ropeUnitAttachmentDummy setVariable [ATTACHMENT_DESCENT_LOOP_VAR,nil];\n        [_attachmentLoopId] call CBA_fnc_removePerFrameHandler;\n    };\n\n    _ropeUnitAttachmentDummy setPosASL (_hookPosition vectorAdd [0, 0, -1]);\n    _ropeUnitAttachmentDummy setMass ATTACHMENT_DUMMY_ORIGINAL_MASS;\n    _ropeUnitAttachmentDummy setCenterOfMass ATTACHMENT_DUMMY_ORIGINAL_CENTER_OF_MASS;\n\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    _fn_playAnimation\n---------------------------------------------------------------------------- */\nprivate _fn_playAnimation = {\n    params [\"_unit\",\"_animation\"];\n\n    if (isNull (objectParent _unit)) then {\n        _unit playMoveNow _animation;\n    } else {\n        // Execute on all machines. PlayMove and PlayMoveNow are bugged: \n        // They have local effects when executed on remote machines inside vehicles.\n        _this remoteExecCall [\"playMoveNow\",0];\n    };\n\n    // if animation doesn't respond, do switchMove\n    if ((animationState _unit) != _animation) then {\n        _this remoteExecCall [\"switchMove\",0];\n    };\n};\n\n/* ----------------------------------------------------------------------------\n    StartFastRopeAnimation\n---------------------------------------------------------------------------- */\nif (_event == \"StartFastRopeAnimation\") exitWith {\n    _args params [\n        [\"_unit\",objNull,[objNull]]\n    ];\n    [_unit, \"KISKA_FastRoping\"] call _fn_playAnimation;\n\n    if (isPlayer _unit) then {\n        private _descentSoundHandlerId = [\n            {\n                private _unit = _this select 0;\n                if !(alive _unit) exitWith {\n                    _unit setVariable [DESCENT_SOUND_VAR,nil];\n                    [_this select 1] call CBA_fnc_removePerFrameHandler;\n                };\n\n                playSound \"KISKA_fastrope_descending\";\n            },\n            1,\n            _unit\n        ] call CBA_fnc_addPerFrameHandler;\n        _unit setVariable [DESCENT_SOUND_VAR,_descentSoundHandlerId];\n    };\n\n\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    EndFastRopeAnimation\n---------------------------------------------------------------------------- */\nif (_event == \"EndFastRopeAnimation\") exitWith {\n    _args params [\n        [\"_unit\",objNull,[objNull]],\n        [\"_reachedGround\",false,[true]]\n    ];\n\n    [_unit,\"\"] call _fn_playAnimation;\n    _unit setVectorUp [0,0,1];\n\n    private _descentSoundHandlerId = _unit getVariable DESCENT_SOUND_VAR;\n    if !(isNil \"_descentSoundHandlerId\") then {\n        _unit setVariable [DESCENT_SOUND_VAR,nil];\n        [_descentSoundHandlerId] call CBA_fnc_removePerFrameHandler;\n    };\n\n    if (_reachedGround AND {isPlayer _unit}) then {\n        playSound \"KISKA_fastrope_thud\";\n    };\n\n    private _currentWeapon = currentWeapon _unit;\n    if (_currentWeapon != \"\") then {\n        _unit action [\"SwitchWeapon\", _unit, _unit, 299];\n        [\n            {\n                params [\"_unit\", \"_weapon\"];\n                // Abort if the unit already selected a different weapon\n                if (\n                    (currentWeapon _unit) != \"\" OR \n                    {\n                        !((lifeState _unit) in [\"HEALTHY\", \"INJURED\"])\n                    }\n                ) exitWith {};\n                _unit selectWeapon _weapon;\n            }, \n            [_unit, _currentWeapon], \n            2\n        ] call CBA_fnc_waitAndExecute;\n    };\n\n\n    nil\n};\n\n\nnil\n",
    "fileName": "fn_fastRope_executeRemoteEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_executeRemoteEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_getConfigData\n\nDescription:\n    Retrieves config data relevant to to fastroping. Has some interoperability \n     with similar properites configured for ACE fastroping. Values are cached\n     after the first retrieval.\n\n    Config data is expected to be defined inside a \n     `<CONFIG> >> \"CfgVehicles\" >> <VEHICLE-CLASS> >> \"KISKA_fastRope\"` config class.\n     This can be under any config and will be located with `KISKA_fnc_findConfigAny`\n     opting for the most specific. This allows consistent config overrides should\n     one choose to do so instead of doing so through SQF.\n\n    (begin config example)\n        // inside description.ext\n        class CfgVehicles\n        {\n            class B_Heli_Light_01_F\n            {\n                class KISKA_FastRope\n                {\n                    ropeOrigins[] = {\"ropeOriginRight\",\"ropeOriginLeft\"};\n                    friesType = \"KISKA_FriesAnchorBar\";\n                    friesAttachmentPoint[] = {0,0.550,-0.007};\n                };\n            };\n        };\n    (end)\n    \n    Values that can be retireved:\n\n    - \"friesType\" <STRING> : The vehicle class of a FRIES attachment point (basically hooks)\n        that the ropes would hang from. If the bespoke KISKA property is not defined, \n        the ACE property `ace_fastrope_friesType` will also be searched for.\n    - \"ropeOrigins\" <(PositionRelative[] | STRING)[]> : The relative position of \n        where the ropes should be attached to the FRIES object or in the case that\n        no \"friesType\" is defined, the vehicle tself. Expected to be an array of\n        relative positions and/or memory points to `attachTo`. If the bespoke KISKA\n        property is not defined, the ACE property `ace_fastrope_ropeOrigins` will also\n        be searched for.\n    - \"friesAttachmentPoint\" <PositionRelative[]> : The relative position to use `attachTo`\n        in order to attach the `friesType` to the fast roping vehicle. If the bespoke KISKA\n        property is not defined, the ACE property `ace_fastrope_friesAttachmentPoint` will also\n        be searched for.\n    - \"onHoverStarted\" <STRING> : Uncompiled code that runs once the vehicle has (within ~2m) \n        reached the intended position that the vehicle will hover to fastrope units down.\n        See the default implementation `KISKA_fnc_fastRopeEvent_onHoverStartedDefault`.\n        `_this` will be the <HASHMAP> fastrope info map.\n    - \"onDropEnded\" <STRING> : Uncompiled code that runs once the vehicle has severed the\n        ropes from the vehicle. See the default implementation `KISKA_fnc_fastRopeEvent_onDropEndedDefault`.\n        `_this` will be the <HASHMAP> fastrope info map.\n\nParameters:\n    0: _vehicleConfig <OBJECT | CONFIG> - The vehicle that a fastrope will be conducted\n        from or its config path.\n    1: _dataToFetch <STRING> - The data to fetch from the config. CASE-SENSITIVE\n        Options are: \"friesType\", \"ropeOrigins\", \"friesAttachmentPoint\", \"\n\nReturns:\n    <STRING | ARRAY | CODE> - The configured value or compiled code for the config value.\n    \nExamples:\n    (begin example)\n        private _ropeOrigins = [\n            (configOf MyVehicle),\n            \"ropeOrigins\"\n        ] call KISKA_fnc_fastRope_getConfigData;\n    (end)\n\n    (begin example)\n        private _friesType = [\n            MyVehicle,\n            \"friesType\"\n        ] call KISKA_fnc_fastRope_getConfigData;    \n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_getConfigData\";\n\n#define FRIES_TYPE_KEY \"friesType\"\n#define ROPE_ORIGINS_KEY \"ropeOrigins\"\n#define FRIES_ATTACHMENT_POINT_KEY \"friesAttachmentPoint\"\n#define ON_HOVER_STARTED_KEY \"onHoverStarted\"\n#define ON_DROP_ENDED_KEY \"onDropEnded\"\n\n#define ACE_ROPE_ORIGINS \"ace_fastrope_ropeOrigins\"\n#define ACE_FRIES_TYPE \"ace_fastrope_friesType\"\n#define ACE_FRIES_ATTACHMENT_POINT \"ace_fastrope_friesAttachmentPoint\"\n\nparams [\n    [\"_vehicleConfig\",configNull,[configNull,objNull]],\n    [\"_dataToFetch\",\"\",[\"\"]]\n];\n\nif (isNull _vehicleConfig) exitWith {};\n\nif (_vehicleConfig isEqualType objNull) then {\n    _vehicleConfig = configOf _vehicleConfig;\n};\n\nprivate _overallMap = localNamespace getVariable \"KISKA_fastRope_dataCacheMap\";\nif (isNil \"_overallMap\") then {\n    _overallMap = createHashMap;\n    localNamespace setVariable [\"KISKA_fastRope_dataCacheMap\",_overallMap];\n};\n\nprivate _vehicleDataMap = _overallMap getOrDefaultCall [_vehicleConfig,{createHashMap},true];\nprivate _dataValue = _vehicleDataMap get _dataToFetch;\nif !(isNil \"_dataValue\") exitWith { _dataValue };\n\ncall {\n    #define FIND_CONFIG_ANY(KEY) \\\n        [[ \\\n            \"CfgVehicles\", \\\n            configName _vehicleConfig, \\\n            \"KISKA_fastRope\", \\\n            KEY \\\n        ]] call KISKA_fnc_findConfigAny\n\n    if (_dataToFetch isEqualTo ROPE_ORIGINS_KEY) exitWith {\n        private _configOfData = FIND_CONFIG_ANY(ROPE_ORIGINS_KEY);\n        if ( (isNull _configOfData) OR { !(isArray _configOfData) } ) then {\n            _dataValue = getArray(_vehicleConfig >> ACE_ROPE_ORIGINS);\n        } else {\n            _dataValue = getArray _configOfData;\n        };\n    };\n\n    if (_dataToFetch isEqualTo FRIES_TYPE_KEY) exitWith {\n        private _configOfData = FIND_CONFIG_ANY(FRIES_TYPE_KEY);\n        if ( (isNull _configOfData) OR { !(isText _configOfData) } ) then {\n            _dataValue = getText(_vehicleConfig >> ACE_FRIES_TYPE);\n        } else {\n            _dataValue = getText _configOfData;\n        };\n    };\n\n    if (_dataToFetch isEqualTo FRIES_ATTACHMENT_POINT_KEY) exitWith {\n        private _configOfData = FIND_CONFIG_ANY(FRIES_ATTACHMENT_POINT_KEY);\n        if ( (isNull _configOfData) OR { !(isArray _configOfData) } ) then {\n            _dataValue = getArray(_vehicleConfig >> ACE_FRIES_ATTACHMENT_POINT);\n            if (_dataValue isEqualTo []) then {\n                _dataValue = [0,0,0];\n            };\n        } else {\n            _dataValue = getArray _configOfData;\n        };\n    };\n\n    if (_dataToFetch isEqualTo ON_HOVER_STARTED_KEY) exitWith {\n        private _onHoverStartedConfig = FIND_CONFIG_ANY(ON_HOVER_STARTED_KEY);\n        if (isText _onHoverStartedConfig) then {\n            _dataValue = compileFinal (getText _onHoverStartedConfig);\n        } else {\n            _dataValue = {};\n        };\n    };\n\n    if (_dataToFetch isEqualTo ON_DROP_ENDED_KEY) exitWith {\n        private _onDropEndedConfig = FIND_CONFIG_ANY(ON_DROP_ENDED_KEY);\n        if (isText _onDropEndedConfig) then {\n            _dataValue = compileFinal (getText _onDropEndedConfig);\n        } else {\n            _dataValue = {};\n        };\n    };\n};\n\nif (isNil \"_dataValue\") exitWith {\n    [[\"Unexpected _dataToFetch -> \",_dataToFetch],true] call KISKA_fnc_log;\n    nil\n};\n\n\n_vehicleDataCacheMap set [_dataToFetch, _dataValue];\n_dataValue\n",
    "fileName": "fn_fastRope_getConfigData.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_getConfigData.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_isVehicleStillCapable\n\nDescription:\n    Checks if a vehicle can still drop units after it has been told to fastrope.\n\n    The vehicle must be alive, and its engine must be on (`isEngineOn`).\n     The `_fastRopeInfoMap` must also return `false` for `_allRopesBroken`.\n\nParameters:\n    0: _fastRopeInfoMap <HASHMAP> - The hashmap that contains various pieces\n        of information pertaining to the given fastrope instance.\n\nReturns:\n    <BOOL> - Whether or not units can still fastrope from this vehicle.\n\nExamples:\n    (begin example)\n        private _unitsCanStillFastRope = \n            _fastRopeInfoMap call KISKA_fnc_fastRope_isVehicleStillCapable;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_isVehicleStillCapable\";\n\nparams [\"_fastRopeInfoMap\"];\n\nprivate _vehicle = _fastRopeInfoMap getOrDefaultCall [\"_vehicle\",{objNull}];\n\n(alive _vehicle) AND\n{ isEngineOn _vehicle } AND\n{ !(_fastRopeInfoMap getOrDefaultCall [\"_allRopesBroken\",{false},true]) }\n",
    "fileName": "fn_fastRope_isVehicleStillCapable.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_isVehicleStillCapable.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_ropeAttachedUnit\n\nDescription:\n    Attaches or detachs a given unit from the given rope.\n\n    Also sets the rope info as being occupied or unoccupied.\n\nParameters:\n    0: _ropeInfoMap <HASHMAP> - The info map of the rope to attach or detach a unit from.\n    1: _setAttachedUnit <OBJECT> - Default: `nil` - A `nil` value will detach the\n        currently attached unit from the rope. If an object, that unit will be\n        attached to the rope.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // attach player to the rope\n        [MY_ROPE_INFO, player] call KISKA_fnc_fastRope_ropeAttachedUnit;\n    (end)\n\n    (begin example)\n        // detach unit from rope\n        [MY_ROPE_INFO] call KISKA_fnc_fastRope_ropeAttachedUnit;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_ropeAttachedUnit\";\n\n#define ATTACH_TO_DUMMY_COORDS [0, 0, -1.45]\n#define ROPE_UNWIND_SPEED 6\n\nprivate _DEFAULT_MAP = createHashMap;\nparams [\n    [\"_ropeInfoMap\",_DEFAULT_MAP,[_DEFAULT_MAP]],\n    [\"_setAttachedUnit\",nil,[objNull]]\n];\n\nprivate _ropeUnitAttachmentDummy = _ropeInfoMap getOrDefaultCall [\"_unitAttachmentDummy\", {objNull}];\nprivate _detachUnit = isNil \"_setAttachedUnit\";\nif (_detachUnit) exitWith {\n    private _attachedUnit = _ropeInfoMap getOrDefaultCall [\"_attachedUnit\", {objNull}];\n    detach _attachedUnit;\n    _ropeInfoMap set [\"_attachedUnit\",nil];\n    _ropeInfoMap set [\"_isOccupied\",false];\n\n    if !(isNull _attachedUnit) then {\n        _attachedUnit setVariable [\"KISKA_fastRope_attachedToRope\",nil];\n\n        private _hook = _ropeInfoMap getOrDefaultCall [\"_hook\", {objNull}];\n        [\n            \"EndAttachmentDescentLoop\",\n            [_ropeUnitAttachmentDummy,getPosASLVisual _hook]\n        ] remoteExecCall [\"KISKA_fnc_fastRope_executeRemoteEvent\",_ropeUnitAttachmentDummy];\n\n        [\n            \"EndFastRopeAnimation\",\n            [_attachedUnit,_reachedGround]\n        ] remoteExecCall [\"KISKA_fnc_fastRope_executeRemoteEvent\",_attachedUnit];\n    };\n\n    nil\n};\n\n\n[\n    \"UpdateAttachmentDummyMass\",\n    [_ropeUnitAttachmentDummy,getPosASLVisual _hook]\n] remoteExecCall [\"KISKA_fnc_fastRope_executeRemoteEvent\",_ropeUnitAttachmentDummy];\n\n[\n    [_ropeInfoMap get \"_ropeTop\", _ropeInfoMap get \"_ropeLength\"],\n    [_ropeInfoMap get \"_ropeBottom\", 0.5]\n] apply {\n    _x params [\"_rope\",\"_unwindLength\"];\n    [ [_rope, ROPE_UNWIND_SPEED, _unwindLength] ] remoteExec [\"ropeUnwind\",_rope];\n};\n\n[\n    _ropeUnitAttachmentDummy,\n    _setAttachedUnit\n] remoteExec [\"disableCollisionWith\",[_ropeUnitAttachmentDummy,_setAttachedUnit]];\n\n_ropeInfoMap set [\"_attachedUnit\",_setAttachedUnit];\n_ropeInfoMap set [\"_isOccupied\",true];\n_setAttachedUnit attachTo [_ropeInfoMap get \"_unitAttachmentDummy\", ATTACH_TO_DUMMY_COORDS];\n\n[\n    \"StartFastRopeAnimation\",\n    _setAttachedUnit\n] remoteExecCall [\"KISKA_fnc_fastRope_executeRemoteEvent\",_setAttachedUnit];\n\n[\n    \"StartAttachmentDescentLoop\",\n    _ropeUnitAttachmentDummy\n] remoteExecCall [\"KISKA_fnc_fastRope_executeRemoteEvent\",_ropeUnitAttachmentDummy];\n\n_setAttachedUnit setVariable [\"KISKA_fastRope_attachedToRope\",true];\n\n\n_setAttachedUnit\n",
    "fileName": "fn_fastRope_ropeAttachedUnit.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_ropeAttachedUnit.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_fastRope_startDeploymentProcess\n\nDescription:\n    Begins the deployment process by waiting until the vehicle is allowed to deploy\n     ropes and then deploys those ropes and initiates `KISKA_fnc_fastRope_dropUnits`.\n\nParameters:\n    0: _fastRopeInfoMap <HASHMAP> - The hashmap that contains various pieces\n        of information pertaining to the given fastrope instance.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_fastRope_startDeploymentProcess\";\n\nparams [\"_fastRopeInfoMap\"];\n\n[\n    {\n        !(_this call KISKA_fnc_fastRope_isVehicleStillCapable) OR \n        { _this getOrDefaultCall [\"_canDeployRopes\",{true}] }\n    },\n    {\n        if (\n            !(_this call KISKA_fnc_fastRope_isVehicleStillCapable)\n        ) exitWith {\n            _this call KISKA_fnc_fastRope_end;\n            nil\n        };\n        \n        _this call KISKA_fnc_fastRope_deployRopes;\n        [\n            {\n                if (\n                    !(_this call KISKA_fnc_fastRope_isVehicleStillCapable)\n                ) exitWith { true };\n                \n                private _ropeInfoMaps = _this get \"_ropeInfoMaps\";\n                private _indexOfRopeNotUnwound = _ropeInfoMaps findIf { \n                    !(ropeUnwound (_x get \"_ropeBottom\"))\n                };\n                _indexOfRopeNotUnwound isEqualTo -1 // all ropes unwound\n            },\n            {\n                if (_this getOrDefaultCall [\"_unitsToDeployIsCode\",{false}]) then {\n                    private _unitsToDeploy = [\n                        [_this getOrDefaultCall [\"_vehicle\",{objNull}]],\n                        _this getOrDefaultCall [\"_unitsToDeploy\",{{}}]\n                    ] call KISKA_fnc_callBack;\n                    _this set [\"_unitsToDeploy\",_unitsToDeploy];\n                };\n                \n                _this call KISKA_fnc_fastRope_dropUnits;\n            },\n            0.25,\n            _this\n        ] call KISKA_fnc_waitUntil;\n    },\n    0.25,\n    _fastRopeInfoMap\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_fastRope_startDeploymentProcess.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_FastRope/Functions/fn_fastRope_startDeploymentProcess.sqf"
  },
  {
    "text": "#include \"..\\Headers\\GroupChangerCommonDefines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad\n\nDescription:\n    Executes in the onload event for the KISKA's Group Changer Dislog\n\nParameters:\n    0: _display <DISPLAY> - The display of the dialog\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_display] call KISKA_fnc_GCHOnLoad;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_display\"];\n\nif (missionNamespace getVariable [\"KISKA_CBA_GCH_closeMap\",true]) then {\n    openMap false;\n};\n\n// prepare globals for controls\nlocalNamespace setVariable [\"KISKA_GCH_display\",_display];\n\n\n/* ----------------------------------------------------------------------------\n    Misc\n---------------------------------------------------------------------------- */\n// leader name indicator\nprivate _leaderNameIndicator_ctrl = _display displayCtrl GCH_LEADER_NAME_INDICATOR_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_leaderNameIndicator_ctrl\",_leaderNameIndicator_ctrl];\n\n\n// Show AI Check Box\nprivate _showAiCheckBox_ctrl = _display displayCtrl GCH_SHOW_AI_CHECKBOX_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_showAiCheckBox_ctrl\",_showAiCheckBox_ctrl];\n[_showAiCheckBox_ctrl] call KISKA_fnc_GCHOnLoad_showAiCheckbox;\n\n\n/* ----------------------------------------------------------------------------\n    Combo Boxes\n---------------------------------------------------------------------------- */\n// can be deleted\nprivate _canBeDeletedCombo_ctrl = _display displayCtrl GCH_CAN_BE_DELETED_COMBO_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_canBeDeletedCombo_ctrl\",_canBeDeletedCombo_ctrl];\n[_canBeDeletedCombo_ctrl] call KISKA_fnc_GCHOnLoad_canBeDeletedCombo;\n\n// can rally\nprivate _canRallyCombo_ctrl = _display displayCtrl GCH_CAN_RALLY_COMBO_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_canRallyCombo_ctrl\",_canRallyCombo_ctrl];\n[_canRallyCombo_ctrl] call KISKA_fnc_GCHOnLoad_canRallyCombo;\n\n// Assign Team\nprivate _assignTeamCombo_ctrl = _display displayCtrl GCH_CAN_ASSIGN_TEAM_COMBO_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_assignTeamCombo_ctrl\",_assignTeamCombo_ctrl];\n[_assignTeamCombo_ctrl] call KISKA_fnc_GCHOnLoad_assignTeamCombo;\n\n\n/* ----------------------------------------------------------------------------\n    List Boxes\n---------------------------------------------------------------------------- */\n// current group unit list\nprivate _currentGroupListBox_ctrl = _display displayCtrl GCH_CURRENT_GROUP_LISTBOX_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_currentGroupListBox_ctrl\",_currentGroupListBox_ctrl];\n\n// side groups list\nprivate _sidesGroupListBox_ctrl = _display displayCtrl GCH_SIDE_GROUPS_LISTBOX_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_sidesGroupListBox_ctrl\",_sidesGroupListBox_ctrl];\n[_sidesGroupListBox_ctrl] call KISKA_fnc_GCHOnLoad_sideGroupsList;\n\n\n/* ----------------------------------------------------------------------------\n    Buttons\n---------------------------------------------------------------------------- */\n// join group button\nprivate _joinGroupButton_ctrl = _display displayCtrl GCH_JOIN_GROUP_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_joinGroupButton_ctrl\",_joinGroupButton_ctrl];\n[_joinGroupButton_ctrl] call KISKA_fnc_GCHOnLoad_joinGroupButton;\n\n// leave group button\nprivate _leaveGroupButton_ctrl = _display displayCtrl GCH_LEAVE_GROUP_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_leaveGroupButton_ctrl\",_leaveGroupButton_ctrl];\n[_leaveGroupButton_ctrl] call KISKA_fnc_GCHOnLoad_leaveGroupButton;\n\n// close button\nprivate _closeButton_ctrl = _display displayCtrl GCH_CLOSE_BUTTON_IDC;\n//localNamespace setVariable [\"KISKA_GCH_closeButton_ctrl\",_closeButton_ctrl];\n[_closeButton_ctrl] call KISKA_fnc_GCHOnLoad_closeButton;\n\n// set leader button\nprivate _setLeaderButton_ctrl = _display displayCtrl GCH_SET_LEADER_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_setLeaderButton_ctrl\",_setLeaderButton_ctrl];\n[_setLeaderButton_ctrl] call KISKA_fnc_GCHOnLoad_setLeaderButton;\n\n// set Group ID button\nprivate _setGroupIdButton_ctrl = _display displayCtrl GCH_SET_GROUP_ID_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_setGroupIdButton_ctrl\",_setGroupIdButton_ctrl];\n// edit\nprivate _groupIdEdit_ctrl = _display displayCtrl GCH_SET_GROUP_ID_EDIT_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_groupIdEdit_ctrl\",_groupIdEdit_ctrl];\n[_setGroupIdButton_ctrl] call KISKA_fnc_GCHOnLoad_setGroupIdButton;\n\n\n\n\n\n\n\n_display displayAddEventHandler [\"unload\",{\n    // clear localNamespace variables\n    [\n        \"KISKA_GCH_display\",\n        \"KISKA_GCH_selectedGroup\",\n        \"KISKA_GCH_currentGroupListBox_ctrl\",\n        \"KISKA_GCH_leaveGroupButton_ctrl\",\n        \"KISKA_GCH_groupUnitList\",\n        \"KISKA_GCH_leaderNameIndicator_ctrl\",\n        \"KISKA_GCH_setLeaderButton_ctrl\",\n        \"KISKA_GCH_joinGroupButton_ctrl\",\n        \"KISKA_GCH_showAiCheckBox_ctrl\",\n        \"KISKA_GCH_groupIdEdit_ctrl\",\n        \"KISKA_GCH_canBeDeletedCombo_ctrl\",\n        \"KISKA_GCH_canRallyCombo_ctrl\",\n        \"KISKA_GCH_sidesGroupListBox_ctrl\",\n        \"KISKA_GCH_sideGroupsArray\",\n        \"KISKA_GCH_setGroupIdButton_ctrl\",\n        \"KISKA_GCH_assignTeamCombo_ctrl\"\n    ] apply {\n        localNamespace setVariable [_x,nil];\n    };\n}];\n\n\n// there needs to be a variable you can assign to units/players that does not allow them to leave groups\n// or it only allows them to join certain groups\n",
    "fileName": "fn_GCHOnLoad.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad.sqf"
  },
  {
    "text": "#include \"..\\Headers\\GCH Colors.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_assignTeamCombo\n\nDescription:\n    Adds control event handler to the combo box for turning it on and off.\n\nParameters:\n    0: _control <CONTROL> - The control for the combo box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_assignTeamCombo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_assignTeamCombo\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    private _unitList = localNamespace getVariable [\"KISKA_GCH_groupUnitList\",[]];\n    private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n    private _unitLBIndex = lbCurSel _currentGroupListBox_ctrl;\n    private _selectedUnit = _unitList select (_currentGroupListBox_ctrl lbValue _unitLBIndex);\n\n    private _selectedgroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n    private _groupLeader = leader _selectedgroup;\n\n    private _unitIsPlayer = _selectedUnit isEqualTo player;\n    if (_unitIsPlayer OR {_groupLeader isEqualTo player} OR {call KISKA_fnc_isAdminOrHost}) then {\n        if (alive _selectedUnit) then {\n            [_selectedUnit,_selectedIndex] remoteExec [\"KISKA_fnc_GCH_assignTeam\",[_groupLeader,_selectedUnit] select (_unitIsPlayer)];\n            [] spawn {\n                sleep 1;\n                [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n            };\n\n        } else {\n            [\"This unit appears to be dead\"] call KISKA_fnc_errorNotification;\n\n        };\n\n    } else {\n        [\"You must be the admin or host to change this setting\"] call KISKA_fnc_errorNotification;\n\n    };\n\n}];\n\n_control lbAdd \"MAIN\";\n\nprivate _index = _control lbAdd \"BLUE\";\n_control lbSetColor [_index, COLOR_BLUE];\n\n_index = _control lbAdd \"GREEN\";\n_control lbSetColor [_index, COLOR_GREEN];\n\n_index = _control lbAdd \"RED\";\n_control lbSetColor [_index, COLOR_RED];\n\n_index = _control lbAdd \"YELLOW\";\n_control lbSetColor [_index, COLOR_YELLOW];\n\n\n_control lbSetCurSel 0;\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_assignTeamCombo.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_assignTeamCombo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_canBeDeletedCombo\n\nDescription:\n    Adds control event handler to the combo box for turning it on and off.\n\nParameters:\n    0: _control <CONTROL> - The control for the combo box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_canBeDeletedCombo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_canBeDeletedCombo\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    if (call KISKA_fnc_isAdminOrHost) then {\n\n        private _selectedgroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n\n        if !(isNull _selectedgroup) then {\n\n            private _canDelete = isGroupDeletedWhenEmpty _selectedgroup;\n            private _fn_setGroupAutoDelete = {\n                params [\"_allowDelete\"];\n\n                if (local _selectedgroup) then {\n                    _selectedgroup deleteGroupWhenEmpty _allowDelete;\n                } else {\n                    [_selectedgroup, _allowDelete] remoteExecCall [\"KISKA_fnc_GCH_groupDeleteQuery\",2];\n                };\n            };\n\n\n            if (_selectedIndex isEqualTo 0) then {\n                // if you can delete the group, set to false\n                if (_canDelete) then {\n                    [false] call _fn_setGroupAutoDelete;\n                };\n            } else {\n                // If you can't delete the group, set to true\n                if !(_canDelete) then {\n                    [true] call _fn_setGroupAutoDelete;\n                };\n            };\n        };\n    } else {\n        // when selecting a group, and this control is created/updated in the right pane, this error may show for certain users\n        // despite not having changed the setting, therefore, this boolean is used to see if this control was just created and this\n        // is the second time or more the control is adjusted\n        if !(_control getVariable [\"KISKA_firstTimeComboChanged\",false]) then {\n            [\"You must be the admin or host to change this setting\"] call KISKA_fnc_errorNotification;\n\n        } else {\n            _control setVariable [\"KISKA_firstTimeComboChanged\",false];\n\n        };\n    };\n}];\n\n_control lbAdd \"NO\";\n_control lbAdd \"YES\";\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_canBeDeletedCombo.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_canBeDeletedCombo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_canRallyCombo\n\nDescription:\n    Adds control event handler to the combo box for turning it on and off.\n\nParameters:\n    0: _control <CONTROL> - The control for the combo box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_canRallyCombo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_canRallyCombo\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    private _selectedgroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n    if !(isNull _selectedgroup) then {\n\n        if ([_selectedgroup] call KISKA_fnc_GCH_isAllowedToEdit) then {\n            // NO\n            if (_selectedIndex isEqualTo 0) then {\n                [_selectedgroup,true] remoteExecCall [\"KISKA_fnc_disallowGroupRally\",2];\n            } else {\n            // YES\n                [_selectedgroup] remoteExecCall [\"KISKA_fnc_allowGroupRally\",2];\n            };\n        } else {\n            // when selecting a group, and this control is created/updated in the right pane, this error may show for certain users\n            // despite not having changed the setting, therefore, this boolean is used to see if this control was just created and this\n            // is the second time or more the control is adjusted\n            if !(_control getVariable [\"KISKA_firstTimeComboChanged\",false]) then {\n                [\"You do not have permission to change this setting\"] call KISKA_fnc_errorNotification;\n\n            } else {\n                _control setVariable [\"KISKA_firstTimeComboChanged\",false];\n\n            };\n        };\n    };\n\n}];\n\n_control lbAdd \"NO\";\n_control lbAdd \"YES\";\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_canRallyCombo.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_canRallyCombo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_closeButton\n\nDescription:\n    Adds control event handler to the close buttont that will close the dialog.\n\nParameters:\n    0: _control <CONTROL> - The control for the close button\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_closeButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_closeButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    (localNamespace getVariable \"KISKA_GCH_display\") closeDisplay 2;\n}];\n\n\nnil",
    "fileName": "fn_GCHOnLoad_closeButton.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_closeButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_joinGroupButton\n\nDescription:\n    The function that fires on the join group button click event.\n    The Event is called from KISKA_fnc_GCHOnLoad.\n\nParameters:\n    0: _control <CONTROL> - The control of the button\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n       [buttonControl]  call KISKA_fnc_GCHOnLoad_joinGroupButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_joinGroupButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n\n    if !(isNull _selectedGroup) then {\n        if ((group player) isNotEqualTo _selectedGroup) then {\n            private _groupIsLocal = local _selectedGroup;\n            [player] joinSilent _selectedGroup;\n        };\n\n    } else {\n        [\"The group you are trying to join does not exist\"] call KISKA_fnc_errorNotification;\n\n    };\n\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_joinGroupButton.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_joinGroupButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnload_leaveGroupButton\n\nDescription:\n    The function that fires on the leave group button click event.\n    The Event is added in KISKA_fnc_GCHOnLoad.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [buttonControl] call KISKA_fnc_GCHOnload_leaveGroupButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_leaveGroupButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n    private _newGroup = createGroup [_playerSide, true];\n    [player] joinSilent _newGroup;\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_leaveGroupButton.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_leaveGroupButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_setGroupIdButton\n\nDescription:\n    The function that fires on the set group id button click event.\n\n    This is called from KISKA_fnc_GCHOnLoad\n\nParameters:\n    0: _control <CONTROL> - The control of the button\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [buttonControl] call KISKA_fnc_GCHOnLoad_setGroupIdButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_setGroupIdButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    private _editBox_ctrl = localNamespace getVariable \"KISKA_GCH_groupIdEdit_ctrl\";\n    private _newId = ctrlText _editBox_ctrl;\n\n    private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n\n    if !(isNull _selectedGroup) then {\n        // case sensetive check to see if there is a change in the name\n        if !(_newId isEqualTo (groupId _selectedGroup)) then {\n\n            private _sideGroups = localNamespace getVariable \"KISKA_GCH_sideGroupsArray\";\n            // check if another group already has the id\n            private _alreadyHasName = [\n                _sideGroups,\n                {(groupId _x) isEqualTo (_thisArgs select 0)},\n                [_newId]\n            ] call KISKA_fnc_findIfBool;\n\n            if !(_alreadyHasName) then {\n                _selectedGroup setGroupIdGlobal [_newId];\n\n                // update side group list with new id\n                private _index = _sideGroups findIf {\n                    _x isEqualTo _selectedGroup\n                };\n\n                private _sideGroupsList_ctrl = localNamespace getVariable \"KISKA_GCH_sidesGroupListBox_ctrl\";\n                _sideGroupsList_ctrl lbSetText [_index,_newId];\n                [\"Group Id Updated\"] call KISKA_fnc_notification;\n            } else {\n                [\"Another group on your side already has this ID\"] call KISKA_fnc_errorNotification;\n            };\n        };\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_setGroupIdButton.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_setGroupIdButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_setLeaderButton\n\nDescription:\n    The function that fires on the set leader button click event.\n\n    The function is called in KISKA_fnc_GCHOnLoad.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n           [buttonControl] call KISKA_fnc_GCHOnLoad_setLeaderButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_setLeaderButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n\n    private _group = [] call KISKA_fnc_GCH_getSelectedGroup;\n\n    if ([_group] call KISKA_fnc_GCH_isAllowedToEdit) then {\n        private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n        private _selectedindex = lbCurSel _currentGroupListBox_ctrl;\n        private _unitArrayIndex = _currentGroupListBox_ctrl lbValue _selectedindex;\n\n        private _unitArray = localNamespace getVariable \"KISKA_GCH_groupUnitList\";\n        private _unitToSet = _unitArray select _unitArrayIndex;\n\n        if !(_unitToSet isEqualTo (leader _group)) then {\n            if (local _group) then {\n                _group selectLeader _unitToSet;\n            } else {\n                [_group,_unitToSet] remoteExecCall [\"KISKA_fnc_GCH_setLeaderRemote\",2];\n            };\n        };\n\n\n        // update leader name indicator\n        [false,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n    } else {\n        [\"You must be the leader or admin to set a leader\"] call KISKA_fnc_errorNotification;\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_setLeaderButton.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_setLeaderButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_showAiCheckbox\n\nDescription:\n    Adds control event handler to check box and sets its intial state.\n\nParameters:\n    0: _control <CONTROL> - The control for the checkbox\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_showAiCheckbox;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_showAiCheckbox\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"CheckedChanged\",{\n    params [\"_control\", \"_checked\"];\n\n    // convert from number to bool\n    _checked = [false,true] select _checked;\n    localNamespace setVariable [\"KISKA_GCH_showAI\",_checked];\n\n    [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n}];\n\n\n// set checked or not initially on open\n_control cbSetChecked (localNamespace getVariable [\"KISKA_GCH_showAI\",true]);",
    "fileName": "fn_GCHOnLoad_showAiCheckbox.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_showAiCheckbox.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_sideGroupsList\n\nDescription:\n    Adds eventhandler to the listbox.\n\nParameters:\n    0: _control <CONTROL> - The control for the list box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_sideGroupsList;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_sideGroupsList\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n// add event handler\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    // get selected group\n    private _sideGroups = localNamespace getVariable \"KISKA_GCH_sideGroupsArray\";\n    private _sideGroupsIndex = _control lbValue _selectedIndex;\n    private _selectedGroup = _sideGroups select _sideGroupsIndex;\n    localNamespace setVariable [\"KISKA_GCH_selectedGroup\",_selectedGroup];\n\n    [true,true,true,true,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n}];\n\n\n[true] call KISKA_fnc_GCH_updateSideGroupsList;\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_sideGroupsList.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCHOnLoad_sideGroupsList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_addDiaryEntry\n\nDescription:\n    Creates a diary entry in the map for the player to open the Group Manager\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_addDiaryEntry\";\n\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\"] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_GCH_addDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n[\n    [\n        \"Group Manager GUI\",\n        \"<execute expression='call KISKA_fnc_GCH_openDialog;'>Open Group Changer Dialog</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_GCH_addDiaryEntry.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_addDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_addGroupEventhandlers\n\nDescription:\n    Adds group eventhandlers that help the GCH GUI function.\n\nParameters:\n    0: _group <GROUP> - The Group to add the eventhandlers to\n\nReturns:\n    <HASHMAP> - A map with all event ids contained within it\n\nExamples:\n    (begin example)\n        [group player] call KISKA_fnc_GCH_addGroupEventhandlers\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_addGroupEventhandlers\";\n\nif !(hasInterface) exitWith {[]};\n\nparams [\n    [\"_group\",grpNull,[grpNull]]\n];\n\n\nif (isNull _group) exitWith {\n    [\"Null group provided, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _eventMap = _group getVariable \"KISKA_GCH_groupEventIdMap\";\nif !(isNil \"_eventMap\") exitWith {\n    [[\"Attempted to re apply group eventhandlers to: \",_group,\" when event map is: \",_eventMap]] call KISKA_fnc_log;\n    _eventMap\n};\n\n\nprivate _unitJoinedGroup_eventId = _group addEventHandler [\"UnitJoined\", {\n    params [\"_joinedGroup\",\"_unitThatJoined\"];\n    \n    private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n    if (_joinedGroup isEqualTo _selectedGroup) then {\n        [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n    };\n\n    if (_unitThatJoined isEqualTo player) then {\n        private _joinedGroupIsExcluded = [_joinedGroup] call KISKA_fnc_GCH_isGroupExcluded;\n        if (!_joinedGroupIsExcluded) exitWith {};\n\n        private _joinedGroupAlreadyHasPlayer = [group player] call KISKA_fnc_GCH_doesGroupHaveAnotherPlayer;\n        if (_joinedGroupAlreadyHasPlayer) exitWith {};\n\n        [_joinedGroup,false,true] call KISKA_fnc_GCH_setGroupExcluded;\n    };\n}];\n\n\nprivate _unitLeftGroup_eventId = _group addEventHandler [\"UnitLeft\", {\n    params [\"_group\", \"_unitThatLeft\"];\n\n    if !(isNull _group) then {\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n        if (_group isEqualTo _selectedGroup) then {\n            [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n        };\n    };\n}];\n\nprivate _groupIdChanged_eventId = _group addEventHandler [\"GroupIdChanged\", {\n    params [\"_group\", \"_newGroupId\"];\n    \n    if !(isNull _group) then {\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n        if (_group isEqualTo _selectedGroup) then {\n            [false,false,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n        };\n\n        [false] call KISKA_fnc_GCH_updateSideGroupsList;\n    };\n}];\n\nprivate _groupLeaderChanged_eventId = _group addEventHandler [\"LeaderChanged\", {\n    params [\"_group\", \"_newLeader\"];\n\n    if !(isNull _group) then {\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n        if (_group isEqualTo _selectedGroup) then {\n            [false,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n        };\n    };\n}];\n\nprivate _groupEmpty_eventId = _group addEventHandler [\"Empty\", {\n    // params [\"_group\"];\n}];\n\n\n_eventMap = createHashMapFromArray [\n    [\"unitjoined\",_unitJoinedGroup_eventId],\n    [\"unitleft\",_unitLeftGroup_eventId],\n    [\"idchanged\",_groupIdChanged_eventId],\n    [\"leaderchanged\",_groupLeaderChanged_eventId],\n    [\"emptygroup\",_groupEmpty_eventId]\n];\n_group setVariable [\"KISKA_GCH_groupEventIdMap\",_eventMap];\n\n\n_eventMap\n",
    "fileName": "fn_GCH_addGroupEventhandlers.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_addGroupEventhandlers.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_addMissionEvents\n\nDescription:\n    Adds mission event handlers for keeping track of groups.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_addMissionEvents\";\n\nif !(hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\n\naddMissionEventHandler [\"GroupCreated\", {\n    params [\"_group\"];\n    [_group] call KISKA_fnc_GCH_addGroupEventhandlers;\n}];\n\n\naddMissionEventHandler [\"GroupDeleted\", {\n    params [\"_group\"];\n\n    private _groupChangerOpen = [] call KISKA_fnc_GCH_isOpen;\n    if (_groupChangerOpen) then {\n        private _groupIsExcluded = [_group] call KISKA_fnc_GCH_isGroupExcluded;\n        private _deletedGroupSide = side _group;\n        private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n\n        if ((_playerSide isEqualTo _deletedGroupSide) AND (!_groupIsExcluded)) then {\n            [true] call KISKA_fnc_GCH_updateSideGroupsList;\n        };\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_GCH_addMissionEvents.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_addMissionEvents.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_assignTeamCombo\n\nDescription:\n    Reassigns a unit's team\n\nParameters:\n    0: _unit <OBJECT> - The unit to reassign\n    1: _team <NUMBER> - the team to assign\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [aUnit] remoteExec [\"KISKA_fnc_GCH_assignTeam\",LocalPlayerUnitOrLeaderOfGroup];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_assignTeam\";\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled!\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_GCH_assignTeam;\n};\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_team\",0,[123]]\n];\n\nif (isNull _unit) exitWith {\n    [\"Null object passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nswitch (_team) do {\n    case 1:{\n        _unit assignTeam \"BLUE\";\n    };\n    case 2:{\n        _unit assignTeam \"GREEN\";\n    };\n    case 3:{\n        _unit assignTeam \"RED\";\n    };\n    case 4:{\n        _unit assignTeam \"YELLOW\";\n    };\n\n    default {\n        _unit assignTeam \"MAIN\";\n    };\n};\n\n\nnil\n",
    "fileName": "fn_GCH_assignTeam.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_assignTeam.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_canPlayerChangeGroup\n\nDescription:\n    The function that fires on the leave group button click event.\n    The Event is added in KISKA_fnc_GCHOnLoad.\n\nParameters:\n    0: _groupToJoin : <group> - The group a player wants to join\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [someGroup] call KISKA_fnc_GCH_canPlayerChangeGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_canPlayerChangeGroup\";\n\n#define TRYING_TO_CREATE_NEW_GROUP 1\n#define TRYING_TO_JOIN_GROUP_WITHOUT_PERMS 2\n\nparams [\n    [\"_groupToJoin\",\"new group\",[grpNull,\"\"]]\n];\n\nprivate _allowedGroups = missionNamespace getVariable [\"KISKA_allowedGroups\",[]];\nprivate _currentPlayerGroup = group player;\n\nprivate _doExit = -1;\n\nif !(_allowedGroups isEqualTo []) then {\n\n    private _isInAllowedGroup = [\n        _allowedGroups,\n        {(group player) isEqualTo _x}\n    ] call KISKA_fnc_findIfBool;\n\n    if (_isInAllowedGroup AND {_groupToJoin isEqualTo \"new group\"}) exitWith {\n        _doExit = TRYING_TO_CREATE_NEW_GROUP;\n    };\n\n};\n\nif (_doExit isNotEqualTo -1) exitWith {\n\n    switch (_doExit) do {\n\n        case TRYING_TO_CREATE_NEW_GROUP: {\n            [\"You cannot create a new group, you must join only your allowed groups\"] call KISKA_fnc_errorNotification;\n        };\n\n        case TRYING_TO_JOIN_GROUP_WITHOUT_PERMS: {\n            private _text = parseText \"You are limited in the groups you can join, consult the Side Groups list. <t color='#00b530'>Green</t> are joinable.\";\n            [_text] call KISKA_fnc_errorNotification;\n        };\n    };\n};\n\nif (isNull _groupToJoin) exitWith {\n    [\"The group you are attempting to join no longer exists\"] call KISKA_fnc_errorNotification;\n};\n",
    "fileName": "fn_GCH_canPlayerChangeGroup.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_canPlayerChangeGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_doesGroupHaveAnotherPlayer\n\nDescription:\n    Checks if a group contains another player other than the local player\n\nParameters:\n    0: _group <GROUP> - The group to search in\n\nReturns:\n    <BOOL> - True if another player is in ther group\n\nExamples:\n    (begin example)\n        [group player] call KISKA_fnc_GCH_doesGroupHaveAnotherPlayer\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_doesGroupHaveAnotherPlayer\";\n\nparams [\n    [\"_group\",grpNull,[grpNull]]\n];\n\n\nif (isNull _group) exitWith {\n    [\"Null group passed\"] call KISKA_fnc_log;\n    false\n};\n\n\nprivate _anotherPlayerInGroup = [\n    units _group,\n    {\n        (_x isNotEqualTo player) AND (isPlayer _x)\n    }\n] call KISKA_fnc_findIfBool;\n\n\n_anotherPlayerInGroup\n",
    "fileName": "fn_GCH_doesGroupHaveAnotherPlayer.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_doesGroupHaveAnotherPlayer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_dontExcludePlayerGroupDefault\n\nDescription:\n    In order to maintain a player-group-is-not-excluded by default in the \n     Group Changer, when a player joins the game, they will set their group\n     to be not excluded on all other machines and JIP\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_dontExcludePlayerGroupDefault\";\n\nif !(hasInterface) exitWith {};\n\nprivate _playerGroup = group player;\nif (isNull _playerGroup) exitWith {};\n\nprivate _isGroupExcluded = [_playerGroup,true] call KISKA_fnc_GCH_isGroupExcluded;\nprivate _exclusionWasSet = !(isNil \"_isGroupExcluded\");\nif (_exclusionWasSet) exitWith {};\n\n[_playerGroup,false,true] call KISKA_fnc_GCH_setGroupExcluded;\n\n\nnil\n",
    "fileName": "fn_GCH_dontExcludePlayerGroupDefault.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_dontExcludePlayerGroupDefault.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_getPlayerSide\n\nDescription:\n    Returns the side of the player's group in order to avoid if the player is\n     captive and the object is technically a part of the civ faction for instance.\n\nParameters:\n    NONE\n\nReturns:\n    <SIDE> - The side of the player's group\n\nExamples:\n    (begin example)\n        private _playerSide = call KISKA_fnc_GCH_getPlayerSide;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_getPlayerSide\";\n\nif (!hasInterface) exitWith {\n    sideLogic\n};\n\n\nside (group player)",
    "fileName": "fn_GCH_getPlayerSide.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_getPlayerSide.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_getSelectedGroup\n\nDescription:\n    Returns the selected group in the group changer.\n\nParameters:\n    NONE\n\nReturns:\n    <GROUP> - The currently selected group or grpNull if not found\n\nExamples:\n    (begin example)\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_getSelectedGroup\";\n\nif !(hasInterface) exitWith {grpNull};\n\nlocalNamespace getVariable [\"KISKA_GCH_selectedGroup\",grpNull]",
    "fileName": "fn_GCH_getSelectedGroup.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_getSelectedGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_getSideGroups\n\nDescription:\n    Gets all groups of a particular side and that are not exlcuded from the GCH\n\nParameters:\n    0: _side <SIDE> - The side to get the groups of\n\nReturns:\n    <ARRAY> - List of all the groups\n\nExamples:\n    (begin example)\n        private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n        _groups = [_playerSide] call KISKA_fnc_GCH_getSideGroups;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_getSideGroups\";\n\nif !(hasInterface) exitWith {[]};\n\nparams [\n    [\"_side\",BLUFOR,[sideUnknown]]\n];\n\n\nallGroups select {\n    (side _x) isEqualTo _side AND\n    (!([_x] call KISKA_fnc_GCH_isGroupExcluded))\n};\n",
    "fileName": "fn_GCH_getSideGroups.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_getSideGroups.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_groupDeleteQuery\n\nDescription:\n    Acts as a liason from a client to add a group to auto delete if necessary.\n\n    Only works where the group is local and need to use groupOwner to get that\n     which only works on the server.\n\nParameters:\n    0: _group <GROUP> - The group to change the auto-deletion on\n    1: _canDelete <BOOL> - Set the group to be deleted or not\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myGroup,false] call KISKA_fnc_GCH_groupDeleteQuery;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_groupDeleteQuery\";\n\nif (!isServer) exitWith {\n    [\"Must be run on server\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nparams [\"_group\",\"_canDelete\"];\n\n_this remoteExecCall [\"deleteGroupWhenEmpty\",groupOwner _group];\n\n\nnil\n",
    "fileName": "fn_GCH_groupDeleteQuery.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_groupDeleteQuery.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_isAllowedToEdit\n\nDescription:\n    Checks if a machine is allowed to edit a given property in the GCH dialog.\n\nParameters:\n    0: _groupLeader <OBJECT or GROUP> - The leader or group to edit the property on.\n        If provided, it will be assumed that even the group leader can edit the property\n\nReturns:\n    <BOOL> - True if yes, false if no.\n\nExamples:\n    (begin example)\n        _canEdit = [myGroup] call KISKA_fnc_GCH_isAllowedToEdit;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_isAllowedToEdit\";\n\n// hosts and admins can always edit\nif (call KISKA_fnc_isAdminOrHost) exitWith {\n    true\n};\n\nparams [\n    [\"_groupLeader\",objNull,[objNull,grpNull]]\n];\n\nif (_groupLeader isEqualType grpNull) then {\n    _groupLeader = leader _groupLeader;\n};\n\nif (isNull _groupLeader) exitWith {\n    false\n};\n\nif (local _groupLeader) then {\n    true\n} else {\n    false\n};\n",
    "fileName": "fn_GCH_isAllowedToEdit.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_isAllowedToEdit.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_isGroupExcluded\n\nDescription:\n    Checks if a group is excluded from the Group Changer menu.\n\nParameters:\n    0: _group <GROUP> - The group to check exclusion of\n    1: _canBeNil <BOOL> - Whether or not to operate under the assumption of a default \"true\" value.\n        if `true`, function can either return a BOOL or nil for the var never having been set\n\nReturns:\n    <BOOL or nil> - Returns true if the group is excluded, false if not, or nil if never defined\n\nExamples:\n    (begin example)\n        private _isExcluded = [group player] call KISKA_fnc_GCH_isGroupExcluded;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_isGroupExcluded\";\n\nif !(hasInterface) exitWith {true};\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_canBeNil\",false,[true]]\n];\n\n\nif (_canBeNil) exitWith {_group getVariable \"KISKA_GCH_exclude\"};\n_group getVariable [\"KISKA_GCH_exclude\",true];\n",
    "fileName": "fn_GCH_isGroupExcluded.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_isGroupExcluded.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_isOpen\n\nDescription:\n    Checks if the group changer is open or not.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - Returns true if the group changer is open and false if it is not\n\nExamples:\n    (begin example)\n        private _isOpen = call KISKA_fnc_GCH_isOpen;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCH_isOpen\";\n\nif !(hasInterface) exitWith {false};\nprivate _gchDisplay = localNamespace getVariable [\"KISKA_GCH_display\",displayNull];\n\n\n!(isNull _gchDisplay)\n\n",
    "fileName": "fn_GCH_isOpen.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_isOpen.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_openDialog\n\nDescription:\n    Opens KISKA Group Changer dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_GCH_openDialog;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_openDialog\";\n\nif (missionNamespace getVariable [\"KISKA_CBA_GCH_enabled\",true]) then {\n    createDialog \"KISKA_GCH_dialog\";\n} else {\n    [\"The Group Changer Dialog is diabled in the Server Addon Options\"] call KISKA_fnc_errorNotification;\n};\n\n\nnil\n",
    "fileName": "fn_GCH_openDialog.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_openDialog.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_setGroupExcluded\n\nDescription:\n    Sets a group's exclusion from the Group Changer.\n\nParameters:\n    0: _group <GROUP> - The group to check exclusion of\n    1: _isExcluded <BOOL> - True to exclude group, false to include\n    2: _synchronize <BOOL> - True to remoteExec this function and provide a JIP message\n\nReturns:\n    <BOOL> - Returns true if the group is excluded or false if not\n\nExamples:\n    (begin example)\n        // exclude group\n        private _isExcluded = [group player,true] call KISKA_fnc_GCH_setGroupExcluded;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_setGroupExcluded\";\n\nif (!hasInterface) exitWith {true};\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_isExcluded\",true,[true]],\n    [\"_synchronize\",false,[true]]\n];\n\n\nif (isNull _group) exitWith {\n    [\"null group provided\"] call KISKA_fnc_log;\n    true\n};\n\nif (_synchronize) exitWith {\n    private _jipId = \"KISKA_GCH_groupExclusion:\" + (str _group);\n    [_group,_isExcluded] remoteExecCall [\"KISKA_fnc_GCH_setGroupExcluded\",0,_jipId];\n};\n\n_group setVariable [\"KISKA_GCH_exclude\",_isExcluded];\n[true] call KISKA_fnc_GCH_updateSideGroupsList;\n\n\n_isExcluded\n",
    "fileName": "fn_GCH_setGroupExcluded.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_setGroupExcluded.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_setLeaderRemote\n\nDescription:\n    Remotely sets a leader of a group from the server. (Must be run on the server)\n\nParameters:\n    0: _group <GROUP> - The group to set the unit to leader\n    1: _unitToSet <OBJECT> - The unit to set to leader of the group\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [group player, player] call KISKA_fnc_GCH_setLeaderRemote;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_setLeaderRemote\";\n\nparams [\"_group\",\"_unitToSet\"];\n\nif (!isServer) exitWith {\n    [\"Must be run on server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n_this remoteExecCall [\"selectLeader\",groupOwner _group];\n\n\nnil",
    "fileName": "fn_GCH_setLeaderRemote.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_setLeaderRemote.sqf"
  },
  {
    "text": "#include \"..\\Headers\\GCH Colors.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_updateCurrentGroupSection\n\nDescription:\n    Updates the individual components of the current group section of the GUI.\n\nParameters:\n    0: _updateUnitList <BOOL> - Updates the list of units\n    1: _updateLeaderIndicator <BOOL> - Updates the text that shows the leader's name\n    2: _updateGroupId <BOOL> - Updates the group's ID name\n    3: _updateCanDeleteCombo <BOOL> - Updates the state of the can delete combo list\n    4: _updateCanRallyCombo <BOOL> - Updates the state of the can delete combo list\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // update just the unit list\n        [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCH_updateCurrentGroupSection\";\n\nprivate _gchIsOpen = [] call KISKA_fnc_GCH_isOpen;\nif !(_gchIsOpen) exitWith {};\n\nparams [\n    [\"_updateUnitList\",false,[true]],\n    [\"_updateLeaderIndicator\",false,[true]],\n    [\"_updateGroupId\",false,[true]],\n    [\"_updateCanDeleteCombo\",false,[true]],\n    [\"_updateCanRallyCombo\",false,[true]]\n];\n\nprivate _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\nif (isNull _selectedGroup) exitWith {\n    private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n    lbClear _currentGroupListBox_ctrl;\n\n    private _leaderNameIndicator_ctrl = localNamespace getVariable \"KISKA_GCH_leaderNameIndicator_ctrl\";\n    _leaderNameIndicator_ctrl ctrlSetText \"\";\n\n    private _groupEditId_ctrl = localNamespace getVariable \"KISKA_GCH_groupIdEdit_ctrl\";\n    _groupEditId_ctrl ctrlSetText \"\";\n\n    private _canBeDeletedCombo_ctrl = localNamespace getVariable \"KISKA_GCH_canBeDeletedCombo_ctrl\";\n    lbClear _canBeDeletedCombo_ctrl;\n\n    private _canRallyCombo_ctrl = localNamespace getVariable [\"KISKA_GCH_canRallyCombo_ctrl\",controlNull];\n    lbClear _canRallyCombo_ctrl;\n};\n\n\nif (_updateUnitList) then {\n    private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n    lbClear _currentGroupListBox_ctrl;\n\n    private _groupUnits = units _selectedGroup;\n    if !(localNamespace getVariable \"KISKA_GCH_showAI\") then {\n        _groupUnits = _groupUnits select {isPlayer _x};\n    };\n\n    localNamespace setVariable [\"KISKA_GCH_groupUnitList\",_groupUnits];\n\n    if !(count _groupUnits > 0) exitWith {};\n\n\n    private [\"_index\",\"_team\"];\n    private _fn_setTeamColor = {\n        // don't change white team\n        if ((_team == \"MAIN\") OR (_team == \"\")) exitWith {};\n\n        if (_team == \"BLUE\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_BLUE];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_BLUE];\n        };\n        if (_team == \"GREEN\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_GREEN];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_GREEN];\n        };\n        if (_team == \"RED\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_RED];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_RED];\n        };\n        if (_team == \"YELLOW\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_YELLOW];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_YELLOW];\n        };\n\n    };\n\n    private \"_name\";\n    {\n        _name = name _x; // if a logic is in a group, it does not have a name\n        if (_name isNotEqualTo \"\") then {\n            _index = _currentGroupListBox_ctrl lbAdd _name;\n            // store index value in array before we sort alphabetically\n            _currentGroupListBox_ctrl lbSetValue [_index,_forEachIndex];\n\n            // color AI Green\n            if !(isPlayer _x) then {\n                _currentGroupListBox_ctrl lbSetTooltip [_index,\"AI\"];\n            };\n\n            _team = assignedTeam _x;\n            call _fn_setTeamColor;\n        };\n\n    } forEach _groupUnits;\n\n    lbSort _currentGroupListBox_ctrl;\n};\n\n\nif (_updateLeaderIndicator) then {\n    private _leader = leader _selectedGroup;\n    private \"_leaderName\";\n    if (isNull _leader) then {\n        _leaderName = \"NO LEADER\";\n    } else {\n        _leaderName = name _leader;\n    };\n    private _leaderNameIndicator_ctrl = localNamespace getVariable \"KISKA_GCH_leaderNameIndicator_ctrl\";\n    _leaderNameIndicator_ctrl ctrlSetText _leaderName;\n};\n\n\nif (_updateGroupId) then {\n    private _groupId = groupId _selectedGroup;\n    private _groupEditId_ctrl = localNamespace getVariable \"KISKA_GCH_groupIdEdit_ctrl\";\n    _groupEditId_ctrl ctrlSetText _groupId;\n};\n\n\nif (_updateCanDeleteCombo) then {\n    private _canBeDeletedCombo_ctrl = localNamespace getVariable \"KISKA_GCH_canBeDeletedCombo_ctrl\";\n    private _canDeleteWhenEmpty = isGroupDeletedWhenEmpty _selectedGroup;\n    _canBeDeletedCombo_ctrl setVariable [\"KISKA_firstTimeComboChanged\",true];\n    _canBeDeletedCombo_ctrl lbSetCurSel ([0,1] select _canDeleteWhenEmpty);\n};\n\n\nif (_updateCanRallyCombo) then {\n    private _canRallyCombo_ctrl = localNamespace getVariable [\"KISKA_GCH_canRallyCombo_ctrl\",controlNull];\n    _canRallyCombo_ctrl ctrlEnable false;\n\n    [_selectedGroup,_canRallyCombo_ctrl] spawn {\n        params [\"_selectedGroup\",\"_canRallyCombo_ctrl\"];\n\n        private _groupCanRally = [\n            \"KISKA_canRally\",\n            _selectedGroup,\n            false,\n            2\n        ] call KISKA_fnc_getVariableTarget;\n        \n        // make sure the menu is still open as it takes time to get a message from the server\n        // also make sure the same group is selected in the list\n        private _menuIsOpen = !isNull (localNamespace getVariable [\"KISKA_GCH_display\",displayNull]);\n        private _didNotSelectAnotherGroup = _selectedGroup isEqualTo ([] call KISKA_fnc_GCH_getSelectedGroup);\n        if (_menuIsOpen AND    _didNotSelectAnotherGroup) then {\n            _canRallyCombo_ctrl ctrlEnable true;\n            _canRallyCombo_ctrl setVariable [\"KISKA_firstTimeComboChanged\",true];\n            _canRallyCombo_ctrl lbSetCurSel ([0,1] select _groupCanRally);\n        };\n    };\n};\n\n\nnil\n",
    "fileName": "fn_GCH_updateCurrentGroupSection.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_updateCurrentGroupSection.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_updateSideGroupsList\n\nDescription:\n    Updates the side's groups list for the GCH dialog.\n\nParameters:\n    0: _queryForGroups <BOOL> - Does a search for all groups that can appear in the \n        Group Changer need to be reconducted?\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [true] call KISKA_fnc_GCH_updateSideGroupsList;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCH_updateSideGroupsList\";\n\n#define PLAYER_GROUP_COLOR [0,1,0,0.6] // Green\n\nif !([] call KISKA_fnc_GCH_isOpen) exitWith {};\n\nparams [\n    [\"_queryForGroups\",true,[true]]\n];\n\nprivate _listControl = localNamespace getVariable [\"KISKA_GCH_sidesGroupListBox_ctrl\",controlNull];\nif (isNull _listControl) exitWith {\n    [\"_listControl is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nlbClear _listControl;\n\nprivate _sideGroups = localNamespace getVariable [\"KISKA_GCH_sideGroupsArray\",[]];\nif (_queryForGroups OR (_sideGroups isEqualTo [])) then {\n    private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n    _sideGroups = [_playerSide] call KISKA_fnc_GCH_getSideGroups;\n    localNamespace setVariable [\"KISKA_GCH_sideGroupsArray\",_sideGroups];\n};\n\nprivate _selectedGroup = call KISKA_fnc_GCH_getSelectedGroup;\nprivate _groupWasPreviouslySelected = !(isNull _selectedGroup);\n\nif (_sideGroups isEqualTo []) exitWith {\n    if (_groupWasPreviouslySelected) then {\n        call KISKA_fnc_GCH_updateCurrentGroupSection;\n    };\n\n    nil\n};\n\n// add to listbox\nprivate _selectedIndex = -1;\nprivate _playerGroup = group player;\n\n{\n    private _index = _listControl lbAdd (groupId _x);\n    // saving the index as a value so that it can be referenced against the _sideGroups array\n    _listControl lbSetValue [_index,_forEachIndex];\n\n    // highlight the player group\n    if (_x isEqualTo _playerGroup) then {\n        _listControl lbSetColor [_index, PLAYER_GROUP_COLOR];\n    };\n    \n    if (_groupWasPreviouslySelected AND (_x isEqualTo _selectedGroup)) then {\n        _selectedIndex = _forEachIndex;\n    };\n} forEach _sideGroups;\n\n\n// sort list alphabetically\nlbSort _listControl;\n\nprivate _selectedGroupNotInList = _selectedIndex < 0;\nif (_selectedGroupNotInList) exitWith {\n    if (_groupWasPreviouslySelected) then {\n        call KISKA_fnc_GCH_updateCurrentGroupSection;\n    };\n\n    nil\n};\n\nprivate _listSize = lbSize _listControl;\nfor \"_listBoxIndex\" from 0 to (_listSize - 1) do {\n    private _sideGroupsIndexOfLbEntry = _listControl lbValue _listBoxIndex;\n    \n    if (_sideGroupsIndexOfLbEntry isEqualTo _selectedIndex) then {\n        _listControl lbSetCurSel _listBoxIndex;\n        break;\n    };\n};\n\n\n\nnil\n",
    "fileName": "fn_GCH_updateSideGroupsList.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_GroupChanger/Functions/fn_GCH_updateSideGroupsList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_addItemToPool\n\nDescription:\n    Adds an entry into the local Simple Store pool for the given id.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n    1: _itemToAdd <ANY> - Whatever value that is meant to be added.\n    2: _itemId <STRING> Default: `{_storeId}_item_{number}` - A unique identifier\n        for the item. If one is not provided, an ID is generated using `KISKA_fnc_generateUniqueId`.\n\nReturns:\n    <STRING> - the item's `_itemId`\n\nExamples:\n    (begin example)\n        [\n            \"myStore\",\n            \"MyValue\"\n        ] call KISKA_fnc_simpleStore_addItemToPool;\n    (end)\n\n    (begin example)\n        [\n            \"myStore\",\n            \"MyValue\",\n            \"KISKA_itemId\"\n        ] call KISKA_fnc_simpleStore_addItemToPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_addItemToPool\";\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_storeId\",\"\",[\"\"]],\n    \"_itemToAdd\",\n    [\"_itemId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\n// TODO 176: change to map\nprivate _poolItemsMap = [_storeId] call KISKA_fnc_simpleStore_getPoolItems;\nif (_itemId isEqualTo \"\") then {\n    _itemId = [[_storeId,\"item\"] joinString \"_\"] call KISKA_fnc_generateUniqueId;\n};\n_poolItemsMap set [_itemId,_itemToAdd];\n\n[_storeId] call KISKA_fnc_simpleStore_refreshSelectedList;\n[_storeId] call KISKA_fnc_simpleStore_refreshPoolList;\n\n\n_itemId\n",
    "fileName": "fn_simpleStore_addItemToPool.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_addItemToPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_addItemToPool_global\n\nDescription:\n    The same as `KISKA_fnc_simpleStore_addItemToPool` except it abstracts away the\n    generating of an item's id and handling of JIP messages. Ideally should be used\n    in conjunction with `KISKA_fnc_simpleStore_removeItemFromPool_global`.\n\n    This will trigger an execution of `KISKA_fnc_simpleStore_addItemToPool` on all\n    machines and add a JIP queue message.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n    1: _itemToAdd <ANY> - Whatever value that is meant to be added.\n\nReturns:\n    <STRING> - the item's global identifier which is also used for the JIP queue.\n\nExamples:\n    (begin example)\n        private _itemId = [\n            \"myStore\",\n            \"MyValue\"\n        ] call KISKA_fnc_simpleStore_addItemToPool_global;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_addItemToPool_global\";\n\nparams [\n    [\"_storeId\",\"\",[\"\"]],\n    \"_itemToAdd\"\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _itemId = [[_storeId,\"item\"] joinString \"_\"] call KISKA_fnc_generateUniqueId;\n[_storeId,_itemToAdd,_itemId] remoteExecCall [\"KISKA_fnc_simpleStore_addItemToPool\",0,_itemId];\n\n\n_itemId\n",
    "fileName": "fn_simpleStore_addItemToPool_global.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_addItemToPool_global.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_getDisplay\n\nDescription:\n    Gets the display for the given stimple store.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n\nReturns:\n    DISPLAY - The simple store's display or `displayNull` in the event that it\n        is not currently open.\n\nExamples:\n    (begin example)\n        private _myStoreDisplay = [\n            \"myStore\"\n        ] call KISKA_fnc_simpleStore_getDisplay;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_getDisplay\";\n\nif !(hasInterface) exitWith { displayNull };\ndisableSerialization;\n\nparams [\n    [\"_storeId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    displayNull\n};\n\nprivate _activeDisplay = localNamespace getVariable [\"KISKA_simpleStore_activeDisplay\",displayNull];\nif (isNull _activeDisplay) exitWith { displayNull };\n\nprivate _displayStoreId = _activeDisplay getVariable [\"KISKA_simpleStore_id\",\"\"];\nif (_displayStoreId != _storeId) exitWith { displayNull };\n\n\n_activeDisplay\n",
    "fileName": "fn_simpleStore_getDisplay.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_getDisplay.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_getPoolItems\n\nDescription:\n    Gets the current map of pool items for a particular simple store id.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n\nReturns:\n    <HASHMAP> - The specified simple store's item map\n\nExamples:\n    (begin example)\n        private _storeItemsMap = [\n            \"myStore\"\n        ] call KISKA_fnc_simpleStore_getPoolItems;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_getPoolItems\";\n\nparams [\n    [\"_storeId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _storeIdToPoolItemsMap = call KISKA_fnc_simpleStore_getStoreMap;\n_storeId = toLowerANSI _storeId;\nprivate _poolItemsMap = _storeIdToPoolItemsMap get _storeId;\n\nif (isNil \"_poolItemsMap\") then { \n    _poolItemsMap = createHashMap;\n    _storeIdToPoolItemsMap set [_storeId,_poolItemsMap];\n};\n\n\n_poolItemsMap\n",
    "fileName": "fn_simpleStore_getPoolItems.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_getPoolItems.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_getStoreMap\n\nDescription:\n    Gets the global map that stores the store id and what the current pool items\n    list is.\n\nParameters:\n    NONE\n\nReturns:\n    HASHMAP - The data which maps a store id to it's pool list.\n\nExamples:\n    (begin example)\n        private _storeIdToPoolItemsMap = call KISKA_fnc_simpleStore_getStoreMap;\n        private _myStoresPoolItems = _storeIdToPoolItemsMap get \"myStore\";\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_getStoreMap\";\n\n\nprivate _map = localNamespace getVariable \"KISKA_simpleStore_storeIdToPoolItemsMap\";\nif !(isNil \"_map\") exitWith { _map };\n\n_map = createHashMap;\nlocalNamespace setVariable [\"KISKA_simpleStore_storeIdToPoolItemsMap\",_map];\n\n\n_map\n",
    "fileName": "fn_simpleStore_getStoreMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_getStoreMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_isStoreOpen\n\nDescription:\n    Checks if the given store is open.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n\nReturns:\n    BOOL - whether or not the store is open.\n\nExamples:\n    (begin example)\n        private _isMyStoreOpen = [\n            \"myStore\"\n        ] call KISKA_fnc_simpleStore_isStoreOpen;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_isStoreOpen\";\n\nif !(hasInterface) exitWith { false };\ndisableSerialization;\n\nparams [\n    [\"_storeId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    false\n};\n\n\nprivate _storeDisplay = [_storeId] call KISKA_fnc_simpleStore_getDisplay;\nisNull _storeDisplay\n",
    "fileName": "fn_simpleStore_isStoreOpen.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_isStoreOpen.sqf"
  },
  {
    "text": "#include \"..\\Headers\\SimpleStoreCommonDefines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_open\n\nDescription:\n    Opens a simple store dialog/initializes it if it has not been opened prior.\n\nParameters:\n    0: _paramsMap : <HASHMAP> - A hashmap of the following arguments:\n        - `_storeId` <STRING>: The id for the particular simple store.\n        - `_fn_poolItemToListboxItem` <CODE>: A mapping function that will be called on every\n            item in the pool items list to convert it into a listbox item to show\n            in the UI. In the event that the function returns `nil` the item will\n            be excluded from the pool list. \n\n                Parameters: \n                \n                - 0: <ANY> - A pool item.\n                - 1: <NUMBER> - The index of the item in the pool.\n\n                Should return an array containing:\n\n                - 0: <STRING> - The text of the listbox element.\n                - 1: <STRING> - Default: `\"\"` - A path for the picture of the element.\n                - 2: <ARRAY> - Default: `[]` - An RBGA array for the picture's color.\n                - 3: <ARRAY> - Default: `[]` - An RBGA array for the picture's color when selected.\n                - 4: <STRING> - Default: `\"\"` - The element's tooltip.\n        \n        - `_fn_getSelectedItems` <CODE>: A function that will be called whenever\n            `KISKA_fnc_simpleStore_refreshSelectedList` is. Must return an array of\n            items formatted the same as an item returned from `_fn_poolItemToListboxItem`\n            with the addition of index 5 being the listbox item's `data` property.\n\n            Passed the following args:\n                \n                - 0: <STRING> - The store id.\n\n        - `_fn_onTake` <CODE>: A function that will be called when the Take button \n            is clicked. Passed the following args:\n\n                - 0: <STRING> - The store id.\n                - 1: <ANY> - Whatever the item from the pool that was selected.\n                - 2: <STRING> - The item's id from the pool items map retrieved from \n                    `KISKA_fnc_simpleStore_getPoolItems`. Will be an empty string (`\"\"`)\n                    if no item is selected.\n\n        - `_fn_onStore` <CODE>: A function that will be called when the Store button \n            is clicked. Passed the following args:\n\n                - 0: <STRING> - The store id.\n                - 1: <STRING> - The item's `lbData`.\n                - 2: <NUMBER> - The index of the selected item in the selected items list. \n                    This is the index of the source array, not the index in the list box.\n\n        - `_storeTitle` <STRING>: Default `\"KISKA Simple Store\"` - The text that appears at on the top banner.\n        - `_storePoolTitle` <STRING>: Default `\"Pool List\"` - The text that appears \n            above the pool list to identify it.\n        - `_storeSelectedItemsTitle` <STRING>: Default `\"Selected List\"` - The text that appears \n            above the selected items list to identify it.\n        - `_headerBannerBackgroundColor` <COLOR(RGBA)>: Default `profile color` - The color \n            of the store title header.\n\nReturns:\n    <DISPLAY> - The simple store dialog's display\n\nExamples:\n    (begin example)\n        myStoreSelectedItems = [];\n        private _args = createHashMapFromArray [\n            [\"_storeId\",\"myStore\"],\n            [\"_fn_getSelectedItems\",{myStoreSelectedItems}],\n            [\n                \"_fn_onTake\",\n                {\n                    params [\"_storeId\",\"_itemId\"];\n                    _this call KISKA_fnc_simpleStore_removeItemFromPool;\n                }\n            ],\n            [\n                \"_fn_onStore\",\n                {\n                    params [\"_storeId\",\"_data\",\"_index\"];\n                    [\n                        _storeId,\n                        myStoreSelectedItems deleteAt _index\n                    ] call KISKA_fnc_simpleStore_addItemToPool;\n                }\n            ]\n        ];\n        _args call KISKA_fnc_simpleStore_open;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_open\";\n\nif !(hasInterface) exitWith {};\ndisableSerialization;\n\nprivate _currentStore = localNamespace getVariable [\"KISKA_simpleStore_activeDisplay\",displayNull];\nif !(isNull _currentStore) exitWith {\n    [\"Another simple store is currently open\",true] call KISKA_fnc_log;\n    displayNull\n};\n\nprivate _paramsMap = _this;\nprivate _paramDetails = [\n    [\"_storeId\",{\"\"},[\"\"]],\n    [\"_fn_poolItemToListboxItem\",{{ _this select 0 }},[{}]],\n    [\"_fn_getSelectedItems\",{{}},[{}]],\n    [\"_fn_onTake\",{{}},[{}]],\n    [\"_fn_onStore\",{{}},[{}]],\n    [\"_storeTitle\",{\"KISKA Simple Store\"},[\"\"]],\n    [\"_storePoolTitle\",{\"Pool List\"},[\"\"]],\n    [\"_storeSelectedItemsTitle\",{\"Selected List\"},[\"\"]],\n    [\n        \"_headerBannerBackgroundColor\",\n        {\n            [\n                (profilenamespace getvariable ['GUI_BCG_RGB_R',0.13]),\n                (profilenamespace getvariable ['GUI_BCG_RGB_G',0.54]),\n                (profilenamespace getvariable ['GUI_BCG_RGB_B',0.21]),\n                1\n            ]\n        },\n        [[]]\n    ]\n];\n\nprivate _paramValidationResult = [_paramsMap,_paramDetails] call KISKA_fnc_hashMapParams;\nif (_paramValidationResult isEqualType \"\") exitWith {\n    [_paramValidationResult,true] call KISKA_fnc_log;\n    nil\n};\n(_paramValidationResult select 0) params (_paramValidationResult select 1);\n\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    displayNull\n};\n\nif (_fn_getSelectedItems call KISKA_fnc_isEmptyCode) exitWith {\n    [\"_fn_getSelectedItems is empty, it must be implemented\",true] call KISKA_fnc_log;\n    displayNull\n};\nif (_fn_onTake call KISKA_fnc_isEmptyCode) exitWith {\n    [\"_fn_onTake is empty, it must be implemented\",true] call KISKA_fnc_log;\n    displayNull\n};\nif (_fn_onStore call KISKA_fnc_isEmptyCode) exitWith {\n    [\"_fn_onStore is empty, it must be implemented\",true] call KISKA_fnc_log;\n    displayNull\n};\n\nprivate _display = createDialog [\"KISKA_simpleStore_dialog\",false];\nprivate _storeHeaderControl = _display displayCtrl SIMPLE_STORE_HEADER_TEXT_IDC;\n_storeHeaderControl ctrlSetBackgroundColor _headerBannerBackgroundColor;\n_storeHeaderControl ctrlSetText _storeTitle;\n(_display displayCtrl SIMPLE_STORE_POOL_HEADER_TEXT_IDC) ctrlSetText _storePoolTitle;\n(_display displayCtrl SIMPLE_STORE_SELECTED_HEADER_TEXT_IDC) ctrlSetText _storeSelectedItemsTitle;\n\n\n/* ----------------------------------------------------------------------------\n    Variables\n---------------------------------------------------------------------------- */\nlocalNamespace setVariable [\"KISKA_simpleStore_activeDisplay\",_display];\n_display setVariable [\"KISKA_simpleStore_id\",_storeId];\n_display setVariable [\"KISKA_simpleStore_poolListControl\",_display displayCtrl SIMPLE_STORE_POOL_LIST_IDC];\n_display setVariable [\"KISKA_simpleStore_selectedListControl\",_display displayCtrl SIMPLE_STORE_SELECTED_LIST_IDC];\n_display setVariable [\"KISKA_simpleStore_fn_getSelectedItems\",_fn_getSelectedItems];\n_display setVariable [\"KISKA_simpleStore_fn_onStore\",_fn_onStore];\n_display setVariable [\"KISKA_simpleStore_fn_onTake\",_fn_onTake];\n_display setVariable [\"KISKA_simpleStore_fn_poolItemToListboxItem\",_fn_poolItemToListboxItem];\n\n\n/* ----------------------------------------------------------------------------\n    Event Handlers\n---------------------------------------------------------------------------- */\n(_display displayCtrl SIMPLE_STORE_TAKE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\", {\n    params [\"_buttonControl\"];\n\n    private _simpleStoreDisplay = ctrlParent _buttonControl;\n    private _poolListControl = _simpleStoreDisplay getVariable \"KISKA_simpleStore_poolListControl\";\n    private _selectedListboxIndex = lbCurSel _poolListControl;\n\n    if (\n        _selectedListboxIndex >= 0 AND \n        // if a user selects an item and then clicks the button again\n        // lbCurSel still returns the index of the previously selected one\n        {(_poolListControl lbText _selectedListboxIndex) isNotEqualTo \"\"}\n    ) then {\n        private _selectedItemId = _poolListControl lbData _selectedListboxIndex;\n        private _storeId = _simpleStoreDisplay getVariable \"KISKA_simpleStore_id\";\n        private _poolItemsMap = [_storeId] call KISKA_fnc_simpleStore_getPoolItems;\n        private _selectedItem = _poolItemsMap get _selectedItemId;\n        [\n            _storeId,\n            _selectedItem,\n            _selectedItemId\n        ] call (_simpleStoreDisplay getVariable \"KISKA_simpleStore_fn_onTake\");\n    };\n}];\n\n(_display displayCtrl SIMPLE_STORE_STORE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\", {\n    params [\"_buttonControl\"];\n    private _simpleStoreDisplay = ctrlParent _buttonControl;\n    private _selectedListControl = _simpleStoreDisplay getVariable \"KISKA_simpleStore_selectedListControl\";\n    private _selectedListboxIndex = lbCurSel _selectedListControl;\n\n    if (\n        _selectedListboxIndex >= 0 AND \n        // if a user selects an item and then clicks the button again\n        // lbCurSel still returns the index of the previously selected one\n        {(_selectedListControl lbText _selectedListboxIndex) isNotEqualTo \"\"}\n    ) then {\n        [\n            _simpleStoreDisplay getVariable \"KISKA_simpleStore_id\",\n            _selectedListControl lbData _selectedListboxIndex,\n            _selectedListboxIndex\n        ] call (_simpleStoreDisplay getVariable \"KISKA_simpleStore_fn_onStore\");\n    };\n}];\n\n(_display displayCtrl SIMPLE_STORE_CLOSE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\", {\n    params [\"_control\"];\n    private _simpleStoreDisplay = ctrlParent _control;\n    _simpleStoreDisplay closeDisplay 2;\n}];\n\n_display displayAddEventHandler [\"unload\",{\n    localNamespace setVariable [\"KISKA_simpleStore_activeDisplay\",nil];\n}];\n\n\n[_storeId] call KISKA_fnc_simpleStore_refreshSelectedList;\n[_storeId] call KISKA_fnc_simpleStore_refreshPoolList;\n\n\n_display\n",
    "fileName": "fn_simpleStore_open.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_open.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_refreshPoolList\n\nDescription:\n    Triggers a refresh of the data that is in the pool list box of the given\n    store.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"myStore\"] call KISKA_fnc_simpleStore_refreshPoolList;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_refreshPoolList\";\n\nif !(hasInterface) exitWith {};\ndisableSerialization;\n\nparams [\n    [\"_storeId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _storeDisplay = [_storeId] call KISKA_fnc_simpleStore_getDisplay;\nif (isNull _storeDisplay) exitWith {\n    [[\"Store \",_storeId,\" is not open\"],false] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _poolItemsListControl = _storeDisplay getVariable [\"KISKA_simpleStore_poolListControl\",controlNull];\nprivate _previouslySelectedIndex = lbCurSel _poolItemsListControl;\nlbClear _poolItemsListControl;\n\nprivate _poolItems = [_storeId] call KISKA_fnc_simpleStore_getPoolItems;\nif ((count _poolItems) < 1) exitWith { nil };\n\n\nprivate _fn_poolItemToListboxItem = _storeDisplay getVariable \"KISKA_simpleStore_fn_poolItemToListboxItem\";\n{\n    private _listBoxItem = [_y,_forEachIndex] call _fn_poolItemToListboxItem;\n    if (isNil \"_listBoxItem\") then {continue};\n\n    _listBoxItem params [\n        [\"_text\",\"\",[\"\"]],\n        [\"_picture\",\"\",[\"\"]],\n        [\"_pictureColor\",[],[[]]],\n        [\"_pictureColorSelected\",[],[[]]],\n        [\"_tooltip\",\"\",[\"\"]]\n    ];\n\n    private _element = _poolItemsListControl lbAdd _text;\n    _poolItemsListControl lbSetTooltip [_element,_tooltip];\n    _poolItemsListControl lbSetData [_element,_x];\n\n    if (_picture isNotEqualTo \"\") then {\n        _poolItemsListControl lbSetPicture [_element,_picture];\n    };\n    if (_pictureColor isNotEqualTo []) then {\n        _poolItemsListControl lbSetPictureColor [_element,_pictureColor];\n    };\n    if (_pictureColorSelected isNotEqualTo []) then {\n        _poolItemsListControl lbSetPictureColor [_element,_pictureColorSelected];\n    };\n} forEach _poolItems;\n\nlbSort _poolItemsListControl;\n\nprivate _maxIndex = (count _poolItems) - 1;\nif (_previouslySelectedIndex > _maxIndex) then {\n    _previouslySelectedIndex = _maxIndex;\n};\n_poolItemsListControl lbSetSelected [_previouslySelectedIndex,true];\n\n\nnil\n",
    "fileName": "fn_simpleStore_refreshPoolList.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_refreshPoolList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_refreshSelectedList\n\nDescription:\n    Triggers a refresh of the data that is in the selected items list box of \n    the given store for the local machine.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"myStore\"] call KISKA_fnc_simpleStore_refreshSelectedList;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_refreshSelectedList\";\n\nif !(hasInterface) exitWith {};\ndisableSerialization;\n\nparams [\n    [\"_storeId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _storeDisplay = [_storeId] call KISKA_fnc_simpleStore_getDisplay;\nif (isNull _storeDisplay) exitWith {\n    [[\"Store \",_storeId,\" is not open\"],false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _selectedItemsListControl = _storeDisplay getVariable [\"KISKA_simpleStore_selectedListControl\",controlNull];\nprivate _previouslySelectedIndex = lbCurSel _selectedItemsListControl;\nlbClear _selectedItemsListControl;\n\nprivate _fn_getSelectedItems = _storeDisplay getVariable \"KISKA_simpleStore_fn_getSelectedItems\";\nprivate _selectedItems = [_storeId] call _fn_getSelectedItems;\nif (_selectedItems isEqualTo []) exitWith { nil };\n\n{\n    if (isNil \"_x\") then {continue};\n    \n    _x params [\n        [\"_text\",\"\",[\"\"]],\n        [\"_picture\",\"\",[\"\"]],\n        [\"_pictureColor\",[],[[]]],\n        [\"_pictureColorSelected\",[],[[]]],\n        [\"_tooltip\",\"\",[\"\"]],\n        [\"_data\",\"\",[\"\"]]\n    ];\n\n    private _element = _selectedItemsListControl lbAdd _text;\n    _selectedItemsListControl lbSetValue [_element,_forEachIndex];\n    _selectedItemsListControl lbSetTooltip [_element,_tooltip];\n    _selectedItemsListControl lbSetData [_element,_data];\n\n    if (_picture isNotEqualTo \"\") then {\n        _selectedItemsListControl lbSetPicture [_element,_picture];\n    };\n    if (_pictureColor isNotEqualTo []) then {\n        _selectedItemsListControl lbSetPictureColor [_element,_pictureColor];\n    };\n    if (_pictureColorSelected isNotEqualTo []) then {\n        _selectedItemsListControl lbSetPictureColor [_element,_pictureColorSelected];\n    };\n} forEach _selectedItems;\n\n\nprivate _maxIndex = (count _selectedItems) - 1;\nif (_previouslySelectedIndex > _maxIndex) then {\n    _previouslySelectedIndex = _maxIndex;\n};\n_selectedItemsListControl lbSetSelected [_previouslySelectedIndex,true];\n\n\nnil\n",
    "fileName": "fn_simpleStore_refreshSelectedList.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_refreshSelectedList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_removeItemFromPool\n\nDescription:\n    Removes the item with the provided ID from the item pool of the given store.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n    1: _poolItemId <STRING> - The id of the item to remove from the item pool.\n\nReturns:\n    <ANY> - whatever the removed item was\n\nExamples:\n    (begin example)\n        private _removedItem = [\n            \"myStore\",\n            \"KISKA_myStore_item_1\"\n        ] call KISKA_fnc_simpleStore_removeItemFromPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_removeItemFromPool\";\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_storeId\",\"\",[\"\"]],\n    [\"_poolItemId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _poolItemsMap = [_storeId] call KISKA_fnc_simpleStore_getPoolItems;\nprivate _deletedItem = _poolItemsMap deleteAt _poolItemId;\n\n[_storeId] call KISKA_fnc_simpleStore_refreshSelectedList;\n[_storeId] call KISKA_fnc_simpleStore_refreshPoolList;\n\n\n_deletedItem\n",
    "fileName": "fn_simpleStore_removeItemFromPool.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_removeItemFromPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_simpleStore_removeItemFromPool_global\n\nDescription:\n    The same as `KISKA_fnc_simpleStore_removeItemFromPool` except it abstracts\n    away the removal of a JIP queue message for the item to be added to the pool.\n\n    This will execute `KISKA_fnc_simpleStore_removeItemFromPool` on all machines.\n\nParameters:\n    0: _storeId <STRING> - The id for the particular simple store.\n    1: _poolItemId <STRING> - The id of the item to remove from the item pool.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"myStore\",\n            \"KISKA_myStore_item_1\"\n        ] call KISKA_fnc_simpleStore_removeItemFromPool_global;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_simpleStore_removeItemFromPool_global\";\n\nparams [\n    [\"_storeId\",\"\",[\"\"]],\n    [\"_poolItemId\",\"\",[\"\"]]\n];\n\nif (_storeId isEqualTo \"\") exitWith {\n    [\"_storeId is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\n_this remoteExecCall [\"KISKA_fnc_simpleStore_removeItemFromPool\",0];\n// remove JIP queue message for adding the item to the pool\n// see KISKA_fnc_simpleStore_addItemToPool_global\nremoteExec [\"\",_poolItemId];",
    "fileName": "fn_simpleStore_removeItemFromPool_global.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SimpleStore/Functions/fn_simpleStore_removeItemFromPool_global.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_addGrammarXml\n\nDescription:\n    Adds an xml grammar file to the speech recognizer.\n\nParameters:\n    0: _name <STRING> - The name of the grammar to add\n    1: _xml <STRING> - The xml in string format\n\nReturns:\n    <BOOL> - true if will be added, false if cannot be added\n\nExamples:\n    (begin example)\n        [\"name\",loadFile \"myXmlFile.xml\"] call KISKA_fnc_SR_addGrammarXml;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_addGrammarXml\";\n\nparams [\n    [\"_name\",\"\",[\"\"]],\n    [\"_xml\",\"\",[\"\"]]\n];\n\nif (_name isEqualTo \"\") exitWith {\n    [\"Grammar must have a unique name!\",true] call KISKA_fnc_log;\n};\nif (_xml isEqualTo \"\") exitWith {\n    [\"Invalid xml passed!\",true] call KISKA_fnc_log;\n};\n\nprivate _return = [\"kiska_ext_sr_addgrammarxml\",_this] call KISKA_fnc_SR_callExtension;\n\n\nif (_return == \"true\") exitWith {true};\nfalse",
    "fileName": "fn_SR_addGrammarXml.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SpeechRecognition/SQF Functions/fn_SR_addGrammarXml.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_callExtension\n\nDescription:\n    Calls to KISKA_speechRecognition(_x64).dll extension to run a function within\n     it.\n\nParameters:\n    0: _functionToRun <STRING> - The name of the function to run\n    1: _args <ARRAY> - Any arguments to pass to the extension\n\nReturns:\n    <STRING> - Whatever the extension returns\n\nExamples:\n    (begin example)\n        private _return = [\"kiska_ext_sr_startrecording\"] call KISKA_fnc_SR_callExtension;\n    (end)\n\n    (begin example)\n        private _return = [\n            \"kiska_ext_sr_addgrammarxml\",\n            [\"my grammar\",\"...gramarxml\"]\n        ] call KISKA_fnc_SR_callExtension;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_callExtension\";\n\nparams [\n    [\"_functionToRun\",\"\",[\"\"]],\n    [\"_args\",[],[[]]]\n];\n\nif (_functionToRun isEqualTo \"\") exitWith {\n    [\"Empty function call provided\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_args isEqualTo []) exitWith {\n    \"KISKA_SpeechRecognition\" callExtension _functionToRun;\n};\n\n\n\"KISKA_SpeechRecognition\" callExtension [_functionToRun,_args];\n",
    "fileName": "fn_SR_callExtension.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SpeechRecognition/SQF Functions/fn_SR_callExtension.sqf"
  },
  {
    "text": "params [\n    \"_name\", \n    \"_function\", \n    \"_data\"\n];\n\nhint (str _this);",
    "fileName": "fn_SR_callbackHandler.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SpeechRecognition/SQF Functions/fn_SR_callbackHandler.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_startRecording\n\nDescription:\n    Starts KISKA Speech recognition's extension's listening to the the user's\n     microphone to complete a speech recognition event.\n\nParameters:\n    0: _timelineId <NUMBER> - The id of the timeline to stop\n\nReturns:\n    <BOOL> - true if recording started, false if recording is currently happening\n\nExamples:\n    (begin example)\n        private _started = call KISKA_fnc_SR_startRecording;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_startRecording\";\n\nprivate _return = [\"kiska_ext_sr_startrecording\"] call KISKA_fnc_SR_callExtension;\n\nif (_return == \"true\") exitWith {true};\nfalse",
    "fileName": "fn_SR_startRecording.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SpeechRecognition/SQF Functions/fn_SR_startRecording.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_stopRecording\n\nDescription:\n    Manually stops KISKA's Speech Recognition extension from listening to the user's\n     microphone.\n\n    NOTE: Every complete recognition of a phrase after beginning a recording will \n     automatically stop the extension from listening. The purpose of this function \n     is to manually tell the extension you want to stop recording during the act of \n     saying a phrase\n\nParameters:\n\nReturns:\n    <BOOL> - true if a recording was stopped, false if recording was not happening \n     when called\n\nExamples:\n    (begin example)\n        private _stopped = call KISKA_fnc_SR_stopRecording;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_stopRecording\";\n\nprivate _return = [\"kiska_ext_sr_stoprecording\"] call KISKA_fnc_SR_callExtension;\n\nif (_return == \"true\") exitWith {true};\nfalse",
    "fileName": "fn_SR_stopRecording.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SpeechRecognition/SQF Functions/fn_SR_stopRecording.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_addDiaryEntry\n\nDescription:\n    Creates a diary entry in the map for the player to open the support Manager\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_addDiaryEntry\";\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\"] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 3;\n    false\n};\n\n[\n    [\n        \"Support Manager GUI\",\n        \"<execute expression='call KISKA_fnc_supportManager_open;'>Open Support Manager</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_supportManager_addDiaryEntry.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SupportManager/Functions/fn_supportManager_addDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_addToPool\n\nDescription:\n    Adds an entry into the support manager pool globally.\n\nParameters:\n    0: _supportConfig <CONFIG | STRING> - The config or a string of a class \n        that is in a `KISKA_Supports` class in either the \n        `missionConfigFile`, `campaignConfigFile`, or `configFile`.\n    1: _numberOfUsesLeft <NUMBER> - Default: `-1` - The number of support uses left or rounds\n        available to use. If less than 0, the configed value will be used.\n\nReturns:\n    <STRING> - the item's global identifier which is also used for the JIP queue.\n\nExamples:\n    (begin example)\n        [\"someClassInKISKA_Supports\"] call KISKA_fnc_supportManager_addToPool;\n    (end)\n\n    (begin example)\n        private _itemId = [\n            configFile >> \"CfgCommunicationMenu\" >> \"MySupport\"\n        ] call KISKA_fnc_supportManager_addToPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_addToPool\";\n\n#define STORE_ID \"kiska-support-manager\"\n\nif !(hasInterface) exitWith {};\n\nparams [\n    [\"_supportConfig\",configNull,[configNull,\"\"]],\n    [\"_numberOfUsesLeft\",-1,[123]]\n];\n\nif (_supportConfig isEqualType \"\") then {\n    _supportConfig = [[\"KISKA_Supports\",_supportConfig]] call KISKA_fnc_findConfigAny;\n};\nif (isNull _supportConfig) exitWith {\n    [\"Could not find _supportConfig\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _itemId = [\n    STORE_ID,\n    [_supportConfig,_numberOfUsesLeft]\n] call KISKA_fnc_simpleStore_addItemToPool_global;\n\n\n_itemId\n",
    "fileName": "fn_supportManager_addToPool.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SupportManager/Functions/fn_supportManager_addToPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_open\n\nDescription:\n    Opens KISKA Support Manager dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_supportManager_open;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_open\";\n\nif !(hasInterface) exitWith {\n    [\"Attempting to open support manager with no interface\"] call KISKA_fnc_log;\n    nil\n};\n\ndisableSerialization;\n\nprivate _args = [\n    localNamespace,\n    \"KISKA_supportManager_openArgs\",\n    {\n        createHashMapFromArray [\n            [\"_storeId\",\"kiska-support-manager\"],\n            [\"_storeSelectedItemsTitle\",\"Current Supports\"],\n            [\"_storePoolTitle\",\"Support Pool\"],\n            [\"_storeTitle\",\"Support Manager\"],\n            [\n                \"_fn_poolItemToListboxItem\",\n                {\n                    params [\n                        [\"_poolItem\",[],[[]]],\n                        [\"_index\",-1,[123]]\n                    ];\n\n                    _poolItem params [\n                        [\"_config\",configNull,[configNull]], \n                        [\"_useCount\",-1,[123]]\n                    ];\n                    \n                    private _supportManagerDetails = _config >> \"KISKA_supportManagerDetails\";\n                    if (isNull _supportManagerDetails) exitWith {\n                        [[\"_config at index ->\",_index,\" has null KISKA_supportManagerDetails class\"],true] call KISKA_fnc_log;\n                        nil\n                    };\n\n                    [\n                        getText(_supportManagerDetails >> \"text\"),\n                        getText(_supportManagerDetails >> \"picture\"),\n                        getArray(_supportManagerDetails >> \"pictureColor\"),\n                        getArray(_supportManagerDetails >> \"selectedPictureColor\"),\n                        getText(_supportManagerDetails >> \"tooltip\")\n                    ]\n                }\n            ],\n            [\n                \"_fn_getSelectedItems\",\n                {\n                    private _usedIconColor = missionNamespace getVariable [\"KISKA_CBA_supportManager_usedIconColor\",[0.75,0,0,1]];\n                    private _items = [];\n                    (call KISKA_fnc_supports_getMap) apply {\n                        _y params [\n                            [\"_supportConfig\",configNull,[configNull]],\n                            [\"_numberOfUsesLeft\",-1,[123]]\n                        ];\n                        \n                        private _supportManagerDetails = _supportConfig >> \"KISKA_supportManagerDetails\";\n                        private _supportId = _x;\n                        if (isNull _supportManagerDetails) then {\n                            [[\"_supportManagerDetails for id -> \",_supportId,\" is null\"],true] call KISKA_fnc_log;\n                            continue;\n                        };\n\n                        private [\"_pictureColor\",\"_selectedPictureColor\"];\n                        private _configuredNumberOfUses = getNumber(_supportConfig >> \"KISKA_supportDetails\" >> \"numberOfUses\");\n                        if (_numberOfUsesLeft isNotEqualTo _configuredNumberOfUses) then {\n                            _pictureColor = _usedIconColor;\n                        } else {\n                            pictureColor = getArray(_supportManagerDetails >> \"pictureColor\");\n                            _selectedPictureColor = getArray(_supportManagerDetails >> \"selectedPictureColor\");\n                        };\n\n                        private _data = _supportId;\n                        _items pushBack [\n                            getText(_supportManagerDetails >> \"text\"),\n                            getText(_supportManagerDetails >> \"picture\"),\n                            _pictureColor,\n                            _selectedPictureColor,\n                            getText(_supportManagerDetails >> \"tooltip\"),\n                            _data\n                        ];\n                    };\n\n                    _items\n                }\n            ],\n            [\n                \"_fn_onTake\",\n                {\n                    params [\"_storeId\",\"_supportData\",\"_poolItemId\"];\n\n                    private _maxAllowedSupports = missionNamespace getVariable [\"KISKA_CBA_supportManager_maxSupports\",10];\n                    private _hasMaxSupports = count (call KISKA_fnc_supports_getMap) isEqualTo _maxAllowedSupports;\n                    if (_hasMaxSupports) exitWith { \n                        [\"You already have the max supports possible\"] call KISKA_fnc_errorNotification;\n                        nil\n                    };\n\n                    _supportData params [\n                        [\"_supportConfig\",configNull,[configNull]],\n                        [\"_numberOfUsesLeft\",-1,[123]]\n                    ];\n\n                    private _supportManagerDetails = _supportConfig >> \"KISKA_supportManagerDetails\";\n                    private _condition = getText(_supportManagerDetails >> \"managerCondition\");\n                    private _canTakeSupport = (_condition isEqualTo \"\") OR { [_supportConfig] call (compile _condition) };\n                    if (_canTakeSupport) exitWith {\n                        [_supportConfig,_numberOfUsesLeft] call KISKA_fnc_supports_add;\n                        [_poolItemId] call KISKA_fnc_supportManager_removeFromPool;\n                        nil\n                    };\n\n                    private _conditionMessage = getText(_supportConfig >> \"conditionMessage\");\n                    if (_conditionMessage isEqualTo \"\") then {\n                        _conditionMessage = \"You do not have permission for this support\";\n                    };\n\n                    [_conditionMessage] call KISKA_fnc_errorNotification;\n                }\n            ],\n            [\n                \"_fn_onStore\",\n                {\n                    params [\"\",\"_supportId\"];\n                    private _supportConfigAndUses = [_supportId] call KISKA_fnc_supports_remove;\n                    _supportConfigAndUses call KISKA_fnc_supportManager_addToPool;\n                }\n            ]\n        ]\n    }\n] call KISKA_fnc_getOrDefaultSet;\n_args call KISKA_fnc_simpleStore_open;\n\n// check if player wants map to close when openning the manager\nif (missionNamespace getVariable [\"KISKA_CBA_supportManager_closeMap\",true]) then {\n    openMap false;\n};\n\n\nnil\n",
    "fileName": "fn_supportManager_open.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SupportManager/Functions/fn_supportManager_open.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_removeFromPool\n\nDescription:\n    Removes the item with the provided ID from the support manager pool globally.\n\nParameters:\n    0: _itemId <STRING> - The ID of the item in the pool to remove.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _itemId = [\n            configFile >> \"CfgCommunicationMenu\" >> \"MySupport\"\n        ] call KISKA_fnc_supportManager_addToPool;\n        \n        // ... some time later ...\n\n        [_itemId] call KISKA_fnc_supportManager_removeFromPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_removeFromPool\";\n\n#define STORE_ID \"kiska-support-manager\"\n\nif !(hasInterface) exitWith {};\n\nparams [\n    [\"_itemId\",\"\",[\"\"]]\n];\n\n\n[STORE_ID,_itemId] call KISKA_fnc_simpleStore_removeItemFromPool_global;\n\n\nnil\n",
    "fileName": "fn_supportManager_removeFromPool.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_SupportManager/Functions/fn_supportManager_removeFromPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_addDiaryEntry\n\nDescription:\n    Creates a diary entry in the map for the player to open the trait Manager.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_addDiaryEntry\";\n\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\"] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_traitManager_addDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 3;\n    false\n};\n\n[\n    [\n        \"Trait Manager GUI\",\n        \"<execute expression='call KISKA_fnc_traitManager_open;'>Open Trait Manager GUI</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_traitManager_addDiaryEntry.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_TraitManager/Functions/fn_traitManager_addDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_addToPool\n\nDescription:\n    Adds an entry into the support manager pool globally.\n\nParameters:\n    0: _traitConfig <CONFIG | STRING> - The config of a trait or a string of a class \n        that is in a `KISKA_Traits` class in either the \n        `missionConfigFile`, `campaignConfigFile`, or `configFile`.\n\nReturns:\n    <STRING> - the item's global identifier which is also used for the JIP queue.\n\nExamples:\n    (begin example)\n        \"someClassInKISKA_Traits\" call KISKA_fnc_traitManager_addToPool;\n    (end)\n\n    (begin example)\n        private _itemId = [\n            configFile >> \"Traits\" >> \"MyTrait\"\n        ] call KISKA_fnc_traitManager_addToPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_addToPool\";\n\n#define STORE_ID \"kiska-trait-manager\"\n#define NUMBER_TRAITS [\"LOADCOEF\",\"AUDIBLECOEF\",\"CAMOUFLAGECOEF\"]\n\nparams [\n    [\"_traitConfig\",configNull,[configNull,\"\"]],\n    [\"_numberOfUsesLeft\",-1,[123]]\n];\n\nif (_traitConfig isEqualType \"\") then {\n    _traitConfig = [[\"KISKA_Traits\",_traitConfig]] call KISKA_fnc_findConfigAny;\n};\nif (isNull _traitConfig) exitWith {\n    [\"Could not find _traitConfig\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _traitName = toUpperANSI (configName _traitConfig);\nif (_traitName in NUMBER_TRAITS) exitWith {\n    [[_traitName,\" is a reserved numerical trait\"],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _itemId = [\n    STORE_ID,\n    _traitConfig\n] call KISKA_fnc_simpleStore_addItemToPool_global;\n\n\n_itemId\n",
    "fileName": "fn_traitManager_addToPool.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_TraitManager/Functions/fn_traitManager_addToPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_open\n\nDescription:\n    Opens KISKA Trait Manager dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_traitManager_open;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_open\";\n\n#define RESERVED_TRAITS [\"MEDIC\",\"ENGINEER\",\"EXPLOSIVESPECIALIST\",\"UAVHACKER\"]\n#define NUMBER_TRAITS [\"LOADCOEF\",\"AUDIBLECOEF\",\"CAMOUFLAGECOEF\"]\n\n\nif !(hasInterface) exitWith {\n    [\"Attempting to open trait manager with no interface\"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _args = [\n    localNamespace,\n    \"KISKA_traitManager_openArgs\",\n    {\n        createHashMapFromArray [\n            [\"_storeId\",\"kiska-trait-manager\"],\n            [\"_storeSelectedItemsTitle\",\"Current Traits\"],\n            [\"_storePoolTitle\",\"Trait Pool\"],\n            [\"_storeTitle\",\"Trait Manager\"],\n            [\n                \"_fn_poolItemToListboxItem\",\n                {\n                    params [\n                        [\"_traitConfig\",configNull,[configNull]],\n                        [\"_index\",-1,[123]]\n                    ];\n                \n                    private _traitManagerDetails = _traitConfig >> \"KISKA_traitManagerDetails\";\n                    if (isNull _traitConfig) exitWith {\n                        [[\"_traitConfig at index -> \",_index,\" is null\"],true] call KISKA_fnc_log;\n                        nil\n                    };\n                    if (isNull _traitManagerDetails) exitWith {\n                        [[\"_traitConfig >> KISKA_traitManagerDetails at index -> \",_index,\" is null\"],true] call KISKA_fnc_log;\n                        nil\n                    };\n\n                    private _traitText = getText(_traitManagerDetails >> \"text\");\n                    if (_traitText isEqualTo \"\") then {\n                        _traitText = configName _traitConfig;\n                    };\n\n                    [\n                        _traitText,\n                        getText(_traitManagerDetails >> \"picture\"),\n                        getArray(_traitManagerDetails >> \"pictureColor\"),\n                        getArray(_traitManagerDetails >> \"selectedPictureColor\"),\n                        getText(_traitManagerDetails >> \"tooltip\")\n                    ]\n                }\n            ],\n            [\n                \"_fn_getSelectedItems\",\n                {\n                    private _items = [];\n                    (getAllUnitTraits player) apply {\n                        _x params [\"_traitName\",\"_traitValue\"];\n\n                        _traitName = toUpperANSI _traitName;\n                        if (\n                            (_traitName in NUMBER_TRAITS) OR\n                            {\n                                (_traitValue isEqualType true) AND {!_traitValue}\n                            }\n                        ) then { continue };\n\n                        private _traitConfig = [[\"KISKA_Traits\",_traitName]] call KISKA_fnc_findConfigAny;\n                        if (isNull _traitConfig) then {\n                            [[\"_traitName \", _traitName,\" is not configured in KISKA_Traits\"],false] call KISKA_fnc_log;\n                            continue;\n                        };\n                        \n                        private _traitManagerDetails = _traitConfig >> \"KISKA_traitManagerDetails\";\n                        if (isNull _traitManagerDetails) then {\n                            [[\"_traitName \", _traitName,\" is missing a KISKA_traitManagerDetails class\"],false] call KISKA_fnc_log;\n                            continue;\n                        };\n\n                        private _traitText = getText(_traitManagerDetails >> \"text\");\n                        if (_traitText isEqualTo \"\") then {\n                            _traitText = _traitName;\n                        };\n\n                        _items pushBack [\n                            _traitText,\n                            getText(_traitManagerDetails >> \"picture\"),\n                            getArray(_traitManagerDetails >> \"pictureColor\"),\n                            getArray(_traitManagerDetails >> \"selectedPictureColor\"),\n                            getText(_traitManagerDetails >> \"tooltip\"),\n                            _traitName\n                        ];\n                    };\n\n                    _items\n                }\n            ],\n            [\n                \"_fn_onTake\",\n                {\n                    params [\"_storeId\",\"_traitConfig\",\"_poolItemId\",\"_selectedIndex\"];\n\n                    if (_selectedIndex < 0) exitWith {\n                        [\"You must select an item to take\"] call KISKA_fnc_errorNotification;\n                    };\n\n                    private _traitName = toUpperANSI (configName _traitConfig);\n                    private _currentTraitValue = player getUnitTrait _traitName;\n                    if (!(isNil \"_currentTraitValue\") AND {_currentTraitValue}) exitWith {\n                        [\n                            format [\"You already possess the %1 trait\",_traitName]\n                        ] call KISKA_fnc_errorNotification;\n                    };\n\n                    private _traitManagerDetailsConfig = _traitConfig >> \"KISKA_traitManagerDetails\";\n                    private _condition = getText(_traitManagerDetailsConfig >> \"condition\");\n                    private _canTakeTrait = (_condition isEqualTo \"\") OR { [_traitConfig] call (compile _condition) };\n                    if (_canTakeTrait) exitWith {\n                        private _isCustomTrait = !(_traitName in RESERVED_TRAITS);\n                        player setUnitTrait [_traitName,true,_isCustomTrait];\n                        [_poolItemId] call KISKA_fnc_traitManager_removeFromPool;\n                        nil\n                    };\n\n                    private _conditionMessage = getText(_traitManagerDetailsConfig >> \"conditionMessage\");\n                    if (_conditionMessage isEqualTo \"\") then {\n                        _conditionMessage = format [\"You do not have permission to take the %1 trait\",_traitName];\n                    };\n\n                    [_conditionMessage] call KISKA_fnc_errorNotification;\n                }\n            ],\n            [\n                \"_fn_onStore\",\n                {\n                    params [\"\",\"_trait\",\"_selectedIndex\"];\n\n                    if (_selectedIndex < 0) exitWith {\n                        [\"You must select an item to store\"] call KISKA_fnc_errorNotification;\n                    };\n                    \n                    private _isCustomTrait = !(_trait in RESERVED_TRAITS);\n                    player setUnitTrait [_trait,false,_isCustomTrait];\n                    _trait call KISKA_fnc_traitManager_addToPool;\n                }\n            ]\n        ]\n    }\n] call KISKA_fnc_getOrDefaultSet;\n_args call KISKA_fnc_simpleStore_open;\n\n// check if player wants map to close when openning the manager\nif (missionNamespace getVariable [\"KISKA_CBA_traitManager_closeMap\",true]) then {\n    openMap false;\n};\n\n\nnil\n",
    "fileName": "fn_traitManager_open.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_TraitManager/Functions/fn_traitManager_open.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_removeFromPool\n\nDescription:\n    Removes the item with the provided ID from the trait manager pool globally.\n\nParameters:\n    0: _itemId <STRING> - The ID of the item in the pool to remove.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _itemId = [\n            configFile >> \"KISKA_Traits\" >> \"MyTrait\"\n        ] call KISKA_fnc_traitManager_addToPool;\n        \n        // ... some time later ...\n\n        _itemId call KISKA_fnc_traitManager_removeFromPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_removeFromPool\";\n\n#define STORE_ID \"kiska-trait-manager\"\n\nif !(hasInterface) exitWith {};\n\nparams [\n    [\"_itemId\",\"\",[\"\"]]\n];\n\n\n[STORE_ID,_itemId] call KISKA_fnc_simpleStore_removeItemFromPool_global;\n\n\nnil\n",
    "fileName": "fn_traitManager_removeFromPool.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_TraitManager/Functions/fn_traitManager_removeFromPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_addOpenGuiDiaryEntry\n\nDescription:\n    Creates a diary entry to open the VDL dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_addOpenGuiDiaryEntry\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_VDL_addOpenGuiDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n[\n    [\n        \"View Distance Limiter\",\n        \"<execute expression='call KISKA_fnc_VDL_openDialog;'>View Distance Limiter</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_VDL_addOpenGuiDiaryEntry.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_ViewDistanceLimiter/Functions/fn_VDL_addOpenGuiDiaryEntry.sqf"
  },
  {
    "text": "#include \"..\\Headers\\View Distance Limiter Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_controlsGroup_onLoad\n\nDescription:\n    Acts as the onload event for the KISKA View Distance Limiter Dialog\n\nParameters:\n    0: _controlsGroup <CONTROL> - The controls group for the particular setting\n    1: _varName <STRING> - The name of the profileNamespace variable in which this\n        setting will be saved when changed\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [controlsGroup,\"someName\"] call KISKA_fnc_VDL_controlsGroup_onLoad;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_controlsGroup_onLoad\";\n\nif (!hasInterface) exitWith {};\n\ndisableSerialization;\n\nparams [\"_controlsGroup\",\"_varName\"];\n\n\n_controlsGroup setVariable [CTRL_GRP_VAR_STR,_varName];\n\n/* ----------------------------------------------------------------------------\n    Slider\n---------------------------------------------------------------------------- */\nprivate _slider_ctrl = _controlsGroup controlsGroupCtrl VDL_SLIDER_IDC;\n_controlsGroup setVariable [CTRL_GRP_SLIDER_CTRL_VAR_STR,_slider_ctrl];\n_slider_ctrl ctrlAddEventHandler [\"SliderPosChanged\",{\n    params [\"_slider_ctrl\", \"_newValue\"];\n\n    private _settingControlGroup = ctrlParentControlsGroup _slider_ctrl;\n    private _editBox_ctrl = _settingControlGroup getVariable CTRL_GRP_EDIT_CTRL_VAR_STR;\n\n    private _strValue = str _newValue;\n    _editBox_ctrl ctrlSetText _strValue;\n    _slider_ctrl ctrlSetTooltip _strValue;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Set Button\n---------------------------------------------------------------------------- */\nprivate _setButton_ctrl = _controlsGroup controlsGroupCtrl VDL_SET_BUTTON_IDC;\n_setButton_ctrl ctrlAddEventHandler [\"ButtonClick\",{\n    params [\"_setButton_ctrl\"];\n\n    private _settingControlGroup = ctrlParentControlsGroup _setButton_ctrl;\n    private _slider_ctrl = _settingControlGroup getVariable [CTRL_GRP_SLIDER_CTRL_VAR_STR,controlNull];\n\n    private _varName = _settingControlGroup getVariable CTRL_GRP_VAR_STR;\n    private _value = sliderPosition _slider_ctrl;\n\n    profileNamespace setVariable [_varName,_value];\n    localNamespace setVariable [_varName,_value];\n\n    saveProfileNamespace;\n    [\"Saved changes\"] call KISKA_fnc_notification;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Edit Box\n---------------------------------------------------------------------------- */\nprivate _editBox_ctrl = _controlsGroup controlsGroupCtrl VDL_EDIT_BUTTON_IDC;\n_controlsGroup setVariable [CTRL_GRP_EDIT_CTRL_VAR_STR,_editBox_ctrl];\n_editBox_ctrl ctrlAddEventHandler [\"KeyUp\",{\n    params [\"_editBox_ctrl\"];\n\n    private _text = ctrlText _editBox_ctrl;\n    private _number = _text call BIS_fnc_parseNumberSafe;\n    // if we don't check that an actual number is present, we can't start with a blank edit box if say doing negative numbers\n    if (str _number == _text) then {\n        private _settingControlGroup = ctrlParentControlsGroup _editBox_ctrl;\n        private _slider_ctrl = _settingControlGroup getVariable CTRL_GRP_SLIDER_CTRL_VAR_STR;\n\n        private _sliderRange = sliderRange _slider_ctrl;\n        private _sliderMin = _sliderRange select 0;\n        private _sliderMax = _sliderRange select 1;\n        // check to see if entered number fits inside slider range\n        if ((_number >= _sliderMin) AND {_number <= _sliderMax}) then {\n            _slider_ctrl ctrlSetTooltip (str _number);\n            _slider_ctrl sliderSetPosition _number;\n        };\n    };\n}];\n\n\n\nprivate _defaultValue = getNumber(\n    configFile >> \n    \"KISKA_viewDistanceLimiter_dialog\" >> \n    \"controls\" >> \n    ctrlClassName _controlsGroup >> \n    \"controls\" >> \n    \"settingSlider\" >> \n    \"sliderPosition\"\n);\nprivate _profileValue = profileNamespace getVariable [_varName,_defaultValue];\nprivate _currentValue = localNamespace getVariable [_varName,_profileValue];\n\n_editBox_ctrl ctrlSetText (str _currentValue);\n_slider_ctrl sliderSetPosition _currentValue;\n\n\nnil\n",
    "fileName": "fn_VDL_controlsGroup_onLoad.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_ViewDistanceLimiter/Functions/fn_VDL_controlsGroup_onLoad.sqf"
  },
  {
    "text": "#include \"..\\Headers\\View Distance Limiter Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_onLoad\n\nDescription:\n    Acts as the onload event for the KISKA View Distance Limiter Dialog\n\nParameters:\n    0: _display <DISPLAY> - The display of the dialog\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [display] call KISKA_fnc_VDL_onLoad;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_onLoad\";\n\nif (!hasInterface) exitWith {};\n\ndisableSerialization;\n\nparams [\"_display\"];\n\n\n/* ----------------------------------------------------------------------------\n    unload event\n---------------------------------------------------------------------------- */\nlocalNamespace setVariable [\"KISKA_VDL_display\",_display];\n_display displayAddEventHandler [\"Unload\", {\n    //params [\"_display\"];\n    localNamespace setVariable [\"KISKA_VDL_display\",nil];\n}];\n\n\n/* ----------------------------------------------------------------------------\n    System On Check box\n---------------------------------------------------------------------------- */\nprivate _systemOnCheckox = _display displayCtrl VDL_SYSTEM_ON_CHECKBOX_IDC;\nif (localNamespace getVariable [\"KISKA_VDL_isRunning\",false]) then {\n    _systemOnCheckox cbSetChecked true;\n};\n\n_systemOnCheckox ctrlAddEventHandler [\"CheckedChanged\",{\n    params [\"_control\", \"_checked\"];\n    _checked = [false,true] select _checked;\n\n    localNamespace setVariable [\"KISKA_VDL_run\",_checked];\n    private _vdlIsRunning = localNamespace getVariable [\"KISKA_VDL_isRunning\",false];\n    if (_checked AND !_vdlIsRunning) then {\n        #define GET_SLIDER_POS_FOR_CTRLGRP(idc) sliderPosition (((ctrlParent _control) displayCtrl idc) controlsGroupCtrl VDL_SLIDER_IDC)\n        [\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_TARGET_FPS_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_CHECK_FREQ_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_MIN_OBJECT_DIST_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_MAX_OBJECT_DIST_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_INCRIMENT_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_TERRAIN_DIST_CTRL_GRP_IDC )\n        ] spawn KISKA_fnc_viewDistanceLimiter;\n    };\n\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Tie View Distance Check box\n---------------------------------------------------------------------------- */\nprivate _tieViewDist_checkBox = _display displayCtrl VDL_TIED_DISTANCE_CHECKBOX_IDC;\nif (localNamespace getVariable [\"KISKA_VDL_tiedViewDistance\",false]) then {\n    _tieViewDist_checkBox cbSetChecked true;\n};\n\n_tieViewDist_checkBox ctrlAddEventHandler [\"CheckedChanged\",{\n    params [\"\", \"_checked\"];\n    _checked = [false,true] select _checked;\n    localNamespace setVariable [\"KISKA_VDL_tiedViewDistance\",_checked];\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Close button\n---------------------------------------------------------------------------- */\n(_display displayCtrl VDL_CLOSE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    (localNamespace getVariable [\"KISKA_VDL_display\",displayNull]) closeDisplay 2;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Set all button\n---------------------------------------------------------------------------- */\n(_display displayCtrl VDL_SET_ALL_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    params [\"_setButton_ctrl\"];\n\n    private _display = localNamespace getVariable [\"KISKA_VDL_display\",displayNull];\n    (_display getVariable \"KISKA_VDL_controlGroups\") apply {\n        private _slider_ctrl = _x getVariable [CTRL_GRP_SLIDER_CTRL_VAR_STR,controlNull];\n\n        private _varName = _x getVariable [CTRL_GRP_VAR_STR,\"\"];\n        private _value = sliderPosition _slider_ctrl;\n        profileNamespace setVariable [_varName,_value];\n        localNamespace setVariable [_varName,_value];\n    };\n\n    saveProfileNamespace;\n    [\"Saved All changes\"] call KISKA_fnc_notification;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Control groups\n---------------------------------------------------------------------------- */\nprivate _controlGroups = [];\n[\n    [VDL_TARGET_FPS_CTRL_GRP_IDC, \"KISKA_VDL_fps\"],\n    [VDL_MIN_OBJECT_DIST_CTRL_GRP_IDC, \"KISKA_VDL_minDist\"],\n    [VDL_MAX_OBJECT_DIST_CTRL_GRP_IDC, \"KISKA_VDL_maxDist\"],\n    [VDL_TERRAIN_DIST_CTRL_GRP_IDC, \"KISKA_VDL_viewDist\"],\n    [VDL_CHECK_FREQ_CTRL_GRP_IDC, \"KISKA_VDL_freq\"],\n    [VDL_INCRIMENT_CTRL_GRP_IDC, \"KISKA_VDL_increment\"]\n] apply {\n    private _controlIdc = _x select 0;\n    private _control = _display displayCtrl _controlIdc;\n    private _settingVariableName = _x select 1;\n    [_control,_settingVariableName] call KISKA_fnc_VDL_controlsGroup_onLoad;\n    _controlGroups pushBack _control;\n};\n\n_display setVariable [\"KISKA_VDL_controlGroups\",_controlGroups];\n\n\nnil\n",
    "fileName": "fn_VDL_onLoad.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_ViewDistanceLimiter/Functions/fn_VDL_onLoad.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_openDialog\n\nDescription:\n    Opens the GUI for the VDL system.\n\nParameters:\n    NONE\n\nReturns:\n    BOOL\n\nExamples:\n    (begin example)\n        call KISKA_fnc_VDL_openDialog;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_openDialog\";\n\nif (!hasInterface) exitWith {false};\n\nif !(missionNamespace getVariable [\"KISKA_CBA_VDL_available\",true]) exitWith {\n    [\"The View Distance Limiter Dialog is not available\"] call KISKA_fnc_notification;\n    false\n};\n\nif (missionNamespace getVariable [\"KISKA_CBA_VDL_closeMap\",true]) then {\n    openMap false;\n};\n\n\ncreateDialog \"KISKA_viewDistanceLimiter_dialog\";\n",
    "fileName": "fn_VDL_openDialog.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_ViewDistanceLimiter/Functions/fn_VDL_openDialog.sqf"
  },
  {
    "text": "#include \"..\\Headers\\View Distance Limiter Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_viewDistanceLimiter\n\nDescription:\n    Starts a looping function for limiting a player's viewDistance.\n    Loop can be stopped by setting mission variable \"KISKA_VDL_run\" to false.\n    All other values have global vars that can be edited while it is in use.\n\n    See each param for associated global var.\n\nParameters:\n    0: _targetFPS <NUMBER> - The desired FPS (lower) limit (KISKA_VDL_fps)\n    1: _checkFreq <NUMBER> - The frequency of checks for FPS (KISKA_VDL_freq)\n    2: _minObjectDistance <NUMBER> - The minimum the objectViewDistance, can be set by (KISKA_VDL_minDist)\n    3: _maxObjectDistance <NUMBER> - The max the objectViewDistance, can be set by (KISKA_VDL_maxDist)\n    4: _increment <NUMBER> - The amount the viewDistance can incriment up or down each cycle (KISKA_VDL_inc)\n    5: _viewDistance <NUMBER> - This is the static overall viewDistance, can be set by (KISKA_VDL_viewDist)\n                                 This is static because it doesn't affect FPS too much.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        Every 3 seconds, check\n        [45,3,500,1700,25,3000] spawn KISKA_fnc_viewDistanceLimiter;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_viewDistanceLimiter\";\n\n#define DEFAULT_TARGET_FPS 60\n#define DEFAULT_FREQ 0.5\n#define DEFAULT_MIN_DIST 500\n#define DEFAULT_MAX_DIST 1200\n#define DEFAULT_INCREMENT 25\n#define DEFAULT_VIEW_DIST 3000\n\nif (!hasInterface) exitWith {};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in a scheduled environment. Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_viewDistanceLimiter\n};\n\nparams [\n    [\"_targetFPS\",localNamespace getVariable [\"KISKA_VDL_fps\",DEFAULT_TARGET_FPS],[123]],\n    [\"_checkFreq\",localNamespace getVariable [\"KISKA_VDL_freq\",DEFAULT_FREQ],[123]],\n    [\"_minObjectDistance\",localNamespace getVariable [\"KISKA_VDL_minDist\",DEFAULT_MIN_DIST],[123]],\n    [\"_maxObjectDistance\",localNamespace getVariable [\"KISKA_VDL_maxDist\",DEFAULT_MAX_DIST],[123]],\n    [\"_increment\",localNamespace getVariable [\"KISKA_VDL_increment\",DEFAULT_INCREMENT],[123]],\n    [\"_viewDistance\",localNamespace getVariable [\"KISKA_VDL_viewDist\",DEFAULT_VIEW_DIST],[123]]\n];\n\n\nlocalNamespace setVariable [\"KISKA_VDL_run\",true];\nlocalNamespace setVariable [\"KISKA_VDL_fps\",_targetFPS];\nlocalNamespace setVariable [\"KISKA_VDL_freq\",_checkFreq];\nlocalNamespace setVariable [\"KISKA_VDL_increment\",_increment];\nif (_minObjectDistance > _maxObjectDistance) then {\n    _minObjectDistance = _maxObjectDistance;\n};\nlocalNamespace setVariable [\"KISKA_VDL_minDist\",_minObjectDistance];\nlocalNamespace setVariable [\"KISKA_VDL_maxDist\",_maxObjectDistance];\nif (_viewDistance < _maxObjectDistance) then {\n    _viewDistance = _maxObjectDistance;\n};\nlocalNamespace setVariable [\"KISKA_VDL_viewDist\",_viewDistance];\n\nlocalNamespace setVariable [\"KISKA_VDL_isRunning\",true];\nwhile {\n    private _adjustmentFrequency = localNamespace getVariable [\"KISKA_VDL_freq\",DEFAULT_FREQ];\n    sleep _adjustmentFrequency;\n\n    localNamespace getVariable [\"KISKA_VDL_run\",false]\n} do {\n    private _currentObjectViewDistance = getObjectViewDistance select 0;\n    private _isViewDistanceTied = localNamespace getVariable [\"KISKA_VDL_tiedViewDistance\",false];\n    private _viewDistance = localNamespace getVariable [\"KISKA_VDL_viewDist\",DEFAULT_VIEW_DIST];\n    if (\n        (!_isViewDistanceTied) AND \n        (_viewDistance isNotEqualTo viewDistance)\n    ) then {\n        setViewDistance _viewDistance;\n    };\n\n    private _targetFPS = localNamespace getVariable [\"KISKA_VDL_fps\",DEFAULT_TARGET_FPS];\n    private _adjustmentIncrement = localNamespace getVariable [\"KISKA_VDL_increment\",DEFAULT_INCREMENT];\n    private _fpsIsHigherThanTarget = diag_fps > _targetFPS;\n    private \"_newViewDistance\";\n    if (_fpsIsHigherThanTarget) then {\n        private _maxDistance = localNamespace getVariable [\"KISKA_VDL_maxDist\",DEFAULT_MAX_DIST];\n        _newViewDistance = _currentObjectViewDistance + _adjustmentIncrement;\n        if (_newViewDistance > _maxDistance) then {\n            _newViewDistance = _maxDistance;\n        };\n\n    } else {\n        private _minDistance = localNamespace getVariable [\"KISKA_VDL_minDist\",DEFAULT_MIN_DIST];\n        _newViewDistance = _currentObjectViewDistance - _adjustmentIncrement;\n        if (_newViewDistance < _minDistance) then {\n            _newViewDistance = _minDistance;\n        };\n\n    };\n\n    if (_newViewDistance == _currentObjectViewDistance) then { continue; };\n    if (_isViewDistanceTied) then {\n        setViewDistance _newViewDistance;\n    };\n    setObjectViewDistance _newViewDistance;\n};\n\nlocalNamespace setVariable [\"KISKA_VDL_isRunning\",false];\nsetViewDistance -1;\nsetObjectViewDistance -1;\n",
    "fileName": "fn_viewDistanceLimiter.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/KISKA_ViewDistanceLimiter/Functions/fn_viewDistanceLimiter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_addSupportMenuAction\n\nDescription:\n    Adds the ACE action to a player object that allows them to self interact\n     and pull up the support menu.\n\nParameters:\n    0: _player <OBJECT> - The player object\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_addSupportMenuAction\";\n\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif !([\"ace_main\"] call KISKA_fnc_isPatchLoaded) exitWith {\n    [\"ACE is not loaded, action will not be added\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_ACE_addSupportMenuAction;\n};\n\nwaitUntil {\n    sleep 0.1;\n    !(isNull player)\n};\n\nprivate _action = [\n    \"Open Comm Menu\",\n    \"Open Comm Menu\",\n    \"\\a3\\Ui_f\\data\\GUI\\Cfg\\CommunicationMenu\\call_ca.paa\",\n    {showCommandingMenu \"#User:BIS_fnc_addCommMenuItem_menu\"},\n    {alive player}\n] call ace_interact_menu_fnc_createAction;\n\n[player,1,[\"ACE_SelfActions\"],_action] call ace_interact_menu_fnc_addActionToObject;\n",
    "fileName": "fn_ACE_addSupportMenuAction.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/ACE/fn_ACE_addSupportMenuAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_unconsciousIsCaptive\n\nDescription:\n    Adds a CBA event that hooks into when a player becomes unconcious, making them\n     turn captive in order to keep the AI from shooting downed players.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_unconsciousIsCaptive\";\n\nif (!hasInterface) exitWith {};\n\nif (!canSuspend) exitWith {\n    [] spawn KISKA_fnc_ACE_unconsciousIsCaptive;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\n\nif !([\"ace_medical\"] call KISKA_fnc_isPatchLoaded) exitWith {\n    [\"ACE medical is not loaded, will not add event...\",false] call KISKA_fnc_log;\n    nil\n};\n\n\nif (localNamespace getVariable [\"KISKA_ACE_addedUnconsciousPlayerEvent\",false]) exitWith {};\n\n\n[\n    \"ace_unconscious\",\n    {\n        params [\"_unit\",\"_unconscious\"];\n        if (_unit isEqualTo player) then {\n\n            if (_unconscious) then {\n                [\"Player ace_unconscious event fired.\"] call KISKA_fnc_log;\n                private _makeCaptive = localNamespace getVariable [\"KISKA_CBA_ACE_unconciousPlayerIsCaptive\",true];\n                private _wasCaptiveBefore = captive _unit;\n                private _wasMadeCaptive =  false;\n\n                if (!_wasCaptiveBefore AND {_makeCaptive}) then {\n                    [\"Player was not captive beforehand, will be made captive\"] call KISKA_fnc_log;\n                    _wasMadeCaptive = true;\n                    _unit setCaptive true;\n                };\n\n                localNamespace setVariable [\"KISKA_ACE_wasMadeCaptive\",_wasMadeCaptive];\n\n            } else { // if waking up\n                [\"Player is waking from unconscious state\"] call KISKA_fnc_log;\n\n                if (captive _unit) then {\n                    [\"Player is a captive\"] call KISKA_fnc_log;\n\n                    if (localNamespace getVariable [\"KISKA_ACE_wasMadeCaptive\",false]) then {\n                        [\"Player was previosuly made captive, captive will be turned off...\"] call KISKA_fnc_log;\n                        _unit setCaptive false;\n                    };\n\n                };\n\n                localNamespace setVariable [\"KISKA_ACE_wasMadeCaptive\",false];\n\n            };\n\n        };\n    }\n] call CBA_fnc_addEventhandler;\n\n\nwaitUntil {\n    sleep 1;\n    !isNull player;\n};\n\n\nplayer addEventHandler [\"Respawn\",{\n    params [\"_unit\"];\n    \n    if (captive _unit) then {\n        [\n            \"Player is a captive\",\n            missionNamespace getVariable [\"KISKA_CBA_logWithError\",false],\n            true,\n            false,\n            \"KISKA_unconsciousACEEvent_respawnHandler\"\n        ] call KISKA_fnc_log;\n\n        if (localNamespace getVariable [\"KISKA_ACE_wasMadeCaptive\",false]) then {\n            [\n                \"Player was previosuly made captive, captive will be turned off...\",\n                missionNamespace getVariable [\"KISKA_CBA_logWithError\",false],\n                true,\n                false,\n                \"KISKA_unconsciousACEEvent_respawnHandler\"\n            ] call KISKA_fnc_log;\n\n            _unit setCaptive false;\n        };\n\n    };\n\n    localNamespace setVariable [\"KISKA_ACE_wasMadeCaptive\",false];\n}];\n\n\nlocalNamespace setVariable [\"KISKA_ACE_addedUnconsciousPlayerEvent\",true];\n\n\nnil\n",
    "fileName": "fn_ACE_unconsciousIsCaptive.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/ACE/fn_ACE_unconsciousIsCaptive.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACEX_setHCTransfer\n\nDescription:\n    Simply sets the blacklist variable of a given unit from being transferred by the\n     ACEX headless client module. Variable is set on the server.\n\nParameters:\n    0: _unit <GROUP or OBJECT> - The unit to blacklist\n    1: _setting <BOOL> - The blacklist value to set (true to blacklist, false to allow transfer)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // disable transfer\n        [someGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n    (end)\n\n    (begin example)\n        // enable transfer\n        [someGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACEX_setHCTransfer\";\n\nif (!isMultiplayer) exitWith {\n    [\"No need to run in singleplayer...\"] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_unit\",objNull,[grpNull,objNull]],\n    [\"_setting\",false,[true]]\n];\n\nif (isNull _unit) exitWith {\n    [\"A null unit was passed, will not blacklist\",true] call KISKA_fnc_log;\n    nil\n};\n\n_unit setVariable [\"acex_headless_blacklist\",_setting,2];\n\n\nnil\n",
    "fileName": "fn_ACEX_setHCTransfer.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/ACEX/fn_ACEX_setHCTransfer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_AAAZone\n\nDescription:\n    Sets up a zone that when entered by an enemy aircraft, the provided vehicle will engage.\n\n    Otherwise, vehicle will stay the same.\n\nParameters:\n    0: _vehicle : <OBJECT> - The AAA piece\n    1: _radius : <NUMBER> - How far out the turret is alerted to\n    2: _checkTime : <NUMBER> - How often does the AAA scan the area for targets\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myVehicle] spawn KISKA_fnc_AAAZone;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_AAAZone\";\n\n\nif (!canSuspend) exitWith {\n    [\"ReExecuting in scheduled environment\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_AAAZone;\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_radius\",1000,[123]],\n    [\"_checkTime\",5,[123]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null object\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (!local _vehicle) exitWith {\n    [[_vehicle,\" is not local to machine, executing on owner\"],false] call KISKA_fnc_log;\n    _this remoteExec [\"KISKA_fnc_AAAZone\",_vehicle];\n    nil\n};\n\nprivate _gunner = gunner _vehicle;\nif (isNull _gunner) exitWith {\n    [[_vehicle,\" does not have a gunner\"],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _gunnerGroup = group _gunner;\nif (isNull _gunnerGroup) exitWith {\n    [\"_gunnerGroup is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n// disable HC transfer\n[_gunnerGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\nprivate _fn_controlShots = {\n    params [\"_doShoot\"];\n\n    if (_doShoot) then {\n        [_gunner,\"WEAPONAIM\"] remoteExecCall [\"enableAI\",_gunner];\n        [_gunnerGroup,\"RED\"] remoteExecCall [\"setCombatMode\",_gunnerGroup];\n\n    } else {\n        [_gunner,\"WEAPONAIM\"] remoteExecCall [\"disableAI\",_gunner];\n        [_gunnerGroup,\"BLUE\"] remoteExecCall [\"setCombatMode\",_gunnerGroup];\n\n    };\n};\n\n// disable unit\n[false] call _fn_controlShots;\n\n\nprivate _AAAside = side _vehicle;\nprivate _doFire = false;\nprivate \"_entitiesInRadius\";\n\n_vehicle setVariable [\"KISKA_doAAA\",true];\nwhile {sleep _checkTime; _vehicle getVariable [\"KISKA_doAAA\",true]} do {\n    _entitiesInRadius = _vehicle nearEntities [\"air\",_radius];\n\n    // if any air units are found\n    if (_entitiesInRadius isNotEqualTo []) then {\n        //[\"Found entities in radius\",false] call KISKA_fnc_log;\n\n        // find an enemy unit to fire at\n        private _index = _entitiesInRadius findIf {\n            //[[\"Side of\",_x,\"is\",side _x,\": side of AAA is\",_AAASide]] call KISKA_fnc_log;\n            [side _x,_AAAside] call BIS_fnc_sideIsEnemy;\n        };\n\n        // if an enemy aircraft is found AND _vehicle is not already engaging\n        if (_index isNotEqualTo -1 AND {!_doFire}) then {\n            //[[\"Found a unit to engage and not already doing so, weapon aim on for\",_gunner],false] call KISKA_fnc_log;\n\n            _doFire = true;\n            [true] call _fn_controlShots;\n        } else {\n            // only disable if no targets are found and already engaging\n            //[[\"Did not meet fire standards. Do fire? \",_doFire,\" Index? \",_index],false] call KISKA_fnc_log;\n\n            if (_index isEqualTo -1 AND {_doFire}) then {\n                //[\"No enemy targets to engage anymore. Disabling weapon aim and _doFire to false\",false] call KISKA_fnc_log;\n\n                _doFire = false;\n                [false] call _fn_controlShots;\n            };\n        };\n    } else {\n        //[\"No entities in area found\",false] call KISKA_fnc_log;\n\n        if (_doFire) then {\n            //[\"Setting _doFire to false\",false] call KISKA_fnc_log;\n\n            _doFire = false;\n        };\n    };\n\n    // if vehicle is dead or gunner is absent\n    if !(alive _gunner) then {\n        //[[\"_gunner \",_gunner,\" is no longer alive, exiting\"]] call KISKA_fnc_log;\n\n        if (alive _vehicle) then {\n            //[[\"_vehicle \",_vehicle,\" is still alive, setting KISKA_doAAA to nil\"]] call KISKA_fnc_log;\n\n            _vehicle setVariable [\"KISKA_doAAA\",nil];\n        };\n\n        break;\n    };\n\n    if !(alive _vehicle) then {\n        //[[\"_vehicle \",_vehicle,\" is no longer alive, exiting\"]] call KISKA_fnc_log;\n        break;\n    };\n};\n\nif (alive _gunner) then {\n    [true] call _fn_controlShots;\n    // allow HC transfer\n    [_gunnerGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n};\n\n\nnil\n",
    "fileName": "fn_AAAZone.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_AAAZone.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_arty\n\nDescription:\n    Fires a number of rounds from artillery piece at target with random disperstion values\n\nParameters:\n    0: _gun : <OBJECT> - The artillery piece\n    1: _target : <OBJECT or ARRAY> - Self Expllanitory\n    2: _rounds : <NUMBER> - Number of rounds to fire\n    3: _randomDistance : <NUMBER> - max distance error margin (0 will be directly on target for all rounds)\n    4: _randomDirection : <NUMBER> - 360 direction within rounds can land\n    5: _fireTime : <ARRAY> - Array of random time between shots for bell curve\n\nReturns:\n    Nothing\n\nExamples:\n    (begin example)\n        [vehicle, target, 2, 100, 360, [9,10,11]] spawn KISKA_fnc_arty;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_arty\";\n\nif (!canSuspend) exitWith {\n    [\"ReExecuting in scheduled environment\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_arty;\n};\n\nparams [\n    [\"_gun\",objNull,[objNull]],\n    [\"_target\",objNull,[objNull,[]]],\n    [\"_rounds\",1,[1]],\n    [\"_randomDistance\",0,[1]],\n    [\"_randomDirection\",360,[1]],\n    [\"_fireTime\",[10,11,12],[[],1]]\n];\n\nif (!(alive _gun) OR !(alive (gunner _gun))) exitWith {\n    [[_gun,\" or its gunner are not alive, exiting...\"]] call KISKA_fnc_log;\n    nil\n};\n\nif (_rounds < 1) exitWith {\n    [[_gun,\" was told to fire less than 1 round, exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _ammo = (getArtilleryAmmo [_gun]) select 0;\nif (isNil \"_ammo\") exitWith {\n    [[_gun,\" was told to fire but has no ammo, exiting...\"]] call KISKA_fnc_log;\n    nil\n};\n\nprivate [\"_fireDirection\",\"_fireDistance\",\"_targetToAimAt\"];\nfor \"_i\" from 1 to _rounds do {\n    if (!(alive _gun) OR !(alive (gunner _gun))) then {\n        [[_gun,\" or its gunner are not alive, exiting...\"]] call KISKA_fnc_log;\n        break;\n    };\n\n    _fireDirection = round random _randomDirection;\n    _fireDistance = round random _randomDistance;\n    _targetToAimAt = _target getPos [_fireDistance, _fireDirection];\n\n    _gun doArtilleryFire [_targetToAimAt,_ammo,1];\n\n    _rounds = _rounds - 1;\n\n    if (_i isNotEqualTo _rounds) then {\n        sleep (round random _fireTime);\n    };\n};\n\n\nnil\n",
    "fileName": "fn_arty.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_arty.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_attack\n\nDescription:\n    Modified version of CBA_fnc_taskAttack.\n    Now allows setting of different behaviour and combatMode.\n\nParameters:\n    0: _group <GROUP or OBJECT> - Unit(s) to attack\n    1: _position <OBJECT, LOCATION, GROUP, or ARRAY> - The position to attack\n    2: _radius <NUMBER> - Radius for waypoint placement\n    3: _behaviour <STRING> - What behaviour will the attacker(s) have\n    4: _combatMode <STRING> - What combatMode will the attacker(s) have\n    5: _override <BOOL> - Clear units current waypoints\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [group1,attackPosition,100,\"COMBAT\",\"RED\"] call KISKA_fnc_attack;\n    (end)\n\nAuthor:\n    Rommel,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_attack\";\n\nparams [\n    [\"_group\",grpNull,[objNull,grpNull]],\n    [\"_position\",objNull,[[],objNull,locationNull,grpNull]],\n    [\"_radius\",-1,[123]],\n    [\"_behaviour\",\"AWARE\",[\"\"]],\n    [\"_combatMode\",\"RED\",[\"\"]],\n    [\"_override\",false,[true]]\n];\n\n_group = _group call CBA_fnc_getGroup;\n\n// Don't create waypoints on each machine\nif !(local _group) exitWith {\n    [[\"Found that \",_group,\" was not local, exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n// Allow TaskAttack to override other set waypoints\nif (_override) then {\n    [_group,-1,true] call KISKA_fnc_clearWaypoints;\n};\n\n[_group, _position, _radius, \"SAD\", _behaviour, _combatMode] call CBA_fnc_addWaypoint;\n\n\nnil\n",
    "fileName": "fn_attack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_attack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_clearWaypoints\n\nDescription:\n    Clears a group's waypoints and conditionally halts their previous movement.\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group to clear the waypoints of.\n    1: _numberToRemove <NUMBER> - The number of waypoints to remove (-1 will remove all)\n    2: _stopUnits <BOOL> - Should the units stop in place after clear?\n\nReturns:\n    NOTHING\n\nExample:\n    (begin example)\n        [group player,-1,false] call KISKA_fnc_clearWaypoints\n    (end)\n\nAuthor(s):\n    SilentSpike,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nparams [\n    [\"_group\", grpNull, [grpNull, objNull]],\n    [\"_numberToRemove\",-1,[123]],\n    [\"_stopUnits\", false, [true]]\n];\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\nprivate _numberOfCurrentWaypoints = count (waypoints _group);\nif (_numberOfCurrentWaypoints isEqualTo 0) exitWith {};\n\nif (_numberToRemove isEqualTo -1) then {\n    _numberToRemove = _numberOfCurrentWaypoints;\n};\n\nfor \"_i\" from (_numberToRemove - 1) to 0 step -1 do {\n    deleteWaypoint [_group, _i];\n};\n\nprivate _removedAllWaypoints = _numberToRemove isEqualTo _numberOfCurrentWaypoints;\nif (!_stopUnits OR !_removedAllWaypoints) exitWith {};\n\n\n\nif ((units _group) isNotEqualTo []) then {\n    // Create a self-deleting waypoint at the leader position to halt all planned movement (based on old waypoints)\n    private _wp = _group addWaypoint [getPosASL (leader _group), -1];\n    _wp setWaypointStatements [\"true\", \"deleteWaypoint [group this, currentWaypoint (group this)]\"];\n};\n\n\nnil",
    "fileName": "fn_clearWaypoints.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_clearWaypoints.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_defend\n\nDescription:\n    A function for a group to defend a parsed location. Should be ran locally.\n\n    Units will mount nearby static machine guns and garrison in nearby buildings.\n    10% chance to patrol the radius unless specified differently (100% when no available building positions).\n    0% chance to hold defensive positions in combat unless specified differently.\n\nModifications:\n    Accounted for doMove command's inability to use z-axis\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group to do the defending\n    1: _position <OBJECT, LOCATION, GROUP, or ARRAY> - centre of area to defend <ARRAY, OBJECT, LOCATION, GROUP> (Default: _group)\n    2: _radius <NUMBER> - radius of area to defend <NUMBER> (Default: 50)\n    3: _threshold <NUMBER> - minimum building positions required to be considered for garrison <NUMBER> (Default: 3)\n    4: _patrol <NUMBER or BOOL> - chance for each unit to patrol instead of garrison, true for default, false for 0% <NUMBER, BOOLEAN> (Default: 0.1)\n    5: _hold <NUMBER or BOOL> - chance for each unit to hold their garrison in combat, true for 100%, false for 0% <NUMBER, BOOLEAN> (Default: 0)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [this] call KISKA_fnc_defend\n    (end)\n\nAuthor:\n    Rommel,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_defend\";\n\n\nparams [\n    [\"_group\",grpNull,[grpNull,objNull]],\n    [\"_position\",[],[[],objNull,grpNull,locationNull],3],\n    [\"_radius\", 50, [0]],\n    [\"_threshold\", 3, [0]],\n    [\"_patrol\", 0.1, [true, 0]],\n    [\"_hold\", 0, [true, 0]]\n];\n\n// Input validation stuff here\n_group = _group call CBA_fnc_getGroup;\n// Don't create waypoints on each machine\nif !(local _group) exitWith {\n    [[\"Found that \",_group,\" was not local, exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_position = [_position, _group] select (_position isEqualTo []);\n_position = _position call CBA_fnc_getPos;\n\nif (_patrol isEqualType true) then {\n    _patrol = [0, 0.1] select _patrol;\n};\n\nif (_hold isEqualType true) then {\n    _hold = [0,1] select _hold;\n};\n\n// Start of the actual function\n[_group] call KISKA_fnc_clearWaypoints;\n\nprivate _statics = _position nearObjects [\"StaticWeapon\", _radius];\nprivate _buildings = _position nearObjects [\"Building\", _radius];\n\n// Filter out occupied statics\n_statics = _statics select {locked _x != 2 && {(_x emptyPositions \"Gunner\") > 0}};\n\n// Filter out buildings below the size threshold (and store positions for later use)\n_buildings = _buildings select {\n    private _positions = _x buildingPos -1;\n\n    if (isNil {_x getVariable \"CBA_taskDefend_positions\"}) then {\n        _x setVariable [\"CBA_taskDefend_positions\", _positions];\n    };\n\n    count (_positions) >= _threshold\n};\n\n// If patrolling is enabled then the leader must be free to lead it\nprivate _units = units _group;\nif (_patrol > 0 && {count _units > 1}) then {\n    _units deleteAt (_units find (leader _group));\n};\n\n\n_units apply {\n    // 31% chance to occupy nearest free static weapon\n    if ((random 1 < 0.31) && { !(_statics isEqualto []) }) then {\n        _x assignAsGunner (_statics deleteAt 0);\n        [_x] orderGetIn true;\n    } else {\n        // Respect chance to patrol, or force if no building positions left\n        if !((_buildings isEqualto []) || { (random 1 < _patrol) }) then {\n            private _randomBuildingIndex = [_buildings] call KISKA_fnc_randomIndex;\n            private _building = _buildings select _randomBuildingIndex;\n\n            private _buildingDefendPositions = _building getVariable [\"CBA_taskDefend_positions\", []];\n            if (_buildingDefendPositions isNotEqualTo []) then {\n                private _pos = [_buildingDefendPositions] call KISKA_fnc_deleteRandomIndex;\n\n                // If building positions are all taken remove from possible buildings\n                if (_buildingDefendPositions isEqualTo []) then {\n                    _buildings deleteAt _randomBuildingIndex;\n                    _building setVariable [\"CBA_taskDefend_positions\", nil];\n                } else {\n                    _building setVariable [\"CBA_taskDefend_positions\", _buildingDefendPositions];\n                };\n\n                // Wait until AI is in position then force them to stay\n                [_x, _pos, _hold] spawn {\n                    params [\"_unit\", \"_pos\", \"_hold\"];\n                    if (surfaceIsWater _pos) exitwith {};\n\n                    _unit doMove _pos;\n                    waituntil {unitReady _unit};\n                    // doMove does not accout for height of a position, so we force it the AI there\n                    if !((getPosATL _unit) isEqualTo _pos) then {\n                        _unit setPosATL _pos;\n                    };\n\n                    if (random 1 < _hold) then {\n                        _unit disableAI \"PATH\";\n                    } else {\n                        doStop _unit;\n                    };\n                /*\n                    [\n                        {unitReady (_this select 0)},\n                        {\n                            params [\n                                [\"_unit\",objNull,[objNull]],\n                                [\"_pos\",[0,0,0],[[]]],\n                                [\"_hold\", 0, [true, 0]]\n                            ];\n\n                            if !((getPosATL _unit) isEqualTo _pos) then {\n                                _unit setPosATL _pos;\n                            };\n\n                            if (random 1 < _hold) then {\n                                _unit disableAI \"PATH\";\n                            } else {\n                                doStop _unit;\n                            };\n                        },\n                        [_unit,_pos,_hold]\n                    ] call CBA_fnc_waitUntilAndExecute;\n                */\n\n                    // This command causes AI to repeatedly attempt to crouch when engaged\n                    // If ever fixed by BI then consider uncommenting\n                    // _unit setUnitPos \"UP\";\n                };\n            };\n        };\n    };\n};\n\n// Unassigned (or combat reacted) units will patrol\n[_group, _position, _radius, 5, \"sad\", \"safe\", \"red\", \"limited\"] call CBA_fnc_taskPatrol;\n\n\nnil\n",
    "fileName": "fn_defend.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_defend.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_driveTo\n\nDescription:\n    Units will drive to point and get out of vehicle.\n\nParameters:\n    0: _crew : <GROUP, OBJECT[], or OBJECT> - The units to move into the vehicle and drive\n    1: _vehicle : <OBJECT> - The vehicle to put units into\n    2: _dismountPoint : <OBJECT or ARRAY> - The position to move to, can be object or position array\n    3: _completionRadius : <NUMBER> - The radius at which the waypoint is complete and the units can disembark from the _dismountPoint, -1 for exact placement\n    4: _speed : <STRING> - The for the driver group to move at\n    5: _codeOnComplete : <CODE, STRING, or ARRAY> - Code to run upon completion of disembark. See KISKA_fnc_callBack\n        \n        Parameters:\n        \n        - 0: <OBJECT> - The vehicle, crew (ARRAY), and crew groups (ARRAY)\n        - 1: <OBJECT[]> - The crew of the vehicle\n        - 2: <GROUP[]> - All the groups that are in the vehicle crew\n\nReturns:\n    <BOOL> - false if encountered error, true if success\n\nExamples:\n    (begin example)\n        [_group1, _vehicle, myDismountPoint] call KISKA_fnc_driveTo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_driveTo\";\n\nparams [\n    [\"_crew\",[],[[],grpNull,objNull]],\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_dismountPoint\",objNull,[[],objNull]],\n    [\"_completionRadius\",10,[123]],\n    [\"_speed\",\"NORMAL\",[\"\"]],\n    [\"_codeOnComplete\",{},[{},\"\",[]]]\n];\n\nif ((_crew isEqualTypeAny [grpNull,objNull] AND {isNull _crew}) OR {_crew isEqualTo []}) exitWith {\n    [[\"_crew for \",_vehicle,\" is undefined\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",true] call KISKA_fnc_log;\n    false\n};\n\n\nif (_crew isEqualType grpNull) then {\n    _crew = units _crew;\n};\nif (_crew isEqualType objNull) then {\n    _crew = [_crew];\n};\n\n\nprivate _vehicleCrew = crew _vehicle;\nprivate _crewGroups = [];\n{\n    if !(_x in _vehicleCrew) then {\n        _x moveInAny _vehicle;\n    };\n    _crewGroups pushBackUnique (group _x);\n} forEach _crew;\n\nprivate _driverGroup = group (driver _vehicle);\n_driverGroup setSpeedMode _speed;\n\n\n// disable HC transfer while driving\n[_driverGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n/* [_driverGroup] call KISKA_fnc_clearWaypoints; */\n/* [_driverGroup,_dismountPoint,-1,\"MOVE\",\"UNCHANGED\",\"NO CHANGE\",_speed,\"NO CHANGE\",\"\",[0,0,0],_completionRadius] call CBA_fnc_addWaypoint; */\n\n// position loop\n[_vehicle,_crew,_codeOnComplete,_completionRadius,_dismountPoint,_driverGroup,_crewGroups] spawn {\n    params [\n        \"_vehicle\",\n        \"_crew\",\n        \"_codeOnComplete\",\n        \"_completionRadius\",\n        \"_dismountPoint\",\n        \"_driverGroup\",\n        \"_crewGroups\"\n    ];\n\n\n    // Need to wait for driver to be ready to move\n    private _driver = driver _vehicle;\n    waitUntil {\n        if (!alive _driver OR {!(_driver in _vehicle)}) exitWith {true};\n        sleep 0.1;\n        unitReady _driver;\n    };\n\n    private \"_dismountPointPos\";\n    if (_dismountPoint isEqualType objNull) then {\n        _dismountPointPos = getPosATL _dismountPoint;\n    } else {\n        _dismountPointPos = _dismountPoint;\n    };\n\n    _driverGroup move _dismountPointPos;\n\n    waitUntil {\n        if (\n            _vehicle distance _dismountPoint <= _completionRadius OR\n             !(alive _vehicle) OR\n             (isNull (driver _vehicle) OR\n              {!(_driver in _vehicle)})\n        ) exitWith {true};\n\n        sleep 1;\n        false\n    };\n\n    if (alive _vehicle) then {\n        [[\"_vehicle \",_vehicle,\" has reached its destination\"],false] call KISKA_fnc_log;\n\n        _crew apply {\n            [_x,_vehicle] remoteExecCall [\"leaveVehicle\",_x];\n        };\n    };\n\n    // enable HC transfer\n    [_driverGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n\n    [\n        [_vehicle,_crew,_crewGroups],\n        _codeOnComplete\n    ] call KISKA_fnc_callBack;\n\n};\n\n\ntrue\n",
    "fileName": "fn_driveTo.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_driveTo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_dropOff\n\nDescription:\n    Tells a vehicle to move to a position and then drop off the specified units.\n\nParameters:\n    0: _vehicle : <OBJECT> - The vehicle that will drop of units\n    1: _dropOffPosition : <OBJECT or ARRAY> - The position to drop units off, can be object or position array\n    2: _unitsToDropOff : <GROUP, ARRAY, or OBJECT> - The units to drop off\n    3: _completionRadius : <NUMBER> - The radius at which the waypoint is complete and the units can disembark from the _dropOffPosition, -1 for exact placement\n    4: _speed : <STRING> - The for the driver group to move at\n    5: _codeOnComplete : <CODE, STRING, or ARRAY> - Code to run upon completion of disembark. See KISKA_fnc_callBack\n        \n        Params:\n        \n            - 0. <OBJECT> - The vehicle that will drop of units\n            - 1. <ARRAY> - The units dropped off at this location\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            myVehicle,\n            myPosition,\n            player\n        ] call KISKA_fnc_dropOff;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_dropOff\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_dropOffPosition\",objNull,[[],objNull]],\n    [\"_unitsToDropOff\",[],[[],grpNull,objNull]],\n    [\"_completionRadius\",10,[123]],\n    [\"_speed\",\"NORMAL\",[\"\"]],\n    [\"_codeOnComplete\",{},[{},\"\",[]]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _driver = driver _vehicle;\nif !(alive _driver) exitWith {\n    [\"_driver is null or dead, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _positionIsObject = _dropOffPosition isEqualType objNull;\nif (_positionIsObject AND (isNull _dropOffPosition)) exitWith {\n    [\"_dropOffPosition is null, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_positionIsObject) then {\n    _dropOffPosition = getPosATL _dropOffPosition;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Verify _unitsToDropOff parameter\n---------------------------------------------------------------------------- */\nif (_unitsToDropOff isEqualTo []) exitWith {\n    [\"_unitsToDropOff is empty, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_unitsToDropOff isEqualTypeAny [objNull,grpNull] AND {isNull _unitsToDropOff}) exitWith {\n    [\"_unitsToDropOff isNull, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_unitsToDropOff isEqualType grpNull) then {\n    _unitsToDropOff = units _unitsToDropOff;\n};\n\nif (_unitsToDropOff isEqualType objNull) then {\n    _unitsToDropOff = [_unitsToDropOff];\n};\n\nprivate _unitsToDropOffFiltered = [];\n\nif (_unitsToDropOff isEqualType []) then {\n    _unitsToDropOff apply {\n        if (_x isEqualType grpNull) then {\n            _unitsToDropOffFiltered append (units _x);\n        };\n\n        if (_x isEqualType objNull) then {\n            _unitsToDropOffFiltered pushBack _x;\n        };\n    };\n};\n\n\n/* ----------------------------------------------------------------------------\n    Main Function\n---------------------------------------------------------------------------- */\nprivate _driverGroup = group _driver;\n_driverGroup setSpeedMode _speed;\n// disable HC transfer while driving\n[_driverGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n[\n    _vehicle,\n    _unitsToDropOffFiltered,\n    _codeOnComplete,\n    _completionRadius,\n    _dropOffPosition,\n    _driver,\n    _driverGroup\n] spawn {\n    params [\n        \"_vehicle\",\n        \"_unitsToDropOffFiltered\",\n        \"_codeOnComplete\",\n        \"_completionRadius\",\n        \"_dropOffPosition\",\n        \"_driver\",\n        \"_driverGroup\"\n    ];\n\n\n    // Need to wait for driver to be ready to move\n    private _driver = driver _vehicle;\n    waitUntil {\n        if !(alive _driver) exitWith {true};\n        sleep 0.1;\n        unitReady _driver;\n    };\n\n    if (_driver in _vehicle) then {\n        _driverGroup move _dropOffPosition;\n    };\n\n    waitUntil {\n        if (\n            _vehicle distance _dropOffPosition <= _completionRadius OR\n            !(alive _vehicle) OR\n            (isNull (driver _vehicle) OR\n            {!(_driver in _vehicle)})\n        ) exitWith {true};\n\n        sleep 1;\n        false\n    };\n\n    if (alive _vehicle) then {\n        [[\"_vehicle \",_vehicle,\" has reached its destination\"],false] call KISKA_fnc_log;\n\n        _unitsToDropOffFiltered apply {\n            [_x,_vehicle] remoteExec [\"leaveVehicle\",_x];\n            [_x,_vehicle] remoteExec [\"moveOut\",_x];\n            sleep 0.5;\n        };\n\n        waitUntil {\n            if (\n                !alive _vehicle OR\n                {(_unitsToDropOffFiltered findIf {_x in _vehicle}) < 0}\n            ) exitWith {true};\n\n            sleep 1;\n            false\n        };\n    };\n\n    // enable HC transfer\n    [_driverGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n\n    [\n        [_vehicle,_unitsToDropOffFiltered],\n        _codeOnComplete\n    ] call KISKA_fnc_callBack;\n};\n\nnil\n",
    "fileName": "fn_dropOff.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_dropOff.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_engageHeliTurretsLoop\n\nDescription:\n    Sets up a helicopter's turrets to be able to properly engage enemies without\n     without the pilot going crazy.\n\n    Starts a loop that will reveal targets within a given radius to gunners to engage.\n\n    You can use variables in the _heli's namepsace to adjust params dynamically:\n        \"KISKA_heliTurrets_endLoop\" - ends the function\n        \"KISKA_heliTurrets_sleepTime\" - adjusts the _sleepTime param\n        \"KISKA_heliTurrets_revealAccuracy\" - adjusts the _revealAccuracy param\n        \"KISKA_heliTurrets_detectionRadius\" - adjusts the _detectionRadius param\n        \"KISKA_heliTurrets_running\" - checks if the system is running\n\nParameters:\n    0: _heli : <OBJECT> - The helicopter to set up\n    1: _sleepTime : <NUMBER> - Time in between each \"refresh\" of the targets gunners are revealed\n    2: _revealAccuracy : <NUMBER> - The accuracy of the reveals of targets for gunners\n    3: _detectionRadius : <NUMBER> - The radius within to search for targets for the gunners\n    4: _skill : <NUMBER> - The skill of the vehicle crew\n    5: _makeInvulnerable : <BOOL> - Makes vehicle crew invulnerable or not\n    6: _turretsWithWeapons : <ARRAY> - If you've already found which turrets to regard as \"gunner\" turrets, pass their turret paths\n        or the function will get them.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            5,\n            4,\n            250,\n            1,\n            true\n        ] spawn KISKA_fnc_engageHeliTurretsLoop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_engageHeliTurretsLoop\";\n\n#define MIN_SLEEP_TIME 0.01\n#define EXIT_VAR_STR \"KISKA_heliTurrets_endLoop\"\n#define SLEEP_TIME_VAR_STR \"KISKA_heliTurrets_sleepTime\"\n#define REVEAL_ACC_VAR_STR \"KISKA_heliTurrets_revealAccuracy\"\n#define IS_RUNNING_VAR_STR \"KISKA_heliTurrets_running\"\n#define DETECT_RADIUS_VAR_STR \"KISKA_heliTurrets_detectionRadius\"\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled! Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_engageHeliTurretsLoop;\n};\n\n\nparams [\n    [\"_heli\",objNull,[objNull]],\n    [\"_sleepTime\",5,[123]],\n    [\"_revealAccuracy\",4,[123]],\n    [\"_detectionRadius\",250,[123]],\n    [\"_skill\",1,[123]],\n    [\"_makeInvulnerable\",false,[true]],\n    [\"_turretsWithWeapons\",[],[[]]]\n];\n\n\nif (isNull _heli) exitWith {\n    [\"A null object was passed\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    verify vehicle is compatible\n---------------------------------------------------------------------------- */\nprivate _aircraftType = typeOf _heli;\nif (_turretsWithWeapons isEqualTo []) then {\n    _turretsWithWeapons = [_aircraftType] call KISKA_fnc_classTurretsWithGuns;\n};\nif (_turretsWithWeapons isEqualTo []) exitWith {\n    [[_aircraftType,\" does not have properly configured turrets!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Prepare AI\n---------------------------------------------------------------------------- */\nprivate _turretUnits = [];\nprivate _turretSeperated = false;\nprivate _vehicleCrew = crew _heli;\nprivate _side = side (_vehicleCrew select 0);\n\n_vehicleCrew apply {\n    if (_makeInvulnerable) then {\n       _x allowDamage false;\n    };\n    _x setSkill _skill;\n\n    _x disableAI \"SUPPRESSION\";\n    _x disableAI \"RADIOPROTOCOL\";\n\n    // give turrets their own groups so that they can engage targets at will\n    if ((_heli unitTurret _x) in _turretsWithWeapons) then {\n    /*\n        About seperating one turret...\n        My testing has revealed that in order to have both turrets on a helicopter (if it has two)\n         engaging targets simultaneously, one needs to be in a seperate group from the pilot, and one\n         needs to be grouped with the pilot.\n    */\n        if !(_turretSeperated) then {\n            _turretSeperated = true;\n            private _group = createGroup _side;\n            [_x] joinSilent _group;\n            _group setCombatBehaviour \"COMBAT\";\n            _group setCombatMode \"RED\";\n        };\n        _turretUnits pushBack _x;\n    } else { // disable targeting for the other crew\n        _x disableAI \"AUTOCOMBAT\";\n        _x disableAI \"TARGET\";\n        //_x disableAI \"AUTOTARGET\";\n        _x disableAI \"FSM\";\n    };\n};\n\n// keep the pilots from freaking out under fire\nprivate _pilotsGroup = group (currentPilot _heli);\n_pilotsGroup setBehaviour \"CARELESS\"; // Only careless group will follow speed limit\n// the pilot group's combat mode MUST be a fire-at-will version as it adjusts it for the entire vehicle\n_pilotsGroup setCombatMode \"RED\";\n\n\n\n/* ----------------------------------------------------------------------------\n    Loop\n---------------------------------------------------------------------------- */\nprivate _fn_getTargets = {\n    (_heli nearEntities [[\"MAN\",\"CAR\",\"TANK\"],(_heli getVariable [DETECT_RADIUS_VAR_STR, _detectionRadius])]) select {\n        !(isAgent teamMember _x) AND\n        {[side _x, _side] call BIS_fnc_sideIsEnemy}\n    };\n};\n\n\nif (_sleepTime < MIN_SLEEP_TIME) then {\n    _sleepTime = MIN_SLEEP_TIME;\n};\n\n\n_heli setVariable [EXIT_VAR_STR,false];\n_heli setVariable [IS_RUNNING_VAR_STR,true];\n_heli setVariable [DETECT_RADIUS_VAR_STR, _detectionRadius];\n_heli setVariable [SLEEP_TIME_VAR_STR, _sleepTime];\n_heli setVariable [REVEAL_ACC_VAR_STR, _revealAccuracy];\n\n\nprivate _targetsInArea = [];\n// using waituntil to avoid running more then once a frame\nwaitUntil {\n    if (!(alive _heli) OR (_heli getVariable [EXIT_VAR_STR,false])) exitWith {true};\n\n    _targetsInArea = call _fn_getTargets;\n    if (_targetsInArea isNotEqualTo []) then {\n\n        _targetsInArea apply {\n            _currentTarget = _x;\n\n            _turretUnits apply {\n                if !(isNull _x) then {\n                    _x reveal [_currentTarget,(_heli getVariable [REVEAL_ACC_VAR_STR, _revealAccuracy])];\n                };\n            };\n\n        };\n\n    };\n\n    sleep (_heli getVariable [SLEEP_TIME_VAR_STR, _sleepTime]);\n\n    false\n};\n\n_heli setVariable [IS_RUNNING_VAR_STR,false];\n_heli setVariable [EXIT_VAR_STR,false];\n",
    "fileName": "fn_engageHeliTurretsLoop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_engageHeliTurretsLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_heliLand\n\nDescription:\n    Makes a helicopter land at a given position.\n\nParameters:\n    0: _aircraft <OBJECT> - The helicopter\n    1: _landingPosition <PositionASL[] or OBJECT> - Where to land. If object, position ATL is used.\n    2: _landMode <STRING> - Options are `\"LAND\"`, `\"GET IN\"`, and `\"GET OUT\"`\n    3: _landingDirection <NUMBER> - The direction the vehicle should face when landed.\n        `-1` means that there shouldn't be any change to the direction. Be aware that this \n        will have to `setDir` of the helipad.\n    4: _afterLandCode <CODE, STRING, or ARRAY> - Code to `spawn` after the helicopter has landed. See `KISKA_fnc_callBack`.\n        \n        Parameters:\n        - 0: <OBJECT> - The helicopter\n        \n\nReturns:\n    <BOOL> - True if helicopter can attempt, false if problem\n\nExamples:\n    (begin example)\n        [myHeli,position player] call KISKA_fnc_heliLand;\n    (end)\n\nAuthor:\n    Karel Moricky,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_heliLand\";\n\n#define INVISIBLE_PAD_TYPE \"Land_HelipadEmpty_F\"\n#define LAND_EVENT \"KISKA_landedEvent\"\n#define HIGH_LANDED_THRESHOLD 3\n#define ALTITUDE_COMPARE_LOG_COUNT 10\n#define VELOCITY_THRESHOLD 5\n\nparams [\n    [\"_aircraft\",objNull,[objNull]],\n    [\"_landingPosition\",[],[[],objNull]],\n    [\"_landMode\",\"LAND\",[\"\"]],\n    [\"_landingDirection\",-1,[123]],\n    [\"_afterLandCode\",{},[{},\"\",[]]]\n];\n\nif (isNull _aircraft) exitWith {\n    [\"_aircraft is a null object\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (!(_aircraft isKindOf \"Helicopter\") AND {!(_aircraft isKindOf \"VTOL_Base_F\")}) exitWith {\n    [[_aircraft,\" is not a helicopter or VTOL, exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n[group (currentPilot _aircraft),true] call KISKA_fnc_ACEX_setHCTransfer;\n\n// move command only supports positions, not objects\nif (_landingPosition isEqualType objNull) then {\n    if (_landingDirection isEqualTo -1) then {\n        _landingDirection = getDir _landingPosition;\n    };\n    _landingPosition = getPosASL _landingPosition;\n};\n\n// Using a helipad to support the ability to have a landing direction\n// Helicopters will attempt to land in the direction the helipad is facing\nprivate _helipadToLandAt = INVISIBLE_PAD_TYPE createVehicle _landingPosition;\n_helipadToLandAt setPosASL _landingPosition;\nif (_landingDirection isNotEqualTo -1) then {\n    _helipadToLandAt setDir _landingDirection;\n};\n\nprivate _keepEngineOn = false;\nprivate _consideredLandedHeightOffset = 0.1;\n_landMode = toUpperANSI _landMode;\nif (_landMode isNotEqualTo \"LAND\") then {\n    switch (_landMode) do {\n        case \"GETIN\";\n        case \"GETOUT\";\n        case \"GET IN\";\n        case \"GET OUT\": {\n            _keepEngineOn = true;\n            _consideredLandedHeightOffset = HIGH_LANDED_THRESHOLD;\n        };\n\n        default {\n            [[\"Unknown land type: \", _landMode,\" used for aircraft: \",_aircraft,\" . Changing to mode 'LAND'\"],true] call KISKA_fnc_log;\n            _landMode = \"LAND\";\n        };\n    };\n};\n\n\n[\n    _aircraft,\n    _landingPosition,\n    _landMode,\n    _afterLandCode,\n    _keepEngineOn,\n    _consideredLandedHeightOffset,\n    _helipadToLandAt\n] spawn {\n    params [\n        \"_aircraft\",\n        \"_landingPosition\",\n        \"_landMode\",\n        \"_afterLandCode\",\n        \"_keepEngineOn\",\n        \"_consideredLandedHeightOffset\",\n        \"_helipadToLandAt\"\n    ];\n\n    [_aircraft,_landingPosition] remoteExecCall [\"move\",_aircraft];\n    _aircraft setVariable [\"KISKA_isLanding\",true];\n\n    private _aircraftPositionLogs = [];\n    private _isWavingOff = {\n        import [\"_aircraft\",\"_landingPosition\"];\n        private _currentLandStatus = landAt _aircraft;\n        private _currentLandResult = _currentLandStatus select 1;\n        if (_currentLandResult != \"Found\") exitWith { true };\n\n        private _currentLandingPosition = _currentLandStatus select 2;\n        (_currentLandingPosition vectorDistance _landingPosition) > 20\n    };\n\n    private _helipadPosition = getPosASL _helipadToLandAt;\n    private _helipadAltitude = _helipadPosition select 2;\n    private _wasToldToLand = false;\n\n    waitUntil {\n        sleep 1;\n\n        if (\n            !(alive _aircraft) OR \n            (_aircraft getVariable [\"KISKA_cancelLanding\",false])\n        ) then { breakWith true };\n\n        if !(_wasToldToLand) exitWith {\n            if (unitReady _aircraft) then {\n                hint \"was told to land\";\n                [_aircraft,[_helipadToLandAt,_landMode]] remoteExecCall [\"landAt\",_aircraft];\n                _wasToldToLand = true;\n            };\n            false\n        };\n\n        private _aircraftPosition = getPosASL _aircraft;\n        private _currentAircraftAltitude = _aircraftPosition select 2;\n        if (\n            (isTouchingGround _aircraft) OR \n            (_currentAircraftAltitude <= (_consideredLandedHeightOffset + _helipadAltitude))\n        ) then {\n            hint \"touchdown\";\n\n            // reinforce land\n            // sometimes, the helicopter will \"land\" but immediately take off again\n            // this is why the thing is told to land again\n            sleep 2;\n            [_aircraft,[_helipadToLandAt,_landMode]] remoteExecCall [\"landAt\",_aircraft];\n\n            if (_keepEngineOn) then {\n                [_aircraft,true] remoteExecCall [\"engineOn\",_aircraft];\n            };\n\n            breakWith true;\n        };\n\n        if (call _isWavingOff) exitWith {\n            hint \"is waving off\";\n            _wasToldToLand = false;\n            sleep 2;\n            _aircraft land \"NONE\";\n            hint \"cancelled landing\";\n            \n            false\n        };\n\n        false\n    };\n\n    // variable to track if other code can run\n    _aircraft setVariable [\"KISKA_cancelLanding\",false];\n    _aircraft setVariable [\"KISKA_isLanding\",false];\n\n    [[_aircraft],_afterLandCode] call KISKA_fnc_callBack;\n    [_aircraft,LAND_EVENT,[_aircraft]] call BIS_fnc_callScriptedEventHandler;\n\n    deleteVehicle _helipadToLandAt;\n};\n\n\nnil\n",
    "fileName": "fn_heliLand.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_heliLand.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_heliPatrol\n\nDescription:\n    Has a helicopter patrol looking for enemy men.\n    If \"spotted\", the helicopter will land in a safe area and drop off infantry if onboard.\n    It will then move to engage the units if it has weapons or just stalk them if not.\n    The infantry will continually stalk the unit until dead.\n\nParameters:\n    0: _helicopter <OBJECT> - The patrolling helicopter\n    1: _patrolPoints <ARRAY> - An Array of patrol points (OBJECTs or positions)\n    2: _spotDistance3D <NUMBER> - How far away can the helicopter spot a player\n    3: _patrolHeight <NUMBER> - What's the flying height of the helicopter\n    4: _patrolSpeed <STRING> - setWaypointSpeed, takes \"UNCHANGED\", \"LIMITED\", \"NORMAL\", and \"FULL\"\n    5: _randomPatrol <BOOL> - Should patrol points be randomized or followed in array order\n\n\nReturns:\n    <BOOL> - True if helicopter will patrol, false if problem encountered\n\nExamples:\n    (begin example)\n        [heli,[logic1,logic2,logic3],500,200,false] call KISKA_fnc_heliPatrol;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_heliPatrol\";\n\nparams [\n    [\"_helicopter\",objNull,[objNull]],\n    [\"_patrolPoints\",[],[[]]],\n    [\"_spotDistance3D\",800,[123]],\n    [\"_patrolHeight\",100,[123]],\n    [\"_patrolSpeed\",\"NORMAL\",[\"\"]],\n    [\"_randomPatrol\",true,[true]]\n];\n\nif (isNull _helicopter) exitWith {\n    [\"_helicopter is a null object\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_patrolHeight > _spotDistance3D) exitWith {\n    [[_patrolHeight,\" is higher then \",_spotDistance3D,\". The helicopter can't spot anything\"],true] call KISKA_fnc_log;\n    false\n};\n\nif !(_patrolPoints isEqualTypeAny [objNull,[]]) exitWith {\n    [[_patrolPoints,\" need to be either positions or objects, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _pilot = currentPilot _helicopter;\n\nif (isNull _pilot) exitWith {\n    [[\"No pilot found in \",_helicopter],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _helicopterGroup = group _pilot;\n[_helicopterGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n_helicopter flyInHeight _patrolHeight;\n\n[_helicopterGroup,_patrolPoints,count _patrolPoints,_randomPatrol,\"SAFE\",_patrolSpeed,\"WHITE\"] call KISKA_fnc_patrolSpecific;\n\n\n\n[_helicopter,_spotDistance3D,_helicopterGroup] spawn {\n    params [\"_helicopter\",\"_spotDistance3D\",\"_helicopterGroup\"];\n\n    // search for targets\n    private [\"_targets\",\"_foundTargetIndex\"];\n    private _helicopterSide = side _helicopterGroup;\n    waitUntil {\n        _targets = _helicopter nearEntities [\"MAN\",_spotDistance3D];\n        _foundTargetIndex = _targets findIf {\n                ([side _x,_helicopterSide] call BIS_fnc_sideIsEnemy) AND\n                {(_x distance _helicopter) <= _spotDistance3D} AND\n                {side _x != Civilian}\n            };\n        if (_foundTargetIndex isNotEqualTo -1) exitWith {true};\n        sleep 4;\n        false\n    };\n    // Move to land\n    private _foundTarget = _targets select _foundTargetIndex;\n    private _foundTargetPosition = getPosATL _foundTarget;\n\n    private _landingZone = [_foundTarget,300,500,5,0,0,0,[],[_foundTargetPosition,_foundTargetPosition]] call BIS_fnc_findSafePos;\n    _landingZone pushBack 0;\n\n    [_helicopterGroup] call KISKA_fnc_clearWaypoints;\n    [_helicopterGroup,_landingZone,0,\"TR UNLOAD\",\"AWARE\",\"WHITE\",\"NORMAL\"] call CBA_fnc_addwaypoint;\n\n\n    // waituntil the helicopter is about to land\n    waitUntil {\n        sleep 2;\n        ((getPosATLVisual _helicopter select 2) < 2)\n    };\n    // tell all groups that in the aircraft that aren't crew to stalk the target group\n    private _targetGroup = group _foundTarget;\n    private _groups = [];\n    (crew _helicopter) apply {\n        private _group = group _x;\n        if (!(_group in _groups) AND {_group isNotEqualTo _helicopterGroup}) then {\n            _groups pushBack _group\n        };\n    };\n    _groups apply {\n        [_x,_targetGroup] spawn BIS_fnc_stalk;\n        _x setCombatMode \"YELLOW\";\n    };\n\n\n    // Wait for all passengers to be out\n    private _helicopterGroupCount = count (units _helicopterGroup);\n    waitUntil {\n        if (count (crew _helicopter) <= _helicopterGroupCount) exitWith {true};\n        sleep 1;\n        false\n    };\n\n    // tell the helicopter to engage the target\n    [_helicopterGroup,_targetGroup] spawn BIS_fnc_stalk;\n    _helicopterGroup setCombatMode \"RED\";\n};\n\n\ntrue\n",
    "fileName": "fn_heliPatrol.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_heliPatrol.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hover\n\nDescription:\n    Sends a vehicle to a given point to hover.\n\n    Pilots should ideally be placed in \"CARELESS\" behaviour when around enemies.\n\nParameters:\n    0: _vehicle <OBJECT> - The helicopter/vtol to hover\n    1: _hoverPosition <PositionASL[] or OBJECT> - The positionASL to drop the \n        units off at; Z coordinate matters\n    2: _callBackMap <HASHMAP> - A map of callback functions that can be optionally added:\n        \n        - `_shouldHoverStop`: <CODE> - Code that should return a boolean to determine \n            if the vehicle should stop its hover. This condition is checked every 0.05s.\n            \n            Parameters:\n\n            - 0: _vehicle - The hover vehicle\n            - 1: _pilot - The `currentPilot` of the vehicle\n\n        - `_onHoverEnd`: <CODE, STRING, or ARRAY> - Code that executes after the \n            hover completes, see `KISKA_fnc_callBack`\n            \n            Parameters:\n            \n            - 0: _vehicle - The hover vehicle\n            - 1: _pilot - The `currentPilot` of the vehicle\n\n        - `_onHoverStart`: <CODE, STRING, or ARRAY> - Code that executes after the \n            vehicle is within 5m of the hover position, see `KISKA_fnc_callBack`\n            \n            Parameters:\n            \n            - 0: _vehicle - The hover vehicle\n            - 1: _pilot - The `currentPilot` of the vehicle\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            myHeli,\n            myHoverPositionASL,\n            createHashMapFromArray [\n                [\n                    \"_shouldHoverStop\", \n                    {\n                        localNamespace getVariable [\"stopMyHover\",false]\n                    }\n                ],\n                [\n                    \"_onHoverEnd\",\n                    {\n                        hint \"after hover\";\n                    }\n                ]\n            ]\n        ] call KISKA_fnc_hover;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hover\";\n\n#define HOVER_INTERVAL 0.05\n#define START_VELOCITY_CONTROL_DISTANCE 400\n#define DEFAULT_VELOCITY_MAGNITUDE 50\n#define MAX_DECELERATION_SPEED 10\n#define ACCELERATION_INCREMENT 0.25\n#define DISTANCE_TO_DISABLE_PILOT_AI 25\n#define DISTANCE_TO_STOP_VELOCITY_ADJUSTMENT 2.5\n#define DISTANCE_TO_TRIGGER_ON_HOVER_START 5\n\nprivate _defaultMap = createHashMap;\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_hoverPosition\",[],[objNull,[]],3],\n    [\"_callBackMap\",_defaultMap,[_defaultMap]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _hoverPositionIsObject = _hoverPosition isEqualType objNull;\nif (_hoverPositionIsObject AND { isNull _hoverPosition }) exitWith {\n    [\"null _hoverPosition passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_hoverPositionIsObject) then {\n    _hoverPosition = getPosASL _hoverPosition;\n};\n\n\nprivate _vehicleGroup = group (commander _vehicle);\n_vehicleGroup allowFleeing 0;\nprivate _pilot = driver _vehicle;\n_pilot setSkill 1;\n_pilot move (ASLToATL _hoverPosition);\n\nprivate _onHoverStartDefined = \"_onHoverStart\" in _callBackMap;\n// guides helicopter to drop position\n[\n    {\n        params [\"_args\", \"_id\"];\n        _args params [\"_vehicle\",\"_callBackMap\"];\n        \n        private _pilot = currentPilot _vehicle;\n        if (\n            !(alive _vehicle) OR\n            {!(isEngineOn _vehicle)} OR // in case engine dies\n            {!(alive _pilot)} OR\n            { \n                [_vehicle,_pilot] call (_callBackMap getOrDefaultCall [\"_shouldHoverStop\",{{false}},true]) \n            }\n        ) exitWith {\n            if (_pilot getVariable [\"KISKA_hover_hoverAiDisabled\",true]) then {\n                _pilot setVariable [\"KISKA_hover_hoverAiDisabled\",nil];\n                [_pilot,\"PATH\"] remoteExecCall [\"enableAI\",_pilot];\n            };\n\n            private _onHoverEnd = _callBackMap getOrDefaultCall [\"_onHoverEnd\",{{}}];\n            if (_onHoverEnd isNotEqualTo {}) then {\n                [[_vehicle,_pilot],_onHoverEnd] call KISKA_fnc_callBack;\n            };\n\n            [_id] call CBA_fnc_removePerFrameHandler;\n        };\n        \n        private _currentVehiclePosition_ASL = getPosASLVisual _vehicle;\n        private _hoverPosition = _args select 2;\n        private _distanceToHoverPosition = _currentVehiclePosition_ASL vectorDistance _hoverPosition;\n\n        if (_distanceToHoverPosition > START_VELOCITY_CONTROL_DISTANCE) exitWith {};\n\n        if (isNil {_vehicle getVariable \"KISKA_hoverTransformStart_speed\"}) then {\n            _vehicle setVariable [\"KISKA_hoverTransformStart_speed\",(speed _vehicle) / 3.6];\n        };\n\n        private _speed = _vehicle getVariable \"KISKA_hoverTransformStart_speed\";\n        private _velocityMagnitude = DEFAULT_VELOCITY_MAGNITUDE;\n\n        private _withinAccelerationArea = _distanceToHoverPosition > 100;\n        if (_withinAccelerationArea) then {\n            if (_speed < _velocityMagnitude) then {\n                _speed = _speed + ACCELERATION_INCREMENT;\n                _vehicle setVariable [\"KISKA_hoverTransformStart_speed\",_speed];\n            };\n\n        } else {\n            _speed = (_speed - 1) max MAX_DECELERATION_SPEED;\n            _vehicle setVariable [\"KISKA_hoverTransformStart_speed\",_speed];\n\n        };\n\n\n        if (\n            (_distanceToHoverPosition <= DISTANCE_TO_DISABLE_PILOT_AI) AND\n            (_pilot checkAIFeature \"PATH\")\n        ) then {\n            [_pilot,\"PATH\"] remoteExecCall [\"disableAI\",_pilot];\n            _pilot setVariable [\"KISKA_hover_hoverAiDisabled\",true];\n        };\n\n        _velocityMagnitude = _speed;\n        if (_distanceToHoverPosition >= DISTANCE_TO_STOP_VELOCITY_ADJUSTMENT) then {\n            if ( _distanceToHoverPosition <= 15 ) then {\n                _velocityMagnitude = (_distanceToHoverPosition / 10) * 5;\n            };\n\n            private _currentVelocity = velocity _vehicle;\n            _currentVelocity = (_currentVehiclePosition_ASL vectorFromTo _hoverPosition) vectorMultiply _velocityMagnitude;\n            _vehicle setVelocity _currentVelocity;\n        };\n\n        private _onHoverStartDefined = _args select 3;\n        if (\n            _onHoverStartDefined AND \n            {_distanceToHoverPosition <= DISTANCE_TO_TRIGGER_ON_HOVER_START} AND \n            {\n                !(_vehicle getVariable [\"KISKA_hover_onHoverStartTriggered\",false])\n            }\n        ) then {\n            _vehicle setVariable [\"KISKA_hover_onHoverStartTriggered\",true];\n            private _onHoverStart = _callBackMap get \"_onHoverStart\";\n            [[_vehicle,_pilot],_onHoverStart] call KISKA_fnc_callBack;\n        };\n\n    },\n    HOVER_INTERVAL,\n    [\n        _vehicle,\n        _callBackMap,\n        _hoverPosition,\n        _onHoverStartDefined\n    ]\n] call CBA_fnc_addPerFrameHandler;\n\n\nnil\n",
    "fileName": "fn_hover.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_hover.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_initDynamicSimConfig\n\nDescription:\n    Initializes the dynamic simulation system with the given values based on\n     mission config values.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_initDynamicSimConfig\";\n\nprivate _dynamicSimConfig = missionConfigFile >> \"KISKA_dynamicSimulation\";\nif (isNull _dynamicSimConfig) exitWith {\n    [\"_dynamicSimConfig at missionConfigFile >> 'KISKA_dynamicSimulation', is null\",false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _enableSystem = [_dynamicSimConfig >> \"enableDynamicSimulation\"] call BIS_fnc_getCfgDataBool;\nenableDynamicSimulationSystem _enableSystem;\n\n\nprivate _coefConfig = _dynamicSimConfig >> \"Coef\";\nprivate _coefProperties = [\"IsMoving\"];\n_coefProperties apply {\n    private _propertyConfig = _coefConfig >> _x;\n    if !(isNumber _propertyConfig) then {\n        [[_x,\" was not defined (as number) in the missionConfigFile >> KISKA_dynamicSimulation >> Coef class\"],false] call KISKA_fnc_log;\n        continue;\n    };\n\n    _x setDynamicSimulationDistanceCoef (getNumber _propertyConfig);\n};\n\n\nprivate _activationDistanceConfig = _dynamicSimConfig >> \"ActivationDistance\";\nprivate _distanceProperties = [\"Group\",\"Vehicle\",\"EmptyVehicle\",\"Prop\"];\n_distanceProperties apply {\n    private _propertyConfig = _activationDistanceConfig >> _x;\n    if !(isNumber _propertyConfig) then {\n        [[_x,\" was not defined (as number) in the missionConfigFile >> KISKA_dynamicSimulation >> ActivationDistance class\"],false] call KISKA_fnc_log;\n        continue;\n    };\n\n    _x setDynamicSimulationDistance (getNumber _propertyConfig);\n};\n\n\nnil",
    "fileName": "fn_initDynamicSimConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_initDynamicSimConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_lookHere\n\nDescription:\n    Takes objects and sets their direction towards the nearest object or position within a set\n\nParameters:\n    0: _objectsToRotate <OBJECT or ARRAY> - The objects to setDir on \n    1: _positionsToLookAt <OBJECT or ARRAY> - The positions or objects to search for nearest\n    2: _setDirection <BOOL> - Also set objects direction relative to the look position\n\nReturns:\n    BOOL\n\nExamples:\n    (begin example)\n        [player,[[0,0,0]]] call KISKA_fnc_lookHere;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_lookHere\";\n\nparams [\n    [\"_objectsToRotate\",[],[objNull,[]]],\n    [\"_positionsToLookAt\",[],[objNull,[]]],\n    [\"_setDirection\",true,[true]]\n];\n\nif (_objectsToRotate isEqualTo [] OR {_objectsToRotate isEqualType objNull AND {isNull _objectsToRotate}}) exitWith {\n    [\"_objectsToRotate is undefined\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_objectsToRotate isEqualtype objNull) then {\n    _objectsToRotate = [_objectsToRotate];\n};\n\n_objectsToRotate apply {\n    private _nearestPosition = [_positionsToLookAt,_x] call BIS_fnc_nearestPosition;\n    \n    if (_setDirection) then {\n        _x setDir (_x getRelDir _nearestPosition);\n    };\n    \n    _x doWatch _nearestPosition;\n};\n\n\ntrue",
    "fileName": "fn_lookHere.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_lookHere.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_patrolSpecific\n\nDescription:\n    Creates a cycle of waypoints for a patrol using a predetermined set of possible points\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group or unit to give waypoints to\n    1: _postions <(PositionATL[] | Position2D[] | OBJECT)[]> - An array of possible \n        positions to patrol between. Can be either positions or objects.\n    2: _numWaypoints <NUMBER> - The number of waypoints, use -1 to patrol all given positions\n\n    (Optional)\n    3: _random <BOOL> - Should waypoints be randomized from _positions array\n    4: _behaviour <STRING> - setWaypointBehaviour, takes \"UNCHANGED\", \"SAFE\", \"COMBAT\", \"AWARE\", \"CARELESS\", and \"STEALTH\"\n    5: _speed <STRING> - setWaypointSpeed, takes \"UNCHANGED\", \"LIMITED\", \"NORMAL\", and \"FULL\"\n    6: _combatMode <STRING> - setWaypointCombatMode, takes \"NO CHANGE\", \"BLUE\", \"GREEN\", \"WHITE\", \"YELLOW\", and \"RED\"\n    7: _formation <STRING> - setWaypointFormation, takes \"NO CHANGE\", \"COLUMN\", \"STAG COLUMN\", \"WEDGE\", \"ECH LEFT\", \"ECH RIGHT\", \"VEE\", \"LINE\", \"FILE\", and \"DIAMOND\"\n\nReturns:\n    <BOOL> - True if units will patrol, false if problem encountered\n\nExamples:\n    (begin example)\n        [_group,_positionsArray,5] call KISKA_fnc_patrolSpecific;\n    (end)\n\nAuthor:\n    Ansible2,\n    Spectre\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_patrolSpecific\";\n\nparams [\n    [\"_group\",grpNull,[grpNull,objNull]],\n    [\"_positions\",[],[[]]],\n    [\"_numWaypoints\",-1,[1]],\n    [\"_random\",true,[true]],\n    [\"_behaviour\",\"SAFE\",[\"\"]],\n    [\"_speed\",\"LIMITED\",[\"\"]],\n    [\"_combatMode\",\"RED\",[\"\"]],\n    [\"_formation\",\"STAG COLUMN\",[\"\"]]\n];\n\nif !(local _group) exitWith {\n    [[\"Found that \",_group,\" was not local, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (isNull _group) exitwith {\n    [[\"Found that \",_group,\" was null, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (_numWaypoints < 0) then {\n    _numWaypoints = count _positions;\n};\nif (_numWaypoints < 2) exitwith {\n    [[_numWaypoints,\" is not above 2, needs to be atleast 2, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (_positions isEqualTo []) exitwith {\n    [[_positions,\". No positions passed, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif ((count _positions) < 1) exitwith {\n    [[_positions,\". Need more positions to be passed. Exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\n\n[_group] call KISKA_fnc_clearWaypoints;\n\nprivate \"_cyclePosition\";\n\nfor \"_i\" from 0 to (_numWaypoints - 1) do {\n    private \"_selectedPosition\";\n    private \"_waypoint\";\n\n    if (_random) then {\n        _selectedPosition = [_positions] call KISKA_fnc_deleteRandomIndex;\n        _waypoint = _group addWaypoint [_selectedPosition,0];\n    } else {\n        _selectedPosition = _positions select _i;\n        _waypoint = _group addWaypoint [_selectedPosition,0];\n    };\n\n    if (_i isEqualTo 0) then {\n        _cycleposition = _selectedPosition;\n    };\n\n    _waypoint setWaypointType \"MOVE\";\n    [_waypoint,_behaviour] remoteExec [\"setWaypointBehaviour\",2];\n    [_waypoint,_formation] remoteExec [\"setWaypointFormation\",2];\n    [_waypoint,_speed] remoteExec [\"setWaypointSpeed\",2];\n    _waypoint setWaypointCombatMode _combatMode;\n};\n\n\n_cycleWaypoint = _group addWaypoint [_cyclePosition,0];\n_cycleWaypoint setWaypointType \"CYCLE\";\n\n\ntrue\n",
    "fileName": "fn_patrolSpecific.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_patrolSpecific.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_setCrew\n\nDescription:\n    Moves units into a vehicle as crew and then as passengers.\n\nParameters:\n    0: _crew : <GROUP, ARRAY, or OBJECT> - The units to move into the vehicle\n    1: _vehicle : <OBJECT> - The vehicle to put units into\n    2: _deleteCrewIfNull : <BOOL> - If the vehicle turns out to be null, the provided crew will be deleted\n\nReturns:\n    <BOOL> - True if crew was set, false if problem encountered\n\nExamples:\n    (begin example)\n        [_group1,_vehicle] call KISKA_fnc_setCrew;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setCrew\";\n\nparams [\n    [\"_crew\",grpNull,[[],grpNull,objNull]],\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_deleteCrewIfNull\",true,[true]]\n];\n\nif (_crew isEqualType grpNull) then {\n    _crew = units _crew\n};\n\nif (_crew isEqualType objNull) then {\n    _crew = [_crew]\n};\n\nif (_crew isEqualTo []) exitWith {\n    [[\"Found that vehicle crew is empty, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif !(alive _vehicle) exitWith {\n    [[\"Found that \",_vehicle,\" is either null or dead already, exiting...\"]] call KISKA_fnc_log;\n\n    if (_deleteCrewIfNull) then {\n        [[\"Deleting crew of null vehicle: \",_crew]] call KISKA_fnc_log;\n        _crew apply {\n            deleteVehicle _x;\n        };\n    };\n\n    false\n};\n\n\n// crew moved in too fast after init seems to be unreliable\n// they may not end up in the vehicle\n// if this happens, delay the calling of this function slightly\n_crew apply {\n    if (alive _x) then {\n        private _movedIn = _x moveInAny _vehicle;\n\n        if !(_movedIn) then {\n            [[\"Deleted excess unit: \",_x]] call KISKA_fnc_log;\n            deleteVehicle _x\n        };\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_setCrew.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_setCrew.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_slingLoad\n\nDescription:\n    Tells AI helicopter to pick up a given object and drop it off at a given location.\n\nParameters:\n    0: _heli : <OBJECT> - Helicopter with pilot to perform slingload\n    1: _liftObject : <OBJECT> - The object to sling load\n    2: _dropOffPoint : <ARRAY, OBJECT, LOCATION, or GROUP> - Where to drop the _liftObject off at\n    3: _afterDropCode : <ARRAY, CODE, or STRING> - Code to execute after the drop off waypoint is complete.\n        This is saved to the pilot's namespace in \"KISKA_postSlingLoadCode\" which is deleted after\n        it is called. (See KISKA_fnc_callBack)\n            \n        Parmeters:\n        - 0. <OBJECT> - The pilot of the helicopter\n        - 1. <OBJECT> - The helicopter\n                \n    4: _flightPath : <(PositionASL | OBJECT | LOCATION | GROUP)[]> - An array of sequential positions\n        the aircraft must travel prior to droping off the _liftObject\n\nReturns:\n    <ARRAY> -\n        0: <OBJECT> - The pilot\n        1: <GROUP> - Pilot's group\n        2: <ARRAY> - Generated waypoints\n\nExamples:\n    (begin example)\n        [\n            heli,\n            someObject,\n            dropOff,\n            [\n                [heli],\n                {\n                    hint str [_this,_thisArgs]\n                }\n            ]\n        ] call KISKA_fnc_slingLoad;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_slingLoad\";\n\n// TODO: this may need to be a gradient\n#define LIMIT_SPEED_DISTANCE 200\n#define DISTANCE_STEP_SIZE 50\n#define SPEED_STEP_SIZE 5\n\nparams [\n    [\"_heli\",objNull,[objNull]],\n    [\"_liftObject\",objNull,[objNull]],\n    [\"_dropOffPoint\",objNull,[[],objNull,grpNull,locationNull]],\n    [\"_afterDropCode\",{},[[],{},\"\"]],\n    [\"_flightPath\",[],[[]]]\n];\n\n/* ----------------------------------------------------------------------------\n    Verify Params\n---------------------------------------------------------------------------- */\nif !(alive _heli) exitWith {\n    [\"_heli is not alive! Exiting...\", true] call KISKA_fnc_log;\n    []\n};\n\nprivate _pilot = currentPilot _heli;\nif !(alive _pilot) exitWith {\n    [[_heli,\"'s pilot is not alive! Exiting...\"], true] call KISKA_fnc_log;\n    []\n};\n\nif !(alive _liftObject) exitWith {\n    [\"_liftObject is dead, will not lift...\"] call KISKA_fnc_log;\n    []\n};\n\nif !(_heli canSlingLoad _liftObject) exitWith {\n    [[_heli,\" can't lift \",_liftObject], true] call KISKA_fnc_log;\n    []\n};\n\nprivate _dropOffPointIsInvalid = (\n    (_dropOffPoint isEqualTypeAny [grpNull,locationNull,objNull] AND\n    {isNull _dropOffPoint}) OR\n    (_dropOffPoint isEqualTo [])\n);\n\nif (_dropOffPointIsInvalid) exitWith {\n    [\"Invalid _dropOffPoint provided\",true] call KISKA_fnc_log;\n    []\n};\n\n\n/* ----------------------------------------------------------------------------\n    Add waypoints\n---------------------------------------------------------------------------- */\nprivate _group = group _pilot;\n[_group] call KISKA_fnc_clearWaypoints;\n\n\n/* -------------------------------------\n    Handle Speed\n------------------------------------- */\nprivate _distanceToCargo2d = _heli distance2D _liftObject;\nif (_distanceToCargo2d <= LIMIT_SPEED_DISTANCE) then {\n\n    if !([\"KISKA_limitSpeed\"] call KISKA_fnc_managedRun_isDefined) then {\n        [\n            \"KISKA_limitSpeed\",\n            {\n                params [\n                    [\"_vehicle\",objNull,[objNull]],\n                    [\"_speed\",-1,[123]]\n                ];\n                _vehicle limitSpeed _speed;\n            }\n        ] call KISKA_fnc_managedRun_updateCode;\n    };\n\n    private _speedLimit = ((_distanceToCargo2d / DISTANCE_STEP_SIZE) * SPEED_STEP_SIZE) min SPEED_STEP_SIZE;\n    private _limitSpeedId = [\n        \"KISKA_limitSpeed\",\n        [_heli,_speedLimit],\n        _heli\n    ] call KISKA_fnc_managedRun_execute;\n\n    _pilot setVariable [\"KISKA_slingLoad_limitSpeedId\",_limitSpeedId];\n};\n\n/* -------------------------------------\n    Hook cargo\n------------------------------------- */\n_pilot setVariable [\"KISKA_slingLoad_onHook\",{\n    params [\"_pilot\"];\n\n    private _heli = objectParent _pilot;\n    private _limitSpeedId = _pilot getVariable [\"KISKA_slingLoad_limitSpeedId\",-1];\n    if (_limitSpeedId >= 0) then {\n        [\n            \"KISKA_limitSpeed\",\n            // BOHEMIA BUG: wiki states that -1 will remove a speed limit, however, at least for helicopters, that does not seem to be the case\n            [_heli,999999],\n            _heli,\n            _limitSpeedId\n        ] call KISKA_fnc_managedRun_execute;\n    };\n\n    _pilot setVariable [\"KISKA_slingLoad_limitSpeedId\",nil];\n}];\n\n[\n    _group,\n    _liftObject,\n    -1,\n    \"HOOK\",\n    \"SAFE\",\n    \"BLUE\",\n    \"UNCHANGED\",\n    \"NO CHANGE\",\n    \"[this] call (this getVariable ['KISKA_slingLoad_onHook',{}]); this setVariable ['KISKA_slingLoad_onHook',nil];\"\n] call CBA_fnc_addWaypoint;\n\n\n/* -------------------------------------\n    Drop off\n------------------------------------- */\nif (_flightPath isNotEqualTo []) then {\n    _flightPath apply {\n        [\n            _group,\n            _x,\n            -1,\n            \"MOVE\"\n        ] call CBA_fnc_addWaypoint;\n    };\n};\n\n_pilot setVariable [\"KISKA_postSlingLoadCode\",_afterDropCode];\n_pilot setVariable [\"KISKA_slingLoad_onUnhook\",{\n    params [\"_pilot\"];\n\n    private _heli = objectParent _pilot;\n    private _afterDropCode = _pilot getVariable ['KISKA_postSlingLoadCode',{}]; \n    [[_pilot,_heli],_afterDropCode] call KISKA_fnc_callBack; \n\n    _pilot setVariable ['KISKA_postSlingLoadCode',nil];\n}];\n\n[\n    _group,\n    _dropOffPoint,\n    -1,\n    \"UNHOOK\",\n    \"UNCHANGED\",\n    \"NO CHANGE\",\n    \"UNCHANGED\",\n    \"NO CHANGE\",\n    \"[this] call (this getVariable ['KISKA_slingLoad_onUnhook',{}]); this setVariable ['KISKA_slingLoad_onUnhook',nil];\"\n] call CBA_fnc_addWaypoint;\n\n\n[_pilot, _group, waypoints _group];\n",
    "fileName": "fn_slingLoad.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_slingLoad.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spawn\n\nDescription:\n    Randomly spawns units on an array of positions.\n\n    PositionATL is expected and arrays can have 4 indexes with a direction for the\n     unit to face being the 4th. If no direction is specified, a random one is chosen.\n     Using an object instead of a position will result in the unit facing the same way\n     that the object is.\n\n    This is destructive on the _spawnPositions array so be sure to copy (+_spawnPositions)\n     if you need to reuse the array.\n\nParameters:\n    0: _numberOfUnits <NUMBER> - Number of units to spawn, if -1, all provided positions\n        will be filled\n    1: _numberOfUnitsPerGroup <NUMBER> - Number of units per group\n    2: _unitTypes <ARRAY> - Unit types to select randomly from (can be weighted or unweighted array)\n    3: _spawnPositions <ARRAY> - List of positions at which units will randomly spawn, the array can be positions and/or objects.\n        If given an empty array, all units will spawn at [0,0,0]\n\n    4: _canUnitsMove <BOOL> - Can units walk (optional)\n    5: _enableDynamic <BOOL> - Should the units be dynamically simmed (Optional)\n    6: _side <SIDE> - Side of units (optional)\n    7: _allowedStances <STRING[] or (STRING,NUMBER)[]> - A weighted or unweighted array of setUnitPos compatible \n     values that the units will be randomly set to (`[\"up\",0.7,\"middle\",0.3]` by default) (optional)\n\nReturns:\n    <OBJECT[]> - All units spawned by the function\n\nExamples:\n    (begin example)\n        _spawnedUnits = [2, 2, _arrayOfTypes, [[0,0,0],spawnObject]] call KISKA_fnc_spawn;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spawn\";\n\nparams [\n    [\"_numberOfUnits\",1,[1]],\n    [\"_numberOfUnitsPerGroup\",1,[1]],\n    [\"_unitTypes\",[\"O_Soldier_F\"],[[]]],\n    [\"_spawnPositions\",[],[[]]],\n\n    [\"_canUnitsMove\",false,[true]],\n    [\"_enableDynamic\",true,[true]],\n    [\"_side\",OPFOR,[sideUnknown]],\n    [\"_allowedStances\",[\"up\",0.7,\"middle\",0.3],[[]]]\n];\n\n// Verify Params\n// Is there at least on position to spawn on\nif (count _spawnPositions < 1) then {\n    for \"_i\" from 1 to _numberOfUnits do {\n        _spawnPositions pushBack [0,0,0];\n    };\n};\n\n\nif (_numberOfUnits < 0) then {\n    _numberOfUnits = count _spawnPositions;\n};\n\nif (_numberOfUnitsPerGroup < 0) then {\n    _numberOfUnitsPerGroup = _numberOfUnits;\n};\n\n// Check atleast one unit to spawn\nif (_numberOfUnits < 1) exitWith {\n    [[\"_numberOfUnits is \",_numberOfUnits,\" needs to be atleast 1. Exiting...\"],true] call KISKA_fnc_log;\n    []\n};\n\nif (_allowedStances isEqualTo []) exitWith {\n    [[\"_allowedStances is empty!\"],true] call KISKA_fnc_log;\n    []\n};\n\n// Re adjust number of units if there are not enough spawn points\nif (count _spawnPositions < _numberOfUnits) then {\n    [[\"Count of _spawnPositions is \",_spawnPositions,\" and _numberOfUnits is \",_numberOfUnits,\" ReAdjusting _numberOfUnits to _spawnPositions\"]] call KISKA_fnc_log;\n\n    _numberOfUnits = count _spawnPositions;\n};\n\n\n// filter out bad unit types\nprivate _unitTypesFiltered = [];\nprivate _weightedArray = _unitTypes isEqualTypeParams [\"\",1];\n{\n    if (_x isEqualType \"\") then {\n        if (isClass (configFile >> \"cfgVehicles\" >> _x) OR {isClass (missionConfigFile >> \"cfgVehicles\" >> _x)}) then {\n            _unitTypesFiltered pushBack _x;\n\n            if (_weightedArray) then {\n                _unitTypesFiltered pushBack (_unitTypes select (_forEachIndex + 1));\n            };\n        } else {\n            [[\"Found invalid class \",_x]] call KISKA_fnc_log;\n        };\n    };\n} forEach _unitTypes;\n\n// exit if no valid types\nif (_unitTypesFiltered isEqualTo []) exitWith {\n    [[\"Did not find any valid unit types in \",_unitTypes],true] call KISKA_fnc_log;\n    []\n};\n\n\n\n// create units\nprivate _spawnedUnits = [];\n\nprivate _numberOfGroups = ceil (_numberOfUnits/_numberOfUnitsPerGroup);\n\nprivate [\n    \"_group\",\n    \"_unit\",\n    \"_selectedSpawnPosition\",\n    \"_selectedUnitType\",\n    \"_faceDirection\",\n    \"_watchPosition\"\n];\n\nfor \"_i1\" from 1 to _numberOfGroups do {\n    // create group\n    _group = createGroup [_side,true];\n    _group setCombatMode \"RED\";\n\n    // create units for group\n    for \"_i2\" from 1 to _numberOfUnitsPerGroup do {\n        // check if number of units requested have been created\n        if ((count _spawnedUnits) isEqualTo _numberOfUnits) then {break};\n\n        _selectedSpawnPosition = [_spawnPositions] call KISKA_fnc_deleteRandomIndex;\n\n        // get unit type\n        _selectedUnitType = [_unitTypesFiltered,\"\"] call KISKA_fnc_selectRandom;\n\n        // if spawn position includes a rotation param, set it\n        if (_selectedSpawnPosition isEqualType objNull) then {\n            _faceDirection = getDir _selectedSpawnPosition;\n\n        } else {\n            if (count _selectedSpawnPosition isEqualTo 4) then {\n                _faceDirection = _selectedSpawnPosition deleteAt 3;\n\n            } else {\n                _faceDirection = floor (random 360);\n\n            };\n\n        };\n        _watchPosition = _selectedSpawnPosition getPos [50,_faceDirection];\n\n        // create unit and make sure it was made\n        _unit = _group createUnit [_selectedUnitType,_selectedSpawnPosition,[],0,\"Can_Collide\"];\n        // units with different default sides then what was selected will not be set to the selected side without this command\n        [_unit] joinSilent _group;\n\n        doStop _unit;\n\n        _unit setDir _faceDirection;\n        _unit doWatch _watchPosition;\n\n        _unit setUnitPos ([_allowedStances,\"\"] call KISKA_fnc_selectRandom);\n        if !(_canUnitsMove) then {\n            _unit disableAI \"path\";\n        };\n\n        // make sure units don't trigger dynamic sim\n        if (_enableDynamic) then {\n            _unit triggerDynamicSimulation false;\n        };\n\n        // put unit in master array\n        if (!isNull _unit) then {\n            _spawnedUnits pushBack _unit;\n        };\n    };\n\n    // ensuring units are moved into their spawn position before\n    // enabling dynamic sin to avoid this bug\n    // https://feedback.bistudio.com/T177900\n    if (_enableDynamic) then {\n        _group enableDynamicSimulation true;\n    };\n};\n\n// add to zeus\nallCurators apply {\n    [_x,[_spawnedUnits,false]] remoteExec [\"addCuratorEditableObjects\",2];\n};\n\n[[\"Spawned \",(count _spawnedUnits)],false] call KISKA_fnc_log;\n\n\n_spawnedUnits\n",
    "fileName": "fn_spawn.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_spawn.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spawnGroup\n\nDescription:\n    Spawns a group, adds to curator, and sets to aware. Based on selected unit types\n\nParameters:\n    0: _numberOfUnits <NUMBER> - Number of units to spawn\n    1: _unitTypes <ARRAY> - Unit types to select randomly from (can be weighted array)\n    2: _side <SIDE> - ...\n    3: _position <ARRAY, OBJECT, GROUP> - Position to spawn on\n    4: _enableDynamicSimulation <BOOL> - ... (optional)\n\nReturns:\n    <GROUP> - The group created by the function\n\nExamples:\n    (begin example)\n        _spawnedGroup = [4, _listOfUnitTypes, OPFOR, [0,0,0], true] call KISKA_fnc_spawnGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spawnGroup\";\n\nparams [\n    [\"_numberOfUnits\",1,[1]],\n    [\"_unitTypes\",[\"O_Soldier_F\"],[[]]],\n    [\"_side\",OPFOR,[sideUnknown]],\n    [\"_position\",[0,0,0],[objNull,grpNull,[]]],\n    [\"_enableDynamicSimulation\",true,[true]]\n];\n\n// Verify params\nif (_numberOfUnits < 1) exitWith {\n    [[\"_numberOfUnits is \",_numberOfUnits,\" needs to be atleast 1. Exiting...\"],true] call KISKA_fnc_log;\n    grpNull\n};\n\n// filter out bad unit types\nprivate _unitTypesFiltered = [];\nprivate _weightedArray = _unitTypes isEqualTypeParams [\"\",1];\n{\n    if (_x isEqualType \"\") then {\n        if (isClass (configFile >> \"cfgVehicles\" >> _x) OR {isClass (missionConfigFile >> \"cfgVehicles\" >> _x)}) then {\n            _unitTypesFiltered pushBack _x;\n\n            if (_weightedArray) then {\n                _unitTypesFiltered pushBack (_unitTypes select (_forEachIndex + 1));\n            };\n        } else {\n            [[\"Found invalid class \",_x]] call KISKA_fnc_log;\n        };\n    };\n} forEach _unitTypes;\n\nif (_unitTypesFiltered isEqualTo []) exitWith {\n    [[\"Did not find any valid unit types in \",_unitTypes],true] call KISKA_fnc_log;\n    grpNull\n};\n\n\n// create units\nprivate _group = createGroup [_side,true];\n\nfor \"_i\" from 1 to _numberOfUnits do {\n    private _selectedUnitType = [_unitTypesFiltered,\"\"] call KISKA_fnc_selectRandom;\n    private _unit = _group createUnit [_selectedUnitType,_position,[],5,\"NONE\"];\n\n    [_unit] joinSilent _group;\n    _unit triggerDynamicSimulation false;\n\n    if (_i isEqualTo 1) then {_unit setUnitRank \"LIEUTENANT\"; continue;};\n    if (_i isEqualTo 2) then {_unit setUnitRank \"SERGEANT\"};\n};\n\n_group setCombatBehaviour \"AWARE\";\n_group setCombatMode \"RED\";\n\nprivate _spawnedUnits = units _group;\nallCurators apply {\n    [_x,[_spawnedUnits,false]] remoteExec [\"addCuratorEditableObjects\",2];\n};\n\nif (_enableDynamicSimulation) then {\n    _group enableDynamicSimulation true;\n};\n\n\n_group\n",
    "fileName": "fn_spawnGroup.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_spawnGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spawnVehicle\n\nDescription:\n    A slightly altered/optimized version of `BIS_fnc_spawnVehicle`.\n\n    Has support for CUP aircraft to spawn at velocity.\n\nParameters:\n    0: _spawnPosition <PositionASL[] or OBJECT> - Where the vehicle should spawn.\n    1: _spawnDirection <NUMBER> - The direction the vehicle is facing when created (relative to north)\n        if `_spawnPosition` is an object and `_spawnDirection == -1`, `_spawnDirection` will be set to the\n        direction of the `_spawnPosition` object\n    2: _vehicleClass <STRING> - The `typeOf` vehicle to spawn\n    3: _group <SIDE or GROUP> - Either the side to create a group on or an\n        already existing group to add the units to\n    4: _crewInstructions <(STRING | OBJECT)[]> - An array of classnames of unit types and/or man objects\n        for the crew. Units are moved into the vehicle using moveInAny in the order provided\n    5: _deleteOverflow <BOOL> - Delete any units from _crewInstructions that prexisted if they don't fit in the vehicle\n\nReturns:\n    <[OBJECT,OBJECT[],GROUP]> -\n    - 0: <OBJECT> - The created vehicle\n    - 1: <OBJECT[]> - The vehicle crew (if soldier type, it will be the same as created vehicle)\n    - 2: <GROUP> -  The group the crew is a part of\n\nExamples:\n    (begin example)\n        [player,0,\"someclass\"] call KISKA_fnc_spawnVehicle;\n    (end)\n\nAuthor(s):\n    Joris-Jan van 't Land,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spawnVehicle\";\n\nparams [\n    [\"_spawnPosition\",[0,0,0],[[],objNull],3],\n    [\"_spawnDirection\",0,[123]],\n    [\"_vehicleClass\",\"\",[\"\"]],\n    [\"_group\",BLUFOR,[sideUnknown,grpNull]],\n    [\"_crewInstructions\",[], [[]]],\n    [\"_deleteOverflow\",true,[true]]\n];\n\nprivate _positionIsObject = _spawnPosition isEqualType objNull;\nif (_positionIsObject AND {isNull _spawnPosition}) exitWith {\n    [\"_spawnPosition is null object!\",true] call KISKA_fnc_log;\n    []\n};\n\n\nif (_vehicleClass isEqualTo \"\") exitWith {\n    [\"_vehicleClass is empty string, exiting...\",true] call KISKA_fnc_log;\n    []\n};\n\nif (_group isEqualType grpNull AND {isNull _group}) exitWith {\n    [[\"Tried to spawn class: \",_vehicleClass,\" but the _group is type GROUP and the group is null, exiting...\"],true] call KISKA_fnc_log;\n    []\n};\n\nif (_positionIsObject AND (_spawnDirection isEqualTo -1)) then {\n    _spawnDirection = getDir _spawnPosition;\n};\n\nif (_positionIsObject) then { _spawnPosition = getPosASL _spawnPosition };\n\n// make a group if side is provided\nprivate _createdNewGroup = false;\nif (_group isEqualType sideEnemy) then {\n    _group = createGroup _group;\n    _createdNewGroup = true;\n};\n\n\n// determine vehicle type and then adjust creation params for it\n// e.g. spawn some vehicles in the air\nprivate _simulationType = getText(configFile >> \"CfgVehicles\" >> _vehicleClass >> \"simulation\");\nprivate \"_createdVehicle\";\nswitch (toLowerANSI _simulationType) do {\n    case \"soldier\": {\n        _createdVehicle = _group createunit [_vehicleClass,ASLToATL _spawnPosition,[],0,\"NONE\"];\n        // units have a tendency to still not be a part of an existing group with createUnit\n        if !(_createdNewGroup) then {\n            [_createdVehicle] joinSilent _group\n        };\n    };\n    case \"airplanex\";\n    case \"airplane\"; // CUP planes do not use airplaneX\n    case \"helicopterrtd\";\n    case \"helicopter\";\n    case \"helicopterx\": {\n        _createdVehicle = createVehicle [_vehicleClass,ASLToAGL _spawnPosition,[],0,\"FLY\"];\n    };\n    default {\n        _createdVehicle = createvehicle [_vehicleClass,ASLToATL _spawnPosition,[],0,\"NONE\"];\n    };\n};\n\n_createdVehicle setPosASL _spawnPosition;\n_createdVehicle setDir _spawnDirection;\n\nprivate _crew = [];\n// soldiers do not need anymore handling\nif (_simulationType == \"soldier\") exitWith {\n    _crew pushBack _createdVehicle;\n    [_createdVehicle, _crew, _group]\n};\n\n\n// Set plane velocity straight ahead so they don't crash\nif (_simulationType == \"airplanex\" OR {_simulationType == \"airplane\"}) then {\n    _createdVehicle setVelocityModelSpace [0,100,0];\n};\n\n// Spawn the crew and add the vehicle to the group\nif (_crewInstructions isEqualTo []) then {\n    createvehiclecrew _createdVehicle;\n    _crew = crew _createdVehicle;\n\n} else {\n    private _movedIn = false;\n    private \"_unit\";\n    _crewInstructions apply {\n        if (_x isEqualType objNull) then {\n            _unit = _x;\n        } else {\n            _unit = _group createunit [_x,[0,0,0],[],0,\"NONE\"];\n        };\n\n        _movedIn = _unit moveInAny _createdVehicle;\n        if (!_movedIn) then {\n            [\n                [\n                    \"Unit \",\n                    _unit,\n                    \" could not be moved into the vehicle \",\n                    _createdVehicle,\n                    \" as there was no room in the vehicle\"\n                ],\n                true\n            ] call KISKA_fnc_log;\n            \n            if (_deleteOverflow) then {\n                deleteVehicle _unit;\n            };\n\n        } else {\n            _crew pushBack _unit;\n        };\n    };\n\n};\n\n_crew joinsilent _group;\n_group addVehicle _createdVehicle;\n\n// If this is a new group, select a leader\nif (_createdNewGroup) then {\n    _group selectLeader (commander _createdVehicle);\n};\n\n\n[_createdVehicle, _crew, _group]\n",
    "fileName": "fn_spawnVehicle.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_spawnVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stalk\n\nDescription:\n    Rewrite of BIS_fnc_stalk for optimizations and features.\n    One provided group will continually be provided waypoints to another group's\n     positions providing a \"stalking\" affect.\n\nParameters:\n    0: _stalkerGroup <GROUP or OBJECT> - The group to do the stalking\n    1: _stalked <GROUP or OBJECT> - The group or unit to be stalked, if group is used, \n        the leader will be stalked until every unit in the group is dead\n    2: _refreshInterval <NUMBER> - How often the _stalkerGroup will have their waypoint\n        updated with the position of the _stalkedGroup, and how often to check the _conditionToEndStalking\n    3: _postStalking <STRING, ARRAY, or CODE> - Code that after stalking is complete\n        will be executed. (See KISKA_fnc_callBack _callBackFunction parameter)\n    4: _conditionToEndStalking <STRING, ARRAY, or CODE> - Code that (if returns true)\n        can end the stalking. (See KISKA_fnc_callBack _callBackFunction parameter).\n        The stalking will automatically end if all units in one or both groups end\n        up dead.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            someGroup,\n            group player,\n            15,\n            {hint str _this},\n            {false}\n        ] spawn KISKA_fnc_stalk\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stalk\";\n\n\nif !(canSuspend) exitWith {\n    [\"Must be run in scheduled environment. Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_stalk;\n};\n\n\nparams [\n    [\"_stalkerGroup\",grpNull,[objNull,grpNull]],\n    [\"_stalked\",grpNull,[objNull,grpNull]],\n    [\"_refreshInterval\",25,[123]],\n    [\"_postStalking\",{},[[],{},\"\"]],\n    [\"_conditionToEndStalking\",{false},[[],{},\"\"]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    Parameter verification\n---------------------------------------------------------------------------- */\nif (isNull _stalkerGroup) exitWith {\n    [\"_stalkerGroup is null! Exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _stalkingGroup = false;\nif (_stalked isEqualType grpNull) then {\n    _stalked = leader _stalked;\n    _stalkingGroup = true;\n};\nif (isNull _stalked) exitWith {\n    [[_stalkerGroup,\" was asked to stalk a null entity! Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_refreshInterval < 5) then {\n    [\"_refreshInterval was less than 5, adjusting to 5\",false] call KISKA_fnc_log;\n    _refreshInterval = 5;\n};\n\nif (_stalkerGroup isEqualType objNull) then {\n    _stalkerGroup = group _stalkerGroup;\n};\n\nprivate _entityCurrentlyStalking = _stalkerGroup getVariable [\"KISKA_stalkingThis\",objNull];\nif !(isNull _entityCurrentlyStalking) exitWith {\n    [\n        [\n            _stalkerGroup,\n            \" is already stalking the entity \",\n            _entityCurrentlyStalking,\n            \" and cannot stalk multiple ones\"\n        ]\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Main loop\n---------------------------------------------------------------------------- */\n_stalkerGroup setVariable [\"KISKA_stalkingThis\",_stalked];\n\nprivate _stalkedGroup = group _stalked;\nprivate _stalkedIsAlive = alive _stalked;\nwhile {\n    ([_stalkerGroup] call KISKA_fnc_isGroupAlive) AND \n    {\n        if (_stalkingGroup) exitWith {\n            [_stalkedGroup] call KISKA_fnc_isGroupAlive\n        };\n\n        _stalkedIsAlive\n    }\n} do {\n    [_stalkerGroup] call KISKA_fnc_clearWaypoints;\n\n    // waypoints don't work great for buildings, move command in close will have them\n    // got up stairs and get on top of enemies\n    private _stalkerGroupLeader = leader _stalkerGroup;\n    private _distance2DBetweenGroups = _stalkerGroupLeader distance2D _stalked;\n    if (_distance2DBetweenGroups > 50) then {\n        [_stalkerGroup, _stalked, 25, \"MOVE\", \"AWARE\", \"YELLOW\", \"FULL\"] call CBA_fnc_addWaypoint;\n    } else {\n        // if not slept before and remoteExecCalled (not just remoteExec'd) unit will just stand still\n        sleep 0.5;\n        [_stalkerGroupLeader, (getPosATL _stalked)] remoteExecCall [\"move\", _stalkerGroupLeader];\n    };\n\n    private _conditionMet = [\n        [_stalkerGroup,_stalked],\n        _conditionToEndStalking\n    ] call KISKA_fnc_callBack;\n    if (_conditionMet) then {break};\n\n\n    sleep _refreshInterval;\n\n    _stalkedIsAlive = alive _stalked;\n    if (_stalkingGroup AND (!_stalkedIsAlive)) then {\n        _stalked = leader _stalkedGroup;\n        _stalkerGroup setVariable [\"KISKA_stalkingThis\",_stalked];\n    };\n};\n\n/* ----------------------------------------------------------------------------\n    Post\n---------------------------------------------------------------------------- */\nif !(isNull _stalkerGroup) then {\n    _stalkerGroup setVariable [\"KISKA_stalkingThis\",nil];\n    (units _stalkerGroup) apply {\n        [_x,objNull] remoteExec [\"commandTarget\",_x];\n    };\n    [_stalkerGroup] call KISKA_fnc_clearWaypoints;\n};\n\n\n[\n    [_stalkerGroup,_stalked,_stalkedGroup],\n    _postStalking\n] call KISKA_fnc_callBack;\n\n\nnil\n",
    "fileName": "fn_stalk.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_stalk.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_vlsFireAt\n\nDescription:\n    Orders VLS to fire at a target. Projectile will follow terrain.\n\nParameters:\n    0: _launcher <OBJECT> - The VLS launcher to have the missile originate from\n    1: _target <OBJECT or ARRAY> - Target to hit missile with, can also be a position (AGL)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [VLS_1,target_1] call KISKA_fnc_vlsFireAt;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_vlsFireAt\";\n\n#define VLS_WEAPON \"weapon_vls_01\"\n#define VLS_CLASS \"B_Ship_MRLS_01_F\"\n#define DUMMY_TARGET_CLASS \"Sign_Arrow_Large_Blue_F\"\n\nparams [\n    [\"_launcher\",objNull,[objNull]],\n    [\"_target\",objNull,[objNull,[]]]\n];\n\n// verify Params\nif (isNull _launcher) exitWith {\n    [[\"Found that _launcher \",_launcher,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\nif !(_launcher isKindOf VLS_CLASS) exitWith {\n    [[typeOf _launcher,\" is not a kind of of B_Ship_MRLS_01_F. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\nif !(local _launcher) exitWith {\n    [[\"Launcher: \",_launcher,\" is not local to the this machine!\"],true] call KISKA_fnc_log;\n    nil\n};\nif ((_target isEqualType objNull) AND {isNull _target}) exitWith {\n    [[\"Found that _target \",_target,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n// _target is position, create a logic to fire at\nif (_target isEqualType []) then {\n    private _targetPosition = _target;\n    _target = DUMMY_TARGET_CLASS createVehicle [0,0,0];\n\n    [_target] remoteExecCall [\"hideObjectGlobal\",2];\n    _target setPosASL (AGLToASL _targetPosition);\n\n    [\n        _launcher,\n        \"fired\",\n        {\n            params [\"_launcher\", \"\", \"\", \"\", \"\", \"\", \"_projectile\"];\n            _thisArgs params [\"_target\"];\n\n            [\n                [[_projectile],{\n                    _thisArgs params [\"_projectile\"];\n                    !(alive _projectile)\n                }],\n                [[_target],{\n                    _thisArgs params [\"_target\"];\n                    deleteVehicle _target;\n                }],\n                5\n            ] call KISKA_fnc_waitUntil;\n\n            _launcher removeEventHandler [\"fired\", _thisID];\n        },\n        [_target]\n    ] call CBA_fnc_addBISEventHandler;\n};\n\n// check if vehicle can recieve remote targets\nif !(vehicleReceiveRemoteTargets _launcher) then {\n    _launcher setVehicleReceiveRemoteTargets true;\n    // return to state\n    [\n        {(_this select 0) setVehicleReceiveRemoteTargets false},\n        [_launcher],\n        3\n    ] call CBA_fnc_waitAndExecute;\n};\n\nprivate _side = side _launcher;\n_side reportRemoteTarget [_target, 2];\n_target confirmSensorTarget [_side, true];\n_launcher fireAtTarget [_target, VLS_WEAPON];\n",
    "fileName": "fn_vlsFireAt.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/AI/fn_vlsFireAt.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim\n\nDescription:\n    Provides an updated version of BIS_fnc_ambientAnim in a tighter package that\n     allows for more customization.\n\nParameters:\n    0: _units <OBJECT[] or OBJECT> - An array of units or a single unit to animate\n    1: _animationParams <HASHMAP, STRING[], (STRING,NUMBER)[], or STRING> - This can be three things:\n        \n        - If a string, a single animation set that is located in the `_animationMap`\n        - If an array, you can have weighted or unweighted array of strings that are random animation sets to select from\n        - lastly, you can have a HASHMAP setup for snap to animations:\n         \n            - `_animSet` <STRING[], (STRING,NUMBER)[], or STRING> - A single snapto animation set or weighted/unweighted array to randomly select from.\n            - `_snapToRange` <NUMBER> - This is how far will be searched around the unit to find an object to \"snap\" onto. Cannot be more then 10m.\n            - `_backupAnims` <STRING[], (STRING,NUMBER)[], or STRING> - Same as `_animSet` but for animations to use in the even that \n            ALL of the `_animSet` animations fail to be used due to valid objects not being within range.\n            - `_fallbackFunction` <CODE, ARRAY, or STRING> - (See `KISKA_fnc_callBack`) In the event that\n            a unit is not able to find an object to snap to AND no _backupAnims are present, this function will be called with the\n            following params. If you still want the unit to be animated in this case, pass `{}`, `\"\"`, or `[]`\n                \n                - 0: _unit <OBJECT> - The unit\n                - 1: _animationParams <STRING[], (STRING,NUMBER)[], or STRING>\n                - 2: _exitOnCombat <BOOL>\n                - 3: _equipmentLevel <STRING[], (STRING,NUMBER)[], or STRING>\n                - 4: _animationMap <HASHMAP or CONFIG>\n\n    2: _exitOnCombat <BOOL> - Whether or not units will stop ambient animations upon detecting an enemy.\n    3: _equipmentLevel <ARRAY or STRING> - A quick means of temporarily adjusting a unit's equipment to match a scene. Options:\n        \n        - \"\": no changes\n        - \"NONE\": no goggles, headgear, vest, weapon, nvgs, backpack\n        - \"LIGHT\": no goggles, headgear, vest, backpack\n        - \"MEDIUM\": no goggles, headgear\n        - \"FULL\": no goggles\n\n    4: _animationMap <HASHMAP or CONFIG> - See KISKA_fnc_ambientAnim_createMapFromConfig\n        This is a hashmap that will searched for information for a specific _animSet\n        A config can be passed and will be parsed/cached.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // exits on combat\n        [\n            someUnit,\n            \"SIT_GROUND_ARMED\",\n            true\n        ] call KISKA_fnc_ambientAnim;\n    (end)\n\n    (begin example)\n        // use animation set SIT_CHAIR_ARMED_2 and snap\n        // to objects within 10 meters of unit's position\n        // if no objects that are snappable for SIT_CHAIR_ARMED_2\n        // are found, unit will use SIT_GROUND_ARMED animation set\n        [\n            someUnit,\n            createHashMapFromArray [\n                [\"_animSet\", \"SIT_CHAIR_ARMED_2\"],\n                [\"_snapToRange\", 10],\n                [\"_backupAnims\",\"SIT_GROUND_ARMED\"]\n            ]\n        ] call KISKA_fnc_ambientAnim;\n    (end)\n\n    (begin example)\n        // STAND_UNARMED_3 is 10x more likely to be used than STAND_ARMED_1\n        [\n            someUnit,\n            [\n                \"STAND_ARMED_1\",1,\n                \"STAND_UNARMED_3\",10\n            ]\n        ] call KISKA_fnc_ambientAnim;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim\";\n// TODO: handle remote units being passed\n// TODO: Add supplemental animation sets by using polpox animation viewer\n// TODO: Add LEAN_ON_TABLE animation set\n#define DEFAULT_ANIMATION_MAP (configFile >> \"KISKA_AmbientAnimations\" >> \"DefaultAnimationMap\")\nprivate _HASHMAP_TYPE = createHashMap;\n\nparams [\n    [\"_units\",objNull,[[],objNull]],\n    [\"_animationParams\",\"\",[\"\",[],_HASHMAP_TYPE]],\n    [\"_exitOnCombat\",false,[true]],\n    [\"_equipmentLevel\",\"\",[\"\",[]]],\n    [\"_animationMap\",DEFAULT_ANIMATION_MAP,[_HASHMAP_TYPE,configNull]]\n];\n\n\nprivate [\"_fallbackFunction\",\"_snapToRange\",\"_animSet\",\"_backupAnims\"];\nprivate _fallbackFunctionIsPresent = false;\nprivate _isSnapAnimations = _animationParams isEqualType _HASHMAP_TYPE;\nprivate _parsedSnapToMapErrors = [];\n\nif !(_isSnapAnimations) then {\n    _animSet = _animationParams;\n\n} else {\n    _animSet = _animationParams getOrDefault [\"_animSet\",\"\"];\n    if !(_animSet isEqualTypeAny [\"\",[]]) then {\n        _parsedSnapToMapErrors pushBack ((str _animSet) + \" is not a valid type for _animSet (STRING or ARRAY)\");\n    };\n\n    _snapToRange = _animationParams getOrDefault [\"_snapToRange\",5];\n    if !(_snapToRange isEqualType 123) then {\n        _parsedSnapToMapErrors pushBack ((str _snapToRange) + \" is not a valid type for _snapToRange (NUMBER)\");\n    };\n\n    _backupAnims = _animationParams getOrDefault [\"_backupAnims\",\"\"];\n    if !(_backupAnims isEqualTypeAny [\"\",[]]) then {\n        _parsedSnapToMapErrors pushBack ((str _backupAnims) + \" is not a valid type for _backupAnims (STRING or ARRAY)\");\n    };\n\n    _fallbackFunction = _animationParams getOrDefault [\"_fallbackFunction\",{}];\n    if !(_fallbackFunction isEqualTypeAny [\"\",{},[]]) then {\n        _parsedSnapToMapErrors pushBack ((str _fallbackFunction) + \" is not a valid type for _fallbackFunction (STRING, CODE, or ARRAY)\");\n    };\n\n\n\n    if (_parsedSnapToMapErrors isNotEqualTo []) exitWith {};\n    \n    if (_snapToRange > 10) then { _snapToRange = 10 };\n    _fallbackFunctionIsPresent = _fallbackFunction isNotEqualTo {} AND\n        _fallbackFunction isNotEqualTo [] AND\n        _fallbackFunction isNotEqualTo \"\";\n};\n\n\n/* ----------------------------------------------------------------------------\n\n    Verify params\n\n---------------------------------------------------------------------------- */\nif (_parsedSnapToMapErrors isNotEqualTo []) exitWith {\n    [[\"Errors with snap animation map:\",_parsedSnapToMapErrors]] call KISKA_fnc_log;\n    nil\n};\n\nif (_units isEqualTo []) exitWith {\n    [\"Empty _units array passed!\", true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _isObject = _units isEqualType objNull;\nif (_isObject AND {isNull _units}) exitWith {\n    [\"Null unit passed\", true] call KISKA_fnc_log;\n    nil\n};\n\nif (_isObject) then {\n    _units = [_units];\n};\n\nprivate _animationMapIsConfig = _animationMap isEqualType configNull;\nif (_animationMapIsConfig AND {isNull _animationMap}) exitWith {\n    [\"_animationMap is null config!\", true] call KISKA_fnc_log;\n    nil\n};\n\nif (_animationMapIsConfig) then {\n    _animationMap = [_animationMap] call KISKA_fnc_ambientAnim_createMapFromConfig;\n};\n\n\nprivate _setsToVerify = _animSet;\nprivate _isWeightedAnimSet = _animSet isEqualTypeParams [\"\",123];\nif !(_animSet isEqualType []) then {\n    _setsToVerify = [_animSet];\n    if (_isSnapAnimations) then {\n        _animSet = _setsToVerify;\n    };\n};\n\nprivate _invalidSets = [];\n{\n    if (_isWeightedAnimSet) then {\n        private _isWeightIndex = (_forEachIndex mod 2) isNotEqualTo 0;\n        if ((_x isEqualType 123) AND _isWeightIndex) then {continue};\n    };\n\n    private _animationSetInfo = _animationMap getOrDefault [_x,[]] ;\n    if (_animationSetInfo isEqualTo []) then {\n        _invalidSets pushBack _x;\n        continue;\n    };\n\n    if (!_isSnapAnimations) then {continue};\n\n    if (_animationSetInfo getOrDefault [\"snapToObjectsMap\",[]] isEqualTo []) then {\n        _invalidSets pushBack (_x + \":snapToObjectsMap_empty\");\n    };\n} forEach _setsToVerify;\n\n\nif (count _invalidSets > 0) exitWith {\n    [[\"Invalid animation set(s) passed: \",_invalidSets],true] call KISKA_fnc_log;\n    nil\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\n    Helper functions\n\n---------------------------------------------------------------------------- */\n\n/* -------------------------------------\n    _fn_getSetupInfoWithoutSnap\n------------------------------------- */\nprivate _fn_getSetupInfoWithoutSnap = {\n    params [\"_animSetToSelectFrom\"];\n\n    private _animSetSelection = _animSetToSelectFrom;\n    if (_animSetToSelectFrom isEqualType []) then {\n        _animSetSelection = [_animSetToSelectFrom,\"\"] call KISKA_fnc_selectRandom;\n    };\n\n    private _animationSetInfo = _animationMap get _animSetSelection;\n    if (isNil \"_animationSetInfo\") exitWith {\n        [\n            [\"Could not find animation set for: \",_animSetSelection,\" inside map: \",_animationMap],\n            true\n        ] call KISKA_fnc_log;\n\n        []\n    };\n\n    \n    [false, _animationSetInfo]\n};\n\n\n/* -------------------------------------\n    _fn_findObjectToSnapTo\n------------------------------------- */\nprivate _fn_findObjectToSnapTo = {\n    params [\"_snapToObjectsMap\",\"_objectsToCheck\"];\n    \n    private _snapToObjectTypes = keys _snapToObjectsMap;\n    private _snapToObjectInfo = [];\n    _objectsToCheck apply {\n        private _objectType = toLowerANSI (typeOf _x);\n        private _snapToObjectMapKey = _objectType;\n        private _objectInUse = !(isNull (_x getVariable [\"KISKA_ambientAnim_objectUsedBy\",objNull]));\n        if (_objectInUse) then { continue };\n        \n        private \"_objectToSnapTo\";\n        if (_objectType in _snapToObjectTypes) then { \n            _objectToSnapTo = _x;\n\n        } else {\n            private _parentTypeIndex = _snapToObjectTypes findIf {\n                _objectType isKindOf _x;\n            };\n            private _objectNotSupportedForAnimationSet = _parentTypeIndex isEqualTo -1;\n            if (_objectNotSupportedForAnimationSet) then { continue };\n            \n            _objectType = _snapToObjectTypes select _parentTypeIndex;\n            _objectToSnapTo = _x;\n\n        };\n\n\n        private _vehicleConfigSnapAllowance = configFile >> \"CfgVehicles\" >> _objectType >> \"KISKA_AmbientAnimations\" >> \"snapAllowance\";\n        private _configedSnapAllowance = getNumber(_vehicleConfigSnapAllowance);\n        private _allowanceNotConfigedInMainConfig = _configedSnapAllowance isEqualTo 0;\n\n        if (_allowanceNotConfigedInMainConfig) then {\n            private _objectKiskaAnimationConfig = [\n                [\"KISKA_AmbientAnimations\",\"ObjectSpecifics\",_objectType]\n            ] call KISKA_fnc_findConfigAny;\n            if (isNull _objectKiskaAnimationConfig) exitWith {};\n\n            _configedSnapAllowance = getNumber(_objectKiskaAnimationConfig >> \"snapAllowance\");\n        };\n\n        private _hasSnapAllowance = _configedSnapAllowance > 1;\n        private _snapAllowanceInfo = [];\n\n        if (_hasSnapAllowance) then {\n            private _usedSnapIds = _x getVariable [\"KISKA_ambientAnim_usedSnapIds\",[]];\n            if ((count _usedSnapIds) >= _configedSnapAllowance) then { continue };\n\n            private _objectSnapPointsHashMap = _snapToObjectsMap get _snapToObjectMapKey;\n            {\n                if (_x in _usedSnapIds) then { continue };\n\n                if (_x isEqualType []) then { \n                    private _someIdsAlreadyBeingUsed = (_x arrayIntersect _usedSnapIds) isNotEqualTo [];\n                    if (_someIdsAlreadyBeingUsed) then { continue };\n                };\n\n                _snapAllowanceInfo pushBack _x;\n                _snapAllowanceInfo pushBack _y;\n            } forEach _objectSnapPointsHashMap;\n        };\n        \n        _snapToObjectInfo pushBack _objectType;\n        _snapToObjectInfo pushBack _objectToSnapTo;\n        if (_snapAllowanceInfo isNotEqualTo []) then {\n            _snapToObjectInfo pushBack _snapAllowanceInfo;\n        };\n\n        break;\n    };\n\n\n    _snapToObjectInfo\n};\n\n\n/* -------------------------------------\n    _fn_handleNoSnap\n------------------------------------- */\nprivate _fn_handleNoSnap = {\n    params [\"_unit\",\"_backupAnims\"];\n\n    private _backupAnimsIsDefined = (_backupAnims isNotEqualTo []) AND (_backupAnims isNotEqualTo \"\");\n    if (_backupAnimsIsDefined) exitWith {\n        [_backupAnims] call _fn_getSetupInfoWithoutSnap\n    };\n\n    // empty _setupInfo return\n    if (!_fallbackFunctionIsPresent) exitWith { [] };\n    [\n        [\n            _unit, \n            _animationParams,\n            _exitOnCombat,\n            _equipmentLevel,\n            _animationMap\n        ],\n        _fallbackFunction\n    ] call KISKA_fnc_callBack;\n\n    // empty _setupInfo\n    []\n};\n\n\n/* -------------------------------------\n    _fn_getSetupInfoWithSnap\n------------------------------------- */\n// TODO:\n// accept that only one set can be be tried from the primary\n// Try extremely hard to dynamically exclude sets from the array (the array can be weighted)\n// shuffle the entire array each time and loop through every set (this would also be hard with weighted arrays)\n// delete one random entry at a time and eventually make the array anew\nprivate _fn_getSetupInfoWithSnap = {\n    params [\"_unit\",\"_animSetToSelectFrom\",\"_backupAnims\"];\n\n    // using nearObjects to support snapping to simple objects\n    private _nearObjects = _unit nearObjects _snapToRange;\n    if (_nearObjects isEqualTo []) exitWith {\n        [[\"There are no near objects to snap to for unit: \",_unit]] call KISKA_fnc_log;\n        [_unit, _backupAnims] call _fn_handleNoSnap\n    };  \n\n\n    private [\"_animSetSelection\",\"_snapToObjectsMap\",\"_animationSetInfoFromSetup\",\"_objectToSnapTo\"];\n    private _snapIdsToUse = -1;\n    private _snapObjectFound = false;\n    private _snapToObjectInfo = [];\n    private _checkedAnimSets = [];\n    private _step = [1,2] select _isWeightedAnimSet;\n    for \"_i\" from 1 to (count _animSetToSelectFrom) step _step do { \n        if (_isWeightedAnimSet) then {\n            _animSetSelection = [_animSetToSelectFrom,\"\"] call KISKA_fnc_selectRandom;\n            private _indexOfSelectedAnim = _animSetToSelectFrom find _animSetSelection;\n            _animSetToSelectFrom deleteAt _indexOfSelectedAnim;\n            _checkedAnimSets pushBack _animSetSelection;\n            \n            // previous deleteAt will shift the weight into the anim's former index\n            private _animWeight = _animSetToSelectFrom deleteAt _indexOfSelectedAnim;\n            _checkedAnimSets pushBack _animWeight;\n\n        } else {\n            _animSetSelection = [_animSetToSelectFrom] call KISKA_fnc_deleteRandomIndex;\n            _checkedAnimSets pushBack _animSetSelection;\n\n        };\n\n        _animationSetInfoFromSetup = _animationMap get _animSetSelection;\n        _snapToObjectsMap = _animationSetInfoFromSetup get \"snapToObjectsMap\";        \n        // loop\n        _snapToObjectInfo = [_snapToObjectsMap, _nearObjects] call _fn_findObjectToSnapTo;\n\n        _snapObjectFound = _snapToObjectInfo isNotEqualTo [];\n        if (_snapObjectFound) then { break };\n    };\n    // _animSetToSelectFrom array may be used by other units, so \"restore\" it\n    _animSetToSelectFrom append _checkedAnimSets;\n\n\n    if (!_snapObjectFound) exitWith {\n        [[\"No objects met snapping criteria for unit: \",_unit]] call KISKA_fnc_log;\n        [_unit, _backupAnims] call _fn_handleNoSnap\n    };\n\n\n    _snapToObjectInfo params [\"_objectType\",\"\",\"_snapAllowanceInfo\"];\n    _objectToSnapTo = _snapToObjectInfo param [1];\n\n    [_unit,_objectToSnapTo] remoteExecCall [\"disableCollisionWith\",_unit];\n    [_objectToSnapTo,_unit] remoteExecCall [\"disableCollisionWith\",_objectToSnapTo];\n\n    if (isNil \"_snapAllowanceInfo\") then {\n        _objectToSnapTo setVariable [\"KISKA_ambientAnim_objectUsedBy\",_unit];\n        private _relativeObjectInfo = _snapToObjectsMap get _objectType;\n        [_objectToSnapTo,_unit,_relativeObjectInfo] call KISKA_fnc_setRelativeVectorAndPos;\n\n    } else {\n        private _usedSnapIds = _objectToSnapTo getVariable \"KISKA_ambientAnim_usedSnapIds\";\n        if (isNil \"_usedSnapIds\") then {\n            _usedSnapIds = [];\n            _objectToSnapTo setVariable [\"KISKA_ambientAnim_usedSnapIds\",_usedSnapIds];\n        };\n\n\n        _snapIdsToUse = _snapAllowanceInfo select 0;\n        if (_snapIdsToUse isEqualType 123) then {\n            _usedSnapIds pushBack _snapIdsToUse;\n        } else {\n            _usedSnapIds append _snapIdsToUse;\n        };\n\n        private _relativeObjectInfo = _snapAllowanceInfo select 1;\n        [_objectToSnapTo,_unit,_relativeObjectInfo] call KISKA_fnc_setRelativeVectorAndPos;\n    };\n\n\n    [true, _animationSetInfoFromSetup, _objectToSnapTo, _snapIdsToUse]\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\n    Apply Animations\n\n---------------------------------------------------------------------------- */\nprivate _randomEquipmentLevel = _equipmentLevel isEqualType [];\n_units apply {\n    private _unit = _x;\n    if !(alive _unit) then {\n        continue;\n    };\n\n    private _unitIsAnimated = !(isNil {_unit getVariable \"KISKA_ambientAnimMap\"});\n    if (_unitIsAnimated) then {\n        [_unit] call KISKA_fnc_ambientAnim_stop;\n    };\n\n    private _unitInfoMap = createHashmap;\n    detach _unit;\n    \n\n    private \"_setupInfo\";\n    if (_isSnapAnimations) then {\n        _setupInfo = [_unit,_animSet,_backupAnims] call _fn_getSetupInfoWithSnap;\n    } else {\n        _setupInfo = [_animSet] call _fn_getSetupInfoWithoutSnap;\n    };\n\n\n    if (_setupInfo isEqualTo []) then { continue };\n\n\n    _setupInfo params [\n        \"_isSnapAnim\",\n        \"_animationSetInfo\"\n    ];\n\n    _unitInfoMap set [\"_animationSetInfo\",_animationSetInfo];\n    if (_isSnapAnim) then {\n        private _objectToSnapTo = _setupInfo param [2,objNull];\n        _unitInfoMap set [\"_snapToObject\",_objectToSnapTo];\n\n        private _snapIdsToUse = _setupInfo param [3,-1];\n        if (_snapIdsToUse isNotEqualTo -1) then {\n            _unitInfoMap set [\"_usedSnapIds\",_snapIdsToUse];\n        };\n    };\n\n\n    /* --------------------------------------\n        Handle AttachTo Logic\n        // some animations (STAND_ARMED_1)\n        // will wind up stuttering if not attached to a logic.\n        // this also happens with BIS_fnc_ambientAnim.\n        // unknown why.\n\n        // This does also benefit some seated animations if required.\n    -------------------------------------- */\n    // TODO: error here, \"_animationSetInfo\" is not hashmap, but array???\n    if (_animationSetInfo getOrDefault [\"attachToLogic\",false]) then {\n        private _logicGroup = [_x] call KISKA_fnc_ambientAnim_getNearestAttachLogicGroup;\n        if (isNull _logicGroup) then {\n            _logicGroup = createGroup sideLogic;\n            _logicGroup deleteGroupWhenEmpty true;\n            _logicGroup addEventHandler [\"Deleted\",{\n                params [\"_group\"];\n                \n                private _mapId = _group getVariable [\"KISKA_ambientAnimGroup_ID\",-1];\n                if (_mapId >= 0) then {\n                    private _logicGroupsMap = call KISKA_fnc_ambientAnim_getAttachLogicGroupsMap;\n                    _logicGroupsMap deleteAt _mapId;\n                };\n            }];\n\n            [_logicGroup] call KISKA_fnc_ambientAnim_addAttachLogicGroup;\n        };\n\n        private _helper = _logicGroup createUnit [\"Logic\", [0,0,0], [], 0, \"NONE\"];\n        _helper setPosWorld (getPosWorld _unit);\n        _helper setVectorDir (vectorDir _unit);\n        _helper setVectorUp (vectorUp _unit);\n\n        _unitInfoMap set [\"_attachToLogic\",_helper];\n        _unit attachTo [_helper,[0,0,0]];\n    };\n\n\n    /* --------------------------------------\n        Handle Equipment\n    -------------------------------------- */\n    private _loadoutBeforeAnimation = getUnitLoadout _unit;\n    private _loadoutAdjusted = false;\n\n    private _removeAllWeapons = _animationSetInfo getOrDefault [\"removeAllWeapons\",false];\n    if (_removeAllWeapons) then {\n        removeAllWeapons _unit;\n        _loadoutAdjusted = true;\n        \n    } else {\n        private _removeSecondaryWeapon = _animationSetInfo getOrDefault [\"removeSecondaryWeapon\",false];\n        if (_removeSecondaryWeapon) then {\n            _unit removeWeaponGlobal (secondaryWeapon _unit);\n            _loadoutAdjusted = true;\n        };\n\n        private _removeHandgun = _animationSetInfo getOrDefault [\"removeHandgun\",false];\n        if (_removeHandgun) then {\n            _unit removeWeaponGlobal (handgunWeapon _unit);\n            _loadoutAdjusted = true;\n        };\n\n        private _removePrimaryWeapon = _animationSetInfo getOrDefault [\"removePrimaryWeapon\",false];\n        if (_removePrimaryWeapon) then {\n            _unit removeWeaponGlobal (primaryWeapon _unit);\n            _loadoutAdjusted = true;\n        };\n    };\n\n\n    private _removeBackpack = _animationSetInfo getOrDefault [\"removeBackpack\",false];\n    if (_removeBackpack) then {\n        removeBackpack _unit;\n        _loadoutAdjusted = true;\n    };\n\n    private _removeNightVision = _animationSetInfo getOrDefault [\"removeNightVison\",false];\n    if (_removeNightVision) then {\n        removeAllAssignedItems _unit;\n        _loadoutAdjusted = true;\n    };\n\n    private \"_equipmentLevelSelection\";\n    if (_randomEquipmentLevel) then {\n        _equipmentLevelSelection = [_equipmentLevel,\"\"] call KISKA_fnc_selectRandom;\n    } else {\n        _equipmentLevelSelection = _equipmentLevel;\n    };\n\n    switch (_equipmentLevelSelection) do\n    {\n        case \"NONE\":\n        {\n            removeGoggles _unit;\n            removeHeadgear _unit;\n            removeVest _unit;\n            removeAllWeapons _unit;\n            removeBackpack _unit;\n            removeAllAssignedItems _unit;\n            _loadoutAdjusted = true;\n        };\n        case \"LIGHT\":\n        {\n            removeGoggles _unit;\n            removeHeadgear _unit;\n            removeVest _unit;\n            removeBackpack _unit;\n            _loadoutAdjusted = true;\n        };\n        case \"MEDIUM\":\n        {\n            removeGoggles _unit;\n            removeHeadgear _unit;\n            _loadoutAdjusted = true;\n        };\n        case \"FULL\":\n        {\n            removeGoggles _unit;\n            _loadoutAdjusted = true;\n        };\n        default\n        {\n        };\n    };\n\n    if (_loadoutAdjusted) then {\n        _unitInfoMap set [\"_loadoutBeforeAnimation\",_loadoutBeforeAnimation];\n    };\n\n    [\"ANIM\",\"AUTOTARGET\",\"FSM\",\"MOVE\",\"TARGET\"] apply {\n        [_unit,_x] remoteExecCall [\"disableAI\",_unit];\n    };\n\n\n    private _baseJipId = \"KISKA_AmAnim_\" + (str _unit);\n    _unitInfoMap set [\"KISKA_ambientAnim_JIPId_switchMove\",(_baseJipId + \"_sm\")];\n    _unitInfoMap set [\"KISKA_ambientAnim_JIPId_playMoveNow\",(_baseJipId + \"_pmn\")];\n\n    /* --------------------------------------\n        Initial Animate\n    -------------------------------------- */\n    _unit setVariable [\"KISKA_ambientAnimMap\",_unitInfoMap];\n    [_unit] call KISKA_fnc_ambientAnim_play;\n\n\n    /* --------------------------------------\n        Add Eventhandlers\n    -------------------------------------- */\n    private _animDoneEventHandlerId = _unit addEventHandler [\"AnimDone\",\n        {\n            params [\"_unit\",\"_anim\"];\n\n            if (alive _unit) then {\n                _this call KISKA_fnc_ambientAnim_play;\n            };\n        }\n    ];\n    _unitInfoMap set [\"_animDoneEventHandlerId\",_animDoneEventHandlerId];\n\n\n    private _unitKilledEventHandlerId = _unit addEventHandler [\"KILLED\",\n        {\n            params [\"_unit\"];\n            [_unit,false] call KISKA_fnc_ambientAnim_stop;\n        }\n    ];\n    _unitInfoMap set [\"_unitKilledEventHandlerId\",_unitKilledEventHandlerId];\n\n\n    private _unitDeletedEventHandlerId = _unit addEventHandler [\"Deleted\",\n        {\n            params [\"_unit\"];\n            [_unit,true] call KISKA_fnc_ambientAnim_stop;\n        }\n    ];\n    _unitInfoMap set [\"_unitDeletedEventHandlerId\",_unitDeletedEventHandlerId];\n\n\n    if (_exitOnCombat) then {\n        private _eventHandlerConfig = [\n            \"KISKA_eventHandlers\",\n            \"Behaviour\"\n        ] call KISKA_fnc_findConfigAny;\n\n        private _behaviourEventId = [\n            _unit,\n            _eventHandlerConfig,\n            {\n                params [\"_unit\",\"_behaviour\",\"_eventHandlerConfig\"];\n\n                if (_behaviour == \"COMBAT\") then {\n                    [\n                        _unit,\n                        _eventHandlerConfig,\n                        _thisScriptedEventhandler\n                    ] call KISKA_fnc_eventHandler_remove;\n\n                    [_unit] call KISKA_fnc_ambientAnim_stop;\n                };\n            }\n        ] call KISKA_fnc_eventHandler_addFromConfig;\n\n        _unitInfoMap set [\"_behaviourEventId\",_behaviourEventId];\n    };\n\n\n};\n\n\nnil",
    "fileName": "fn_ambientAnim.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_addAttachLogicGroup\n\nDescription:\n    Adds a group to the global attachTo logics map used to store them for reference.\n\nParameters:\n    0: _logicGroup <GROUP> - The group to add\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [createGroup sideLogic] call KISKA_fnc_ambientAnim_getAttachToLogicGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_addAttachLogicGroup\";\n\nparams [\n    [\"_logicGroup\",grpNull,[grpNull]]\n];\n\nprivate _logicSide = side _logicGroup;\nif (_logicSide isNotEqualTo sideLogic) exitWith {\n    [\n        [\n            \"Group: \",\n            _logicGroup,\n            \" is not a valid side of sideLogic, it is side: \",\n            _logicSide\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\nprivate _logicGroupsMap = call KISKA_fnc_ambientAnim_getAttachLogicGroupsMap;\n\nprivate _id = [\"KISKA_ambientAnimGroup_ID\"] call KISKA_fnc_idCounter;\n_logicGroup setVariable [\"KISKA_ambientAnimGroup_ID\",_id];\n_logicGroupsMap set [_id,_logicGroup];\n\n\nnil\n",
    "fileName": "fn_ambientAnim_addAttachLogicGroup.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_addAttachLogicGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_createMapFromConfig\n\nDescription:\n    Parses a given config into a hashmap that can be used by KISKA_fnc_ambientAnim.\n    This config will then be the hashmap KISKA_ambientAnim_configAnimationSetMap\n     with the config as the key.\n\n    See configFile >> \"KISKA_AmbientAnimations\" for an example of a configed map.\n    \n    (begin config example)\n        class ambientAnimsConfig\n        {\n            class someAnimSet\n            {\n                animations[] = {\"myAnimation\"}; // the only required property of an anim set\n            };\n        };\n    (end)\n\nParameters:\n    0: _config <CONFIG> - A config to parse into a hashmap\n\nReturns:\n    <HASHMAP> - A map of the animation sets and their properties.\n\nExamples:\n    (begin example)\n        private _map = [\n            configFile >> \"KISKA_AmbientAnimations\"\n        ] call KISKA_fnc_ambientAnim_createMapFromConfig;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_createMapFromConfig\";\n\nparams [\n    [\"_config\",configNull,[configNull]]\n];\n\n\nif (isNull _config) exitWith {\n    [\"Null config passed!\",true] call KISKA_fnc_log;\n    []\n};\n\nif (isNil \"KISKA_ambientAnim_configAnimationSetMap\") then {\n    missionNamespace setVariable [\"KISKA_ambientAnim_configAnimationSetMap\",createHashMap];\n};\n\nprivate _animationMap = KISKA_ambientAnim_configAnimationSetMap getOrDefault [_config,[]];\nif (_animationMap isNotEqualTo []) exitWith {_animationMap};\n\n\nprivate _fn_getRelativeInfo = {\n    params [\"_snapToObjectClass\"];\n\n    private _relativeInfoArray = getArray(_snapToObjectClass >> \"relativeInfo\");\n    if (_relativeInfoArray isNotEqualTo []) exitWith { _relativeInfoArray };\n\n    [\n        getArray(_snapToObjectClass >> \"relativePos\"),\n        getArray(_snapToObjectClass >> \"relativeDir\"),\n        getArray(_snapToObjectClass >> \"relativeUp\")\n    ]\n};\n\nprivate _fn_parseSnapToObjectClass = {\n    params [\"_snapToObjectsConfig\"];\n    \n    private _snapToObjectClasses = configProperties [_snapToObjectsConfig,\"isClass _x\"];\n    \n    private _snapToObjects = [];\n    _snapToObjectClasses apply {\n        private _snapToObjectClass = _x;\n        private _type = toLowerANSI (getText(_snapToObjectClass >> \"type\"));\n        if (_type isEqualTo \"\") then {\n            [[\"No type found parsing relative object info for \",_snapToObjectClass],true] call KISKA_fnc_log;\n            continue;\n        };\n\n        private _snapPointClassConfigs = configProperties [_snapToObjectClass >> \"snapPoints\",\"isClass _x\"];\n        private _isNotMultiSnap = _snapPointClassConfigs isEqualTo [];\n        if (_isNotMultiSnap) then {\n            private _relativeInfo = [_snapToObjectClass] call _fn_getRelativeInfo;\n            _snapToObjects pushBack [\n                _type,\n                _relativeInfo\n            ];\n            \n            continue;\n        };\n\n\n        private _objectSnapPointsHashMap = createHashMap;\n        _snapPointClassConfigs apply {\n            private \"_snapId\";\n            \n            if (isArray(_x >> \"snapId\")) then {\n                _snapId = getArray(_x >> \"snapId\");\n\n            } else {\n                _snapId = getNumber(_x >> \"snapId\");\n                if (_snapId isEqualTo 0) then {\n                    [[\"Found invalid or nonexistent snap id in config: \",_x],true] call KISKA_fnc_log;\n                    continue;\n                };\n\n            };\n\n\n            private _relativeInfoArray = [_x] call _fn_getRelativeInfo;\n            _objectSnapPointsHashMap set [_snapId,_relativeInfoArray];\n        };\n\n        _snapToObjects pushBack [_type, _objectSnapPointsHashMap]\n\n    };\n\n    \n    _snapToObjects\n};\n\n\n_animationMap = createHashMap;\nprivate _classes = configProperties [_config, \"isClass _x\", true];\n_classes apply {\n    // map for specific animation set class\n    private _animationSetInfo = createHashMap;\n    private _animations = getArray(_x >> \"animations\");\n    if (_animations isEqualTo []) then {\n        [[\"Class: \", _x,\" did not have any animations defined and will not be parsed!\",true]] call KISKA_fnc_log;\n        continue;\n    };\n    _animationSetInfo set [\"animations\", _animations];\n\n    private _snapToObjectsConfig = _x >> \"snapToObjects\";\n\n    private _parsedSnapToObjects = [];\n    if !(isNull _snapToObjectsConfig) then {\n        if (isArray _snapToObjectsConfig) then {\n            _parsedSnapToObjects = getArray(_x >> \"snapToObjects\");\n\n        } else {\n            if (isClass _snapToObjectsConfig) then {\n                _parsedSnapToObjects = [_snapToObjectsConfig] call _fn_parseSnapToObjectClass;\n            };\n\n        };\n\n        if (_parsedSnapToObjects isNotEqualTo []) then {\n            private _snapToObjectsMap = createHashMapFromArray _parsedSnapToObjects;\n            _animationSetInfo set [\"snapToObjectsMap\", _snapToObjectsMap];\n        };\n    };\n\n    private _configClass = _x;\n    [\n        [\"removeAllWeapons\",\"removeAllWeapons\"],\n        [\"removeSecondaryWeapon\",\"removeSecondaryWeapon\"],\n        [\"removeHandgun\",\"removeHandgun\"],\n        [\"removePrimaryWeapon\",\"removePrimaryWeapon\"],\n        [\"attachToLogic\",\"attachToLogic\"],\n        [\"removeBackpack\",\"removeBackpack\"],\n        [\"removeNightVision\",\"removeNightVision\"],\n        [\"canInterpolate\",\"canInterpolate\"]\n    ] apply {\n        _x params [\"_hashMapKey\",\"_configPropertyName\"];\n        private _configValue = [_configClass >> _configPropertyName] call BIS_fnc_getCfgDataBool;\n        _animationSetInfo set [_hashMapKey,_configValue];\n    };\n\n    _animationMap set [configName _configClass, _animationSetInfo];\n};\nKISKA_ambientAnim_configAnimationSetMap set [_config, _animationMap];\n\n\n_animationMap\n",
    "fileName": "fn_ambientAnim_createMapFromConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_createMapFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_getAttachLogicGroupsMap\n\nDescription:\n    Returns the hashmap that contains all logic groups used for ambient animations.\n\n    Users can then reference all the groups with the `values` command.\n\n    A hashmap was used in order to provide a quicker means of removing entries when\n     a group is deleted as opposed to having to used the `find` command with an array.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - A hashmap containing all the logic group\n\nExamples:\n    (begin example)\n        private _map = call KISKA_fnc_ambientAnim_getAttachLogicGroupsMap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_getAttachLogicGroupsMap\";\n\nprivate _map = localNamespace getVariable \"KISKA_ambientAnim_attachLogicGroupsMap\";\nif (isNil \"_map\") then {\n    _map = createHashMap;\n    localNamespace setVariable [\"KISKA_ambientAnim_attachLogicGroupsMap\",_map];\n};\n\n\n_map\n",
    "fileName": "fn_ambientAnim_getAttachLogicGroupsMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_getAttachLogicGroupsMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_addAttachLogicGroup\n\nDescription:\n    Finds the nearest attach logic group used for ambient animations.\n\nParameters:\n    0: _position <OBJECT or Position-2D> - The position to check\n\nReturns:\n    <GROUP> - the nearest logic group used for ambient animations\n\nExamples:\n    (begin example)\n        private _group = [player] call KISKA_fnc_ambientAnim_getNearestAttachLogicGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_getNearestAttachLogicGroup\";\n\n#define RADIUS_TO_CHECK 100\n\nparams [\n    [\"_position\",[],[objNull,[]],[2,3]]\n];\n\nif ((_position isEqualType objNull) AND {isNull _position}) exitWith {\n    [\"empty array provided\",true] call KISKA_fnc_log;\n    grpNull\n};\n\nif (_position isEqualTo []) exitWith {\n    [\"empty array provided\",true] call KISKA_fnc_log;\n    grpNull\n};    \n\n\nprivate _nearestDistance = -1;\nprivate _nearest = grpNull;\n// radius is 3d for nearEntities\n(_position nearEntities [\"Logic\",RADIUS_TO_CHECK]) apply {\n    private _id = _x getVariable \"KISKA_ambientAnimGroup_ID\";\n    if (isNil \"_id\") then {continue};\n\n    private _distance = _position distance2D _x;\n    private _aNearestWasFound = !(isNull _nearest);\n    if (_aNearestWasFound AND (_distance > _nearestDistance)) then {\n        continue\n    };\n\n    _nearestDistance = _distance;\n    _nearest = _x;\n};\n\n\n_nearest\n",
    "fileName": "fn_ambientAnim_getNearestAttachLogicGroup.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_getNearestAttachLogicGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim\n\nDescription:\n    Returns whether or not a unit is currently using Kiska's ambient animation\n     system.\n\nParameters:\n    0: _unit <OBJECT> - A unit to check if they are using KISKA ambient anim system\n\nReturns:\n    <BOOL> - Whether or not the unit is using KISKA's ambient animation system\n\nExamples:\n    (begin example)\n        private _isAnimated = [someUnit] call KISKA_fnc_ambientAnim_isAnimated;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_isAnimated\";\n\nparams [\n    [\"_unit\",objNull,[objNull]]\n];\n\nif !(alive _unit) exitWith {\n    false\n};\n\nprivate _isAnimated = !(isNil {_unit getVariable \"KISKA_ambientAnimMap\"});\n\n\n_isAnimated\n",
    "fileName": "fn_ambientAnim_isAnimated.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_isAnimated.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_play\n\nDescription:\n    Starts animations for KISKA_fnc_ambientAnim.\n\n    This should not be directly called and is instead handled in events defined\n     in KISKA_fnc_ambientAnim.\n\nParameters:\n    0: _unit <OBJECT> - The unit to animate\n    1: _previousAnim <STRING> - The previous animation the unit played\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        (SHOULD NOT BE DIRECTLY CALLED)\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_play\";\n\nif (canSuspend) exitWith {\n    [\n        KISKA_fnc_ambientAnim_play,\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_previousAnim\",\"\",[\"\"]]\n];\n\nif !(alive _unit) exitWith {\n    [_unit] call KISKA_fnc_ambientAnim_stop;\n};\n\nprivate _ambientAnimInfoMap = _unit getVariable \"KISKA_ambientAnimMap\";\nif (isNil \"_ambientAnimInfoMap\") exitWith {\n    [\"Error: _ambientAnimInfoMap not found\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _animationSetInfo = _ambientAnimInfoMap get \"_animationSetInfo\";\nprivate _nearUnits = _unit nearEntities [\"man\", 5];\n_nearUnits deleteAt (_nearUnits find _unit);\n\nprivate _takenAnimations = _nearUnits apply {toLowerANSI (animationState _x)};\n_takenAnimations pushBack (toLowerANSI _previousAnim);\nprivate _setAnimations = _animationSetInfo getOrDefault [\"animations\",[]];\nprivate _animationsToUse = _setAnimations - _takenAnimations;\nif (_animationsToUse isEqualTo []) then {\n    _animationsToUse = _setAnimations;\n};\nprivate _animation = [_animationsToUse,\"\"] call KISKA_fnc_selectRandom;\n\nif (_animationSetInfo getOrDefault [\"canInterpolate\",false]) then {\n    private _jipId = _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_playMoveNow\";\n    [_unit,_animation] remoteExec [\"playMoveNow\",0,_jipId];\n\n} else {\n    // best practice to make sure an animation actually plays is to use both switchMove and playMoveNow\n    private _jipId = _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_switchMove\";\n    [_unit,_animation] remoteExec [\"switchMove\",0,_jipId];\n    \n    _jipId = _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_playMoveNow\";\n    [_unit,_animation] remoteExec [\"playMoveNow\",0,_jipId];\n\n};\n/* [[\"Play called for \", _unit,\" _previousAnim: \", _previousAnim, \" Current Anim: \",_animation]] call KISKA_fnc_log; */\n\nnil\n",
    "fileName": "fn_ambientAnim_play.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_play.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_setStoredLoadout\n\nDescription:\n    When a unit has it's loadout adjusted for an ambient animation, the loadout\n     they previously had is stored and restored after their ambient animation stops.\n\nParameters:\n    0: _unit <OBJECT> - The unit to animate\n    1: _loadout <ARRAY> - The loadout to store\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            someUnit,\n            getUnitLoadout someUnit\n        ] call KISKA_fnc_ambientAnim_setStoredLoadout;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_setStoredLoadout\";\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_loadout\",[],[[]]]\n];\n\nif (isNull _unit) exitWith {\n    [\"null unit passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _ambientAnimInfoMap = _unit getVariable \"KISKA_ambientAnimMap\";\nif (isNil \"_ambientAnimInfoMap\") exitWith {\n    [[_unit,\" does not have a KISKA_ambientAnimMap within their namespace\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_ambientAnimInfoMap set [\"_loadoutBeforeAnimation\",_loadout];\n\n\nnil\n",
    "fileName": "fn_ambientAnim_setStoredLoadout.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_setStoredLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_stop\n\nDescription:\n    Stops a unit's use of KISKA_fnc_ambientAnim and returns them to the state they\n     were in before it ran.\n\nParameters:\n    0: _unit <OBJECT> - The unit who is running KISKA ambient anims\n    1: _triggeredByDeletion <BOOL> - If this stop was initiated by the delete Eventhandler\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [someUnit] call KISKA_fnc_ambientAnim_stop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_stop\";\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_triggeredByDeletion\",false,[true]]\n];\n\nif (isNull _unit) exitWith {\n    [\"_unit is null\",false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _ambientAnimInfoMap = _unit getVariable \"KISKA_ambientAnimMap\";\nif (isNil \"_ambientAnimInfoMap\") exitWith {\n    if (!_triggeredByDeletion) then {\n        [[_unit,\" does not have a KISKA_ambientAnimMap currently in their namespace!\"],true] call KISKA_fnc_log;\n    };\n\n    nil\n};\n\n// remove JIP messages\nremoteExec [\"\", _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_switchMove\"];\nremoteExec [\"\", _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_playMoveNow\"];\n\n\ndetach _unit;\nprivate _attachToLogic = _ambientAnimInfoMap getOrDefault [\"_attachToLogic\",objNull];\nif !(isNull _attachToLogic) then {\n    deleteVehicle _attachToLogic;\n};\n\nprivate _behaviourEventId = _ambientAnimInfoMap getOrDefault [\"_behaviourEventId\",-1];\nif (_behaviourEventId >= 0) then {\n    private _eventHandlerConfig = [\n        \"KISKA_eventHandlers\",\n        \"Behaviour\"\n    ] call KISKA_fnc_findConfigAny;\n    \n    [\n        _unit,\n        _eventHandlerConfig,\n        _behaviourEventId\n    ] call KISKA_fnc_eventHandler_remove;\n};\n\nprivate _snapToObject = _ambientAnimInfoMap getOrDefault [\"_snapToObject\",objNull];\nprivate _snapObjectIsNotNull = !(isNull _snapToObject);\nif (_snapObjectIsNotNull) then {\n    _snapToObject setVariable [\"KISKA_ambientAnim_objectUsedBy\",nil];\n    private _snapIdsUsedByUnit = _ambientAnimInfoMap getOrDefault [\"_usedSnapIds\",-1];\n    if (_snapIdsUsedByUnit isEqualTo -1) exitWith {};\n    \n    \n    private _objectUsedSnapIdList = _snapToObject getVariable [\"KISKA_ambientAnim_usedSnapIds\",[]];\n    if (_snapIdsUsedByUnit isEqualType 123) exitWith {\n        _objectUsedSnapIdList deleteAt (_objectUsedSnapIdList find _snapIdsUsedByUnit);\n    };\n\n    if (_snapIdsUsedByUnit isEqualType []) exitWith {\n        _snapIdsUsedByUnit apply {\n            _objectUsedSnapIdList deleteAt (_objectUsedSnapIdList find _snapIdsUsedByUnit);\n        };\n    };\n};\n\n\nif (_triggeredByDeletion) exitWith {};\nprivate _unitDeletedEventHandlerId = _ambientAnimInfoMap get \"_unitDeletedEventHandlerId\";\n_unit removeEventHandler [\"Deleted\", _unitDeletedEventHandlerId];\n\n\nif !(alive _unit) exitWith {};\n\n\n[\"ANIM\",\"AUTOTARGET\",\"FSM\",\"MOVE\",\"TARGET\"] apply {\n    [_unit,_x] remoteExecCall [\"enableAI\",_unit];\n};\n\nprivate _animDoneEventHandlerId = _ambientAnimInfoMap get \"_animDoneEventHandlerId\";\n_unit removeEventHandler [\"AnimDone\", _animDoneEventHandlerId];\n\nprivate _unitKilledEventHandlerId = _ambientAnimInfoMap get \"_unitKilledEventHandlerId\";\n_unit removeEventHandler [\"KILLED\", _unitKilledEventHandlerId];\n\n\n_unit setVariable [\"KISKA_ambientAnimMap\",nil];\n\n\nprivate _unitLoadoutBeforeAnimation = _ambientAnimInfoMap getOrDefault [\"_loadoutBeforeAnimation\",[]];\nif (_unitLoadoutBeforeAnimation isNotEqualTo []) then {\n    _unit setUnitLoadout _unitLoadoutBeforeAnimation;\n};\n\n\nif (_snapObjectIsNotNull) then {\n    [_unit, _snapToObject] remoteExecCall [\"enableCollisionWith\", _unit];\n    [_snapToObject,_unit] remoteExecCall [\"enableCollisionWith\", _snapToObject];\n};\n\n\n[_unit,\"\"] remoteExecCall [\"KISKA_fnc_resetMove\"];\n\n\nnil\n",
    "fileName": "fn_ambientAnim_stop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Animations/fn_ambientAnim_stop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig\n\nDescription:\n    Spawns a configed KISKA base.\n\nParameters:\n    0: _baseConfig <STRING or CONFIG> - The config path of the base config or the string\n        className of a config located in `missionConfigFile >> \"KISKA_bases\"\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        private _baseMap = [\"SomeBaseConfig\"] call KISKA_fnc_bases_createFromConfig;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig\";\n\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\n\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_turrets;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_infantry;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_agents;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_patrols;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_landVehicles;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_simples;\n\n\n// return base map\n[_baseConfig] call KISKA_fnc_bases_getHashmap\n",
    "fileName": "fn_bases_createFromConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_createFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_agents\n\nDescription:\n    Spawns a configed KISKA bases' agents.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config or the string\n        className of a config located in `missionConfigFile >> \"KISKA_bases\"\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_agents;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_agents\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_agentsList = _baseMap get \"agent list\";\n\nprivate _agentsConfig = _baseConfig >> \"agents\";\nprivate _agentClasses = configProperties [_agentsConfig >> \"sets\",\"isClass _x\"];\n\n\n/* ----------------------------------------------------------------------------\n\n    Create Agents\n\n---------------------------------------------------------------------------- */\n_agentClasses apply {\n    private _agentsSetConfig = _x;\n\n    private _spawnPositions = [\n        \"spawnPositions\",\n        _agentsSetConfig,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_spawnPositions isEqualType \"\") then {\n        _spawnPositions = [_spawnPositions] call KISKA_fnc_getMissionLayerObjects;\n    };\n    if (_spawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n    _spawnPositions = [_spawnPositions] call CBA_fnc_shuffle;\n\n    private _numberOfUnits = [\n        \"numberOfUnits\", \n        _agentsSetConfig, \n        -1,\n        false,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_numberOfUnits isEqualType \"\") then {\n        _numberOfUnits = [[_agentsSetConfig,_spawnPositions],_numberOfUnits,false] call KISKA_fnc_callBack;\n    };\n\n    private _numberOfSpawns = count _spawnPositions;\n    if ((_numberOfSpawns < _numberOfUnits) OR (_numberOfUnits isEqualTo -1)) then {\n        _numberOfUnits = _numberOfSpawns;\n    };\n\n\n    private _unitClasses = [\"unitClasses\", _agentsSetConfig, []] call KISKA_fnc_bases_getPropertyValue;\n    if (_unitClasses isEqualType \"\") then {\n        _unitClasses = [[_agentsSetConfig],_unitClasses] call KISKA_fnc_callBack;\n    };\n    if (_unitClasses isEqualTo []) then {\n        [[\"Found no unitClasses to use for KISKA base class: \",_agentsSetConfig], true] call KISKA_fnc_log;\n        continue;\n    };\n\n    \n    private _side = [\"side\", _agentsSetConfig, 0] call KISKA_fnc_bases_getPropertyValue;\n    _side = _side call BIS_fnc_sideType;\n\n    private _enableDynamicSim = [\"dynamicSim\", _agentsSetConfig, true, true] call KISKA_fnc_bases_getPropertyValue;\n\n    private _agents = [];\n    for \"_i\" from 0 to (_numberOfUnits - 1) do {\n        private _spawnPosition = _spawnPositions select _i;\n        private _direction = 0;\n        if (_spawnPosition isEqualType objNull) then {\n            _direction = getDir _spawnPosition;\n        };\n        if ((_spawnPosition isEqualType []) AND {(count _spawnPosition) > 3}) then {\n            _direction = _spawnPosition deleteAt 3;\n        };\n\n        private _agent = createAgent [\n            [_unitClasses,\"\"] call KISKA_fnc_selectRandom,\n            _spawnPosition,\n            [],\n            0,\n            \"CAN_COLLIDE\"\n        ];\n\n        _agent enableDynamicSimulation _enableDynamicSim;\n        _agent setDir _direction;\n        _agents pushBack _agent;\n    };\n\n    [_agentsSetConfig,_agents] call KISKA_fnc_bases_initAmbientAnimFromClass;\n\n    private _randomGearConfig = [\n        \"KISKA_randomGear\",\n        _agentsSetConfig,\n        true,\n        false\n    ] call KISKA_fnc_bases_getClassConfig;\n    if (isClass _randomGearConfig) then {\n        [_agents,_randomGearConfig] call KISKA_fnc_randomGearFromConfig;\n    };\n\n    private _onUnitsCreated = [\n        \"onUnitsCreated\", \n        _agentsSetConfig, \n        \"\",\n        false,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_onUnitsCreated isNotEqualTo \"\") then {\n        [[_agentsSetConfig,_agents],_onUnitsCreated,false] call KISKA_fnc_callBack;\n    };\n\n    _base_agentsList append _agents;\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_agents.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_createFromConfig_agents.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_infantry\n\nDescription:\n    Spawns a configed KISKA bases' infantry.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config or the string\n        className of a config located in `missionConfigFile >> \"KISKA_bases\"\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_infantry;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_infantry\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\nprivate _base_infantryUnits = _baseMap get \"infantry units\";\nprivate _base_infantryGroups = _baseMap get \"infantry groups\";\n\nprivate _infantryConfig = _baseConfig >> \"infantry\";\nprivate _infantryClasses = configProperties [_infantryConfig >> \"sets\",\"isClass _x\"];\n\n\n\n/* ----------------------------------------------------------------------------\n\n    Create Infantry\n\n---------------------------------------------------------------------------- */\n_infantryClasses apply {\n    private _infantrySetConfig = _x;\n\n    private _spawnPositions = [\n        \"spawnPositions\",\n        _infantrySetConfig,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n\n    if (_spawnPositions isEqualType \"\") then {\n        _spawnPositions = [_spawnPositions] call KISKA_fnc_getMissionLayerObjects;\n    };\n    if (_spawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _unitClasses = [\"unitClasses\", _infantrySetConfig, []] call KISKA_fnc_bases_getPropertyValue;\n    if (_unitClasses isEqualType \"\") then {\n        _unitClasses = [[_infantrySetConfig],_unitClasses] call KISKA_fnc_callBack;\n    };\n    if (_unitClasses isEqualTo []) then {\n        [[\"Found no unitClasses to use for KISKA base class: \",_infantrySetConfig], true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _side = [\"side\", _infantrySetConfig, 0] call KISKA_fnc_bases_getPropertyValue;\n    _side = _side call BIS_fnc_sideType;\n\n    private _numberOfUnits = [\n        \"numberOfUnits\", \n        _infantrySetConfig, \n        -1,\n        false,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_numberOfUnits isEqualType \"\") then {\n        _numberOfUnits = [[_infantrySetConfig,_spawnPositions],_numberOfUnits,false] call KISKA_fnc_callBack;\n    };\n\n    private _unitsPerGroup = [\n        \"unitsPerGroup\", \n        _infantrySetConfig, \n        -1,\n        false,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_unitsPerGroup isEqualType \"\") then {\n        _unitsPerGroup = [[_infantrySetConfig,_numberOfUnits],_unitsPerGroup,false] call KISKA_fnc_callBack;\n    };\n\n    private _allowedStances = [\n        \"stances\", \n        _infantrySetConfig, \n        [\"up\",0.7,\"middle\",0.3],\n        false,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n\n    private _canPath = [\n        \"canPath\", \n        _infantrySetConfig, \n        true,\n        true,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n\n    private _enableDynamicSim = [\"dynamicSim\", _infantrySetConfig, true, true] call KISKA_fnc_bases_getPropertyValue;\n\n    private _units = [\n        _numberOfUnits,\n        _unitsPerGroup,\n        _unitClasses,\n        _spawnPositions,\n        _canPath,\n        _enableDynamicSim,\n        _side,\n        _allowedStances\n    ] call KISKA_fnc_spawn;\n\n    if (_units isEqualTo []) then {\n        [\n            [\n                \"Unable to create any units for config: \",\n                _infantrySetConfig,\n                \" Check KISKA Base configuration for it.\"\n            ],\n            true\n        ] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    [_infantrySetConfig,_units] call KISKA_fnc_bases_initAmbientAnimFromClass;\n\n    private _onUnitsCreated = [\n        \"onUnitsCreated\", \n        _infantrySetConfig, \n        \"\",\n        false,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_onUnitsCreated isNotEqualTo \"\") then {\n        [[_infantrySetConfig,_units],_onUnitsCreated,false] call KISKA_fnc_callBack;\n    };\n\n    _base_unitList append _units;\n    _base_infantryUnits append _units;\n\n    private _groups = [];\n    _units apply {\n        private _group = group _x;\n        _groups pushBackUnique _group;\n    };\n\n    _base_groupList append _groups;\n    _base_infantryGroups append _groups;\n    _groups apply {\n        _x setVariable [\"KISKA_bases_config\",_infantrySetConfig];\n    };\n\n\n    if (isNull (_x >> \"reinforce\")) then { continue; };\n    [_groups,_x] call KISKA_fnc_bases_initReinforceFromClass;\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_infantry.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_createFromConfig_infantry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_landVehicles\n\nDescription:\n    Spawns a configed KISKA bases' land vehicles.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config or the string\n        className of a config located in `missionConfigFile >> \"KISKA_bases\"\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_landVehicles;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_landVehicles\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\nprivate _base_landVehicles = _baseMap get \"land vehicles\";\nprivate _base_landVehicleGroups = _baseMap get \"land vehicle groups\";\n\nprivate _baseLandVehiclesConfig = _baseConfig >> \"landVehicles\";\nprivate _landVehicleClasses = configProperties [_baseLandVehiclesConfig >> \"sets\",\"isClass _x\"];\n\n/* ----------------------------------------------------------------------------\n\n    Create Vehicles\n\n---------------------------------------------------------------------------- */\n_landVehicleClasses apply {\n    private _vehicleSetConfig = _x;\n\n    private _side = [\"side\", _vehicleSetConfig, 0] call KISKA_fnc_bases_getPropertyValue;\n    _side = _side call BIS_fnc_sideType;\n\n    private _spawnPositions = [\n        \"spawnPositions\",\n        _vehicleSetConfig,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_spawnPositions isEqualType \"\") then {\n        _spawnPositions = [_spawnPositions] call KISKA_fnc_getMissionLayerObjects;\n    };\n    if (_spawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_vehicleSetConfig],true] call KISKA_fnc_log;\n        continue;\n    };\n\n    private _classNames = [\"vehicleClassNames\", _vehicleSetConfig,[]] call KISKA_fnc_bases_getPropertyValue;\n    if (_classNames isEqualType \"\") then {\n        _classNames = [[_vehicleSetConfig],_classNames,false] call KISKA_fnc_callBack;\n    };\n    if (_classNames isEqualTo []) then {\n        [[\"Could not find classNames for land vehicles in KISKA bases class: \",_vehicleSetConfig],true] call KISKA_fnc_log;\n        continue;\n    };\n\n    private _numberOfVehicles = [\"numberOfVehicles\", _vehicleSetConfig, -1] call KISKA_fnc_bases_getPropertyValue;\n    private _totalNumberOfSpawns = count _spawnPositions;\n    if (_numberOfVehicles isEqualType \"\") then {\n        _numberOfVehicles = [[_vehicleSetConfig,_spawnPositions,_totalNumberOfSpawns],_numberOfVehicles,false] call KISKA_fnc_callBack;\n    };\n    if (_numberOfVehicles < 0) then {\n        _numberOfVehicles = _totalNumberOfSpawns\n    };\n\n    private _canPath = [\n        \"canPath\", \n        _vehicleSetConfig, \n        true,\n        true,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    private _enableDynamicSim = [\"dynamicSim\", _vehicleSetConfig, true, true] call KISKA_fnc_bases_getPropertyValue;\n    private _onVehicleCreated = [\"onVehicleCreated\", _vehicleSetConfig, \"\"] call KISKA_fnc_bases_getPropertyValue;\n   \n    private _crew = [\"crew\", _vehicleSetConfig, []] call KISKA_fnc_bases_getPropertyValue;\n    if (_crew isEqualType \"\") then {\n        _crew = [[_vehicleSetConfig],_crew] call KISKA_fnc_callBack;\n    };\n    if (_crew isEqualTo []) then {\n        [[\"Found no unitClasses to use for KISKA base class: \",_vehicleSetConfig], true] call KISKA_fnc_log;\n        continue;\n    };\n\n    private _hasReinforce = !(isNull (_vehicleSetConfig >> \"reinforce\"));\n    for \"_i\" from 1 to _numberOfVehicles do {\n        private _spawnPosition = [_spawnPositions] call KISKA_fnc_deleteRandomIndex;\n        private _class = [_classNames,\"\"] call KISKA_fnc_selectRandom;\n        \n        private \"_spawnDirection\";\n        if (_spawnPosition isEqualType objNull) then {\n            _spawnDirection = getDir _spawnPosition;\n        } else {\n            private _isPostionWithDirection = (count _spawnPosition) > 3;\n            if (_isPostionWithDirection) then {\n                _spawnDirection = _spawnPosition deleteAt 3;\n            } else {\n                _spawnDirection = 0;\n            };\n        };\n\n        private _vehicleInfo = [\n            _spawnPosition,\n            _spawnDirection,\n            _class,\n            _side,\n            _crew,\n            true\n        ] call KISKA_fnc_spawnVehicle;\n        _vehicleInfo params [\"_vehicle\",\"_crewUnits\",\"_crewGroup\"];\n\n        if (_enableDynamicSim) then {\n            [_vehicle, true] remoteExec [\"enableDynamicSimulation\", 2];\n            [_crewGroup, true] remoteExec [\"enableDynamicSimulation\", 2];\n        };\n\n        if !(_canPath) then {\n            (driver _vehicle) disableAI \"PATH\";\n        };\n\n        if (_onVehicleCreated isNotEqualTo \"\") then {\n            [[_vehicleSetConfig,_vehicle,_crewUnits,_crewGroup],_onVehicleCreated] call KISKA_fnc_callBack;\n        };\n\n        _base_unitList append _crewUnits;\n        _base_groupList pushBack _crewGroup;\n        _base_landVehicles pushBack _vehicle;\n        _base_landVehicleGroups pushBack _crewGroup;\n\n        if (_hasReinforce) then { \n            [_vehicleSetConfig, _crewGroup] call KISKA_fnc_bases_initReinforceFromClass;\n        };\n    };\n\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_landVehicles.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_createFromConfig_landVehicles.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_patrols\n\nDescription:\n    Spawns a configed KISKA bases' patrols.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config or the string\n        className of a config located in `missionConfigFile >> \"KISKA_bases\"\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_patrols;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_patrols\";\n\n#define DEFAULT_PATROL_BEHAVIOUR \"SAFE\"\n#define DEFAULT_PATROL_SPEED \"LIMITED\"\n#define DEFAULT_PATROL_COMBATMODE \"RED\"\n#define DEFAULT_PATROL_FORMATION \"STAG COLUMN\"\n#define PATROL_TYPE_GENERATED \"GENERATED\"\n#define PATROL_TYPE_DEFINED \"DEFINED\"\n#define POINT_ORDER_UNCHANGED 0\n#define POINT_ORDER_RANDOM 1\n#define POINT_ORDER_NAME_NUMERIC 2\n#define DEFAULT_DEFINED_NUMBER_OF_POINTS -1\n#define DEFAULT_GENERATED_NUMBER_OF_POINTS 5\n#define DEFAULT_PATROL_RADIUS 500\n#define DEFAULT_WAYPOINT_TYPE \"MOVE\"\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\nprivate _base_patrolUnits = _baseMap get \"patrol units\";\nprivate _base_patrolGroups = _baseMap get \"patrol groups\";\n\nprivate _patrolsConfig = _baseConfig >> \"patrols\";\nprivate _patrolSets = configProperties [_patrolsConfig >> \"sets\",\"isClass _x\"];\n\n/* ----------------------------------------------------------------------------\n\n    Create Patrols\n\n---------------------------------------------------------------------------- */\n_patrolSets apply {\n    private _patrolSetConfig = _x;\n\n    private _spawnPosition = [\n        \"specificSpawn\",\n        _patrolSetConfig,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n\n    if (_spawnPosition isEqualTo []) then {\n        private _spawnPositions = [\n            \"spawnPositions\",\n            _patrolSetConfig,\n            [],\n            false,\n            false,\n            false\n        ] call KISKA_fnc_bases_getPropertyValue;\n\n        if (_spawnPositions isEqualType \"\") then {\n            _spawnPositions = [_spawnPositions] call KISKA_fnc_getMissionLayerObjects;\n        };\n\n        if (_spawnPositions isEqualTo []) then {\n            [[\"Could not find spawn positions for KISKA bases class: \",_x],true] call KISKA_fnc_log;\n            continue;\n        };\n\n        _spawnPosition = [_spawnPositions] call KISKA_fnc_selectRandom;\n    } else {\n        if (_spawnPosition isEqualType \"\") then {\n            _spawnPosition = [[_patrolSetConfig],_spawnPosition] call KISKA_fnc_callBack;\n        };\n    };\n\n\n\n    private _unitClasses = [\"unitClasses\", _patrolSetConfig, [], false, true, true] call KISKA_fnc_bases_getPropertyValue;\n    if (_unitClasses isEqualType \"\") then {\n        _unitClasses = [[_patrolSetConfig],_unitClasses] call KISKA_fnc_callBack;\n    };\n    if (_unitClasses isEqualTo []) then {\n        [[\"Found no unitClasses to use for KISKA base class: \",_patrolSetConfig], true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _side = [\"side\", _patrolSetConfig, 0, false, true, true] call KISKA_fnc_bases_getPropertyValue;\n    _side = _side call BIS_fnc_sideType;\n\n\n    private _numberOfUnits = [\"numberOfUnits\", _patrolSetConfig, 1,false, true, false] call KISKA_fnc_bases_getPropertyValue;\n    if (_numberOfUnits isEqualType \"\") then {\n        _numberOfUnits = [[_patrolSetConfig],_numberOfUnits] call KISKA_fnc_callBack;\n    };\n\n\n    private _enableDynamicSim = [\"dynamicSim\", _patrolSetConfig, true, true, false] call KISKA_fnc_bases_getPropertyValue;\n    private _group = [\n        _numberOfUnits,\n        _unitClasses,\n        _side,\n        _spawnPosition,\n        _enableDynamicSim\n    ] call KISKA_fnc_spawnGroup;\n\n\n    private _waypointArgs = [\n        [\"behaviour\",DEFAULT_PATROL_BEHAVIOUR],\n        [\"speed\",DEFAULT_PATROL_SPEED],\n        [\"formation\",DEFAULT_PATROL_FORMATION],\n        [\"combatMode\",DEFAULT_PATROL_COMBATMODE]\n    ] apply {\n        _x params [\"_propertyName\",\"_default\"];\n        [_propertyName,_patrolSetConfig,_default,false,true,false] call KISKA_fnc_bases_getPropertyValue\n    };\n    _waypointArgs params [\"_behaviour\",\"_speed\",\"_formation\",\"_combatMode\"];\n\n\n    private _patrolType = [\"patrolType\",_patrolSetConfig,PATROL_TYPE_GENERATED,false,true,false] call KISKA_fnc_bases_getPropertyValue;\n\n    if (_patrolType == PATROL_TYPE_DEFINED) then {\n        private _patrolPoints = [\"patrolPoints\",_patrolSetConfig,[],false,true,false] call KISKA_fnc_bases_getPropertyValue;\n        private _patrolPointsAreObjects = false;\n        if (_patrolPoints isEqualType \"\") then {\n            _patrolPointsAreObjects = true;\n            _patrolPoints = [_patrolPoints] call KISKA_fnc_getMissionLayerObjects;\n        };\n\n        if (_patrolPoints isEqualTo []) then {\n            [\n                [\n                    \"Retrieved empty patrol points array for config class: \", \n                    _patrolSetConfig\n                ],\n                true\n            ] call KISKA_fnc_log;\n            continue;\n        };\n\n        private _numberOfPoints = [\"numberOfPoints\",_patrolSetConfig,DEFAULT_DEFINED_NUMBER_OF_POINTS,false,true,false] call KISKA_fnc_bases_getPropertyValue;\n        private _pointOrdering = [\"patrolPointOrder\",_patrolSetConfig,POINT_ORDER_UNCHANGED,false,true,false] call KISKA_fnc_bases_getPropertyValue;\n        \n        private _randomize = false;\n        switch (_pointOrdering) do\n        {\n            case POINT_ORDER_NAME_NUMERIC: {\n                if (!_patrolPointsAreObjects) exitWith {};\n\n                private _patrolPointObjectNames = _patrolPoints apply { vehicleVarName _x };\n                private _patrolPointObjectNames_sorted = [_patrolPointObjectNames] call KISKA_fnc_sortStringsNumerically;\n                private _patrolPoints_sorted = _patrolPointObjectNames_sorted apply { missionNamespace getVariable _x };\n\n                _patrolPoints = _patrolPoints_sorted;\n            };\n            case POINT_ORDER_RANDOM: { \n                _randomize = true \n            };\n        };\n\n        [\n            _group,\n            _patrolPoints,\n            _numberOfPoints,\n            _randomize,\n            _behaviour,\n            _speed,\n            _combatMode,\n            _formation\n        ] call KISKA_fnc_patrolSpecific;\n\n    } else {\n        private _numberOfPoints = [\"numberOfPoints\",_patrolSetConfig,DEFAULT_GENERATED_NUMBER_OF_POINTS,false,true,false] call KISKA_fnc_bases_getPropertyValue;\n        if (_numberOfUnits isEqualType \"\") then {\n            _numberOfUnits = [[_patrolSetConfig],_numberOfUnits] call KISKA_fnc_callBack;\n        };\n\n        private _patrolCenter = [\"center\",_patrolSetConfig,-1,false,true,false] call KISKA_fnc_bases_getPropertyValue;\n        if (_patrolCenter isEqualTo -1) then { \n            _patrolCenter = _spawnPosition\n\n        } else {\n            if (_patrolCenter isEqualType \"\") exitWith {\n                _patrolCenter = [[_patrolSetConfig],_patrolCenter] call KISKA_fnc_callBack;\n            };\n\n            if (_patrolCenter isEqualType []) exitWith {\n                _patrolCenter = [_patrolCenter,[]] call KISKA_fnc_selectRandom;\n            };\n        };\n\n        private _patrolRadius = [\"radius\",_patrolSetConfig,DEFAULT_PATROL_RADIUS,false,true,false] call KISKA_fnc_bases_getPropertyValue;\n        private _waypointType = [\"wayPointType\",_patrolSetConfig,DEFAULT_WAYPOINT_TYPE,false,true,false] call KISKA_fnc_bases_getPropertyValue;\n\n        [\n            _group,\n            _patrolCenter,\n            _patrolRadius,\n            _numberOfPoints,\n            _waypointType,\n            _behaviour,\n            _combatMode,\n            _speed,\n            _formation\n        ] call CBA_fnc_taskPatrol;\n    };\n\n\n    private _onPatrolCreated = [\n        \"onPatrolCreated\", \n        _patrolSetConfig, \n        \"\",\n        false,\n        true,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    private _units = units _group;\n    if (_onPatrolCreated isNotEqualTo \"\") then {\n        [[_patrolSetConfig,_units,_group],_onPatrolCreated] call KISKA_fnc_callBack;\n    };\n\n    _base_groupList pushBack _group;\n    _base_patrolGroups pushBack _group;\n\n    _base_unitList append _units;\n    _base_patrolUnits append _units;\n\n    if (isNull (_patrolSetConfig >> \"reinforce\")) then { continue; };\n    [_group,_patrolSetConfig] call KISKA_fnc_bases_initReinforceFromClass;\n};\n\n\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_patrols.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_createFromConfig_patrols.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_simples\n\nDescription:\n    Spawns a configed KISKA bases' simple objects.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config or the string\n        className of a config located in `missionConfigFile >> \"KISKA_bases\"\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_simples;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_simples\";\n\n#define DEFAULT_SIMPLE_OFFSET [0, 0, 0.1]\n\n#define SIMPLE_DATA_INDEX_TYPEISCODE 0\n#define SIMPLE_DATA_INDEX_TYPE 1\n#define SIMPLE_DATA_INDEX_OFFSET 2\n#define SIMPLE_DATA_INDEX_VECTORUP 3\n#define SIMPLE_DATA_INDEX_VECTORDIR 4\n#define SIMPLE_DATA_INDEX_ANIMATIONS 5\n#define SIMPLE_DATA_INDEX_SELECTIONS 6\n#define SIMPLE_DATA_INDEX_CREATED_EVENT 7\n#define SIMPLE_DATA_INDEX_FOLLOW_TERRAIN 8\n#define SIMPLE_DATA_INDEX_SUPERSIMPLE 9\n\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _simplesConfig = _baseConfig >> \"simples\";\nprivate _simpleConfigSets = configProperties [_simplesConfig,\"isClass _x\"];\n\n\nprivate _simpleObjectClassCache = createHashMap;\nprivate _fn_getSimpleClassData = {\n    params [\"_simpleObjectClass\"];\n\n    if (_simpleObjectClass in _simpleObjectClassCache) exitWith {\n        _simpleObjectClassCache get _simpleObjectClass\n    };\n\n    private _dataArray = [];\n\n    private _typeIsCode = [\n        \"TYPE_IS_CODE\",\n        _simpleObjectClass,\n        false,\n        true,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _typeIsCode;\n\n    private _type = [\n        \"type\",\n        _simpleObjectClass,\n        \"\",\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    if (_typeIsCode) then {\n        _type = compileFinal _type;\n    };\n    _dataArray pushBack _type;\n\n    private _offset = [\n        \"offset\",\n        _simpleObjectClass,\n        DEFAULT_SIMPLE_OFFSET,\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _offset;\n\n    private _vectorUp = [\n        \"vectorUp\",\n        _simpleObjectClass,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _vectorUp;\n\n    private _vectorDir = [\n        \"vectorDir\",\n        _simpleObjectClass,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _vectorDir;\n\n    private _animations = [\n        \"animations\",\n        _simpleObjectClass,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _animations;\n\n    private _selections = [\n        \"selections\",\n        _simpleObjectClass,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _selections;\n\n    private _onObjectCreated = [\n        \"onObjectCreated\",\n        _simpleObjectClass,\n        \"\",\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack (compileFinal _onObjectCreated);\n\n    private _followTerrain = [\n        \"followTerrain\",\n        _simpleObjectClass,\n        true,\n        true,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _followTerrain;\n\n    private _superSimple = [\n        \"superSimple\",\n        _simpleObjectClass,\n        true,\n        true,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n    _dataArray pushBack _superSimple;\n\n    \n    _simpleObjectClassCache set [_simpleObjectClass,_dataArray];\n\n\n    _dataArray\n};\n\n\n\n_simpleConfigSets apply {\n    private _simpleSetRootConfig = _x;\n    private _simpleObjectClassesInSet = configProperties [_simpleSetRootConfig,\"isClass _x\"];\n\n    if (_simpleObjectClassesInSet isEqualTo []) then {\n        [\n            [\n                \"Skipped simple bases class: \",_simpleSetRootConfig,\n                \" because no simple classes were found\"\n            ]\n        ] call KISKA_fnc_log;\n\n        continue;\n    };\n\n    private _simpleClassWeights = _simpleObjectClassesInSet apply {\n        private _weightConfig = _x >> \"weight\";\n        if (isNull _weightConfig) then {\n            continueWith 1;\n        };\n\n        getNumber _weightConfig\n    };\n\n    private _spawnPositions = [\n        \"spawnPositions\",\n        _simpleSetRootConfig,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n\n    if (_spawnPositions isEqualType \"\") then {\n        private _layerObjects = [_spawnPositions] call KISKA_fnc_getMissionLayerObjects;\n        _spawnPositions = _layerObjects apply {\n            private _position = getPosWorld _x; \n            _position pushBack (getDir _x);\n            _position\n        };\n    };\n\n    if (_spawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_simpleSetRootConfig],true] call KISKA_fnc_log;\n        continue;\n    };\n\n    _spawnPositions apply {\n        private \"_objectDirection\";\n        if ((count _x) > 3) then {\n            _objectDirection = _x deleteAt 3;\n        } else {\n            _objectDirection = 0;\n        };\n\n\n        private _simpleObjectClass = _simpleObjectClassesInSet selectRandomWeighted _simpleClassWeights;\n        private _simpleClassDataParsed = [_simpleObjectClass] call _fn_getSimpleClassData;\n        // FUTURE: simple objects can be local, ideally we would create these as purely local objects\n        private _object = [\n            _simpleClassDataParsed select SIMPLE_DATA_INDEX_TYPE,\n            _x,\n            _objectDirection,\n            _simpleClassDataParsed select SIMPLE_DATA_INDEX_FOLLOW_TERRAIN,\n            _simpleClassDataParsed select SIMPLE_DATA_INDEX_SUPERSIMPLE\n        ] call BIS_fnc_createSimpleObject;\n\n        _offset = _simpleClassDataParsed select SIMPLE_DATA_INDEX_OFFSET;\n        if (_offset isNotEqualTo []) then {\n            _object setPosASL (_x vectorAdd _offset);\n        };\n\n        _vectorDir = _simpleClassDataParsed select SIMPLE_DATA_INDEX_VECTORDIR;\n        if (_vectorDir isNotEqualTo []) then {\n            _object setVectorDir _vectorDir;\n        };\n\n        _vectorUp = _simpleClassDataParsed select SIMPLE_DATA_INDEX_VECTORUP;\n        if (_vectorUp isNotEqualTo []) then {\n            _object setVectorUp _vectorUp;\n        };\n\n        (_simpleClassDataParsed select SIMPLE_DATA_INDEX_ANIMATIONS) apply {\n            _object animate [_x select 0, _x select 1, true];\n        };\n        (_simpleClassDataParsed select SIMPLE_DATA_INDEX_SELECTIONS) apply {\n            _object hideSelection [_x select 0, (_x select 1) > 0];\n        };\n\n        _onObjectCreated = _simpleClassDataParsed select SIMPLE_DATA_INDEX_CREATED_EVENT;\n        if (_onObjectCreated isNotEqualTo {}) then {\n            [\n                _onObjectCreated,\n                [_object]\n            ] call CBA_fnc_directCall;\n        };\n    };\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_simples.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_createFromConfig_simples.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_turrets\n\nDescription:\n    Spawns a configed KISKA bases' turrets.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config or the string\n        className of a config located in `missionConfigFile >> \"KISKA_bases\"\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_turrets;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_turrets\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_turretGunners = _baseMap get \"turret gunners\";\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\n\nprivate _baseTurretsConfig = _baseConfig >> \"turrets\";\nprivate _turretClasses = configProperties [_baseTurretsConfig >> \"sets\",\"isClass _x\"];\n\n/* ----------------------------------------------------------------------------\n\n    Create Turrets\n\n---------------------------------------------------------------------------- */\n_turretClasses apply {\n    private _turretConfig = _x;\n\n    private _turretSpawnPositions = [\n        \"spawnPositions\",\n        _turretConfig,\n        [],\n        false,\n        false,\n        false\n    ] call KISKA_fnc_bases_getPropertyValue;\n\n    if (_turretSpawnPositions isEqualType \"\") then {\n        _turretSpawnPositions = [_turretSpawnPositions] call KISKA_fnc_getMissionLayerObjects;\n    };\n    if (_turretSpawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _turretClassNames = [\"turretClassNames\", _turretConfig,[]] call KISKA_fnc_bases_getPropertyValue;\n    if (_turretClassNames isEqualType \"\") then {\n        _turretClassNames = [[_turretConfig],_turretClassNames,false] call KISKA_fnc_callBack;\n    };\n    if (_turretClassNames isEqualTo []) then {\n        [[\"Could not find classNames for turrets in KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _numberOfTurrets = [\"numberOfTurrets\", _turretConfig, -1] call KISKA_fnc_bases_getPropertyValue;\n    private _totalNumberOfSpawns = count _turretSpawnPositions;\n    if (_numberOfTurrets isEqualType \"\") then {\n        _numberOfTurrets = [[_turretConfig,_turretSpawnPositions,_totalNumberOfSpawns],_numberOfTurrets,false] call KISKA_fnc_callBack;\n    };\n    if (_numberOfTurrets < 0) then {\n        _numberOfTurrets = _totalNumberOfSpawns\n    };\n\n\n    private _unitClasses = [\"unitClasses\", _turretConfig, []] call KISKA_fnc_bases_getPropertyValue;\n    if (_unitClasses isEqualType \"\") then {\n        _unitClasses = [[_turretConfig],_unitClasses] call KISKA_fnc_callBack;\n    };\n    if (_unitClasses isEqualTo []) then {\n        [[\"Found no unitClasses to use for KISKA base class: \",_turretConfig], true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _turrets = [];\n    for \"_i\" from 1 to _numberOfTurrets do {\n        private _spawnPosition = [_turretSpawnPositions] call KISKA_fnc_deleteRandomIndex;\n        private _class = [_turretClassNames,\"\"] call KISKA_fnc_selectRandom;\n        \n        private [\"_direction\",\"_positionToSet\"];\n        if (_spawnPosition isEqualType objNull) then {\n            _direction = getDir _spawnPosition;\n            _positionToSet = getPosASL _spawnPosition;\n\n        } else {\n            private _isPostionWithDirection = (count _spawnPosition) > 3;\n            if (_isPostionWithDirection) then {\n                _direction = _spawnPosition deleteAt 3;\n            } else {\n                _direction = 0;\n            };\n            _positionToSet = ATLToASL _spawnPosition;\n\n        };\n\n        _turret = createVehicle [_class, _spawnPosition, [], 0, \"NONE\"];\n        _turrets pushBack _turret;\n        _turret setPosASL _positionToSet;\n        _turret setDir _direction;\n    };\n\n    if (_turrets isEqualTo []) then {\n        [[\"Created no turrets for KISKA base class: \",_turretConfig], true] call KISKA_fnc_log;\n        continue;\n    };\n\n    private _side = [\"side\", _turretConfig, 0] call KISKA_fnc_bases_getPropertyValue;\n    _side = _side call BIS_fnc_sideType;\n\n    private _enableDynamicSim = [\"dynamicSim\", _turretConfig, true, true] call KISKA_fnc_bases_getPropertyValue;\n    private _onGunnerCreated = compile ([\"onGunnerCreated\", _turretConfig, \"\"] call KISKA_fnc_bases_getPropertyValue);\n    private _onUnitMovedInGunner = compile ([\"onUnitMovedInGunner\", _turretConfig, \"\"] call KISKA_fnc_bases_getPropertyValue);\n\n    private _maxElevation = [\"maxElevation\", _turretConfig, \"\"] call KISKA_fnc_bases_getPropertyValue;\n    if (_maxElevation isEqualType \"\") then { _maxElevation = compile _maxElevation };\n\n    private _minElevation = [\"minElevation\", _turretConfig, \"\"] call KISKA_fnc_bases_getPropertyValue;\n    if (_minElevation isEqualType \"\") then { _minElevation = compile _minElevation };\n\n    private _maxRotation = [\"maxRotation\", _turretConfig, \"\"] call KISKA_fnc_bases_getPropertyValue;\n    if (_maxRotation isEqualType \"\") then { _maxRotation = compile _maxRotation };\n\n    private _minRotation = [\"minRotation\", _turretConfig, \"\"] call KISKA_fnc_bases_getPropertyValue;\n    if (_minRotation isEqualType \"\") then { _minRotation = compile _minRotation };\n\n\n    private _specifiedTurretLimits = [_minRotation,_maxRotation,_minElevation,_maxElevation];\n    private _adjustTurretLimit = [\n        _specifiedTurretLimits,\n        { (_x isNotEqualTo {}) }\n    ] call KISKA_fnc_findIfBool;\n\n    private _hasReinforce = !(isNull (_turretConfig >> \"reinforce\"));\n    _turrets apply {\n        private _group = createGroup _side;\n        private _unitClass = [_unitClasses,\"\"] call KISKA_fnc_selectRandom;\n        private _unit = _group createUnit [_unitClass,[0,0,0],[],0,\"NONE\"];\n\n        private _eventParams = [_turretConfig,_unit,_x];\n        if (_onGunnerCreated isNotEqualto {}) then {\n            [\n                _onGunnerCreated,\n                _eventParams\n            ] call CBA_fnc_directCall;\n        };\n\n\n        if (_enableDynamicSim) then {\n            [_group, true] remoteExec [\"enableDynamicSimulation\", 2];\n        };\n        _unit moveInGunner _x;\n\n\n        if (_onUnitMovedInGunner isNotEqualto {}) then {\n            [\n                _onUnitMovedInGunner,\n                _eventParams\n            ] call CBA_fnc_directCall;\n        };\n\n\n        if (_adjustTurretLimit) then {\n            private _turretPath = _x unitTurret _unit;\n            private _defaultTurretLimits = _x getTurretLimits _turretPath;\n            private _newTurretLimits = +_defaultTurretLimits;\n            private _callBackArgs = [_turretConfig,_x,_unit,_defaultTurretLimits];\n            {\n                private _limitIsDefault = _x call KISKA_fnc_isEmptyCode;\n                if (_limitIsDefault) then { continue };\n\n                private \"_newLimit\";\n                if (_x isEqualType {}) then {\n                    _newLimit = [\n                        _x,\n                        _callBackArgs\n                    ] call CBA_fnc_directCall;\n                } else {\n                    _newLimit = _x;\n                };\n\n                _newTurretLimits set [_forEachIndex,_newLimit];\n            } forEach _specifiedTurretLimits;\n\n\n            _newTurretLimits params [\"_minTurn\", \"_maxTurn\", \"_minElev\", \"_maxElev\"];\n            _x setTurretLimits [\n                _turretPath,\n                _minTurn,\n                _maxTurn,\n                _minElev,\n                _maxElev\n            ];\n        };\n\n\n\n        _base_turretGunners pushBack _unit;\n        _base_unitList pushBack _unit;\n        _base_groupList pushBack _group;\n\n        if (_hasReinforce) then { \n            [_group,_turretConfig] call KISKA_fnc_bases_initReinforceFromClass;\n        };\n    };\n\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_turrets.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_createFromConfig_turrets.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_getClassConfig\n\nDescription:\n    Used to sift through the various levels of possible configs for a KISKA base.\n\n    Very similar to `KISKA_fnc_bases_getPropertyValue` except it's used to obtain\n     an entire config class by the given name.\n\nParameters:\n    0: _class <STRING> - The name of the class to obtain.\n    1: _setConfigPath <CONFIG> - The config of the base set that is being searched\n        (e.g. `missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\" >> \"infantry\" >> \"sets\" >> \"MyInfantrySet\"`)\n    2: _canSelectFromSetRoot <BOOL> - Whether or not the property can be retrieved from\n        the root of the set class (e.g. `missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\" >> \"infantry\"`)\n        (Default: `true`)\n    3: _canSelectFromBaseRoot <BOOL> - Whether or not the property can be retrieved from\n        the root of the KISKA base class (e.g. `missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\"`)\n        (Default: `true`)\n\nReturns:\n    <CONFIG> - The most specific config of the class or `configNull` if not found.\n\nExamples:\n    (begin example)\n        private _agentsConfig = missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\" >> \"turrets\" >> \"sets\" >> \"agents\";\n        private _agentsRandomGearConfig = [\n            \"KISKA_randomGear\",\n            _agentsConfig,\n            true,\n            false\n        ] call KISKA_fnc_bases_getClassConfig;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_getClassConfig\";\n\nparams [\n    [\"_class\",\"\",[\"\"]],\n    [\"_setConfigPath\",configNull,[configNull]],\n    [\"_canSelectFromSetRoot\",true,[false]],\n    [\"_canSelectFromBaseRoot\",true,[false]]\n];\n\nprivate _setConfigClass = _setConfigPath >> _class;\nif (isClass _setConfigClass) exitWith { _setConfigClass };\n\nprivate _configClass = configNull;\nprivate _configHierarchy = configHierarchy _setConfigPath;\n[\n    [_canSelectFromSetRoot,2],\n    [_canSelectFromBaseRoot,1]\n] apply {\n    _x params [\"_canSelectRoot\",\"_hierarchyPosition\"];\n    if !(_canSelectRoot) then { continue };\n\n    private _rootConfig = _configHierarchy select _hierarchyPosition;\n    private _rootConfigClass = _rootConfig >> _class;\n    if (isClass _rootConfigClass) then { \n        _configClass = _rootConfigClass;\n        break; \n    };\n};\n\n\n_configClass\n",
    "fileName": "fn_bases_getClassConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_getClassConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_getHashmap\n\nDescription:\n    Returns a KISKA bases' hashmap spawn data or initializes if it did not exist.\n\nParameters:\n    0: _baseConfig <CONFIG or STRING> - The config path of the base config\n\nReturns:\n    <HASHMAP> - a hashmap containing data about the base:\n\n    - `unit list`: <OBJECT[]> - All spawned units (includes turret units)\n    - `group list`: <GROUP[]> - All spawned groups (does NOT include turret units)\n    - `turret gunners`: <OBJECT[]> - All turret units\n    - `infantry units`: <OBJECT[]> - All infantry spawned units\n    - `infantry groups`: <GROUP[]> - All infantry spawned groups\n    - `patrol units`: <OBJECT[]> - All patrol spawned units\n    - `patrol groups`: <GROUP[]> - All patrol spawned groups\n    - `land vehicles`: <OBJECT[]> - All land spawned vehicles\n    - `land vehicle groups`: <GROUP[]> - All land vehicle crew groups\n    - `agent list`: <OBJECT[]> - All spawned agents\n\nExamples:\n    (begin example)\n        private _mapOfDataForSpecificBase = [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_getHashmap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_getHashmap\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseName = configName _baseConfig;\nif (isNil \"KISKA_bases_map\") then {\n    missionNamespace setVariable [\"KISKA_bases_map\",createHashMap];\n};\n\nprivate _baseData = KISKA_bases_map getOrDefault [_baseName, -1];\nif (_baseData isNotEqualTo -1) exitWith {_baseData};\n\n\n_baseData = createHashMapFromArray [\n    [\"unit list\",[]],\n    [\"group list\",[]],\n    [\"turret gunners\",[]],\n    [\"infantry units\",[]],\n    [\"infantry groups\",[]],\n    [\"patrol units\",[]],\n    [\"patrol groups\",[]],\n    [\"land vehicles\",[]],\n    [\"land vehicle groups\",[]],\n    [\"agent list\",[]]\n];\nKISKA_bases_map set [_baseName,_baseData];\n\n\n_baseData\n",
    "fileName": "fn_bases_getHashmap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_getHashmap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_getPropertyValue\n\nDescription:\n    Used to sift through the various levels of possible properties for a KISKA base.\n\nParameters:\n    0: _property <STRING> - The property to get the value of\n    1: _setConfigPath <CONFIG> - The config of the base set that is being searched\n        (e.g. `missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\" >> \"infantry\" >> \"sets\" >> \"MyInfantrySet\"`)\n    2: _default <ANY> - The default value to return if the property search returns `nil`\n    3: _isBool <BOOL> - Whether or not the property should be interpreted as a \n        boolean value (Default: `false`)\n    4: _canSelectFromSetRoot <BOOL> - Whether or not the property can be retrieved from\n        the root of the set class (e.g. `missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\" >> \"infantry\"`)\n        (Default: `true`)\n    5: _canSelectFromBaseRoot <BOOL> - Whether or not the property can be retrieved from\n        the root of the KISKA base class (e.g. `missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\"`)\n        (Default: `true`)\n\nReturns:\n    <ANY> - The property value\n\nExamples:\n    (begin example)\n        private _turretConfig = missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\" >> \"turrets\" >> \"sets\" >> \"MyTurretSet\";\n        private _turretSpawnPositions = [\n            \"spawnPositions\",\n            _turretConfig,\n            [],\n        ] call KISKA_fnc_bases_getPropertyValue;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_getPropertyValue\";\n\nparams [\n    [\"_property\",\"\",[\"\"]],\n    [\"_setConfigPath\",configNull,[configNull]],\n    \"_default\",\n    [\"_isBool\",false,[false]],\n    [\"_canSelectFromSetRoot\",true,[false]],\n    [\"_canSelectFromBaseRoot\",true,[false]]\n];\n\nprivate _setPropertyConfig = _setConfigPath >> _property;\nif !(isNull _setPropertyConfig) exitWith {\n    [_setPropertyConfig,_isBool] call KISKA_fnc_getConfigData\n};\n\nprivate _setConditionalValue = [_setConfigPath,_property,_isBool] call KISKA_fnc_getConfigDataConditional;\nif !(isNil \"_setConditionalValue\") exitWith { _setConditionalValue };\n\nprivate \"_propertyValue\";\nprivate _configHierarchy = configHierarchy _setConfigPath;\n[\n    [_canSelectFromSetRoot,2],\n    [_canSelectFromBaseRoot,1]\n] apply {\n    _x params [\"_canSelectRoot\",\"_hierarchyPosition\"];\n    if !(_canSelectRoot) then { continue };\n\n    private _rootConfig = _configHierarchy select _hierarchyPosition;\n    private _rootConditionalValue = [_rootConfig,_property,_isBool] call KISKA_fnc_getConfigDataConditional;\n    if !(isNil \"_rootConditionalValue\") then {\n        _propertyValue = _rootConditionalValue;\n        break;\n    };\n};\n\n\nif !(isNil \"_propertyValue\") exitWith { _propertyValue };\n_default\n",
    "fileName": "fn_bases_getPropertyValue.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_getPropertyValue.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_initAmbientAnimFromClass\n\nDescription:\n    Parses and initializes a KISKA base entry's ambient animation class.\n\n    This is meant to be called from KISKA bases createFromConfig functions.\n\nParameters:\n    0: _configToInit <CONFIG> - The config path to the entry's that has an ambientAnim class\n    1: _units <OBJECT[] or OBJECT> - The units that are under the config to init\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            missionConfigFile >> \"SomeBaseConfig\" >> \"infantry >> \"someInfantryConfigClass\",\n            someUnit\n        ] call KISKA_fnc_bases_initAmbientAnimFromClass;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_initAmbientAnimFromClass\";\n\nparams [\n    [\"_configToInit\",configNull,[configNull]],\n    [\"_units\",objNull,[[],objNull]]\n];\n\nif (isNull _configToInit) exitWith {\n    [\"Passed a null _configToInit\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _ambientAnimConfig = _configToInit >> \"ambientAnim\";\nif (isNull _ambientAnimConfig) exitWith {\n    [[\"Config: \",_configToInit,\" does not have an 'ambientAnim' class in it\"],false] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _exitOnCombat = [_ambientAnimConfig >> \"exitOnCombat\"] call BIS_fnc_getCfgDataBool;\nprivate _equipmentLevel = (_ambientAnimConfig >> \"equipmentLevel\") call BIS_fnc_getCfgData;\nif (isNil \"_equipmentLevel\") then {\n    _equipmentLevel = \"\";\n};\n\n\nprivate _animationParams = \"\";\nprivate _animationSetConfig = _ambientAnimConfig >> \"animationSet\";\nif (isClass _animationSetConfig) then {\n    private _snapToAnimationSets = (_animationSetConfig >> \"snapToAnimations\") call BIS_fnc_getCfgData;\n    if (isNil \"_snapToAnimationSets\") then { _snapToAnimationSets = \"\" };\n\n    private _backupAnimationSets = (_animationSetConfig >> \"backupAnimations\") call BIS_fnc_getCfgData;\n    if (isNil \"_backupAnimationSets\") then { _backupAnimationSets = \"\" };\n\n    private _snapToRange = getNumber(_animationSetConfig >> \"snapToRange\");\n    private _snapRangeIsUndefined = _snapToRange isEqualTo 0;\n    if (_snapRangeIsUndefined) then {\n        _snapToRange = 5;\n    };\n    private _fallbackFunction = getText(_animationSetConfig >> \"fallbackFunction\");\n    \n    _animationParams = createHashMapFromArray [\n        [\"_animSet\",_snapToAnimationSets],\n        [\"_snapToRange\",_snapToRange],\n        [\"_backupAnims\",_backupAnimationSets],\n        [\"_fallbackFunction\",_fallbackFunction]\n    ];\n\n} else {\n    _animationParams = _animationSetConfig call BIS_fnc_getCfgData;\n};\n\n\n\nprivate _args = [\n    _units,\n    _animationParams,\n    _exitOnCombat,\n    _equipmentLevel\n];\n\nprivate _getAnimationMapFunction = getText(_ambientAnimConfig >> \"getAnimationMapFunction\");\nif (_getAnimationMapFunction isNotEqualTo \"\") then {\n    private _animationMap = [[],_getAnimationMapFunction] call KISKA_fnc_callBack;\n    _args pushBack _animationMap;\n};\n\n_args call KISKA_fnc_ambientAnim;\n\n\nnil\n",
    "fileName": "fn_bases_initAmbientAnimFromClass.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_initAmbientAnimFromClass.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_initReinforceFromClass\n\nDescription:\n    Parses a reinforce class that is used in a unit's KIKSA bases class, and\n    initializes the group(s) reactivity to it.\n\nParameters:\n    0: _group <GROUP, GROUP[]> - The config path of the base config\n    1: _config <CONFIG> - The config path of the base config\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _group,\n            SomeBaseConfig >> \"infantry\" >> \"someUnitClass\"\n        ] call KISKA_fnc_bases_initReinforceFromClass;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_initReinforceFromClass\";\n\nparams [\n    [\"_group\",grpNull,[grpNull,[]]],\n    [\"_config\",configNull,[configNull]]\n];\n\nprivate _groupIsArray = _group isEqualType [];\nif ((!_groupIsArray) AND {isNull _group}) exitWith {\n    [\"_group is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_groupIsArray AND {_group isEqualTo []}) exitWith {\n    [\"_group is an empty array!\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (isNull _config) exitWith {\n    [\"_config is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _reinforceClass = _x >> \"reinforce\";\nif (isNull _reinforceClass) exitWith {\n    [\n        [\"config \",_config,\" does not have a 'reinforce' class within it!\"],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _reinforceId = configName _x;\nprivate _idPropertyConfig = _reinforceClass >> \"id\";\nif (isText _idPropertyConfig) then {\n    _reinforceId = _idPropertyConfig call BIS_fnc_getCfgData;\n};\n\nprivate _canCallIds = getArray(_reinforceClass >> \"canCall\");\nprivate _reinforcePriority = getNumber(_reinforceClass >> \"priority\");\nprivate _onEnemyDetected = getText(_reinforceClass >> \"onEnemyDetected\");\n\nif (_groupIsArray) exitWith {\n    _group apply {\n        [\n            _x,\n            _reinforceId,\n            _canCallIds,\n            _reinforcePriority,\n            _onEnemyDetected\n        ] call KISKA_fnc_bases_setupReactivity;\n    };\n\n    nil\n};\n\n\n[\n    _group,\n    _reinforceId,\n    _canCallIds,\n    _reinforcePriority,\n    _onEnemyDetected\n] call KISKA_fnc_bases_setupReactivity;\n\n\nnil\n",
    "fileName": "fn_bases_initReinforceFromClass.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_initReinforceFromClass.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_setupReactivity\n\nDescription:\n    Adds values and eventhandlers to the given group's namespace to be able to \n     interact with KISKA bases reaction system\n\nParameters:\n    0: _group <GROUP> - The group to add setup reactions for\n    1: _reinforceId <NUMBER or STRING> - A globally unqiue identifier for this group (or a collection of groups)\n    2: _canCallIds <STRING[]> - An array of _reinforceIds denoting groups that will respond to\n        distress calls from this group\n    3: _priority <NUMBER> - a number signifying how important this group's call will be\n        (if a group is responding to another call, they will break away from it for this call if higher)\n    4: _onEnemyDetected <CODE or STRING> - Code that will be executed when the group enters combat.\n        Must return a boolean that denotes whether to execute default functionality that happens\n        with the event (see KISKA_fnc_bases_triggerReaction).\n        \n        Parameters:\n        - 0: <GROUP> - The group the event is triggering for\n        - 1: <OBJECT> - The enemy unit that was detected\n        - 2: <ARRAY> - An array of GROUPs that can respond to the call (based on _canCallIds)\n        - 3: <NUMBER> - The same _priority\n\nReturns:\n    <NUMBER> - The event id of the EnemyDetected group eventhandler\n\nExamples:\n    (begin example)\n        [\n            aGroup,\n            123,\n            [\"anotherGroupsId\"],\n            1,\n            {\n                hint str _this;\n                false // continue with default reaction behaviour\n            }\n        ] call KISKA_fnc_bases_setupReactivity;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_setupReactivity\";\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_reinforceId\",\"\",[123,\"\"]],\n    [\"_canCallIds\",[],[[]]],\n    [\"_priority\",1,[123]],\n    [\"_onEnemyDetected\",{},[\"\",{}]]\n];\n\nif (isNull _group) exitWith {\n    [\"Null group passed\",true] call KISKA_fnc_log;\n    -1\n};\n\n\n_group setVariable [\"KISKA_bases_canCallReinforceIds\", _canCallIds];\n_group setVariable [\"KISKA_bases_reinforcePriority\", _priority];\n_group setVariable [\"KISKA_bases_reinforceId\", _reinforceId];\n\nif (_onEnemyDetected isEqualType \"\") then {\n    _onEnemyDetected = compile _onEnemyDetected;\n};\n_group setVariable [\"KISKA_bases_reinforceOnEnemyDetected\",_onEnemyDetected];\n\n\n\nif (isNil \"KISKA_bases_reinforceGroupsMap\") then {\n    missionNamespace setVariable [\"KISKA_bases_reinforceGroupsMap\",createHashMap];\n};\n\nprivate _entryWithId = KISKA_bases_reinforceGroupsMap getOrDefault [_reinforceId,[]];\nprivate _idTaken = _entryWithId isNotEqualTo [];\nif (_idTaken) then {\n    _entryWithId pushBackUnique _group;\n} else {\n    KISKA_bases_reinforceGroupsMap set [_reinforceId,[_group]];\n};\n\n\n_group addEventHandler [\"EnemyDetected\",KISKA_fnc_bases_triggerReaction];\n",
    "fileName": "fn_bases_setupReactivity.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_setupReactivity.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_triggerReaction\n\nDescription:\n    Acts as the default event for the reactive bases when a group calls for reinforcements.\n\nParameters:\n    0: _group <GROUP> - The group the event is triggering for\n    1: _detectedTarget <OBJECT> - The enemy unit that was detected\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            someGroup,\n            anEnemyUnit\n        ] call KISKA_fnc_bases_triggerReaction\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_triggerReaction\";\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_detectedTarget\",objNull,[objNull]]\n];\n\nif ((isNull _group) OR (isNull _detectedTarget)) exitWith {};\n\nprivate _reinforceGroupIds = _group getVariable [\"KISKA_bases_canCallReinforceIds\",[]];\nprivate _groupsToRespond = [];\n_reinforceGroupIds apply {\n    private _groups = KISKA_bases_reinforceGroupsMap get _x;\n    _groupsToRespond append _groups;\n};\n\n\nprivate _priority = _group getVariable [\"KISKA_bases_reinforcePriority\",-1];\nprivate _onEnemyDetected = _group getVariable [\"KISKA_bases_reinforceOnEnemyDetected\",{}];\nif (_onEnemyDetected isNotEqualTo {}) exitWith {\n    [\n        _group,\n        _detectedTarget,\n        _groupsToRespond,\n        _priority\n    ] call _onEnemyDetected;\n\n    nil\n};\n\n\n// don't try to fight air vehicles\nprivate _targetVehicleALT = (getPosATL _detectedTarget) select 2;\nif (_targetVehicleALT >= 5) exitWith {\n    [\n        [\n            _group,\n            \" detected a target that could not be reached: \",\n            _detectedTarget,\n            \" which is of type: \",\n            typeOf _detectedTarget \n        ],\n        false\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    Default response behviour\n---------------------------------------------------------------------------- */\nprivate _fnc_findReplacementTarget = {\n    params [\"_group\"];\n\n    private _simDistance = dynamicSimulationDistance \"Group\";\n    private _targets = [];\n    private \"_leaderOfCallingGroup\";\n    waitUntil {\n        sleep 2;\n        // in case leader changes\n        _leaderOfCallingGroup = leader _group;\n        if !(alive _leaderOfCallingGroup) exitWith {true};\n        _targets = _leaderOfCallingGroup targets [true, _simDistance];\n        if (_targets isEqualTo []) then {continueWith false};\n\n        private _foundEnemyIndex = _targets findIf { !(captive _x) };\n        _foundEnemyIndex isNotEqualTo -1;\n    };\n\n    // in case _closestEnemy dies while processing\n    private _closestEnemy = objNull;\n    private _distanceOfClosest = -1;\n    _targets apply {\n        if (captive _x) then {continue};\n\n        private _distance = _x distance _leaderOfCallingGroup;\n        if (!(alive _closestEnemy) OR (_distance < _distanceOfClosest)) then {\n            _distanceOfClosest = _distance;\n            _closestEnemy = _x;\n        };\n    };\n\n\n    _closestEnemy\n};\n\n\n\n[\n    _group,\n    _detectedTarget,\n    _groupsToRespond,\n    _priority,\n    _fnc_findReplacementTarget\n] spawn {\n    scriptName \"KISKA_fnc_bases_triggerReaction\";\n\n    params [\"_group\",\"_detectedTarget\",\"_groupsToRespond\",\"_priority\",\"_fnc_findReplacementTarget\"];\n\n    sleep 3;\n\n    private _groupIsAlive = [_group] call KISKA_fnc_isGroupAlive;\n    if !(_groupIsAlive) exitWith {};\n\n    if (\n        !(alive _detectedTarget) AND\n        {\n            _detectedTarget = [_group] call _fnc_findReplacementTarget;\n            isNull _detectedTarget\n        }\n    ) exitWith {\n        [\"Original detected target is not alive and could not find replacement\"] call KISKA_fnc_log;\n        nil\n    };\n\n    private _groupRespondingToId = _group getVariable [\"KISKA_bases_respondingToId\",\"\"];\n    private _groupIsAlsoResponding = _groupRespondingToId isNotEqualTo \"\";\n    private _groupReinforceId = _group getVariable [\"KISKA_bases_reinforceId\",\"\"];\n    private _leaderOfCallingGroup = leader _group;\n\n    _groupsToRespond apply {\n        private _currentMissionPriority = _x getVariable [\"KISKA_bases_responseMissionPriority\",-1];\n        private _currentlyStalked = _x getVariable [\"KISKA_bases_stalkingThis\",objNull];\n\n        if (\n            (_currentMissionPriority > _priority) OR \n            (!(isNull _currentlyStalked) AND (_detectedTarget isEqualTo _currentlyStalked))\n        ) then {\n            continue;\n        };\n\n        // check that the group being called doesn't already have\n        // the group calling responding to them\n        // e.g. group1 calls for group2, group2 then calls for group1\n        // group2 shouldn't acknowledge this because group1 already called\n        private _reinforceId = _x getVariable [\"KISKA_bases_reinforceId\",\"\"];\n        private _willBeCircularResponse = _reinforceId isEqualTo _groupRespondingToId;\n        if (_groupIsAlsoResponding AND _willBeCircularResponse) then {\n            continue;\n        };\n\n        private _leaderOfRespondingGroup = leader _x;\n        if ((isNull _x) OR (isNull _leaderOfRespondingGroup)) then {\n            continue;\n        };\n\n        _x setVariable [\"KISKA_bases_stalkingThis\",_detectedTarget];\n\n        private _currentBehaviour = combatBehaviour _x;\n        private _distanceBetweenGroups = _leaderOfRespondingGroup distance _leaderOfCallingGroup;\n        if (\n            (_distanceBetweenGroups > 20) AND\n            (_currentBehaviour != \"combat\")\n        ) then {\n            [_x,\"aware\"] remoteExec [\"setBehaviourStrong\",_leaderOfRespondingGroup];\n        };\n\n        private _groupUnits = units _x;\n        // reset infantry positions\n        _groupUnits apply {\n            private _isAnimated = [_x] call KISKA_fnc_ambientAnim_isAnimated;\n            if (_isAnimated) then {\n                [_x] call KISKA_fnc_ambientAnim_stop;\n            };\n\n            [_x,\"AUTO\"] remoteExec [\"setUnitPos\",_x];\n        };\n        // in case unit was told to stop with doStop\n        [_groupUnits, _leaderOfRespondingGroup] remoteExec [\"doFollow\", _leaderOfRespondingGroup];\n\n        // some time is needed after reseting units with doFollow or they will lock up\n        sleep 1;\n        \n        [_x, _detectedTarget, 15, {\n            params [\"_stalkerGroup\",\"_stalkedUnit\",\"_groupToStalk\"];\n            \n            private _groupIsAlive = [_stalkerGroup] call KISKA_fnc_isGroupAlive;\n            if (!_groupIsAlive) exitWith {};\n\n            private _canStalkGroup = [_groupToStalk] call KISKA_fnc_isGroupAlive;\n            if (!_canStalkGroup) exitWith {\n                _stalkerGroup setVariable [\"KISKA_bases_responseMissionPriority\", nil];\n                _stalkerGroup setVariable [\"KISKA_bases_respondingToId\", nil];\n                _stalkerGroup setVariable [\"KISKA_bases_stalkingThis\", nil];\n            };\n \n            [\n                _stalkerGroup,\n                _groupToStalk,\n                20,\n                {\n                    params [\"_stalkerGroup\"];\n                    \n                    _stalkerGroup setVariable [\"KISKA_bases_responseMissionPriority\", nil];\n                    _stalkerGroup setVariable [\"KISKA_bases_respondingToId\", nil];\n                    _stalkerGroup setVariable [\"KISKA_bases_stalkingThis\", nil];\n                }\n            ] spawn KISKA_fnc_stalk;\n            \n        }] spawn KISKA_fnc_stalk;\n\n        _x setVariable [\"KISKA_bases_responseMissionPriority\",_priority];\n        _x setVariable [\"KISKA_bases_respondingToId\", _groupReinforceId];\n    };\n};\n\n\n\n\nnil\n",
    "fileName": "fn_bases_triggerReaction.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Bases/fn_bases_triggerReaction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ciwsAlarm\n\nDescription:\n    Sounds an alarm for the CIWS\n\nParameters:\n    0: _turret : <OBJECT> - The CIWS turret\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [turret1] spawn KISKA_fnc_ciwsAlarm;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ciwsAlarm\";\n\n#define WAIT_FOR_AIRRAIDSTART 6.4\n#define WAIT_TO_LOOP_SOUND 10.8\n#define ALARM_DISTANCE 1000\n#define ALARM_VOLUME 3\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled; running in scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_ciwsAlarm;\n};\n\nparams [\n    [\"_turret\",objNull,[objNull]]\n];\n\nif (isNull _turret) exitWith {\n    [[_turret,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_turret getVariable [\"KISKA_CIWS_alarmSounding\",false]) exitWith {\n    [[_turret,\" already has its alarm sounding\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n// set turret to engaging targets\n_turret setVariable [\"KISKA_CIWS_allClear\",false];\n_turret setVariable [\"KISKA_CIWS_alarmSounding\",true];\n\n// start the alarms\n[\"KISKA_airRaidStart\",_turret,ALARM_DISTANCE,ALARM_VOLUME] call KISKA_fnc_playSound3d;\n\n// start Sirens\n[_turret] spawn KISKA_fnc_ciwsSiren;\n\n// To make the sounds appear to be synched, wait a bit to start the loop audio\nsleep WAIT_FOR_AIRRAIDSTART;\n\n// start the air raid loop\nwaitUntil {\n    // check if loop should end and play audio if it should\n    if (_turret getVariable \"KISKA_CIWS_allClear\") exitWith {\n        [\"KISKA_airRaidEnd\",_turret,1000,3] call KISKA_fnc_playSound3d;\n        _turret setVariable [\"KISKA_CIWS_alarmSounding\",false];\n        true\n    };\n\n    // play looped audio again\n    [\"KISKA_airRaidLoop\",_turret,1000,3] call KISKA_fnc_playSound3d;\n    // sound should wait to loop back to end audio or loop sound\n    sleep WAIT_TO_LOOP_SOUND;\n    false\n};\n\n\nnil\n",
    "fileName": "fn_ciwsAlarm.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/CIWS/fn_ciwsAlarm.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ciwsInit\n\nDescription:\n    Fires a number of rounds from AAA piece at target with random disperstion values.\n\n    To stop, set the variable \"KISKA_runCIWS\" to false.\n\nParameters:\n    0: _turret : <OBJECT> - The CIWS turret\n    1: _searchDistance : <NUMBER> - How far out will the CIWS be notified of a target\n    2: _engageAboveAltitude : <NUMBER> - What altittiude (AGL) does the target need to be above to be engaged\n    3: _searchInterval : <NUMBER> - Time between checks for targets in area\n    4: _doNotFireBelowAngle : <NUMBER> - Below what angle should the turret NOT fire (keep it from firing at ground accidently)\n    5: _pitchTolerance : <NUMBER> - if the turret's pitch is within this margin of degrees to the target, it can engage\n    6: _rotationTolerance : <NUMBER> - if the turret's rotation is within this margin of degrees to the target, it can engage\n    7: _soundAlarm : <BOOL> - Play air raid siren and sound alarm when incoming detected\n    8: _engageTypes : <ARRAY> - This array decides what types of objects or entities should be engaged by the CIWS\n                                 these are formatted as an array or string inside, using an array allows the\n                                 decision to define a type as supported by nearEntities (which is much faster then the default nearObjects)\n                                 simply by setting it as [\"myEntityType\",true]\n\nReturns:\n    Nothing\n\nExamples:\n    (begin example)\n        [turret,3000,100] spawn KISKA_fnc_ciwsInit;\n    (end)\n\nAuthor:\n    DayZMedic,\n    modified/optimized by Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ciwsInit\";\n\n\n#define DEFAULT_ENGAGE_TYPES [[\"RocketBase\",false],[\"MissileBase\",false],[\"ShellBase\",false],[\"R_230mm_HE\",false]]\n#define NUMBER_OF_MAGS 3\n#define EXPLOSION_DELAY_CONST 0.0005\n#define TURRET_WEAPON \"Gatling_30mm_Plane_CAS_01_F\"\n#define TURRET_MAGAZINE \"1000Rnd_Gatling_30mm_Plane_CAS_01_F\"\n\n\nif !(local (_this select 0)) exitWith {\n    [\"Must be run where the unit is local, remoting to local\",true] call KISKA_fnc_log;\n    _this remoteExec [\"KISKA_fnc_ciwsInit\",(_this select 0)];\n};\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled; running in scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_ciwsInit;\n};\n\nparams [\n    [\"_turret\",objNull,[objNull]],\n    [\"_searchDistance\",3000,[123]],\n    [\"_engageAboveAltitude\",50,[123]],\n    [\"_searchInterval\",2,[123]],\n    [\"_doNotFireBelowAngle\",5,[123]],\n    [\"_pitchTolerance\",3,[123]],\n    [\"_rotationTolerance\",10,[123]],\n    [\"_soundAlarm\",true,[false]],\n    [\"_engageTypes\",DEFAULT_ENGAGE_TYPES,[]]\n];\n\nif (isNull _turret) exitWith {\n    [[_turret,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\nif !(_turret isKindOf \"AAA_System_01_base_F\") exitWith {\n    [[typeOf _turret,\" is not the proper type (AAA_System_01_base_F). Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n// disable HC transfer\n[group _turret,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n\n// give the turret the cool red tracer gatling for more authenticity\n_turret addWeaponTurret [TURRET_WEAPON, [0]];\nfor \"_i\" from 1 to NUMBER_OF_MAGS do {\n    _turret addMagazineTurret [TURRET_MAGAZINE,[0],1000];\n};\n_turret selectWeaponTurret [TURRET_WEAPON,[0]];\n\nprivate _engagedTargetsHash = missionNamespace getVariable [\"KISKA_CIWS_engagedTargetsHash\",createHashMap];\nif (isNil \"KISKA_CIWS_engagedTargetsHash\") then {\n    missionNamespace setVariable [\"KISKA_CIWS_engagedTargetsHash\",_engagedTargetsHash];\n};\n\n\n_turret setVariable [\"KISKA_runCIWS\",true];\n\n// make sure turret only fires when we tell it to\n// possibly add this as a param in the future\n//_turret setCombatMode \"BLUE\";\n\n[[_turret,\" set KISKA_runCIWS to true\"],false] call KISKA_fnc_log;\n\nprivate [\n    \"_targetDistance\",\n    \"_turretPitchAngle\",\n    \"_angleToTarget\",\n    \"_currentPitchTolerance\",\n    \"_turretVector\",\n    \"_turretDir\",\n    \"_relativeDir\",\n    \"_currentRotTolerance\",\n    \"_targetAlt\",\n    \"_firedShots\",\n    \"_turretPitchAngle\",\n    \"_targetPos\",\n    \"_targetBoom\",\n    \"_targetIndex\",\n    \"_targetNetId\"\n];\n\nprivate _incoming = [];\nprivate _fn_updateIncomingList = {\n    // nearestObjects and nearEntities do not work here\n    [[_turret,\" is searching for incoming within \",_searchDistance],false] call KISKA_fnc_log;\n\n    _incoming = [];\n\n    _engageTypes apply {\n        _x params [\n            \"_type\",\n            [\"_isEntity\",false]\n        ];\n\n        if (_isEntity) then {\n            _incoming append (_turret nearEntities [_type,_searchDistance]);\n        } else {\n            _incoming append (_turret nearObjects [_type,_searchDistance]);\n        };\n\n    };\n\n    [[_turret,\" found \",_incoming],false] call KISKA_fnc_log;\n\n    _incoming\n};\n\nprivate _target = objNull;\n\nprivate _fn_isNullTarget = {\n    isNull _target\n};\n\n// used a wait and exec to create a new thread so that this could be evaluated independently\n// the goal is to reduce alarm sound overlap by keeping it going if the rounds are close together\nprivate _fn_checkIfStopAlarm = {\n    [\n        {\n            params [\"_turret\",\"_searchDistance\",\"_engageTypes\"];\n            private _incoming = [];\n\n            _engageTypes apply {\n                _x params [\n                    \"_type\",\n                    [\"_isEntity\",false]\n                ];\n\n                if (_isEntity) then {\n                    _incoming append (_turret nearEntities [_type,_searchDistance]);\n                } else {\n                    _incoming append (_turret nearObjects [_type,_searchDistance]);\n                };\n            };\n\n            if (_incoming isEqualTo []) then {\n                _turret setVariable [\"KISKA_CIWS_allClear\",true];\n            };\n        },\n        [_turret,_searchDistance,_engageTypes],\n        5\n    ] call CBA_fnc_waitAndExecute;\n};\n\n// turrets don't like to watch objects consistently, so we'll use their position instead for doWatch\nprivate _fn_updateTargetPos = {\n    _targetPos = getPosASLVisual _target;\n};\n\nprivate _fn_waitToFireOnTarget = {\n    _turret enableAI \"WEAPONAIM\";\n\n    waitUntil {\n        if (call _fn_isNullTarget) exitWith {\n            [[_turret,\" stopped waiting on null target #1\"],false] call KISKA_fnc_log;\n            true\n        };\n        // keep turret rotating to target\n        [[_turret,\" trying to get an angle on \",_target],false] call KISKA_fnc_log;\n\n// why?\n/*\n        if (call _fn_isNullTarget) exitWith {\n            [[_turret,\" stopped waiting on null target #1\"],false] call KISKA_fnc_log;\n            true\n        };\n*/\n        call _fn_updateTargetPos;\n        _turret lookAt _targetPos;\n\n        //// turret pitch\n        // get turrets pitch angle (0.6 offset is baked into source anim)\n        _turretPitchAngle = abs ((deg (_turret animationSourcePhase \"maingun\")) + 0.6);\n        // get the angle needed to target\n        _angleToTarget = abs (acos ((_turret distance2D _target) / (_turret distance _target)));\n        // get the difference between turrets current pitch and the targets actual angle\n        _currentPitchTolerance = (selectMax [_turretPitchAngle,_angleToTarget]) - (selectMin [_turretPitchAngle,_angleToTarget]);\n        [[\"_turret: \",_turret,\" _turretPitchAngle: \",_turretPitchAngle,\" _angleToTarget: \",_angleToTarget,\" _currentPitchTolerance: \",_currentPitchTolerance],false] call KISKA_fnc_log;\n\n        //// turret rotation\n        // get turrets rotational angle\n        _turretVector = _turret weaponDirection (currentWeapon _turret);\n        _turretDir = (_turretVector select 0) atan2 (_turretVector select 1);\n        _turretDir = [_turretDir] call CBA_fnc_simplifyAngle;\n        // get relative rotational angle to the target\n        _relativeDir = _turret getDir _target;\n        // get the degree between where the target is at relative to the turret position and its actual gun\n        _currentRotTolerance = (_turretDir max _relativeDir) - (_turretDir min _relativeDir);\n        [[\"_turret: \",_turret,\" _turretVector: \",_turretVector,\" _turretDir: \",_turretDir,\" _relativeDir: \",_relativeDir,\" _currentRotTolerance: \",_currentRotTolerance],false] call KISKA_fnc_log;\n\n        // get target alt\n        call _fn_updateTargetPos;\n        _targetAlt = (ASLToAGL _targetPos) select 2;\n\n        if (call _fn_isNullTarget) exitWith {\n            [[_turret,\" stopped waiting on null target #2\"],false] call KISKA_fnc_log;\n            true\n        };\n\n        if (\n            (_currentPitchTolerance <= _pitchTolerance AND\n            {_currentRotTolerance <= _rotationTolerance} AND\n            {_targetALt >= _engageAboveAltitude})/* OR\n\n            {(_turret distance _target) >= (_searchDistance * 0.75)}*/\n        )\n        exitWith {\n            [[_turret,\" got an angle on \",_target],false] call KISKA_fnc_log;\n            true\n        };\n\n        sleep 0.25;\n        [[_turret,\" sleep 0.25\"],false] call KISKA_fnc_log;\n\n        false\n    };\n};\n\nprivate _fn_whileTargetsIncoming = {\n    [[_turret,\" found targets\"],false] call KISKA_fnc_log;\n\n    // while there are still targets in the air; this was orginally a simple for loop, but the alarm sound requires the extra complication of\n    /// searching for incoming projectiles constantly after the first is detected\n    while {\n        [[_turret,\" sleep 0.5, _fn_whileTargetsIncoming\"],false] call KISKA_fnc_log;\n        sleep 0.5;\n        call _fn_updateIncomingList;\n        // if projectiles are still incoming\n        if !(_incoming isEqualTo []) then {true} else {false}\n    } do {\n        // check if sound alarm requested and that the alarm is not already sounding\n        if (_soundAlarm AND {!(_turret getVariable [\"KISKA_CIWS_alarmSounding\",false])}) then {\n            // sound alarm\n            [_turret] spawn KISKA_fnc_ciwsAlarm;\n        };\n\n        [[_turret,\" searching through targets\"],false] call KISKA_fnc_log;\n        _targetIndex = _incoming findIf {\n            // check if another turret is already engaging the target\n            !((_x call BIS_fnc_netId) in KISKA_CIWS_engagedTargetsHash) AND\n            {(_x distance _turret) > 25}\n        };\n\n        if (_targetIndex != -1) then {\n            _target = _incoming select _targetIndex;\n            _targetNetId = _target call BIS_fnc_netId;\n            _targetDistance = _target distance _turret;\n\n            [[_turret,\" found target \",_target,\" at \",_targetDistance,\". Its netId is: \",_targetNetId],false] call KISKA_fnc_log;\n\n            call _fn_waitToFireOnTarget;\n\n            call _fn_fireAtTarget\n\n        } else {\n            [[_turret,\" target, \",_target,\" did not meet params\"],false] call KISKA_fnc_log;\n            //sleep 0.5;\n        };\n    };\n\n};\n\nprivate _fn_fireAtTarget = {\n    if (!(isNull _target) AND {(_turret distance _target) <= _searchDistance}) then {\n        [[_turret,\" got params met on \",_target],false] call KISKA_fnc_log;\n\n        // track if unit actually got off shots\n        _firedShots = false;\n        private _numberOfShots = random [50,100,150];\n        [[\"_numberOfShots is:\",_numberOfShots]] call KISKA_fnc_log;\n\n        private _shotMin = _numberOfShots / 3;\n        [[\"_shotMin is: \",_shotMin],false] call KISKA_fnc_log;\n\n        private _explodeAtShot = round (random [_shotMin,_shotMin * 2,_numberOfShots]);\n        [[\"_explodeAtShot is: \",_explodeAtShot],false] call KISKA_fnc_log;\n\n        private _didExplode = false;\n        private \"_engagedBy\";\n\n        for \"_i\" from 1 to _numberOfShots do {\n\n            if (isNull _target) then {\n                [[_turret,\" target became null\"],false] call KISKA_fnc_log;\n                break;\n            };\n\n            _engagedBy = KISKA_CIWS_engagedTargetsHash getOrDefault [_targetNetId, objNull];\n            [[_target,\" is currently engaged by \",_engagedBy,\". NetId is: \",_targetNetId],false] call KISKA_fnc_log;\n\n            // check if target was engaged by another turret\n            if (!(isNull _engagedBy) AND {_engagedBy isNotEqualTo _turret}) then {\n                [[_turret,\" will not engage \",_target,\"; It's already being engaged by \",_engagedBy],false] call KISKA_fnc_log;\n                break;\n            };\n\n            // keep watching target\n            _turret lookAt _target;\n            _turretPitchAngle = (deg (_turret animationSourcePhase \"maingun\")) + 0.6;\n\n            // only fire above specified angle\n            if (_turretPitchAngle >= _doNotFireBelowAngle) then {\n                // ensure target is not engaged by other turrets\n                if (isNull _engagedBy) then {\n                    [[_turret,\" is set to engage \",_target,\". NetId is: \",_targetNetId],false] call KISKA_fnc_log;\n                    KISKA_CIWS_engagedTargetsHash set [_targetNetId,_turret];\n                };\n\n                // turret shoots 1 round\n                _turret fireAtTarget [_target,currentWeapon _turret];\n\n                // create explosion\n                if (!_didExplode AND {_i >= _explodeAtShot}) then {\n                    [\"Reached explosion, updating target pos\",false] call KISKA_fnc_log;\n                    call _fn_updateTargetPos;\n\n                    // delay explosion because bullets take time to reach their target\n                    if (!isNull _target) then {\n                        [[\"Creating an explosion for target \",_target,\" for turret \",_turret]] call KISKA_fnc_log;\n\n                        [_turret,_targetPos] spawn {\n                            params [\"_turret\",\"_targetPos\"];\n\n                            // bullet travels about 1m every 0.0005s\n                            private _sleep = (EXPLOSION_DELAY_CONST * (_turret distance _targetPos));\n                            sleep _sleep;\n                            createVehicle [\"HelicopterExploBig\",ASLToAGL _targetPos,[],0,\"FLY\"];\n                        };\n\n                        // stop target so it doesn't hit something\n                        _target setVelocity [0,0,0];\n                    };\n\n                    _didExplode = true;\n                };\n\n                // update if unit fired\n                if (!_firedShots) then {\n                    _firedShots = true;\n                };\n\n                [[_turret,\" fired at \",_target,\" shot number \",_i],false] call KISKA_fnc_log;\n            };\n\n            sleep 0.01;\n        };\n\n        // reset lookAt\n        _turret lookAt objNull;\n        // sometimes the turret locks up in its aiming animations (becomes slow to aim)\n        // this is used as a sort of reset\n        _turret disableAI \"WEAPONAIM\";\n\n        if (\n            !(isNull _target) AND\n            {_firedShots} AND\n            {KISKA_CIWS_engagedTargetsHash getOrDefault [_targetNetId, objNull] isEqualTo _turret}\n        ) then {\n            triggerAmmo _target;\n\n            // remove from target hash\n            [[\"Removed turret \",_turret,\" from target hash for target \",_target,\" with a netId of: \",_targetNetId],false] call KISKA_fnc_log;\n            KISKA_CIWS_engagedTargetsHash deleteAt _targetNetId;\n\n            if (alive _target) then {\n                deleteVehicle _target;\n            };\n\n            [[_turret,\" destroyed target \",_target],false] call KISKA_fnc_log;\n        };\n\n    } else {\n        // reset lookAt\n        _turret lookAt objNull;\n        _turret disableAI \"WEAPONAIM\";\n\n        [[_turret,\" target \",_target,\" did not meet params\"],false] call KISKA_fnc_log;\n    };\n};\n\n\n_turret disableAI \"AutoTarget\";\n_turret disableAI \"Target\";\n\nwhile {alive _turret AND {_turret getVariable [\"KISKA_runCIWS\",true]}} do {\n    // get incoming projectiles\n    call _fn_updateIncomingList;\n\n    // if projectiles are present then proceed, else sleep\n    if !(_incoming isEqualTo []) then {\n        call _fn_whileTargetsIncoming;\n\n        // turn off alarm if used\n        if (_soundAlarm) then {\n            call _fn_checkIfStopAlarm\n        };\n\n    } else {\n        [[_turret,\" sleep 0.5, the target did not meet params\"],false] call KISKA_fnc_log;\n        sleep _searchInterval;\n    };\n};\n\nif (alive _turret) then {\n    _turret enableAI \"AutoTarget\";\n    _turret enableAI \"Target\";\n    // enable HC transfer\n    [group _turret,false] call KISKA_fnc_ACEX_setHCTransfer;\n};\n\n\nnil\n",
    "fileName": "fn_ciwsInit.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/CIWS/fn_ciwsInit.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ciwsSiren\n\nDescription:\n    Sounds a siren for the CIWS\n\nParameters:\n    0: _turret : <OBJECT> - The CIWS turret\n\nReturns:\n    Nothing\n\nExamples:\n    (begin example)\n        [turret1] spawn KISKA_fnc_ciwsSiren;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\n#define SIREN_DISTANCE 1000\n#define SIREN_VOLUME 2\n\nscriptName \"KISKA_fnc_ciwsSiren\";\n\nparams [\"_turret\"];\n\nif (_turret getVariable [\"KISKA_CIWS_sirenSounding\",false]) exitWith {\n    [[_turret,\" already has its siren sounding\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_turret setVariable [\"KISKA_CIWS_sirenSounding\",true];\n\nwaitUntil {\n    [\"KISKA_Siren\",_turret,SIREN_DISTANCE,SIREN_VOLUME] call KISKA_fnc_playSound3d;\n    sleep 8;\n    if (_turret getVariable \"KISKA_CIWS_allClear\") exitWith {true};\n\n    false\n};\n\n_turret setVariable [\"KISKA_CIWS_sirenSounding\",false];",
    "fileName": "fn_ciwsSiren.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/CIWS/fn_ciwsSiren.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_findConfigAny\n\nDescription:\n    Searchs `missionConfigFile`, `campaignConfigFile`, and the `configFile`\n     (in that order) to find a config based upon the sub paths provided.\n\n    Returns the first one it finds.\n\n    The BIS counterpart to this is `BIS_fnc_loadClass` and while it can be about 0.0005-0.0010ms\n     faster if the path is short (about 2 entries). It can yield about 0.005ms faster in various cases.\n\nParameters:\n    0: _pathArray : <STRING[]> - A config path broken up into individual pieces\n\nReturns:\n    <CONFIG> - The first config path if found or configNull if not\n\nExamples:\n    (begin example)\n        private _configPath = [[\"CfgMusic\",\"Music_Intro_02_MissionStart\"]] call KISKA_fnc_findConfigAny;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_findConfigAny\";\n\nparams [\n    [\"_pathArray\",[],[[]]]\n];\n\nif (_pathArray isEqualTo []) exitWith {\n    [\"_pathArray is empty array!\",true] call KISKA_fnc_log;\n    configNull\n};\n\nprivate _cache = localNamespace getVariable \"KISKA_findConfigAny_cache\";\nif (isNil \"_cache\") then {\n    _cache = createHashmap;\n    localNamespace setVariable [\"KISKA_findConfigAny_cache\",_cache];\n};\n\nprivate _cachedValue = _cache get _pathArray;\nif (!isNil \"_cachedValue\") exitWith { _cachedValue };\n\nprivate _configFound = false;\nprivate _configReturn = configNull;\n[missionConfigFile,campaignConfigFile,configFile] apply {\n    private _configPath = _x;\n    _pathArray apply {\n        // stop going down this config class path does not exist\n        private _path = _configPath >> _x;\n        if (isNull _path) then {\n            _configFound = false;\n            break;\n        };\n        _configPath = _path;\n        _configFound = true;\n    };\n\n    if (_configFound) then {\n        _configReturn = _configPath;\n        break;\n    };\n};\n\n\n_cache set [_pathArray,_configReturn];\n_configReturn\n",
    "fileName": "fn_findConfigAny.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Configs/fn_findConfigAny.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getConditionalConfigClass\n\nDescription:\n    Similar to `KISKA_fnc_getConfigDataConditional` except this will return the\n     selected conditional class's config instead of a given value in the class.\n    \n    The syntax for a conditional config:\n    (begin config example)\n        // `_conditionalConfigParent` param would be the config path to `MyClass`\n        class MyClass\n        {\n            class KISKA_conditional\n            {\n                cacheResult = 1; // defaults to true\n\n                class ExampleCondition_1\n                {\n                    // A list of addon directories (names) as they would appear in getLoadedModsInfo (case-insensitive).\n                    // All addons in the list must be loaded.\n                    addons[] = { \"A3\" };\n\n                    // A list of CfgPatches classNames that need to be present.\n                    patches[] = { \"A3_Data_F\"};\n\n                    // Uncompiled code that must return a boolean value.\n                    // `false` means the ExampleCondition_1's value will not be used\n                        // Parameters: \n                        // 0: <CONFIG> - The parent condition class (\"MyConditionalClass\")\n                        // 1: <CONFIG> - The current conditional class (`\"MyClass\" >> \"KISKA_conditional\" >> \"ExampleCondition_1\"`)\n                    condition = \"hint str _this; true\";\n\n                    // A class filled with the properties that you can get\n                    class properties\n                    {\n                        exampleProperty_1 = 1;\n                    };\n                };\n\n                class ExampleCondition_2\n                {\n                    class properties\n                    {\n                        exampleProperty_1 = 0;\n                        exampleProperty_2 = 1;\n                    };\n                };\n            };\n\n            exampleProperty_1 = \"default value\";\n        };\n    (end)\n\n    Configs will be prioritized in the order that they are defined. Meaning in the example above,\n     should both `ExampleCondition_1` and `ExampleCondition_2` be met, `ExampleCondition_1` will be used since it is\n     defined higher.\n\n    In the case that no conditional classes are met or none exist, the `_conditionalConfigParent`'s \n     scope will be searched for the property using `KISKA_fnc_getConfigData`.\n\n    The result of the value initially calculated after all the condition checks is by default \n     cached with the `cacheResult` property being interpreted as `true`. This means that the compilation\n     and run of the `condition` properties of the classes will be performed only once and that\n     value will be saved. \n\n    Should any of the conditional properties (`addons`,`patches`,`condition`) be excluded, they will simply \n     be treated as a `true` value. Meaning that if none of the properties are defined, the conditional class\n     will always be valid.\n\nParameters:\n    0: _conditionalConfigParent <CONFIG> - Default: `configNull` - The config path \n        to parse dynamic data from. This should include a class underneath it \n        named `KISKA_conditional`.\n\nReturns:\n    <CONFIG> - The conditional config class, `configNull` in the event a\n        config can't be found.\n\nExamples:\n    (begin example)\n        (missionConfigFile >> \"MyClass\") call KISKA_fnc_getConditionalConfigClass\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getConditionalConfigClass\";\n\nparams [\n    [\"_conditionalConfigParent\",configNull,[configNull]]\n];\n\n\nif (isNull _conditionalConfigParent) exitWith {\n    [\"null _conditionalConfigParent provided\",true] call KISKA_fnc_log;\n    configNull\n};\nprivate _conditionalConfig = _conditionalConfigParent >> \"KISKA_conditional\";\nif !(isClass _conditionalConfig) exitWith {\n    [\n        [\"No 'KISKA_conditional' class exists under\",_conditionalConfigParent],\n        false\n    ] call KISKA_fnc_log;\n    \n    _conditionalConfigParent\n};\n\n\nprivate _cachedResultMap = localNamespace getVariable \"KISKA_conditionalConfig_cachedResultMap\";\nif (isNil \"_cachedResultMap\") then {\n    _cachedResultMap = createHashMap;\n    localNamespace setVariable [\"KISKA_conditionalConfig_cachedResultMap\",_cachedResultMap];\n};\nif (_conditionalConfig in _cachedResultMap) exitWith {_cachedResultMap get _conditionalConfig};\n\n\n\n\n/* ----------------------------------------------------------------------------\n    Use cache if available\n---------------------------------------------------------------------------- */\nprivate _modDirectoriesLowered = uiNamespace getVariable \"KISKA_conditionalConfig_loadedMods\";\nif (isNil \"_modDirectoriesLowered\") then {\n    _modDirectoriesLowered = (call KISKA_fnc_getLoadedModsInfo) apply { \n        private _modDirectoryName = _x select 1;\n        toLowerANSI _modDirectoryName   \n    };\n    uiNamespace setVariable [\"KISKA_conditionalConfig_loadedMods\",_modDirectoriesLowered];\n};\n\nprivate _conditionalClassesMap = localNamespace getVariable \"KISKA_conditionalConfig_parsedConfigMap\";\nif (isNil \"_conditionalClassesMap\") then {\n    _conditionalClassesMap = createHashMap;\n    localNamespace setVariable [\"KISKA_conditionalConfig_parsedConfigMap\",_conditionalClassesMap];\n};\n\nprivate _alreadyParsedConfigs = _conditionalClassesMap get _conditionalConfig;\nprivate \"_conditionalConfigClass\";\nif !(isNil \"_alreadyParsedConfigs\") exitWith {\n    _alreadyParsedConfigs apply {\n        _x params [\"_parsedClass\",\"_condition\"];\n        _conditionArgs set [1,_parsedClass];\n\n        if (\n            (_condition call KISKA_fnc_isEmptyCode) OR \n            {[_conditionalConfig,_parsedClass] call _condition}\n        ) then {\n            _conditionalConfigClass = _parsedClass >> \"properties\";\n            break;\n        };\n    };\n\n    if (isNil \"_conditionalConfigClass\") exitWith { _conditionalConfigParent };\n    _conditionalConfigClass\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Create cache\n---------------------------------------------------------------------------- */\nprivate _conditionalConfigClasses = configProperties [_conditionalConfig,\"isClass _x\"];\n_alreadyParsedConfigs = [];\n_conditionalConfigClasses apply {\n    private _meetsStaticRequirements = true;\n\n    private _requiredPatches = getArray(_x >> \"patches\");\n    _requiredPatches apply {\n        if ([_x] call KISKA_fnc_isPatchLoaded) then { continue };\n        _meetsStaticRequirements = false;\n        break;\n    };\n    if !(_meetsStaticRequirements) then { continue };\n\n\n    private _requiredAddons = getArray(_x >> \"addons\");\n    _requiredAddons apply {\n        if ((toLowerANSI _x) in _modDirectoriesLowered) then { continue };\n        _meetsStaticRequirements = false;\n        break;\n    };\n    if !(_meetsStaticRequirements) then { continue };\n\n    \n    private _condition = compileFinal (getText(_x >> \"condition\"));\n    _alreadyParsedConfigs pushBack [_x,_condition];\n    if (\n        (isNil \"_conditionalConfigClass\") AND \n        {\n            (_condition call KISKA_fnc_isEmptyCode) OR \n            {[_conditionalConfig,_parsedClass] call _condition}\n        }\n    ) then { _conditionalConfigClass = _x >> \"properties\" };\n};\n_conditionalClassesMap set [_conditionalConfig,_alreadyParsedConfigs];\n\n\n\nif (isNil \"_conditionalConfigClass\") then { _conditionalConfigClass = _conditionalConfigParent };\n\nprivate _cacheResult = [\n    _conditionalClassConfig >> \"cacheResult\",\n    _isBool,\n    true\n] call KISKA_fnc_getConfigData;\nif (_cacheResult) then {\n    _cachedResultMap set [_conditionalConfig,_conditionalConfigClass];\n};\n\n\n_conditionalConfigClass\n",
    "fileName": "fn_getConditionalConfigClass.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Configs/fn_getConditionalConfigClass.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getConfigData\n\nDescription:\n    Retrieves the value located at a given config path.\n\n    Faster than BIS_fnc_getCfgData.\n\nParameters:\n    0: _config <CONFIG> - Default: `configNull` - The config path to get data from\n    1: _isBool <BOOL> - Default: `false` - Will convert a number value into a `BOOL`. If the value\n        is more than `0`, the it will be `true`. Any values `<= 0` will be `false`\n    2: _defaultValue <NUMBER | STRING | ARRAY | BOOL | NIL> - Default: `nil` -\n        In the event that the config value is undefined, this value will be returned.\n\nReturns:\n    <NUMBER | STRING | ARRAY | BOOL | NIL> - The value at the given config path, \n        `nil` if undefined and no default value is provided.\n\nExamples:\n    (begin example)\n        private _value = [\n            configFile >> \"CfgVehicles\" >> \"Car\" >> \"displayname\"\n        ] call KISKA_fnc_getConfigData;\n    (end)\n\n    (begin example)\n        private _defaultZeroValue = [\n            configFile >> \"null\" >> \"config\",\n            false,\n            0\n        ] call KISKA_fnc_getConfigData;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getConfigData\";\n\nparams [\n    [\"_config\",configNull,[configNull]],\n    [\"_isBool\",false,[true]],\n    [\"_defaultValue\",nil,[true,123,\"\",[]]]\n];\n\nif (isNull _config) exitWith { \n    // nil values as a variable can sometimes throw errors\n    if (isNil \"_defaultValue\") exitWith {};\n    _defaultValue \n};\nif (isNumber _config) exitWith {\n    private _return = getNumber _config;\n    if (_isBool) then {\n        _return = _return > 0;\n    };\n    _return\n};\nif (isText _config) exitWith { getText _config };\nif (isArray _config) exitWith { getArray _config };\n\n\n_defaultValue\n",
    "fileName": "fn_getConfigData.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Configs/fn_getConfigData.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getConfigDataConditional\n\nDescription:\n    Retrieves the conditional value located in a given config. This code will cache\n     configs and their values after being run once within the `localNamespace`.\n\n    An important note, **only** the highest priority conditional classes' values \n     will be retrievable. \n\n    See `KISKA_fnc_getConditionalConfigClass` for more details in the selection \n     of a conditional class.\n\nParameters:\n    0: _conditionalConfigParent <CONFIG> - Default: `configNull` - The config path to parse dynamic data from.\n        This should include a class underneath it named `KISKA_conditional`.\n    1: _property <STRING> - Default: `\"\"` - The config path to parse dynamic data from\n    2: _isBool <BOOL> - Default: `false` - Will convert a number value into a `BOOL`. If the value\n        is more than `0`, the it will be `true`. Any values `<= 0` will be `false`\n    3: _defaultValue <NUMBER | STRING | ARRAY | BOOL | NIL> - Default: `nil` -\n        In the event that the config value is undefined, this value will be returned.\n\nReturns:\n    <NUMBER | STRING | ARRAY | BOOL> - The value for the given conditional config.\n     `nil` in cases where config value is not found or no conditions are met.\n\nExamples:\n    (begin example)\n        private _value = [\n            missionConfigFile >> \"KISKA_Bases\" >> \"MyBase\",\n            \"myProperty\"\n        ] call KISKA_fnc_getConfigDataConditional;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getConfigDataConditional\";\n\nparams [\n    [\"_conditionalConfigParent\",configNull,[configNull]],\n    [\"_property\",\"\",[\"\"]],\n    [\"_isBool\",false,[true]],\n    [\"_defaultValue\",nil,[true,123,\"\",[]]]\n];\n\nprivate _conditionalConfig = _conditionalConfigParent call KISKA_fnc_getConditionalConfigClass;\nif (isNil \"_defaultValue\") exitWith {\n    [_conditionalConfig >> _property,_isBool] call KISKA_fnc_getConfigData\n};\n\n[_conditionalConfig >> _property,_isBool,_defaultValue] call KISKA_fnc_getConfigData\n",
    "fileName": "fn_getConfigDataConditional.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Configs/fn_getConfigDataConditional.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMostSpecificCfgValue\n\nDescription:\n    Picks the most specific value from a list of configs properties to check.\n\nParameters:\n    0: _property <STRING> - The config property to search for in all of the classes\n    1: _configs <ARRAY> - An array of CONFIGs that you would like to look for the\n        property. These should be within the same configHierarchy.\n    2: _ignoredValues <ARRAY of ARRAY, NUMBER, or STRING> - A list of invalid values\n        for the property to have in order to be ignored. (strings should be lowercase)\n        (NIL will always be ignored)\n    3: _ignoredTypes <ARRAY of ARRAY, NUMBER, or STRING> - A list of invalid types for the property\n\nReturns:\n    <NIL, ARRAY, NUMBER, or STRING> - The config value returned by the most specific config passed\n        that is valid.\n\nExamples:\n    (begin example)\n        private _valueFromMostSpecificClass = [\n            \"myProperty\"\n            [\n                missionConfigFile >> \"SomeClass\",\n                missionConfigFile >> \"SomeClass\" >> \"SomeSubClass\",\n                missionConfigFile >> \"SomeClass\" >> \"SomeSubClass\" >> \"SomeFurtherSubClass\",\n            ],\n            [\"\"], // shouldn't be an empty string,\n            [123] // ignore number properties\n        ] call KISKA_fnc_getMostSpecificCfgValue;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMostSpecificCfgValue\";\n\nparams [\n    [\"_property\",\"\",[\"\"]],\n    [\"_configs\",[],[[]]],\n    [\"_ignoredValues\",0,[123,[],\"\"]],\n    [\"_ignoredTypes\",[],[[]]]\n];\n\nif (_property isEqualTo \"\") exitWith {\n    [\"_property is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate \"_mostSpecificValue\";\nprivate _mostSpecificHierarchyCount = -1;\n_configs apply {\n    if !(_x isEqualType configNull) then {continue};\n    if (isNull _x) then {continue};\n\n    private _hierarchyCount = count (configHierarchy _x);\n    if (_hierarchyCount <= _mostSpecificHierarchyCount) then {continue};\n\n    private _propertyValue = (_x >> _property) call BIS_fnc_getCfgData;\n    if (\n        isNil \"_propertyValue\" OR\n        {_propertyValue isEqualTypeAny _ignoredTypes}\n    ) then {continue};\n\n    private _propertyValueCompare = _propertyValue;\n    if (_propertyValueCompare isEqualType \"\") then {\n        _propertyValueCompare = toLower _propertyValueCompare\n    };\n    if (_propertyValueCompare in _ignoredValues) then {continue};\n\n    _mostSpecificValue = _propertyValue;\n    _mostSpecificHierarchyCount = _hierarchyCount;\n};\n\n// returning _mostSpecificValue in the case of it being nil causes errors\nif (isNil \"_mostSpecificValue\") exitWith { nil };\n_mostSpecificValue\n",
    "fileName": "fn_getMostSpecificCfgValue.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Configs/fn_getMostSpecificCfgValue.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hasConditionalConfig\n\nDescription:\n    Checks if the given config (class) has a class underneath it named `KISKA_conditional`\n     making it eligible to be used with `KISKA_fnc_getConfigDataConditional`.\n\n    (begin config example)\n        class MyConfig\n        {\n            class KISKA_conditional // returns true\n            {\n                // ...\n            };\n        };\n    (end)\n\nParameters:\n    0: _conditionalConfigParent <CONFIG> - Default: `configNull` - The config path to \n        check whether or not it has a conditional class.\n\nReturns:\n    <BOOL> - Whether or not the config has a conditional class.\n\nExamples:\n    (begin example)\n        private _hasConditionalClass = [\n            missionConfigFile >> \"MyConfig\"\n        ] call KISKA_fnc_hasConditionalConfig;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hasConditionalConfig\";\n\nparams [\n    [\"_conditionalConfigParent\",configNull,[configNull]]\n];\n\n\nisClass(_conditionalConfigParent >> \"KISKA_conditional\")\n",
    "fileName": "fn_hasConditionalConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Configs/fn_hasConditionalConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_addVehicle\n\nDescription:\n    Adds a given vehicle to a convoy. The index returned will be a key to the\n     _convoyHashMap that can be used to get the vehicle for that index in the convoy.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to add to\n    1: _vehicle <OBJECT> - The vehicle to add\n    2: _insertIndex <NUMBER> - The index to insert the vehicle into the convoy at. \n        Negative value means the back.\n        (0 is lead vehicle, 1 is vehicle directly behind leader, etc.)\n\n    3: _convoySeperation <NUMBER> - How far the vehicle should keep from the \n        vehicle in front (min of 10)\n\nReturns:\n    <NUMBER> - The index the vehicle was inserted into the convoy at\n\nExamples:\n    (begin example)\n        private _convoyMap = [] call KISKA_fnc_convoy_create;\n        private _spotInConvoy = [\n            _convoyMap,\n            vic\n        ] call KISKA_fnc_convoy_addVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_addVehicle\";\n\n#define MAX_ARRAY_LENGTH 1E7\n#define MIN_COMPLETION_BOX_WIDTH 5\n#define MIN_COMPLETION_BOX_LENGTH 5\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nparams [\n    [\"_convoyHashMap\",nil,[createHashMap]],\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_insertIndex\",-1,[123]],\n    [\"_convoySeperation\",-1,[123]]\n];\n\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [\"nil _convoyHashMap passed\",true] call KISKA_fnc_log;\n    -1\n};\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",true] call KISKA_fnc_log;\n    -1\n};\n\nprivate _driver = driver _vehicle;\nif !(alive _driver) exitWith {\n    [[\"_vehicle \",_vehicle,\" does not have an alive driver\"],false] call KISKA_fnc_log;\n    -1\n};\n\nprivate _convoyStatemachine = _convoyHashMap get \"_stateMachine\";\nif (isNil \"_convoyStatemachine\") exitWith {\n    [[\"_stateMachine is not defined in map: \",_convoyHashMap],true] call KISKA_fnc_log;\n    -1\n};\n\nprivate _convoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n// there can be times where there is a slight amount of speed in a (mostly) stationary vehicle\nif ((speed _convoyLead) > 0.5) exitWith {\n    [[\"_convoyLead \",_convoyLead,\" is moving, must be stopped to add vehicles to the convoy\"]] call KISKA_fnc_log;\n    -1\n};\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\nif (_vehicle in _convoyVehicles) exitWith {\n    [[\"_vehicle \",_vehicle,\" is already in _convoyHashMap \",_convoyHashMap],true] call KISKA_fnc_log;\n    [_vehicle] call KISKA_fnc_convoy_getVehicleIndex\n};\n\n\n\nprivate _convoyCount = count _convoyVehicles;\nprivate _indexToCopyFrom = -1;\nprivate \"_convoyIndex\";\nif (_insertIndex < 0) then {\n    _convoyIndex = _convoyVehicles pushBack _vehicle;\n    _convoyHashMap set [_convoyIndex,_vehicle];\n\n    if (_convoyIndex isEqualTo 1) exitWith {};\n\n    _indexToCopyFrom = _convoyIndex - 1;\n\n} else {\n    private _vehiclesToChangeIndex = _convoyVehicles select [_insertIndex,MAX_ARRAY_LENGTH];\n    \n    _convoyVehicles resize _insertIndex;\n    _convoyIndex = _convoyVehicles pushBack _vehicle;\n    _convoyVehicles append _vehiclesToChangeIndex;\n    _convoyHashMap set [_convoyIndex,_vehicle];\n\n    _vehiclesToChangeIndex apply {\n        private _currentIndex = [_x] call KISKA_fnc_convoy_getVehicleIndex;\n        if (_currentIndex isEqualTo -1) then {\n            [[\"Could not find 'KISKA_convoy_index' in namespace of \", _x,\" to change\"],true] call KISKA_fnc_log;\n            continue\n        };\n\n        private _newIndex = _currentIndex + 1;\n        _convoyHashMap set [_newIndex,_x];\n        _x setVariable [\"KISKA_convoy_index\",_newIndex];\n    };\n\n    _indexToCopyFrom = _insertIndex;\n\n}; \n\n_vehicle setVariable [\"KISKA_convoy_drivePath\",[]];\nif (_indexToCopyFrom isNotEqualTo -1) then {\n    private _vehicleToCopyPathFrom = [\n        _convoyHashMap,\n        _indexToCopyFrom\n    ] call KISKA_fnc_convoy_getVehicleAtIndex;\n\n\n    [\n        _vehicle,\n        -1,\n        [_vehicleToCopyPathFrom] call KISKA_fnc_convoy_getVehicleDrivePath\n    ] call KISKA_fnc_convoy_modifyVehicleDrivePath;\n\n    private _lastAddedPointInDrivePath = [_vehicleToCopyPathFrom] call KISKA_fnc_convoy_getVehicleLastAddedPoint;\n    // if vehicles are added at a convoy inception, this point is often not defined yet for some vehicles\n    if !(isNil \"_lastAddedPointInDrivePath\") then {\n        _vehicle setVariable [\"KISKA_convoy_lastAddedPoint\",_lastAddedPointInDrivePath];\n    };\n\n} else {\n    _vehicle setVariable [\"KISKA_convoy_drivePath\",[]];\n};\n\n\nprivate _vehicleDimensions = [_vehicle] call KISKA_fnc_getBoundingBoxDimensions;\n_vehicleDimensions params [\"_width\",\"_length\",\"_height\"];\n// Not using half dimensions here because of the desire to have\n// the width and height doubled for making sure vehicles\n// don't accidentaly miss a point.\n_vehicle setVariable [\n    \"KISKA_convoy_vehicleCompletionArea\",\n    [\n        [],\n        _width max MIN_COMPLETION_BOX_WIDTH,\n        _length,\n        0,\n        true,\n        _height\n    ]\n];\n\n_vehicle setVariable [\"KISKA_convoy_vehicleAreaOffset\",[0,_length / 2,0]];\n\n[_vehicle,true] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n[_vehicle,false] call KISKA_fnc_convoy_clearVehicleDebugFollowedPath;\n[_vehicle,false] call KISKA_fnc_convoy_clearVehicleDebugFollowPath;\n\n\n_vehicle setVariable [\"KISKA_convoy_hashMap\",_convoyHashMap];\n_vehicle setVariable [\"KISKA_convoy_index\",_convoyIndex];\nif (_convoySeperation < 0) then {\n    _convoySeperation = [\n        _convoyHashMap\n    ] call KISKA_fnc_convoy_getDefaultSeperation;\n};\n\n[\n    _vehicle,\n    _convoySeperation\n] call KISKA_fnc_convoy_setVehicleSeperation;\n\n\n[_vehicle] call KISKA_fnc_convoy_addVehicleKilledEvent;\n\n_vehicle setVariable [\"KISKA_convoy_unitGetOutTimesHashMap\",createHashMap];\nprivate _getOutEventHandlerId = _vehicle addEventHandler [\"GetOut\",{\n    params [\"_vehicle\", \"\", \"_unit\"];\n\n    private _unitGetOutTimeHashMap = _vehicle getVariable \"KISKA_convoy_unitGetOutTimesHashMap\";\n    if !(isNil \"_getOutTimeHashMap\") then {\n        [\n            _unitGetOutTimeHashMap,\n            _unit,\n            time\n        ] call KISKA_fnc_hashmap_set;\n    };\n}];\n\n_vehicle setVariable [\"KISKA_convoy_getOutEventHandlerId\",_getOutEventHandlerId];\n\n\n_convoyIndex\n",
    "fileName": "fn_convoy_addVehicle.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_addVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_addVehicleKilledEvent\n\nDescription:\n    Adds a killed event handler to a given vehicle in a convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to add the killed eventhandler to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_addVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_addVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _vehicleKilledEventId = _vehicle addMPEventHandler [\"MPKILLED\", {\n    if (isServer) then {\n        _this params [\"_vehicle\"];\n\n        private _convoyHashMap = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getConvoyHashMapFromVehicle;\n\n        if (isNil \"_convoyHashMap\") then {\n            [[\"_convoyHashMap was nil, event was for _vehicle: \",_vehicle],true] call KISKA_fnc_log;\n\n        } else {\n            private _function = [\n                _vehicle\n            ] call KISKA_fnc_convoy_getVehicleKilledEvent;\n            private _convoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n\n            [\n                _vehicle,\n                _convoyHashMap,\n                _convoyLead\n            ] call _function;\n\n        };\n    };\n\n}];\n\n_vehicle setVariable [\"KISKA_convoy_vehicleKilledEventID\",_vehicleKilledEventId];\n",
    "fileName": "fn_convoy_addVehicleKilledEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_addVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_clearVehicleDebugFollowPath\n\nDescription:\n\tClears a vehicle's current debug follow path objects array. \n\n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions currently in the vehicle's drive path. This is the follow\n     path. \n    \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to clear the debug follow path of\n    1: _deleteExisting <BOOL> - Whether or not to delete the objects that are\n        currently in the array\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t[_vehicle] call KISKA_fnc_convoy_clearVehicleDebugFollowPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_clearVehicleDebugFollowPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_deleteExisting\",true,[true]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_deleteExisting) then {\n    ([_vehicle] call KISKA_fnc_convoy_getVehicleDebugFollowPath) apply {\n        deleteVehicle _x;\n    };\n};\n_vehicle setVariable [\"KISKA_convoy_debug_followPathObjects\",[]];\n",
    "fileName": "fn_convoy_clearVehicleDebugFollowPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_clearVehicleDebugFollowPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_clearVehicleDebugFollowedPath\n\nDescription:\n\tClears a vehicle's current debug followed path objects array. \n\n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions the vehicle had followed while on its drive path. One \n     followed object is created each time a drive path point is considered \"complete\"\n     (vehicle within a radius of that point).\n    \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to clear the debug followed path of\n    1: _deleteExisting <BOOL> - Whether or not to delete the objects that are\n        currently in the array\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t[_vehicle] call KISKA_fnc_convoy_clearVehicleDebugFollowedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_clearVehicleDebugFollowedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_deleteExisting\",true,[true]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_deleteExisting) then {\n    ([_vehicle] call KISKA_fnc_convoy_getVehicleDebugFollowedPath) apply {\n        deleteVehicle _x;\n    };\n};\n_vehicle setVariable [\"KISKA_convoy_debug_followedPathObjects\",[]];\n",
    "fileName": "fn_convoy_clearVehicleDebugFollowedPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_clearVehicleDebugFollowedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_create\n\nDescription:\n    Creates an advanced KISKA convoy. Vehicles should be already physically placed in the order\n     that they intend to travel in. If creating in an urban setting, ensure vehicles \n     are in a straight line so that they do not initially crash into a building.\n    \n    This will create a CBA statemachine that processes one vehicle a frame. It manages the speed\n     of the vehicle relative to the vehicle in front to keep a desired spacing between them. \n     The space between each vehicle can be customized for that specific vehicle or any \n     individual one.\n    \n    The first vehicle added to the convoy WILL NOT have its movement managed in any capacity.\n     All other vehicles will essentially follow the path of the lead vehicle. You should \n     limit the speed and control the path of the lead vehicle for your specific use case.\n\n    A convoy requires at least one vehicle (the lead vehicle) to be valid at any given moment.\n     It will be automatically deleted otherwise.\n\nParameters:\n    0: _vics <OBJECT[]> - An array of convoy vehicles (that are in their travel order)\n    1: _convoySeperation <NUMBER> - The distance between each vehicle for the convoy (min of 10)\n\nReturns:\n    <HASHMAP> - A hash map containing data pertinent to the convoy's operation\n\nExamples:\n    (begin example)\n        private _convoyHashMap = [\n            [leadVehicle],\n            10\n        ] call KISKA_fnc_convoy_create;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_create\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n\t[\"_vics\",[],[[]]],\n    [\"_convoySeperation\",20,[123]]\n];\n\n\nif (_convoySeperation < 10) then {\n    _convoySeperation = 10;\n};\n\nprivate _stateMachine = [\n    [],\n    true\n] call CBA_stateMachine_fnc_create;\n\n\nprivate _convoyHashMap = createHashMap;\n// when using skip null in CBA_stateMachine_fnc_create\n// a new array will be created and saved in the statemachine's namespace\nprivate _convoyVehicles = _stateMachine getVariable \"CBA_statemachine_list\";\n_convoyHashMap set [\"_convoyVehicles\",_convoyVehicles];\n_convoyHashMap set [\"_speedLimitPoints\",createHashMap];\n\n_convoyHashMap set [\"_stateMachine\",_stateMachine];\n// set to default value\n[_convoyHashMap] call KISKA_fnc_convoy_setPointBuffer;\n[_convoyHashMap,_convoySeperation] call KISKA_fnc_convoy_setDefaultSeperation;\n\n_vics apply {\n    [\n        _convoyHashMap,\n        _x\n    ] call KISKA_fnc_convoy_addVehicle;\n};\n\n\nprivate _mainState = [\n    _stateMachine,\n    KISKA_fnc_convoy_onEachFrame\n] call CBA_stateMachine_fnc_addState;\n\n\n_convoyHashMap\n",
    "fileName": "fn_convoy_create.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_create.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_delete\n\nDescription:\n    Deletes an instance of a KISKA convoy. All vehicles (that aren't the lead)\n\t will halt. This can be executed at any time on a convoy.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to add to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _convoyHashMap = [\n            [leadVehicle],\n            10\n        ] call KISKA_fnc_convoy_create;\n        // some time later...\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_delete\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_convoyHashMap\",nil]\n];\n\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [\"_convoyHashMap is nil\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _convoyVehicles = [\n\t_convoyHashMap\n] call KISKA_fnc_convoy_getConvoyVehicles;\n_convoyVehicles apply {\n\t[_x] call KISKA_fnc_convoy_removeVehicle;\n};\n\nprivate _convoyStatemachine = [\n    _convoyHashMap\n] call KISKA_fnc_convoy_getConvoyStatemachine;\n[_convoyStatemachine] call CBA_statemachine_fnc_delete;\n\n\n(keys _convoyHashMap) apply { _convoyHashMap deleteAt _x };\n\nnil\n",
    "fileName": "fn_convoy_delete.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_delete.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getBumperPosition\n\nDescription:\n    Gets the positionWorld of a vehicles front or rear bumper.\n    This function caches values in a hashmap for use in the frame by frame calls\n     in KISKA's advanced convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the bumper position of\n    1: _isRearBumper <BOOL> - True for rear bumper, false for front bumper\n\nReturns:\n    <PositionWorld> - The world position of the vehicle's bumper\n\nExamples:\n    (begin example)\n        private _rearBumperPositionWorld = [vic,true] call KISKA_fnc_convoy_getBumperPosition;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getBumperPosition\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_isRearBumper\",false,[true]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",false] call KISKA_fnc_log;\n    [0,0,0]\n};\n\n\nprivate _hashMapId = \"KISKA_convoy_vehicleRelativeRearHashMap\";\nif (!_isRearBumper) then {\n    _hashMapId = \"KISKA_convoy_vehicleRelativeFrontHashMap\";\n};\n\nprivate _relativePointHashMap = localNamespace getVariable _hashMapId;\nif (isNil \"_relativePointHashMap\") then {\n    _relativePointHashMap = createHashMap;\n    localNamespace setVariable [_hashMapId,_relativePointHashMap];\n};\n\n\nprivate _vehicleType = typeOf _vehicle;\nprivate _relativeBumperPosition = _relativePointHashMap get _vehicleType;\n\nif !(isNil \"_relativeBumperPosition\") exitWith {\n    _vehicle modelToWorldVisualWorld _relativeBumperPosition\n};\n\n\n_relativeBumperPosition = [_vehicle,_isRearBumper] call KISKA_fnc_getBumperPositionRelative;\n_relativePointHashMap set [_vehicleType,_relativeBumperPosition];\n\n\n_vehicle modelToWorldVisualWorld _relativeBumperPosition\n",
    "fileName": "fn_convoy_getBumperPosition.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getBumperPosition.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyHashMapFromVehicle\n\nDescription:\n    Gets the corresponding hashmap of a convoy for a particular vehicle.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy hashmap of\n\nReturns:\n    <HASHMAP> - The hashmap of the convoy this vehicle belongs to \n        (nil in the case of the vehicle not belonging to a convoy)\n\nExamples:\n    (begin example)\n        private _convoyHashMap = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getConvoyHashMapFromVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyHashMapFromVehicle\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable \"KISKA_convoy_hashMap\"\n",
    "fileName": "fn_convoy_getConvoyHashMapFromVehicle.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getConvoyHashMapFromVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyLeader\n\nDescription:\n    Gets the lead vehicle in a convoy. The convoy lead does not have his movement\n     regulated in any way by the advanced convoy system and will be the vehicle that\n     other units in the convoy follow.\n         \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n\nReturns:\n    <OBJECT> - The lead vehicle in the convoy\n\nExamples:\n    (begin example)\n        private _convoyLeader = [\n            _convoyHashMap\n\t\t] call KISKA_fnc_convoy_getConvoyLeader;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyLeader\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    objNull\n};\n\nparams [\"_convoyHashMap\"];\n\n\n_convoyHashMap getOrDefault [0,objNull]\n",
    "fileName": "fn_convoy_getConvoyLeader.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getConvoyLeader.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyStatemachine\n\nDescription:\n    Returns the CBA statemachine used to control convoy movement and speed. \n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap get the statemachine from\n\nReturns:\n    <LOCATION> - The CBA statemachine\n\nExamples:\n    (begin example)\n        private _convoyStatemachine = [\n            SomeConvoyHashMap\n        ] call KISKA_fnc_convoy_getConvoyStatemachine;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyStatemachine\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    locationNull\n};\n\nparams [\"_convoyHashMap\"];\n\n\n_convoyHashMap getOrDefault [\"_stateMachine\",locationNull]\n",
    "fileName": "fn_convoy_getConvoyStatemachine.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getConvoyStatemachine.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyVehicles\n\nDescription:\n    Returns the list of vehicles in a convoy. This is not a copy of the array used\n     for certain internal operations of the convoy. Make a copy if you intend to modify\n     the contents of the array (see example 2).\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap get vehicles from\n    1: _fromIndex <NUMBER> - If provided, only the vehicles from (and including) the\n        the given index will be returned\n\nReturns:\n    <OBJECT[]> - an array containing each vehicle (in there convoy order)\n\nExamples:\n    (begin example)\n        private _convoyVehicles = [\n            SomeConvoyHashMap\n        ] call KISKA_fnc_convoy_getConvoyVehicles;\n    (end)\n\n    (begin example)\n        private _convoyVehiclesCopy = +([\n            SomeConvoyHashMap\n        ] call KISKA_fnc_convoy_getConvoyVehicles);\n    (end)\n    \n    (begin example)\n        private _startingIndex = 1;\n        private _allVehiclesButLeader = [\n            SomeConvoyHashMap,\n            _startingIndex\n        ] call KISKA_fnc_convoy_getConvoyVehicles;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyVehicles\";\n\n#define MAX_ARRAY_LENGTH 1E7\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_fromIndex\",-1,[123]]\n];\n\nprivate _vehicles = _convoyHashMap getOrDefault [\"_convoyVehicles\",[]];\nif (_fromIndex <= 0) exitWith {_vehicles};\n\n\n_vehicles select [_fromIndex,MAX_ARRAY_LENGTH]\n",
    "fileName": "fn_convoy_getConvoyVehicles.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getConvoyVehicles.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setDefaultSeperation\n\nDescription:\n    Gets the default seperation between NEWLY added vehicles to a convoy.\n    \n\tThis is the seperation that vehicles will get by default when they are\n\t added to the convoy.\n    \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n\nReturns:\n    <NUMBER> - The default sepration between newly added convoy vehicles\n\nExamples:\n    (begin example)\n        private _defaultSeperation = [\n            _convoyHashMap\n\t\t] call KISKA_fnc_convoy_getDefaultSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getDefaultSeperation\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\"_convoyHashMap\"];\n\n_convoyHashMap getOrDefault [\"_convoySeperation\",20]\n",
    "fileName": "fn_convoy_getDefaultSeperation.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getDefaultSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getPointBuffer\n\nDescription:\n    Gets the minimum distance that must be between each position added to a vehicles\n     drive path. Essentially how often the lead vehicle's position is recorded.\n    \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n\nReturns:\n    <NUMBER> - The minimum distance between each drive path point\n\nExamples:\n    (begin example)\n        private _minBufferBetweenPoints = [\n            _convoyHashMap\n\t\t] call KISKA_fnc_convoy_getPointBuffer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getPointBuffer\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\"_convoyHashMap\"];\n\n\n_convoyHashMap getOrDefault [\"_minBufferBetweenPoints\",3]\n",
    "fileName": "fn_convoy_getPointBuffer.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getPointBuffer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleAtIndex\n\nDescription:\n    Gets the a vehicle at the specified index of a convoy. \n    \n    For example, the convoy leader is the vehicle at index 0 \n     and the vehicle directly behind the leader is index 1.\n         \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n    1: _index <NUMBER> - The convoy hashmap to get the value from\n\nReturns:\n    <OBJECT> - The vehicle at the desired index\n\nExamples:\n    (begin example)\n        private _convoyLeader = [\n            _convoyHashMap,\n            0\n\t\t] call KISKA_fnc_convoy_getVehicleAtIndex;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleAtIndex\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    objNull\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_index\",1,[123]]\n];\n\n\n_convoyHashMap getOrDefault [_index,objNull]\n",
    "fileName": "fn_convoy_getVehicleAtIndex.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleAtIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugFollowPath\n\nDescription:\n    Gets a given convoy vehicle's current debug follow path.\n    \n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions currently in the vehicle's drive path. This is the follow\n     path. \n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the follow path of\n\nReturns:\n    <OBJECT[]> - An array of the vehicle's follow path objects\n\nExamples:\n    (begin example)\n        private _debugFollowPathObjects = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugFollowPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugFollowPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_debug_followPathObjects\",[]]\n",
    "fileName": "fn_convoy_getVehicleDebugFollowPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleDebugFollowPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugFollowedPath\n\nDescription:\n    Gets a vehicle's current debug followed path objects array. \n    \n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions the vehicle had followed while on its drive path. One \n     followed object is created each time a drive path point is considered \"complete\"\n     (vehicle within a radius of that point).\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the follow path of\n\nReturns:\n    <OBJECT[]> - An array of the vehicle's followed path objects\n\nExamples:\n    (begin example)\n        private _debugFollowedPathObjects = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugFollowedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugFollowedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_debug_followedPathObjects\",[]]\n",
    "fileName": "fn_convoy_getVehicleDebugFollowedPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleDebugFollowedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath\n\nDescription:\n    Gets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the marker type of\n\nReturns:\n    <STRING> - The classsName used for the 3d debug marker of the follow path\n     of the given convoy vehicle.\n\nExamples:\n    (begin example)\n        private _followPathMarkerType = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\n    \"KISKA_convoy_debugMarkerType_followPath\",\n    \"Sign_Arrow_Large_Cyan_F\"\n]\n",
    "fileName": "fn_convoy_getVehicleDebugMarkerType_followPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleDebugMarkerType_followPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugMarkerType_followedPath\n\nDescription:\n    Sets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the marker type of\n\nReturns:\n    <STRING> - The classsName used for the 3d debug marker of the followed path\n     of the given convoy vehicle.\n\nExamples:\n    (begin example)\n        private _followedPathMarkerType = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugMarkerType_followedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugMarkerType_followedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\n    \"KISKA_convoy_debugMarkerType_followedPath\",\n    \"Sign_Arrow_Large_blue_F\"\n]\n",
    "fileName": "fn_convoy_getVehicleDebugMarkerType_followedPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleDebugMarkerType_followedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDrivePath\n\nDescription:\n    Gets a given convoy vehicle's current drive path. This will return the reference\n     to the actual array used with `setDriveOnPath` for the vehicle's following.\n    \n    You should not set a vehicle's drive path directly. If you want to overwrite a vehicle's\n     current path, use KISKA_fnc_convoy_modifyVehicleDrivePath.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the drive path of\n\nReturns:\n    <PositionATL[]> - An array of the current vehicle's path that it is following\n\nExamples:\n    (begin example)\n        private _currentDrivePath = [_vehicle] call KISKA_fnc_convoy_getVehicleDrivePath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDrivePath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_drivePath\",[]]\n",
    "fileName": "fn_convoy_getVehicleDrivePath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleIndex\n\nDescription:\n    Gets the index in of the provided vehicle in its convoy.\n\n    `0` being the convoy leader and `1` being the vehicle directly behind the convoy\n     leader, for example. `-1` indicates the vehicle is not in a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy index of\n\nReturns:\n    <NUMBER> - The index of the vehicle in its convoy\n\nExamples:\n    (begin example)\n        private _indexOfVehicleInConvoy = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleIndex;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleIndex\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_index\",-1]\n",
    "fileName": "fn_convoy_getVehicleIndex.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleKilledEvent\n\nDescription:\n    Gets the code that should execute when a vehicle dies in a convoy.\n    \n    This will by default return KISKA_convoy_handleVehicleKilled_default if\n     not explicitly set on the vehicle.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the killed event code of\n\nReturns:\n    <CODE> - The code that executes when a vehicle is killed in the convoy\n\nExamples:\n    (begin example)\n        private _eventCode = [\n            vic\n        ] call KISKA_fnc_convoy_getVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\n    \"KISKA_convoy_handleVehicleKilled\",\n    KISKA_fnc_convoy_handleVehicleKilled_default\n]\n",
    "fileName": "fn_convoy_getVehicleKilledEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleLastAddedPoint\n\nDescription:\n    Gets the last position added to the vehicle's drive path from the LEAD VEHICLE.\n\n    This does not include modified positions from KISKA_fnc_convoy_modifyVehicleDrivePath.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the drive path of\n\nReturns:\n    <PositionATL or NIL> - The last position to be added to the vehicle's drive path\n     from the lead vehicles position.\n\nExamples:\n    (begin example)\n        private _lastAddedPositionFromLead = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleLastAddedPoint;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleLastAddedPoint\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable \"KISKA_convoy_lastAddedPoint\"\n",
    "fileName": "fn_convoy_getVehicleLastAddedPoint.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleLastAddedPoint.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleSeperation\n\nDescription:\n    Gets the distance that a given vehicle will keep from the vehicle in front\n     of it when in a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy seperation of\n\nReturns:\n    <NUMBER> - The distance the vehicle will keep from the vehicle in front\n        `-1` indicates that no seperation has been set for the vehicle.\n\nExamples:\n    (begin example)\n        private _vehicleConvoySeperation = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleSeperation\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_seperation\",-1]\n",
    "fileName": "fn_convoy_getVehicleSeperation.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_getVehicleSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleDeadDriver_default\n\nDescription:\n    The default function that runs when a driver is detected as dead in a vehicle convoy.\n    This is not fired based off an event handler but rather a check in the onEachFrame for\n     the convoy vehicles.\n    The function will wait 4 seconds before affecting its behavior on the vehicle.\n    \n    If the previous driver was a player, and a player is in the vehicle, nothing will happen.\n    If the previous driver was a player, and a player is NOT in the vehicle, an AI will take over\n     driving the vehicle.\n    If the previous driver was NOT a player, and a player is in the highest priority seat to\n     be the new driver, nothing will happen.\n    If the previous driver was NOT a player, and an AI is in the highest priority seat to\n     be the new driver, they will be automatically moved into the driver seat.\n    \n    The priority of vehicle role in the order of who the next driver is:\n        1. commander\n        2. cargo\n        3. turrets\n        4. gunner\n\n    This means commanders if present will be desired to move into the driver seat over\n     all other vehicle roles.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle that has a dead driver\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n    3: _deadDriver <OBJECT> - The dead driver\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleDeadDriver_default\";\n\n#define WAIT_TIME 4\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]]\n]; \n\n\nif (_vehicle isEqualTo _convoyLead) exitWith {\n    [_vehicle] call KISKA_fnc_convoy_removeVehicle;\n    \n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n};\n\n\n[{\n\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]],\n    [\"_deadDriver\",objNull,[objNull]]\n]; \n\n\nif (isNull _vehicle) exitWith {\n    [\n        [\n            \"null _vehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _deadDriver) exitWith {\n    [\n        [\n            \"null _deadDriver was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\nprivate _currentDriver = driver _vehicle;\nif (_currentDriver isNotEqualTo _deadDriver) exitWith {};\n\nprivate _driverWasPlayer = isPlayer [_deadDriver];\nprivate \"_preferredNewDriver\";\nprivate _preferredNewDriver_priority = -1;\nprivate _preferredNewDriver_isPlayer = false;\nprivate _rolePriorityHashMap = createHashMapFromArray [\n    [\"commander\",3],\n    [\"cargo\",2],\n    [\"turret\",1],\n    [\"gunner\",0]\n];\n\n(fullCrew _vehicle) apply {\n    _x params [\"_unit\",\"_role\",\"_index\"];\n    _role = toLowerANSI _role;\n    private _unitIsPlayer = isPlayer _unit;\n\n    // always want a player driver to not be replaced with an AI \n    // if there is another player in the vehicle\n    if (_driverWasPlayer AND _unitIsPlayer) then {\n        _preferredNewDriver = nil;\n        break \n    };\n\n    private _unitPriority = _rolePriorityHashMap getOrDefault [_role,-1];\n    if (_preferredNewDriver_priority < _unitPriority) then {\n        _preferredNewDriver_priority = _unitPriority;\n        _preferredNewDriver = _unit;\n        _preferredNewDriver_isPlayer = _unitIsPlayer;\n\n        private _unitIsCommander = _unitPriority isEqualTo 3;\n        private _isPriorityUnit = _unitIsCommander AND (!_driverWasPlayer) AND (!_unitIsPlayer);\n        if (_isPriorityUnit) then { break };\n    };\n};\n\nif (isNil \"_preferredNewDriver\" OR {_preferredNewDriver_isPlayer}) exitWith {};\n\n[_currentDriver, _vehicle] remoteExecCall [\"moveOut\", _currentDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveOut\", _preferredNewDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveInDriver\", _preferredNewDriver];\n\n_vehicle setVariable [\"KISKA_convoy_deadDriverBeingHandled\",false];\n\n\nnil\n   \n},_this,WAIT_TIME] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_convoy_handleDeadDriver_default.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_handleDeadDriver_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleUnconsciousDriver_default\n\nDescription:\n    The default function that runs when a driver is detected as incapacitated in a vehicle convoy.\n\n    The function will wait 4 seconds before affecting its behavior on the vehicle.\n    \n    If the previous driver was a player, and a player is in the vehicle, nothing will happen.\n    If the previous driver was a player, and a player is NOT in the vehicle, an AI will take over\n     driving the vehicle.\n    If the previous driver was NOT a player, and a player is in the highest priority seat to\n     be the new driver, nothing will happen.\n    If the previous driver was NOT a player, and an AI is in the highest priority seat to\n     be the new driver, they will be automatically moved into the driver seat.\n    \n    The priority of vehicle role in the order of who the next driver is:\n        1. commander\n        2. cargo\n        3. turrets\n        4. gunner\n\n    This means commanders if present will be desired to move into the driver seat over\n     all other vehicle roles.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle that has an unconscious driver\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n    3: _unconsciousDriver <OBJECT> - The unconscious driver\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleUnconsciousDriver_default\";\n\n#define WAIT_TIME 4\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n\n[{\n\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]],\n    [\"_unconsciousDriver\",objNull,[objNull]]\n]; \n\n\nif (isNull _vehicle) exitWith {\n    [\n        [\n            \"null _vehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _unconsciousDriver) exitWith {\n    [\n        [\n            \"null _unconsciousDriver was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (_vehicle isEqualTo _convoyLead) exitWith {\n    [_vehicle] call KISKA_fnc_convoy_removeVehicle;\n    \n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n};\n\n\n\nprivate _currentDriver = driver _vehicle;\nif (_currentDriver isNotEqualTo _unconsciousDriver) exitWith {};\n\nprivate _driverWasPlayer = isPlayer [_unconsciousDriver];\nprivate \"_preferredNewDriver\";\nprivate _preferredNewDriver_priority = -1;\nprivate _preferredNewDriver_isPlayer = false;\nprivate _rolePriorityHashMap = createHashMapFromArray [\n    [\"commander\",3],\n    [\"cargo\",2],\n    [\"turret\",1],\n    [\"gunner\",0]\n];\n\n(fullCrew _vehicle) apply {\n    _x params [\"_unit\",\"_role\",\"_index\"];\n    _role = toLowerANSI _role;\n    private _unitIsPlayer = isPlayer _unit;\n\n    // always want a player driver to not be replaced with an AI \n    // if there is another player in the vehicle\n    if (_driverWasPlayer AND _unitIsPlayer) then {\n        _preferredNewDriver = nil;\n        break \n    };\n\n    private _unitPriority = _rolePriorityHashMap getOrDefault [_role,-1];\n    if (_preferredNewDriver_priority < _unitPriority) then {\n        _preferredNewDriver_priority = _unitPriority;\n        _preferredNewDriver = _unit;\n        _preferredNewDriver_isPlayer = _unitIsPlayer;\n\n        private _unitIsCommander = _unitPriority isEqualTo 3;\n        private _isPriorityUnit = _unitIsCommander AND (!_driverWasPlayer) AND (!_unitIsPlayer);\n        if (_isPriorityUnit) then { break };\n    };\n};\n\nif (isNil \"_preferredNewDriver\" OR {_preferredNewDriver_isPlayer}) exitWith {};\n\n[_currentDriver, _vehicle] remoteExecCall [\"moveOut\", _currentDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveOut\", _preferredNewDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveInDriver\", _preferredNewDriver];\n[_currentDriver, _vehicle] remoteExecCall [\"moveInAny\", _currentDriver];\n\n_vehicle setVariable [\"KISKA_convoy_currentUnconsciousDriver\",nil];\n\n\nnil\n   \n},_this,WAIT_TIME] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_convoy_handleUnconsciousDriver_default.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_handleUnconsciousDriver_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleVehicleCantMove_default\n\nDescription:\n\tThe default behaviour that happens when a vehicle in the convoy is disabled.\n\nParameters:\n    0: _disabledVehicle <OBJECT> - The vehicle that has been disabled\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleVehicleCantMove_default\";\n\n#define X_AREA_BUFFER 5\n#define Y_AREA_BUFFER 10\n#define MOVING_POSITIONS_BUFFER 2\n#define LEFT_AZIMUTH_RELATIVE_NORTH 270\n#define RIGHT_AZIMUTH_RELATIVE_NORTH 90\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_disabledVehicle\",objNull,[objNull]],\n    [\"_convoyHashmap\",nil],\n    [\"_convoyLead\",objNull,[objNull]]\n];\n\n[[_disabledVehicle,\" can't move handler called\"]] call KISKA_fnc_log;\n\n/* ----------------------------------------------------------------------------\n\tParameter check\n---------------------------------------------------------------------------- */\nif (isNull _disabledVehicle) exitWith {\n    [\n        [\n            \"null _disabledVehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _disabledVehicle is: \",\n            _disabledVehicle\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _convoyLead) exitWith {\n    [   \n        [\n            \"null _convoyLead was passed, _disabledVehicle is: \",\n            _disabledVehicle,\n\t\t\t\" and _convoyHashMap is: \",\n\t\t\t_convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\nif (_disabledVehicle isEqualTo _convoyLead) exitWith {\n    [_disabledVehicle] call KISKA_fnc_convoy_removeVehicle;\n    \n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\tFunction Defintions\n---------------------------------------------------------------------------- */\nprivate _getBlockedPositions = {\n    params [\"_vehicleBehind_drivePath\",\"_disabledVehicle\"];\n\n    private _disabledVehicle_dimensions = [_disabledVehicle] call KISKA_fnc_getBoundingBoxDimensions;\n    _disabledVehicle_dimensions params [\"_disabledVehicle_width\",\"_disabledVehicle_length\",\"_disabledVehicle_height\"];\n    // Adding buffers to X and Y because points that are too close to the _disabledVehicle\n    // will result in _vehicleBehind crashing into it.\n    private _areaX = (_disabledVehicle_width / 2) + X_AREA_BUFFER;\n    private _areaY = (_disabledVehicle_length / 2) + Y_AREA_BUFFER;\n    private _areaZ = _disabledVehicle_height / 2;\n\n    private _areaCenter = ASLToAGL (getPosASLVisual _disabledVehicle);\n    private _lastIndex = (count _vehicleBehind_drivePath) - 1;\n\n    private _blockedPositions_ATL = [];\n    private _lastBlockedIndex = _lastIndex;\n    {\n        if (_forEachIndex isEqualTo _lastIndex) then { break };\n\n        private _nextPointInPath = _vehicleBehind_drivePath select (_forEachIndex + 1);\n        private _azimuthToNextPoint = _x getDir _nextPointInPath;\n\n        private _currentPointIsInArea = _x inArea [\n            _areaCenter,\n            _areaX,\n            _areaY,\n            _azimuthToNextPoint,\n            true,\n            _areaZ\n        ];\n\n        private _aBlockedPositionWasAlreadyFound = _blockedPositions_ATL isNotEqualTo [];\n        if (_aBlockedPositionWasAlreadyFound AND (!_currentPointIsInArea)) then { break };\n\n        if (_currentPointIsInArea) then {\n            _blockedPositions_ATL pushBack _x;\n            _lastBlockedIndex = _forEachIndex;\n        };\n    } forEach _vehicleBehind_drivePath;\n\n\n    [_blockedPositions_ATL, _lastBlockedIndex]\n};\n\n\nprivate _findClearSide = {\n    params [\"_blockedPositions_ATL\",\"_disabledVehicle\",\"_requiredSpace\"];\n\n    private _firstBlockedPosition = _blockedPositions_ATL select 0;\n\n    private _blockedPositionsCount = count _blockedPositions_ATL;\n    private _middleIndex = (round (_blockedPositionsCount / 2)) - 1;\n    private _middleBlockedPosition = _blockedPositions_ATL select _middleIndex;\n\n    private _lastBlockedPosition = _blockedPositions_ATL select -1;\n\n    private _disabledVehicle_dir = getDirVisual _disabledVehicle;\n    private _leftAzimuth = LEFT_AZIMUTH_RELATIVE_NORTH + _disabledVehicle_dir;\n    private _rightAzimuth = RIGHT_AZIMUTH_RELATIVE_NORTH + _disabledVehicle_dir;\n\n    private _clearSide = -1;\n    private _clearLeft = true;\n    private _clearRight = true;\n\n    [\n        _firstBlockedPosition,\n        _middleBlockedPosition,\n        _lastBlockedPosition\n    ] apply {\n        \n        private _positionASL = ATLToASL _x;\n\n        if (_clearLeft) then {\n            private _positionLeftASL = AGLToASL (_positionASL getPos [_requiredSpace, _leftAzimuth]);\n            private _objectsToDisabledVehiclesLeft = lineIntersectsObjs [\n                _positionASL, \n                _positionLeftASL, \n                _disabledVehicle,\n                objNull,\n                true,\n                32\n            ];\n            private _objectsAreOnTheLeft = _objectsToDisabledVehiclesLeft isNotEqualTo [];\n\n            if (_objectsAreOnTheLeft) then { _clearLeft = false };\n        };\n\n        if (_clearRight) then {\n            private _positionRightASL = AGLToASL (_positionASL getPos [_requiredSpace, _rightAzimuth]);\n            private _objectsToDisabledVehiclesRight = lineIntersectsObjs [\n                _positionASL, \n                _positionRightASL, \n                _disabledVehicle,\n                objNull,\n                true,\n                32\n            ];\n            private _objectsAreOnTheRight = _objectsToDisabledVehiclesRight isNotEqualTo [];\n            \n            if (_objectsAreOnTheRight) then { _clearRight = false };\n        };\n\n        if ((!_clearLeft) AND (!_clearRight)) then { break };\n    };\n\n    if (_clearLeft) then {\n        _clearSide = 0;\n    } else {\n        if (_clearRight) then { _clearSide = 1; };\n    };\n\n\n    _clearSide\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\tDrive around disabled vehicles\n---------------------------------------------------------------------------- */\nprivate _disabledVehicle_index = [_disabledVehicle] call KISKA_fnc_convoy_getVehicleIndex;\nprivate _vehicleBehind_index = _disabledVehicle_index + 1;\nprivate _vehicleBehind = [_convoyHashMap, _vehicleBehind_index] call KISKA_fnc_convoy_getVehicleAtIndex;\n\n\n[_disabledVehicle] call KISKA_fnc_convoy_removeVehicle;\nif (isNull _vehicleBehind) exitWith {\n    [[\"No _vehicleBehind found at index: \",_vehicleBehind_index]] call KISKA_fnc_log;\n    nil\n};\n\n\n[_convoyHashMap] call KISKA_fnc_convoy_syncLatestDrivePoint;\n\nprivate _vehicleBehind_currentDrivePath = [_vehicleBehind] call KISKA_fnc_convoy_getVehicleDrivePath;\nprivate _blockedPositionsResult = [\n    _vehicleBehind_currentDrivePath,\n    _disabledVehicle\n] call _getBlockedPositions;\n\n\nprivate _positionsBlockedByDisabledVehicle_ATL = _blockedPositionsResult select 0;\nif (_positionsBlockedByDisabledVehicle_ATL isEqualTo []) exitWith {\n    [[\n        \"Did not find any blocked drive path positions: _vehicleBehind: \",\n        _vehicleBehind,\n        \" _disabledVehicle: \",\n        _disabledVehicle\n    ]] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _vehicleBehind_dimensions = [_vehicleBehind] call KISKA_fnc_getBoundingBoxDimensions;\nprivate _vehicleBehind_width = _vehicleBehind_dimensions select 0;\n\nprivate _disabledVehicle_dimensions = [_disabledVehicle] call KISKA_fnc_getBoundingBoxDimensions;\nprivate _disabledVehicle_width = _disabledVehicle_dimensions select 0;\nprivate _disabledVehicle_halfWidth = _disabledVehicle_width / 2;\n\nprivate _requiredSpace = _vehicleBehind_width + _disabledVehicle_halfWidth;\nprivate _clearSide = [\n    _positionsBlockedByDisabledVehicle_ATL,\n    _disabledVehicle,\n    _requiredSpace\n] call _findClearSide;\n\n\nprivate _noSideIsClear = _clearSide isEqualTo -1;\nif (_noSideIsClear) exitWith {\n    [_vehicleBehind] call KISKA_fnc_convoy_stopVehicle;\n    [_vehicleBehind, false] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n\n    [[\n        \"Could not find clear side for: _vehicleBehind: \",\n        _vehicleBehind,\n        \" _disabledVehicle: \",\n        _disabledVehicle\n    ]] call KISKA_fnc_log;\n\n\n    nil\n};\n\n\nprivate _distanceToMovePositions = _vehicleBehind_width + _disabledVehicle_halfWidth + MOVING_POSITIONS_BUFFER;\nprivate _disabledVehicle_dir = getDirVisual _disabledVehicle;\n\nprivate _movementDirectionBase = [LEFT_AZIMUTH_RELATIVE_NORTH, RIGHT_AZIMUTH_RELATIVE_NORTH] select _clearSide;\nprivate _movePositionAzimuth = _movementDirectionBase + _disabledVehicle_dir;\n\nprivate _firstPositionToMove = _positionsBlockedByDisabledVehicle_ATL select 0;\nprivate _firstPositionAdjusted_AGL = _firstPositionToMove getPos [_distanceToMovePositions, _movePositionAzimuth];\nprivate _firstPositionAdjusted_ATL = ASLToATL (AGLToASL _firstPositionAdjusted_AGL);\nprivate _movedPositionVectorOffset = _firstPositionToMove vectorDiff _firstPositionAdjusted_ATL;\n\nprivate _positionsBlockedByDisabledVehicle_ATL = _blockedPositionsResult select 0;\nprivate _adjustedPositions = _positionsBlockedByDisabledVehicle_ATL apply {_x vectorDiff _movedPositionVectorOffset};\n\nprivate _deletionRange = count _adjustedPositions;\nprivate _vehicleBehind_lastIndexToBeAdjustedInPath = _blockedPositionsResult select 1;\nprivate _lastIndexOffset = (count _vehicleBehind_currentDrivePath) - (_vehicleBehind_lastIndexToBeAdjustedInPath + 1);\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\n{\n    // don't need to adjust convoy lead\n    if (_forEachIndex isEqualTo 0) then { continue };\n\n    private _vehiclesDrivePath = [_x] call KISKA_fnc_convoy_getVehicleDrivePath;\n    private _vehiclesDrivePathCount = count _vehiclesDrivePath;\n    private _lastIndexToModify = _vehiclesDrivePathCount - _lastIndexOffset;\n    \n    [\n        _x,\n        _lastIndexToModify,\n        _adjustedPositions\n    ] call KISKA_fnc_convoy_modifyVehicleDrivePath;\n} forEach _convoyVehicles;\n\n\n\n/* ----------------------------------------------------------------------------\n\tHandle units that dismount disabled vehicle\n\n    // units may dismount in the path of the vehicle behind attempting to drive past\n    // the driving AI will try to avoid driving over friendlies and will\n    /// run into the back of the disabled vehicle in some cases\n---------------------------------------------------------------------------- */\nprivate _disabledVehicle_boundingBox = 0 boundingBoxReal _disabledVehicle;\nprivate _disabledVehicle_boundingBoxMins = _disabledVehicle_boundingBox select 0;\nprivate _disabledVehicle_boundingBoxMaxes = _disabledVehicle_boundingBox select 1;\n\nprivate _rightSide = _disabledVehicle_boundingBoxMaxes select 0;\nprivate _leftSide = _disabledVehicle_boundingBoxMins select 0;\n\n// Want to put units on the NOT clear side because that is where the vehicle behind will not drive\nprivate _xOffset = [\n    _rightSide,\n    _leftSide\n] select _clearSide;\n\nprivate _relativeDismountPosition = [\n    _xOffset,\n    _disabledVehicle_boundingBoxMins select 1,\n    _disabledVehicle_boundingBoxMins select 2\n];\n\n[\n    {\n        params [\"_disabledVehicle\"];\n        (speed _disabledVehicle) isEqualTo 0;\n    },\n    {\n        params [\"_disabledVehicle\",\"_relativeDismountPosition\"];\n\n        if (isNull _disabledVehicle) exitWith {};\n\n        private _unitsToAdjustDismountPosition = crew _disabledVehicle;\n        private _timeVehicleWasDiscoveredDisabled = time;\n        private _unitGetOutTimeHashMap = _disabledVehicle getVariable \"KISKA_convoy_unitGetOutTimesHashMap\";\n        if !(isNil \"_unitGetOutTimeHashMap\") then {\n            _unitGetOutTimeHashMap apply {  \n                private _timeSinceUnitGotOut = _timeVehicleWasDiscoveredDisabled - _y;\n                private _unitGotOutMoreThanASecondAgo = _timeSinceUnitGotOut >= 1;\n                if (_unitGotOutMoreThanASecondAgo) then { continue };\n\n                private _unit = [\n                    _x\n                ] call KISKA_fnc_hashmap_getObjectOrGroupFromRealKey;\n                \n                if !(alive _unit) then { continue };\n\n                _unitsToAdjustDismountPosition pushBackUnique _unit;\n            };\n        };\n\n        private _dismountPosition = _disabledVehicle modelToWorldVisualWorld _relativeDismountPosition;\n        _unitsToAdjustDismountPosition apply {\n            _x setPosWorld _dismountPosition\n        };\n    },\n    [_disabledVehicle,_relativeDismountPosition],\n    10\n] call CBA_fnc_waitUntilAndExecute;\n\n\nnil\n",
    "fileName": "fn_convoy_handleVehicleCantMove_default.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_handleVehicleCantMove_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleVehicleKilled_default\n\nDescription:\n\tThe default behaviour that happens when a vehicle in the convoy dies.\n\nParameters:\n    0: _killedVehicle <OBJECT> - The vehicle that died\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleVehicleKilled_default\";\n\n#define WAIT_TIME_FOR_VEHICLE 2\n#define PUSH_LEFT_SPEED -10\n#define PUSH_RIGHT_SPEED -10\n#define PUSH_Z_VELOCITY 2\n#define MASS_DIVISION 2\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_killedVehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]]\n];\n\n/* ----------------------------------------------------------------------------\n\tParameter check\n---------------------------------------------------------------------------- */\nif (isNull _killedVehicle) exitWith {\n    [\n        [\n            \"null _killedVehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _killedVehicle is: \",\n            _killedVehicle\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _convoyLead) exitWith {\n    [   \n        [\n            \"null _convoyLead was passed, _killedVehicle is: \",\n            _killedVehicle,\n\t\t\t\" and _convoyHashMap is: \",\n\t\t\t_convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n\tLogic\n---------------------------------------------------------------------------- */\n[_killedVehicle] call KISKA_fnc_convoy_removeVehicle;\n\n// KISKA_fnc_convoy_removeVehicle will adjust the indexes\nif (_killedVehicle isEqualTo _convoyLead) exitWith {\n\n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n\n};\n\n\n/* ---------------------------------\n\tGetting the rear vehicle to move to the lead vehicle\n--------------------------------- */\nprivate _vehicleIndex = [_killedVehicle] call KISKA_fnc_convoy_getVehicleIndex;\nprivate _vehicleThatWasBehind = [_convoyHashMap, _vehicleIndex] call KISKA_fnc_convoy_getVehicleAtIndex;\n[_vehicleThatWasBehind] call KISKA_fnc_convoy_stopVehicle;\n[_vehicleThatWasBehind, false] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n\n// push to the right by default\nprivate _pushToTheSideVelocity = PUSH_RIGHT_SPEED;\nprivate _killedVehicle_position = getPosWorldVisual _killedVehicle;\nfor \"_i\" from 1 to 25 do { \n    private _positionLeft = AGLToASL (_killedVehicle getRelPos [_i,270]);\n    private _objectsAreOnTheLeft = (lineIntersectsObjs [_killedVehicle_position, _positionLeft, _killedVehicle, objNull,false,32]) isNotEqualTo [];\n    if (_objectsAreOnTheLeft) then { break };\n    \n    private _positionRight = AGLToASL (_killedVehicle getRelPos [_i,90]);\n    private _objectsAreOnTheRight = (lineIntersectsObjs [_killedVehicle_position, _positionRight, _killedVehicle, objNull,false,32]) isNotEqualTo [];\n    if (_objectsAreOnTheRight) then {\n        _pushToTheSideVelocity = PUSH_LEFT_SPEED; \n        break \n    };\n};\n\n\n// shove vehicle to the side because AI drivers can't drive past consistently\n[_killedVehicle, [_pushToTheSideVelocity,0,PUSH_Z_VELOCITY]] remoteExecCall [\"setVelocityModelSpace\", _killedVehicle];\n\nprivate _killedVehicle_drivePath = [_killedVehicle] call KISKA_fnc_convoy_getVehicleDrivePath;\n// Waiting to give time for destroyed vehicle to settle from physics\n[\n    {\n        params [\n            \"_vehicleThatWasBehind\",\n            \"_killedVehicle_firstDrivePathPoint\",\n            \"_killedVehicle_drivePath\",\n            \"_killedVehicle\"\n        ];\n\n        // adjust mass so that a vehicle can push the dead one out of the way\n        // in case it runs into the dead one\n        [\n            _killedVehicle, \n            ((getMass _vehicleThatWasBehind) / MASS_DIVISION) \n        ] remoteExecCall [\"setMass\",_killedVehicle];\n\n\n        private _driver = driver _vehicleThatWasBehind;\n        [_driver,\"path\"] remoteExecCall [\"enableAI\",_driver];\n\n        [_vehicleThatWasBehind, true] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n    },\n    [\n        _vehicleThatWasBehind,\n        _killedVehicle_firstDrivePathPoint,\n        _killedVehicle_drivePath,\n        _killedVehicle\n    ],\n    WAIT_TIME_FOR_VEHICLE\n] call CBA_fnc_waitAndExecute;\n\n\nnil\n",
    "fileName": "fn_convoy_handleVehicleKilled_default.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_handleVehicleKilled_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_isVehicleInDebug\n\nDescription:\n    Gets whether or a given vehicle is in debug mode for a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy index of\n\nReturns:\n    <BOOL> - `true` if the vehicle is in debug mode\n\nExamples:\n    (begin example)\n        private _isInDebug = [\n            _vehicle\n        ] call KISKA_fnc_convoy_isVehicleInDebug;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_isVehicleInDebug\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_debug\",false]\n",
    "fileName": "fn_convoy_isVehicleInDebug.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_isVehicleInDebug.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_modifyVehicleDrivePath\n\nDescription:\n\tChanges the drive path of a given convoy vehicle.\n\n    The drive path will be overwritten from the _lastIndexToModify (inclusive) backwards \n     until all of the _pointsToAdd have been placed in the array. This means that \n     this function is not capable of appending to the end of an array, but only adding \n     to the front.\n    \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to modify the drive path of\n    1: _lastIndexToModify <NUMBER> - The (inclusive) index to stop the modification at\n    2: _pointsToAdd <PositionATL[]> - The array of ATL positions to set to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t// overwrite array entirely\n\t\t[\n            _vehicle,\n            -1, // without deleting any points in current drive path, add positions to the front of path\n            [\n                [12,34,56],\n                [12,34,58]\n            ]\n        ] call KISKA_fnc_convoy_modifyVehicleDrivePath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_modifyVehicleDrivePath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_lastIndexToModify\",0,[123]],\n    [\"_pointsToAdd\",[],[[]]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _modificationRange = count _pointsToAdd;\nprivate _vehicleDrivePath = [_vehicle] call KISKA_fnc_convoy_getVehicleDrivePath;\nif (_vehicleDrivePath isEqualTo []) then {\n    _vehicleDrivePath insert [0,_pointsToAdd];\n\n} else {\n    private _vehiclesDrivePathCount = count _vehicleDrivePath;\n    private _startIndex = _lastIndexToModify - _modificationRange;\n    if (_startIndex < 0) then {\n        _modificationRange = _modificationRange + _startIndex;\n        _startIndex = 0;\n    };\n\n\n    if (_modificationRange >= 0) then {\n        _vehicleDrivePath deleteRange [_startIndex, _modificationRange];\n    };\n    _vehicleDrivePath insert [_startIndex, _pointsToAdd];\n\n};\n\n\nif ([_vehicle] call KISKA_fnc_convoy_shouldVehicleDriveOnPath) then {\n    _vehicle setDriveOnPath _vehicleDrivePath;\n};\n",
    "fileName": "fn_convoy_modifyVehicleDrivePath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_modifyVehicleDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_onEachFrame\n\nDescription:\n    Mananges an individual vehicle's position relative to the vehicle in front of\n     it in a convoy. This function is what the statemachine runs each frame/vehicle.\n\n    This function intentionally forgoes the use of several getter/setter functions \n     to reduce overhead because it runs every frame.\n\nParameters:\n    _this <OBJECT> - A convoy vehicle to be processed during the current frame\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_onEachFrame\";\n\n#define MIN_VEHICLE_SPEED_LIMIT_MODIFIER 5\n#define MIN_VEHICLE_SPEED_LIMIT 5\n#define VEHICLE_SPEED_LIMIT_MULTIPLIER 2.5\n#define SMALL_SPEED_LIMIT_DISTANCE_MODIFIER 1.25\n#define LEAD_VEHICLE_MAX_SPEED_TO_HALT_FOLLOW 2\n#define VEHICLE_SHOULD_CATCH_UP_DISTANCE 100\n#define SPEED_DIFFERENTIAL_LIMIT 20\n#define MIN_CONVOY_SEPERATION 10\n#define CONVOY_LEAD_MIN_RECORD_SPEED 5\n#define CONVOY_LEAD_MAX_RECORD_SPEED 20\n\nprivate _currentVehicle = _this;\n\nprivate _convoyHashMap = _currentVehicle getVariable \"KISKA_convoy_hashMap\";\nprivate _convoyLead = _convoyHashMap getOrDefault [0,objNull];\n\n\n/* ----------------------------------------------------------------------------\n    Exit states\n---------------------------------------------------------------------------- */\nif (isNull _convoyLead) exitWith {\n    [_convoyHashMap] call KISKA_fnc_convoy_delete;\n};\n\n\nif !(canMove _currentVehicle) exitWith {\n    private _cantMoveEventHandler = _currentVehicle getVariable [\n        \"KISKA_convoy_handleVehicleCantMove\",\n        KISKA_fnc_convoy_handleVehicleCantMove_default\n    ];\n\n    [\n        _currentVehicle,\n        _convoyHashMap,\n        _convoyLead\n    ] call _cantMoveEventHandler;\n};\n\n// did not use an eventhandler due to the complexity of handling\n// potentially remote units and/or changing drivers\n// and the limited cost of this check\nprivate _currentVehicle_driver = driver _currentVehicle;\nif !(alive _currentVehicle_driver) exitWith {\n    private _deadDriverBeingHandled = _currentVehicle getVariable [\"KISKA_convoy_deadDriverBeingHandled\",false];\n    if (_deadDriverBeingHandled) exitWith {};\n\n    _currentVehicle setVariable [\"KISKA_convoy_deadDriverBeingHandled\",true];\n    \n    private _driverKilledHandler = _currentVehicle getVariable [\n        \"KISKA_convoy_handleDeadDriver\",\n        KISKA_fnc_convoy_handleDeadDriver_default\n    ];\n\n    [\n        _currentVehicle,\n        _convoyHashMap,\n        _convoyLead,\n        _currentVehicle_driver\n    ] call _driverKilledHandler;\n};\t\n\nif ((lifeState _currentVehicle_driver) == \"INCAPACITATED\") exitWith {\n    private _currentUnconsciousDriver = _currentVehicle getVariable \"KISKA_convoy_currentUnconsciousDriver\";\n    if (!isNil \"_currentUnconsciousDriver\" AND {_currentUnconsciousDriver isEqualTo _currentVehicle_driver}) exitWith {};\n    \n    _currentVehicle setVariable [\"KISKA_convoy_currentUnconsciousDriver\",_currentVehicle_driver];\n    private _driverIncapcitatedEventHandler = _currentVehicle getVariable [\n        \"KISKA_convoy_handleUnconsciousDriver\",\n        KISKA_fnc_convoy_handleUnconsciousDriver_default\n    ];\n\n    [\n        _currentVehicle,\n        _convoyHashMap,\n        _convoyLead,\n        _currentVehicle_driver\n    ] call _driverIncapcitatedEventHandler;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Handle Convoy Lead Vehicle\n---------------------------------------------------------------------------- */\nprivate _speedLimitMap = _convoyHashMap get \"_speedLimitPoints\";\nif (_currentVehicle isEqualTo _convoyLead) exitWith {\n    private _convoyLead_currentPosition_ATL = getPosATLVisual _convoyLead;\n    // getOrDefaultCall is slightly faster than getOrDefault for this\n    private _latestPointOnPath = _convoyHashMap getOrDefaultCall [\"_latestPointOnPath\",{[0,0,0]}];\n   \n    private _distanceBetweenPoints = _convoyLead_currentPosition_ATL vectorDistance _latestPointOnPath;\n    private _minBufferBetweenPoints = _convoyHashMap get \"_minBufferBetweenPoints\";\n    if (_distanceBetweenPoints <= _minBufferBetweenPoints) exitWith {};\n\n    private _convoyLeadSpeed = speed _convoyLead;\n    if (\n        (_convoyLeadSpeed < CONVOY_LEAD_MAX_RECORD_SPEED) AND \n        (_convoyLeadSpeed > CONVOY_LEAD_MIN_RECORD_SPEED)\n    ) then {\n        _speedLimitMap set [_convoyLead_currentPosition_ATL, _convoyLeadSpeed];\n    };\n\n    (_convoyHashMap get \"_convoyPath\") pushBack _convoyLead_currentPosition_ATL;\n    _convoyHashMap set [\"_latestPointOnPath\",_convoyLead_currentPosition_ATL];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Handle speed\n---------------------------------------------------------------------------- */\nprivate _currentVehicle_drivePath = _currentVehicle getVariable \"KISKA_convoy_drivePath\";\nprivate _currentPointSpeedLimit = _speedLimitMap getOrDefaultCall [_currentVehicle_drivePath param [0,-1],{-1}];\nprivate _debug = _currentVehicle getVariable [\"KISKA_convoy_debug\",false];\n\nprivate _driverIsAI = !(isPlayer _currentVehicle_driver);\nif (_driverIsAI) then {\n\n    private _currentVehicle_index = _currentVehicle getVariable \"KISKA_convoy_index\";\n    private _vehicleAhead = _convoyHashMap get (_currentVehicle_index - 1);\n\n    private _currentVehicle_frontBumperPosition = [_currentVehicle,false] call KISKA_fnc_convoy_getBumperPosition;\n    private _vehicleAhead_rearBumperPosition = [_vehicleAhead,true] call KISKA_fnc_convoy_getBumperPosition;\n    private _distanceBetweenVehicles = _currentVehicle_frontBumperPosition vectorDistance _vehicleAhead_rearBumperPosition;\n\n    private _vehicleAhead_speed = speed _vehicleAhead;\n    private _currentVehicle_seperation = (_currentVehicle getVariable [\"KISKA_convoy_seperation\",20]) max MIN_CONVOY_SEPERATION;\n    private _vehiclesAreWithinBoundary = _distanceBetweenVehicles < _currentVehicle_seperation;\n\n    private _currentVehicle_isStopped = _currentVehicle getVariable [\"KISKA_convoy_isStopped\",false];\n    private _vehicleAhead_isStopped = _vehicleAhead_speed <= LEAD_VEHICLE_MAX_SPEED_TO_HALT_FOLLOW;\n    private _currentVehicle_shouldBeStopped = _vehicleAhead_isStopped AND _vehiclesAreWithinBoundary;\n\n    if (_currentVehicle_shouldBeStopped AND (!_currentVehicle_isStopped)) exitWith {\n        if (_debug) then {\n            private _currentVehicle_speed = speed _currentVehicle;\n            hint str [\"In Halt\",_currentVehicle_speed,_distanceBetweenVehicles];\n        };\n\n        _currentVehicle setVariable [\"KISKA_convoy_isStopped\",true];\n        [_currentVehicle] call KISKA_fnc_convoy_stopVehicle;\n    };\n\n\n    if ((!_currentVehicle_shouldBeStopped) AND _currentVehicle_isStopped) then {\n        _currentVehicle setVariable [\"KISKA_convoy_isStopped\",false];\n        if !(_currentVehicle_driver checkAIFeature \"path\") then {\n            _currentVehicle_driver enableAI \"path\";\n        };\n    };\n\n    /* ---------------------------------\n        Force speed based on distance\n    --------------------------------- */\n    private _currentVehicle_speed = speed _currentVehicle;\n    private \"_debugText\";\n    private _speedLimit = -1;\n    if (_vehiclesAreWithinBoundary) then {\n        private _modifier = (\n            (_currentVehicle_seperation - _distanceBetweenVehicles) * VEHICLE_SPEED_LIMIT_MULTIPLIER\n        ) max MIN_VEHICLE_SPEED_LIMIT_MODIFIER;\n\n        _speedLimit = (_vehicleAhead_speed - _modifier) max MIN_VEHICLE_SPEED_LIMIT;\n        \n        if (_debug) then {\n            _debugText = parseText format [\n                \"Limited Vehicle Speed\n                <br/>\n                <t align='left'>Within seperation boundary</t>\n                <br/>\n                <t align='left'>Distance To Vehicle In Front: %1</t>\n                <br/>\n                <t align='left'>Current Vehicle Speed: %2</t>\n                <br/>\n                <t align='left'>Speed Limited To: %3</t>\",\n                _distanceBetweenVehicles,\n                _currentVehicle_speed,\n                _speedLimit\n            ];\n        };\n\n    } else {\n        private _distanceToLimitToVehicleAheadSpeed = _currentVehicle_seperation * SMALL_SPEED_LIMIT_DISTANCE_MODIFIER;\n        if (_distanceBetweenVehicles < _distanceToLimitToVehicleAheadSpeed) exitWith {\n            _speedLimit = [_vehicleAhead_speed,5] select _vehicleAhead_isStopped;\n\n            if (_debug) then {\n                _debugText = parseText format [\n                    \"Limited Vehicle Speed To Vehicle Ahead\n                    <br/>\n                    <t align='left'>Vehicle outside of convoy seperation</t>\n                    <br/>\n                    <t align='left'>Distance To Vehicle In Front: %1</t>\n                    <br/>\n                    <t align='left'>Speed Limited To: %2</t>\",\n                    _distanceBetweenVehicles,\n                    _speedLimit\n                ];\n            };\n        };\n\n        if ((_distanceBetweenVehicles > VEHICLE_SHOULD_CATCH_UP_DISTANCE) AND _debug) exitWith { \n            _debugText = parseText format [\n                \"Unlimited Vehicle Speed\n                <br/>\n                <t align='left'>Outside of handle distance (%2)</t>\n                <br/>\n                <t align='left'>Distance To Vehicle In Front: %1</t>\",\n                _distanceBetweenVehicles,\n                VEHICLE_SHOULD_CATCH_UP_DISTANCE\n            ];\n        };\n        \n        private _speedDifferential = abs (_currentVehicle_speed - _vehicleAhead_speed);\n        if (_speedDifferential > SPEED_DIFFERENTIAL_LIMIT) exitWith {\n            _speedLimit = _distanceBetweenVehicles;\n            \n            if (_debug) then {\n                _debugText = parseText format [\n                    \"Limited Speed Based On Differential\n                    <br/>\n                    <t align='left'>Vehicle Speed: %1</t>\n                    <br/>\n                    <t align='left'>Distance To Vehicle In Front: %2</t>\",\n                    _currentVehicle_speed,\n                    _distanceBetweenVehicles\n                ];\n            };\n        };\n        \n        if (_debug) then {\n            _debugText = parseText format [\n                \"Unlimited Vehicle Speed\n                <br/>\n                <t align='left'>Met no handle conditions</t>\n                <br/>\n                <t align='left'>Distance To Vehicle In Front: %1</t>\",\n                _distanceBetweenVehicles\n            ];\n        };\n    };\n\n\n    if (\n        (_currentPointSpeedLimit isNotEqualTo -1) AND \n        (_speedLimit > _currentPointSpeedLimit)\n    ) then {\n        _speedLimit = _currentPointSpeedLimit;\n\n        if (_debug) then {\n            _debugText = parseText format [\n                \"Limited Vehicle Speed\n                <br/>\n                <t align='left'>Low Lead Vehicle Speed At Point</t>\n                <br/>\n                <t align='left'>Speed Limited To: %1</t>\",\n                _currentPointSpeedLimit\n            ];\n        };\n    };\n\n\n    if (_debug) then { hint _debugText };\n\n    _currentVehicle limitSpeed _speedLimit;\n};\n\n\n\n\n/* ----------------------------------------------------------------------------\n    Delete old points\n---------------------------------------------------------------------------- */\nprivate [\"_currentVehicle_debugDrivePathObjects\",\"_currentVehicle_debugDeletedDrivePathObjects\"];\nif (_debug) then {\n    _currentVehicle_debugDrivePathObjects = _currentVehicle getVariable \"KISKA_convoy_debug_followPathObjects\";\n    _currentVehicle_debugDeletedDrivePathObjects = _currentVehicle getVariable \"KISKA_convoy_debug_followedPathObjects\";\n};\n\nprivate _deleteStartIndex = -1;\nprivate _numberToDelete = 0;\n// getting by ASL (instead of getPosVisual) and then converting to AGL is more accurate, don't know why\nprivate _currentVehicle_position_ASL = getPosASLVisual _currentVehicle;\nprivate _offset = _currentVehicle getVariable \"KISKA_convoy_vehicleAreaOffset\";\nprivate _currentVehicle_position_AGL = ASLToAGL _currentVehicle_position_ASL;\nprivate _currentVehicle_direction = getDirVisual _currentVehicle;\nprivate _area = _currentVehicle getVariable \"KISKA_convoy_vehicleCompletionArea\";\n_area set [0,_currentVehicle_position_AGL vectorDiff (_currentVehicle vectorModelToWorldVisual _offset)];\n_area set [3,_currentVehicle_direction];\n{\n    // some points can include speed limit\n    // NOTE/TODO: it might be worth increasing the width/area in general as speed increases.\n    // Higher speed likely means that the probability of missing a point is higher\n\n    private _pointReached = _x inArea _area;\n\n    if !(_pointReached) then { break };\n    _numberToDelete = _numberToDelete + 1;\n\n    private _deleteStartIndexDefined = _deleteStartIndex isNotEqualTo -1;\n    if (_deleteStartIndexDefined) then { continue };\n    _deleteStartIndex = _forEachIndex;\n\n} forEach _currentVehicle_drivePath;\n\nprivate _pointsCanBeDeleted = (_deleteStartIndex >= 0) AND (_numberToDelete > 0);\nif (_pointsCanBeDeleted) then {\n    _currentVehicle_drivePath deleteRange [_deleteStartIndex,_numberToDelete];\n\n    if (_debug) then {\n        private _lastIndexToDelete = _deleteStartIndex + (_numberToDelete - 1);\n        private _debugObjectType = _currentVehicle getVariable [\n            \"KISKA_convoy_debugMarkerType_followedPath\",\n            \"Sign_Arrow_Large_blue_F\"\n        ];\n        private _deletedPointMarker = createVehicle [_debugObjectType, _currentVehicle_position_AGL, [], 0, \"CAN_COLLIDE\"];\n        _currentVehicle_debugDeletedDrivePathObjects pushBack _deletedPointMarker;\n\n        for \"_i\" from _deleteStartIndex to _lastIndexToDelete do { \n            deleteVehicle (_currentVehicle_debugDrivePathObjects select _i);\n        };\n        _currentVehicle_debugDrivePathObjects deleteRange [_deleteStartIndex,_numberToDelete];\n    };\n};\n\n\n/* ----------------------------------------------------------------------------\n    Update current vehicle drive path with new point\n---------------------------------------------------------------------------- */\nprivate _pointToAdd = _convoyHashMap get \"_latestPointOnPath\";\nprivate _lastAddedPoint = _currentVehicle getVariable \"KISKA_convoy_lastAddedPoint\";\nif (_lastAddedPoint isEqualTo _pointToAdd) exitWith {};\n\n\n_currentVehicle setVariable [\"KISKA_convoy_lastAddedPoint\",_pointToAdd];\n\nif (_debug) then {\n    private _debugObjectType = _currentVehicle getVariable [\n        \"KISKA_convoy_debugMarkerType_followPath\",\n        \"Sign_Arrow_Large_Cyan_F\"\n    ];\n\n    // speed limit added to drive path point\n    private _debugObject = createVehicle [_debugObjectType, _pointToAdd, [], 0, \"CAN_COLLIDE\"];\n    _currentVehicle_debugDrivePathObjects pushBack _debugObject;\n};\n\nprivate _indexInserted = _currentVehicle_drivePath pushBack _pointToAdd;\nprivate _doDriveOnPath = _currentVehicle getVariable [\"KISKA_convoy_doDriveOnPath\",true];\nif (_driverIsAI AND {(_indexInserted >= 1) AND _doDriveOnPath}) then {\n    _currentVehicle setDriveOnPath _currentVehicle_drivePath;\n};\n",
    "fileName": "fn_convoy_onEachFrame.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_onEachFrame.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_removeVehicle\n\nDescription:\n    Removes a given vehicle from its convoy.\n\n    This will shift the index's of all vehicles in the convoy that are lower\n     than the given vehicle to remove. If the vehicle is moving (speed > 0)\n     then the vehicle will be told to \"stop\" via a `move` order.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to remove\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_removeVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_removeVehicle\";\n\n#define MAX_ARRAY_LENGTH 1E7\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _convoyHashMap = [_vehicle] call KISKA_fnc_convoy_getConvoyHashMapFromVehicle;\nif (isNil \"_convoyHashMap\") exitWith {\n    [[_vehicle,\" does not have a KISKA_convoy_hashMap in its namespace\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n[_vehicle] call KISKA_fnc_convoy_removeVehicleKilledEvent;\n[_vehicle,true] call KISKA_fnc_convoy_clearVehicleDebugFollowPath;\n[_vehicle,true] call KISKA_fnc_convoy_clearVehicleDebugFollowedPath;\n\n\nprivate _getOutEventHandlerId = _vehicle getVariable [\"KISKA_convoy_getOutEventHandlerId\",-1];\n_vehicle removeEventHandler [\"GetOut\",_getOutEventHandlerId];\n\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\nprivate _vehicleIndex = [_vehicle] call KISKA_fnc_convoy_getVehicleIndex;\n_convoyVehicles deleteAt _vehicleIndex;\n\nprivate _vehiclesToChangeIndex = _convoyVehicles select [_vehicleIndex, MAX_ARRAY_LENGTH];\n_vehiclesToChangeIndex apply {\n    private _currentIndex = [_x] call KISKA_fnc_convoy_getVehicleIndex;\n    if (_currentIndex isEqualTo -1) then {\n        [[\"Could not find 'KISKA_convoy_index' in namespace of \", _x,\" to change\"],true] call KISKA_fnc_log;\n        continue\n    };\n\n    private _newIndex = _currentIndex - 1;\n    _convoyHashMap set [_newIndex,_x];\n    _x setVariable [\"KISKA_convoy_index\",_newIndex];\n};\n\n[_vehicle,\"path\"] remoteExecCall [\"enableAI\",_vehicle];\n_vehicle limitSpeed -1;\n\n// `move` will cancel the setDriveOnPath\nif ((speed _vehicle) > 0) then {\n    [_vehicle, (getPosATLVisual _vehicle)] remoteExecCall [\"move\",_vehicle];\n};\n\n\n[\n    \"KISKA_convoy_isStopped\",\n    \"KISKA_convoy_drivePath\",\n    \"KISKA_convoy_debug_followPathObjects\",\n    \"KISKA_convoy_debug_followedPathObjects\",\n    \"KISKA_convoy_debug\",\n    \"KISKA_convoy_hashMap\",\n    \"KISKA_convoy_index\",\n    \"KISKA_convoy_debugMarkerType_followedPath\",\n    \"KISKA_convoy_debugMarkerType_followPath\",\n    \"KISKA_convoy_vehicleKilledEventID\",\n    \"KISKA_convoy_handleUnconsciousDriver\",\n    \"KISKA_convoy_handleDeadDriver\",\n    \"KISKA_convoy_handleVehicleCantMove\",\n    \"KISKA_convoy_handleVehicleKilled\",\n    \"KISKA_convoy_seperation\",\n    \"KISKA_convoy_lastAddedPoint\",\n    \"KISKA_convoy_deadDriverBeingHandled\",\n    \"KISKA_convoy_doDriveOnPath\",\n    \"KISKA_convoy_currentUnconsciousDriver\",\n    \"KISKA_convoy_getOutEventHandlerId\",\n    \"KISKA_convoy_getOutTimesHashMap\",\n    \"KISKA_convoy_vehicleCompletionArea\",\n    \"KISKA_convoy_vehicleAreaOffset\"\n] apply {\n    _vehicle setVariable [_x,nil];\n};\n\n\nnil\n",
    "fileName": "fn_convoy_removeVehicle.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_removeVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_removeVehicleKilledEvent\n\nDescription:\n    Removes the \"MPKILLED\" event handler of a given vehicle in a convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to add the killed eventhandler to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_removeVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_removeVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _eventId = _vehicle getVariable [\"KISKA_convoy_vehicleKilledEventID\",-1];\n_vehicle removeMPEventHandler [\"MPKILLED\",_eventId];\n_vehicle setVariable [\"KISKA_convoy_vehicleKilledEventID\",nil];\n",
    "fileName": "fn_convoy_removeVehicleKilledEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_removeVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setDefaultSeperation\n\nDescription:\n    Sets the default seperation between NEWLY added vehicles to a convoy.\n    \n    This will NOT update the spacing between any vehicles currently in the convoy.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to set the value in\n    1: _seperation <NUMBER> - The default distance between vehicles\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_convoyHashMap,20] call KISKA_fnc_convoy_setDefaultSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setDefaultSeperation\";\n\n#define MIN_CONVOY_SEPERATION 10\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_seperation\",20,[123]]\n];\n\n\nif (_seperation < MIN_CONVOY_SEPERATION) then {\n    _seperation = MIN_CONVOY_SEPERATION;\n};\n_convoyHashMap set [\"_convoySeperation\",_seperation];\n",
    "fileName": "fn_convoy_setDefaultSeperation.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setDefaultSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setPointBuffer\n\nDescription:\n    Sets the minimum distance that must be between each position added to a vehicles\n     drive path. Essentially how often the lead vehicle's position is recorded.\n    \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n    1: _minBufferBetweenPoints <NUMBER> - The distance between positions in order for\n        them to be added to the convoy drive path\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_convoyHashMap,1] call KISKA_fnc_convoy_setPointBuffer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setPointBuffer\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_minBufferBetweenPoints\",3,[123]]\n];\n\n_convoyHashMap set [\"_minBufferBetweenPoints\",_minBufferBetweenPoints];\n",
    "fileName": "fn_convoy_setPointBuffer.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setPointBuffer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDebug\n\nDescription:\n    Sets whether or not a given vehicle is in debug mode for convoys.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the convoy seperation of\n    1: _debugMode <BOOL> - `true` to enable, `false` to disable debug\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // debug enabled \n        [\n            _vehicle,\n            true\n        ] call KISKA_fnc_convoy_setVehicleDebug;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDebug\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_debug\",false,[true]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_debug\",_debug];\n",
    "fileName": "fn_convoy_setVehicleDebug.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setVehicleDebug.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDebugMarkerType_followPath\n\nDescription:\n    Sets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have not been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the marker type of\n    1: _type <STRING> - The class name of the object to spawn as a marker\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            \"Sign_Arrow_Large_Cyan_F\"\n        ] call KISKA_fnc_convoy_setVehicleDebugMarkerType_followPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDebugMarkerType_followPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_type\",\"Sign_Arrow_Large_Cyan_F\",[\"\"]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_debugMarkerType_followPath\",_type];\n",
    "fileName": "fn_convoy_setVehicleDebugMarkerType_followPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setVehicleDebugMarkerType_followPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDebugMarkerType_followedPath\n\nDescription:\n    Sets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the marker type of\n    1: _type <STRING> - The class name of the object to spawn as a marker\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            \"Sign_Arrow_Large_blue_F\"\n        ] call KISKA_fnc_convoy_setVehicleDebugMarkerType_followedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDebugMarkerType_followedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_type\",\"Sign_Arrow_Large_blue_F\",[\"\"]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_debugMarkerType_followedPath\",_type];\n",
    "fileName": "fn_convoy_setVehicleDebugMarkerType_followedPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setVehicleDebugMarkerType_followedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDriveOnPath\n\nDescription:\n    Sets whether or not the vehicle will initiate new `setDriveOnPath`'s whenever\n     new positions are added to its internal drive path.\n    \n    While false, a vehicle will continue to add points from the lead vehicle to its\n     drive path and will continue to drive on the path prior to the setting of this \n     to false unless otherwise stopped.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the doDriveOnPath var of\n    1: _mode <BOOL> - `true` to enable, `false` to disable driving on newly added points\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // do-drive-on-path enabled \n        [\n            _vehicle,\n            true\n        ] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDriveOnPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_mode\",false,[true]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_doDriveOnPath\",_mode];\n",
    "fileName": "fn_convoy_setVehicleDriveOnPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setVehicleDriveOnPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleKilledEvent\n\nDescription:\n    Sets the code that should execute when a vehicle dies in a convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the killed event on\n    1: _eventCode <CODE> - The code to execute when the vehicle dies in a convoy\n        \n        Parameters:\n        - 0: _vehicle <OBJECT> - The vehicle that died\n        - 1: _convoyHashMap <OBJECT> - The hashmap used for the convoy\n        - 2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            vic,\n            {hint str _this}\n        ] call KISKA_fnc_convoy_setVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_eventCode\",{},[{}]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\n_vehicle setVariable [\n    \"KISKA_convoy_handleVehicleKilled\",\n    _eventCode\n];\n",
    "fileName": "fn_convoy_setVehicleKilledEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleSeperation\n\nDescription:\n    Sets the distance that a given vehicle will keep from the vehicle in front\n     of it when in a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the convoy seperation of\n    1: _seperation <NUMBER> - The distance the vehicle should try to maintain\n        to the vehicle in front of it in a convoy (minimum of 10m)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            10\n        ] call KISKA_fnc_convoy_setVehicleSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleSeperation\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_seperation\",20,[123]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_seperation\",_seperation];\n",
    "fileName": "fn_convoy_setVehicleSeperation.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_setVehicleSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_shouldVehicleDriveOnPath\n\nDescription:\n    Gets whether or not the vehicle will initiate new `setDriveOnPath`'s whenever\n     a new point is added to the vehicle's drive path.\n    \n    While false, a vehicle will continue to receive new points in the vehicles drive path.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to check the value of\n\nReturns:\n    <BOOL> - The vehicle's state of `KISKA_convoy_doDriveOnPath`\n\nExamples:\n    (begin example)\n        private _doDriveOnPath = [_vehicle] call KISKA_fnc_convoy_shouldVehicleDriveOnPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_shouldVehicleDriveOnPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_doDriveOnPath\",false]\n",
    "fileName": "fn_convoy_shouldVehicleDriveOnPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_shouldVehicleDriveOnPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_stopVehicle\n\nDescription:\n    Used in the process of KISKA's advanced convoy to stop a given vehicle.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to stop\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_stopVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_stopVehicle\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",false] call KISKA_fnc_log;\n    nil\n};\n\n// if !(local _vehicle) exitWith {\n//     [[\"_vehicle \",_vehicle,\" is not local!\"],true] call KISKA_fnc_log;\n//     nil\n// };\n\n_vehicle limitSpeed 1;\n// Limiting the speed is not enough for some vehicles (armor)\n// They will either not stop fast enough when follow distances are small\n// Or they start to move around and find random places to go\nprivate _driver = driver _vehicle;\n// TODO: figure out if an AI changes locality, that this disableAI will persist\n// it is not clear which disableAI's are truly Global Effects\n[_driver,\"path\"] remoteExecCall [\"disableAI\",_driver];\n",
    "fileName": "fn_convoy_stopVehicle.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_stopVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_syncLatestDrivePoint\n\nDescription:\n    Ensures all vehicles in the convoy have the latest drive path point from the\n\t convoy lead as the last index of their drive path.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy's hashmap\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [ConvoyHashMap] call KISKA_fnc_convoy_syncLatestDrivePoint;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_syncLatestDrivePoint\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nparams [\"_convoyHashMap\"];\n\nprivate _latestPointToAdd = _convoyHashMap get \"_latestPointOnPath\";\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\n_convoyVehicles apply {\n\tprivate _lastAddedPoint = _x getVariable \"KISKA_convoy_lastAddedPoint\";\n\tif (_lastAddedPoint isEqualTo _latestPointToAdd) then { continue };\n\n\t_x setVariable [\"KISKA_convoy_lastAddedPoint\",_latestPointToAdd];\n\n\tif ([_x] call KISKA_fnc_convoy_isVehicleInDebug) then {\n\t\tprivate _debugObjectType = [_x] call  KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath;\n\t\tprivate _debugObject = createVehicle [_debugObjectType, _latestPointToAdd, [], 0, \"CAN_COLLIDE\"];\n\n\t\tprivate _currentVehicle_debugDrivePathObjects = [_x] call KISKA_fnc_convoy_getVehicleDebugFollowPath;\n\t\t_currentVehicle_debugDrivePathObjects pushBack _debugObject;\n\t};\n\n\tprivate _indexInserted = _currentVehicle_drivePath pushBack _latestPointToAdd;\n\tif (_indexInserted >= 1) then {\n\t\t_x setDriveOnPath _currentVehicle_drivePath;\n\t};\n\n};\n",
    "fileName": "fn_convoy_syncLatestDrivePoint.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Convoy/fn_convoy_syncLatestDrivePoint.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_eventHandler_addFromConfig\n\nDescription:\n    Adds a configed custom eventhandler.\n\nParameters:\n    0: _entityToAddEventHandlerTo <ANY> - The entity to add the eventhandler to\n    1: _config <CONFIG> - The config of the eventhandler\n    2: _code <CODE or STRING> - What to execute when the eventhandler is called\n        _thisScriptedEventHandler is available with the event id\n\nReturns:\n    <NUMBER> - The ID of the eventhandler\n\nExamples:\n    (begin example)\n        private _eventID = [\n            player,\n            myConfig\n        ] call KISKA_fnc_eventHandler_addFromConfig\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_eventHandler_addFromConfig\";\n\nparams [\n    \"_entityToAddEventHandlerTo\",\n    [\"_config\",configNull,[configNull]],\n    [\"_code\",{},[\"\",{}]]\n];\n\nif (isNull _config) exitWith {\n    [\"Could not find config!\",true] call KISKA_fnc_log;\n    -1\n};\n\nif !([_entityToAddEventHandlerTo] call (compile getText(_config >> \"entityCondition\"))) exitWith {\n    [\"_entityToAddEventHandlerTo failed condition check!\",true] call KISKA_fnc_log;\n    -1\n};\n\nprivate _stateMachine_config = _config >> \"stateMachine\";\nprivate _stateMachine_name = getText(_stateMachine_config >> \"name\");\nprivate _stateMachine = localNamespace getVariable [_stateMachine_name,locationNull];\nif (isNull _stateMachine) then {\n    _stateMachine = [_stateMachine_config] call KISKA_fnc_eventhandler_createCBAStateMachine;\n    localNamespace setVariable [_stateMachine_name,_stateMachine];\n    _stateMachine setVariable [\"KISKA_entity_eventhandlerCount_map\",createHashMap];\n};\n\nprivate _entityList = _stateMachine getVariable [\"CBA_statemachine_list\", []];\nif !(_entityToAddEventHandlerTo in _entityList) then {\n    _entityList pushBack _entityToAddEventHandlerTo;\n};\n\n// tracking number of events for use when removing events\nprivate _eventHandlerCount_map = _stateMachine getVariable \"KISKA_entity_eventhandlerCount_map\";\nprivate _currentNumberOfEventsOnEntity = [_eventHandlerCount_map,_entityToAddEventHandlerTo,0] call KISKA_fnc_hashmap_get;\n\nprivate _eventId = [\n    _entityToAddEventHandlerTo,\n    getText(_config >> \"eventName\"),\n    _code\n] call BIS_fnc_addScriptedEventhandler;\n\n_currentNumberOfEventsOnEntity = _currentNumberOfEventsOnEntity + 1;\n// update number of events on entity\n[_eventHandlerCount_map,_entityToAddEventHandlerTo,_currentNumberOfEventsOnEntity] call KISKA_fnc_hashmap_set;\n\n\n_eventId\n",
    "fileName": "fn_eventHandler_addFromConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/EventHandlers/fn_eventHandler_addFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_eventHandler_createCBAStateMachine\n\nDescription:\n    Adds a configed custom eventhandler\n\nParameters:\n    0: _config <CONFIG> - The config of the statemachine\n\nReturns:\n    <LOCATION> - The statemachine\n\nExamples:\n    (begin example)\n        _statemachine = [myConfig] call KISKA_fnc_eventHandler_createCBAStateMachine\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_eventHandler_createCBAStateMachine\";\n\nparams [\n    [\"_config\", configNull, [configNull]]\n];\n\nif (isNull _config) exitWith {\n    [\"_config passed was null!\",true] call KISKA_fnc_log;\n    locationNull;\n};\n\nprivate _skipNull = [_config >> \"skipNull\"] call BIS_fnc_getCfgDataBool;\nprivate _stateMachine = [[], _skipNull] call CBA_stateMachine_fnc_create;\n\nprivate _stateConfigClasses = configProperties [_config, \"isClass _x\", true];\n_stateConfigClasses apply {\n    private _stateName = configName _x;\n    [\n        _stateMachine,\n        compile (getText(_x >> \"onState\")),\n        compile (getText(_x >> \"onStateEntered\")),\n        compile (getText(_x >> \"onStateLeaving\")),\n        _stateName\n    ] call CBA_stateMachine_fnc_addState;\n\n};\n\n// We need to add the transitions in a second loop to make sure the states exist already\n_stateConfigClasses apply {\n    private _stateName = configName _x;\n\n    private _stateTransitionConfigClasses = configProperties [_x, \"isClass _x\", true];\n    _stateTransitionConfigClasses apply {\n        private _transitionName = configName _x;\n        private _targetState = _transitionName;\n        if (isText (_x >> \"targetState\")) then {\n            _targetState = getText (_x >> \"targetState\");\n        };\n\n        private _condition = compile (getText(_x >> \"condition\"));\n        private _onTransition = compile (getText(_x >> \"onTransition\"));\n        private _events = getArray (_x >> \"events\");\n\n        if (_events isEqualTo []) then {\n            [\n                _stateMachine,\n                _stateName,\n                _targetState,\n                _condition,\n                _onTransition,\n                _transitionName\n            ] call CBA_stateMachine_fnc_addTransition;\n\n        } else {\n            [\n                _stateMachine,\n                _stateName,\n                _targetState,\n                _events,\n                _condition,\n                _onTransition,\n                _transitionName\n            ] call CBA_stateMachine_fnc_addEventTransition;\n        };\n\n    };\n\n};\n\n\n_stateMachine\n",
    "fileName": "fn_eventHandler_createCBAStateMachine.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/EventHandlers/fn_eventHandler_createCBAStateMachine.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_eventHandler_remove\n\nDescription:\n    Removes a configed custom eventhandler.\n\n    Worth noting that this will still return `true` even after the event has been\n     removed as BIS_fnc_removeScriptedEventHandler essentially checks that the event\n     isn't one that never could have existed.\n\nParameters:\n    0: _entity <ANY> - The config of the eventhandler\n    1: _eventConfig <CONFIG> - The eventhandler config path\n    2: _id <NUMBER> - The event to remove\n\nReturns:\n    <BOOL> - `true` if removed, `false` if it never existed\n\nExamples:\n    (begin example)\n        private _removed = [\n            player,\n            configFile >> \"KISKA_EventHandlers\" >> \"KISKA_combatBehaviourChangedEvent\",\n            0\n        ] call KISKA_fnc_eventHandler_remove\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_eventHandler_remove\";\n\nparams [\n    \"_removeFrom\",\n    [\"_eventConfig\",configNull,[configNull]],\n    [\"_id\",-1,[123]]\n];\n\nif (isNull _eventConfig) exitWith {\n    [\"_eventConfig is null config!\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _stateMachine_name = getText(_eventConfig >> \"stateMachine\" >> \"name\");\nprivate _stateMachine = localNamespace getVariable [_stateMachine_name,locationNull];\nif (isNull _stateMachine) exitWith {\n    [[\"Statemachine: \", _stateMachine_name,\" has not been instantiated yet!\"],false] call KISKA_fnc_log;\n    false\n};\n\n\nprivate _eventName = getText(_eventConfig >> \"eventName\");\nprivate _removed = [_removeFrom, _eventName, _id] call BIS_fnc_removeScriptedEventHandler;\n\n// remove from statemachine list if no events are left for this machine\nif (_removed) then {\n    private _eventCountMap = _stateMachine getVariable \"KISKA_entity_eventhandlerCount_map\";\n    private _numberOfEvents = [_eventCountMap,_removeFrom] call KISKA_fnc_hashmap_get;\n\n    _numberOfEvents = _numberOfEvents - 1;\n\n    if (_numberOfEvents isEqualTo 0) then {\n        [_eventCountMap,_removeFrom] call KISKA_fnc_hashmap_deleteAt;\n\n        private _entityList = _stateMachine getVariable \"CBA_statemachine_list\";\n        _entityList deleteAt (_entityList find _removeFrom);\n    };\n};\n\n\n_removed\n",
    "fileName": "fn_eventHandler_remove.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/EventHandlers/fn_eventHandler_remove.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_deleteAt\n\nDescription:\n    Deletes a key/value pair if it's in a hashmap, supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to search in\n    1: _key <ANY> - The key to delete\n\nReturns:\n    <ANY> - The deleted value, nil if not found\n\nExamples:\n    (begin example)\n        private _value = [myMap,_key] call KISKA_fnc_hashmap_deleteAt;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_deleteAt\";\n\nparams [\"_map\",\"_key\"];\n\n\n_map deleteAt (_key call KISKA_fnc_hashmap_getRealKey);\n",
    "fileName": "fn_hashmap_deleteAt.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Hashmap/fn_hashmap_deleteAt.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_get\n\nDescription:\n    Gets a value from a hashmap but also supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to get the value from\n    1: _key <ANY> - The key to find in the map\n    2: _default <ANY> - The value to return if the map does not contain the value\n\nReturns:\n    <ANY> - The saved value, default value, or nil if not found and no default provided\n\nExamples:\n    (begin example)\n        private _value = [\n            myMap,\n            someObject,\n            \"Hello World\"\n        ] call KISKA_fnc_hashmap_get;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_get\";\n\nparams [\n    \"_map\",\n    \"_key\",\n    \"_default\"\n];\n\n_key = _key call KISKA_fnc_hashmap_getRealKey;\n\n// while not in every case, there are some instances in which \n// a nil _default will throw an error if called.\n/// in an eventhandler seems to be one such case\n/// hence why it is sectioned off instead of always used\n/// as `_map getOrDefault [_key,nil];`\nif !(isNil \"_default\") exitWith {\n    _map getOrDefault [_key,_default];\n};\n\n_map get _key;\n",
    "fileName": "fn_hashmap_get.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Hashmap/fn_hashmap_get.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_getObjectOrGroupFromRealKey\n\nDescription:\n    Retrieves the global hashmap used to associate a given real key with either a\n\t group or object with KISKA hashmap functions.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - The hashmap used for finding the given object or group from\n\t a real key used in a KISKA hashmap\n\nExamples:\n    (begin example)\n        private _kiskaObjectOrGroupKeyHashMap = call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap\";\n\nprivate _objectGroupKeyMap = localNamespace getVariable \"KISKA_hashmapKeyMap\";\nif !(isNil \"_objectGroupKeyMap\") exitWith {_objectGroupKeyMap};\n\n_objectGroupKeyMap = createHashMap;\nlocalNamespace setVariable [\"KISKA_hashmapKeyMap\",_objectGroupKeyMap];\n\n\n_objectGroupKeyMap\n",
    "fileName": "fn_hashmap_getKiskaObjectGroupKeyMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Hashmap/fn_hashmap_getKiskaObjectGroupKeyMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_getObjectOrGroupFromRealKey\n\nDescription:\n    Translates a real key used be KISKA hashmaps for groups and objects back into\n\t the associated group or object.\n\nParameters:\n    0: _key <STRING> - The real key used to identify an object or group in a KISKA hashmap\n\nReturns:\n    <OBJECT, GROUP, or NIL> - The object or group that is associated with a given key.\n\t `NIL` if no object or group matches the given key.\n\nExamples:\n    (begin example)\n\t\tprivate _key = [someObject] call KISKA_fnc_hashmap_getRealKey;\n        private _someObject = [\n\t\t\t_key\n\t\t] call KISKA_fnc_hashmap_getObjectOrGroupFromRealKey;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_getObjectOrGroupFromRealKey\";\n\nparams [\n\t[\"_key\",\"\",[\"\"]]\n];\n\nprivate _objectGroupKeyMap = call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n\n\n_objectGroupKeyMap get _key\n",
    "fileName": "fn_hashmap_getObjectOrGroupFromRealKey.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Hashmap/fn_hashmap_getObjectOrGroupFromRealKey.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_getRealKey\n\nDescription:\n    Returns the actual value used for a key when using KISKA hashmap functions.\n\t\n\tThis really only applies to objects or groups as they will have a special string\n\t used to identify them in the hashmap. Use this function to get the key of them\n\t if you need to do multiple operations on a hashmap with the same object or group\n\t and do not want the overhead of the functions.\n\nParameters:\n    0: _key <ANY> - The key used with KISKA hashmap functions (such as object or group)\n\nReturns:\n    <ANY> - Whatever the key will be in a hashmap\n\nExamples:\n    (begin example)\n        private _keyUsedInKiskaHashmap = [someObject] call KISKA_fnc_hashmap_getRealKey;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_getRealKey\";\n\nparams [\"_key\"];\n\nif !(_key isEqualTypeAny [grpNull,objNull]) exitWith { _key };\nprivate _keyInNamespace = _key getVariable \"KISKA_hashmap_realKey\";\nif !(isNil \"_keyInNamespace\") exitWith { _keyInNamespace };\n\n\n_keyInNamespace = \"KISKA_hashmap_realKey\" call KISKA_fnc_generateUniqueId;\n_key setVariable [\"KISKA_hashmap_realKey\",_keyInNamespace];\nprivate _objectGroupKeyMap = call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n_objectGroupKeyMap set [_keyInNamespace,_key];\n_key addEventHandler [\"Deleted\", {\n\tparams [\"_objectOrGroup\"];\n\tprivate _key = _objectOrGroup getVariable \"KISKA_hashmap_realKey\";\n\tprivate _objectGroupKeyMap = [] call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n    if !(isNil \"_key\") then { _objectGroupKeyMap deleteAt _key; };\n}];\n\n\n_keyInNamespace\n",
    "fileName": "fn_hashmap_getRealKey.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Hashmap/fn_hashmap_getRealKey.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_in\n\nDescription:\n    Checks if a key exists in a hashmap, supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to search in\n    1: _key <ANY> - The key to find\n\nReturns:\n    <BOOL> - True if the key is found, false if not\n\nExamples:\n    (begin example)\n        [myMap,_key] call KISKA_fnc_hashmap_in;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_in\";\n\nparams [\"_map\",\"_key\"];\n\n(_key call KISKA_fnc_hashmap_getRealKey) in _map\n",
    "fileName": "fn_hashmap_in.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Hashmap/fn_hashmap_in.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_set\n\nDescription:\n    Sets a key/value pair in a hashmap but also supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to insert in to\n    1: _key <ANY> - The key to associate with the value\n    2: _value <ANY> - The value to associate witht the key\n    3: _insertOnly <BOOL> - When `true`, if the key already exists in the hashmap, \n     the value will not be overwritten\n\nReturns:\n    <BOOL> - False if key is new, true if overwriting\n\nExamples:\n    (begin example)\n        private _inserted = [\n            myMap,\n            someObject,\n            \"Hello World\"\n        ] call KISKA_fnc_hashmap_set;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_set\";\n\nparams [\n    \"_map\",\n    \"_key\",\n    \"_value\",\n    [\"_insertOnly\",false,[true]]\n];\n\n_key = _key call KISKA_fnc_hashmap_getRealKey;\n_map set [_key,_value,_insertOnly];\n",
    "fileName": "fn_hashmap_set.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Hashmap/fn_hashmap_set.sqf"
  },
  {
    "text": "\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_assignUnitLoadout\n\nDescription:\n    Searches a config class for an array that matches the units classname.\n    This array is filled with potential loadout arrays for the unit.\n\nParameters:\n    0: _config <CONFIG> - The config to search for the array of loadouts in\n    1: _units <ARRAY, GROUP, or OBJECT> - The unit(s) to apply the function to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            missionConfigFile >> \"KISKA_loadouts\" >> \"ONL\",\n            unit1\n        ] call KISKA_fnc_assignUnitLoadout\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_assignUnitLoadout\";\n\nparams [\n    [\"_configPath\",configNull,[configNull]],\n    [\"_units\",[],[[],objNull,grpNull]]\n];\n\n\n// verify params\nif (isNull _configPath) exitWith {\n    [\"A null config was passed\",true] call KISKA_fnc_log;\n    nil\n};\nif (_units isEqualTo []) exitWith {\n    [\"Empty array for _units\",true] call KISKA_fnc_log;\n    nil\n};\nif (_units isEqualTypeAny [objNull,grpNull] AND {isNull _units}) exitWith {\n    [\"_units is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n// organize other data types into array\nif (_units isEqualType objNull) then {\n    _units = [_units];\n};\nif (_units isEqualType grpNull) then {\n    _units = units _units;\n};\n\n\n// assign loadouts\nprivate _loadoutHashmap = createHashMap;\n_units apply {\n    private _unit = _x;\n\n    if (alive _unit AND {!isNull _unit}) then {\n\n        private \"_loadoutsForClass\";\n        private _unitClass = typeOf _unit;\n        if (_unitClass in _loadoutHashmap) then {\n            _loadoutsForClass = _loadoutHashmap get _unitClass;\n\n        } else {\n            _loadoutsForClass = getArray(_configPath >> _unitClass);\n            _loadoutHashmap set [_unitClass,_loadoutsForClass];\n\n        };\n\n\n        if (_loadoutsForClass isEqualTo []) then {\n            [[\"Class \", _unitClass, \" does not have any configed loadouts in directory: \",_configPath],true] call KISKA_fnc_log;\n\n        } else {\n            private _newLoadout = selectRandom _loadoutsForClass;\n            private _oldLoadout = getUnitLoadout _unit;\n            // making sure changes took over network\n            [\n                {\n                    scriptName \"KISKA_fnc_assignUnitLoadout\";\n\n                    params [\"_unit\",\"_newLoadout\",\"_oldLoadout\"];\n\n                    private _attemptedSetLoadoutCount = _unit getVariable [\"KISKA_assignLoadout_attemptCount\",0];\n                    if (_attemptedSetLoadoutCount >= 5) then {\n                        [[\"Attempted to set the loadout of unit: \",_unit,\" \",_attemptedSetLoadoutCount,\" times without reaching completion\"]] call KISKA_fnc_log;\n                        [[\"unit's current loadout: \",endl,getUnitLoadout _unit]] call KISKA_fnc_log;\n                        [[\"loadout to set to: \",endl,_newLoadout]] call KISKA_fnc_log;\n                    };\n\n\n                    // units don't like being not simmed on dedicated servers while changing loadouts this, so do it temporarily if needed\n                    if (\n                        !(simulationEnabled _unit) AND \n                        !(_unit getVariable [\"KISKA_assignLoadout_enabledSimulation\",false])\n                    ) then {\n                        _unit setVariable [\"KISKA_assignLoadout_enabledSimulation\",true];\n                        [_unit,true] remoteExecCall [\"enableSimulationGlobal\",2];\n                    };\n                    \n                    _unit setUnitLoadout _newLoadout;\n                    _unit setVariable [\"KISKA_assignLoadout_attemptCount\",_attemptedSetLoadoutCount + 1];\n\n                    private _currentLoadout = getUnitLoadout _unit;\n                    if (_currentLoadout isEqualTo _newLoadout) exitWith { true };\n                    if (_currentLoadout isEqualTo _oldLoadout) exitWith { false };\n\n                    // Some loadouts may not have the exact bullet count (round in the chamber or not)\n                    // which causes isEqualTo to return false\n                    private _deepCompareMatches = true;\n                    {\n                        if (_forEachIndex > 5) then {break};\n\n                        private _currentLoadoutClassToCompare = _x select 0;\n                        private _newLoadoutClassToCompare = (_newLoadout select _foreachIndex) select 0;\n                        if (_currentLoadoutClassToCompare != _newLoadoutClassToCompare) then {\n                            _deepCompareMatches = false;\n                            break\n                        };\n                    } forEach _currentLoadout;\n\n\n                    _deepCompareMatches\n                },\n                {\n                    params [\"_unit\",\"_newLoadout\"];\n                    \n                    private _simulationWasDisabled = _unit getVariable [\"KISKA_assignLoadout_enabledSimulation\",false];\n                    // return units to being unsimmed if they were before\n                    if (_simulationWasDisabled) then {\n                        _unit setVariable [\"KISKA_assignLoadout_enabledSimulation\",nil];\n                        [_unit,false] remoteExecCall [\"enableSimulationGlobal\",2];\n                    };\n\n                    if !(isNil {_unit getVariable \"KISKA_ambientAnimMap\"}) then {\n                        [_unit,_newLoadout] call KISKA_fnc_ambientAnim_setStoredLoadout;\n                    };\n\n                    _unit setVariable [\"KISKA_assignLoadout_attemptCount\",nil];\n                },\n                0.5,\n                [_unit,_newLoadout,_oldLoadout]\n            ] call KISKA_fnc_waitUntil;\n\n        };\n\n    };\n};\n\n\nnil\n",
    "fileName": "fn_assignUnitLoadout.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Loadouts/fn_assignUnitLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomGear\n\nDescription:\n    Randomizes gear based upon input arrays for each slot. Be aware that this function\n     is very slow (can take >1ms for a single unit) and should be used ideally \n     on initialization for large numbers of units. \n\n    The units must be local to the machine where this function is executed.\n\n    All gear arrays can be weighted or unweighted arrays.\n\nParameters:\n    0: _units : <OBJECT or OBJECT[]> - The units to randomize the gear of\n    1: _uniforms : <STRING[] or (STRING,NUMBER)[]> - Potential uniforms to wear\n    2: _headgear : <STRING[] or (STRING,NUMBER)[]> - Potential headgear to wear\n    3: _facewear : <STRING[] or (STRING,NUMBER)[]> - Potential facewear (goggles) to wear\n    4: _vests : <STRING[] or (STRING,NUMBER)[]> - Potential vests to wear\n    5: _backpacks : <STRING[] or (STRING,NUMBER)[]> - Potential backpacks to wear\n    6: _primaryWeapons : <[STRING,(STRING[] | (STRING,NUMBER)[])][]> - An array of \n        primary weapons and items to add to them (see example). The items will be\n        added using `addPrimaryWeaponItem`.\n    7: _handguns : <[STRING,(STRING[] | (STRING,NUMBER)[])][]> - An array of \n        handgun weapons and items to add to them (see example). The items will be\n        added using `addHandgunItem`.\n    8: _secondaryWeapons : <[STRING,(STRING[] | (STRING,NUMBER)[])][]> - An array of \n        secondary (launcher) weapons and items to add to them (see example). The items \n        will be added using `addSecondaryWeaponItem`.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _uniforms = [\"U_B_CombatUniform_mcam_vest\"];\n        private _headgear = [];\n        private _facewear = [];\n        private _vests = [];\n        private _backpacks = [];\n        private _primaryWeapons = [\n            // add a mag and optic to rifle\n            [\"arifle_MXC_F\",[\"optic_Aco\",\"30Rnd_65x39_caseless_mag\"]]\n        ];\n\n        [\n            _units,\n            _uniforms,\n            _headgear,\n            _facewear,\n            _vests,\n            _backpacks,\n            _primaryWeapons\n        ] call KISKA_fnc_randomGear;\n    (end)\n\n    (begin example)\n        // Weighted array \n        private _uniforms = [\n            \"U_B_CombatUniform_mcam_vest\", 0.5,\n            \"U_B_CombatUniform_mcam_tshirt\", 0.25,\n            \"U_B_CombatUniform_mcam\", 0.25\n        ];\n\n        [\n            _units,\n            _uniforms\n        ] call KISKA_fnc_randomGear;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomGear\";\n\nparams [\n\t[\"_units\",objNull,[objNull,[]]],\n\t[\"_uniforms\",[],[[]]],\n\t[\"_headgear\",[],[[]]],\n\t[\"_facewear\",[],[[]]],\n\t[\"_vests\",[],[[]]],\n\t[\"_backpacks\",[],[[]]],\n\t[\"_primaryWeapons\",[],[[]]],\n\t[\"_handguns\",[],[[]]],\n\t[\"_secondaryWeapons\",[],[[]]]\n];\n\nif (_units isEqualType objNull) then {\n    _units = [_units];\n};\n\nprivate _gearSelectors = [\n    [_uniforms, { params [\"_gear\",\"_unit\"]; _unit forceAddUniform _gear }],\n    [_headgear, { params [\"_gear\",\"_unit\"]; _unit addHeadgear _gear; }],\n    [_facewear, { params [\"_gear\",\"_unit\"]; _unit addGoggles _gear; }],\n    [_vests, { params [\"_gear\",\"_unit\"]; _unit addVest _gear; }],\n    [_backpacks, { params [\"_gear\",\"_unit\"]; _unit addBackpack _gear; }],\n    [\n        _primaryWeapons, \n        {\n            params [\"_gear\",\"_unit\"];\n            _gear params [\n                \"_weapon\",\n                [\"_weaponItems\",[]]\n            ];\n            _unit addWeapon _weapon;\n            _weaponItems apply { _unit addPrimaryWeaponItem _x };\n        },\n        []\n    ],\n    [\n        _handguns, \n        { \n            params [\"_gear\",\"_unit\"];\n            _gear params [\n                \"_weapon\",\n                [\"_weaponItems\",[]]\n            ];\n            _unit addWeapon _weapon;\n            _weaponItems apply { _unit addHandgunItem _x };\n        },\n        []\n    ],\n    [\n        _secondaryWeapons, \n        { \n            params [\"_gear\",\"_unit\"];\n            _gear params [\n                \"_weapon\",\n                [\"_weaponItems\",[]]\n            ];\n            _unit addWeapon _weapon;\n            _weaponItems apply { _unit addSecondaryWeaponItem _x };\n        },\n        []\n    ]\n];\n\n_units apply {\n    private _unit = _x;\n\n    if (isNull _unit) then {\n        [\"Null unit was passed\",true] call KISKA_fnc_log;\n        continue;\n    };\n\n    if (!local _unit) then {\n        [[_unit,\" is not a local unit; must be executed where unit is local!\"],true] call KISKA_fnc_log;\n        continue;\n    };\n\n    // remove all existing stuff\n    removeAllWeapons _unit;\n    removeAllItems _unit;\n    removeAllAssignedItems _unit;\n    removeUniform _unit;\n    removeVest _unit;\n    removeBackpack _unit;\n    removeHeadgear _unit;\n    removeGoggles _unit;\n\n    _gearSelectors apply {\n        _x params [\n            \"_availableGear\",\n            \"_fn_addGear\",\n            [\"_valueType\",\"\"]\n        ];\n\n        if (_availableGear isEqualTo []) then { continue };\n        \n        private _randomlySelectedGear = [_availableGear,_valueType] call KISKA_fnc_selectRandom;\n        [_randomlySelectedGear, _unit] call _fn_addGear;\n    };\n\n};\n\n\nnil\n",
    "fileName": "fn_randomGear.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Loadouts/fn_randomGear.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomGearFromConfig\n\nDescription:\n    Randomizes gear based upon input arrays for each slot. See `KISKA_fnc_randomGear`\n     for details on behavior.\n\n    Configs can also be conditional (see `KISKA_fnc_getConditionalConfigClass`).\n\n    Here is an example config class for random gear:\n    (begin config example)\n        class MyRandomGearConfigClass\n        {\n            headgear[] = {\n                \"H_Booniehat_khk_hs\",\n                \"H_HelmetB\"\n            };\n            vests[] = {\n                \"V_PlateCarrier1_rgr\",\n                \"V_PlateCarrier2_rgr\"\n            };\n            primaryWeapons[] = {\n                {\"arifle_MX_F\",{\"optic_Aco\",\"30Rnd_65x39_caseless_mag\"}},\n                {\"arifle_MX_F\",{\"optic_Hamr\",\"30Rnd_65x39_caseless_mag\"}}\n            };\n            handguns[] = {\n                {\"hgun_Pistol_heavy_01_F\"}\n            };\n            // Weighted array\n            facewear[] = {\n                \"\", 1, // empty\n                \"G_Shades_Black\", 0.5,\n                \"G_Tactical_Clear\", 0.75,\n                \"G_Tactical_Black\", 2\n            };\n        };\n    (end)\n\nParameters:\n    0: _units : <OBJECT or OBJECT[]> - The unit or units to randomize the gear of.\n    1: _gearConfig : <CONFIG or STRING> - A config that contains weighted or unweighted arrays\n        that match the inputs of `KISKA_fnc_randomGear` (\"uniforms\", \"headgear\", etc.).\n        If a STRING, it is assumed it is the className that exists in `missionConfigFile >> \"KISKA_RandomGear\"`\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            player,\n            missionConfigFile >> \"KISKA_randomGear\" >> \"MyRandomGearConfigClass\"\n        ] call KISKA_fnc_randomGear;\n    (end)\n\n    (begin example)\n        [\n            [unit_1, unit_2],\n            \"MyRandomGearConfigClass\"\n        ] call KISKA_fnc_randomGearFromConfig;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomGearFromConfig\";\n\nparams [\n    [\"_units\",[],[objNull,[]]],\n    [\"_gearConfig\",configNull,[\"\",configNull]]\n];\n\nif (_gearConfig isEqualType \"\") then {\n    _gearConfig = missionConfigFile >> \"KISKA_RandomGear\" >> _gearConfig;\n};\nif (isNull _gearConfig) exitWith {\n    [\"Null _gearConfig passed\",true] call KISKA_fnc_log;\n    nil\n};\n\n_gearConfig = _gearConfig call KISKA_fnc_getConditionalConfigClass;\n[\n    _units,\n    getArray(_gearConfig >> \"uniforms\"),\n    getArray(_gearConfig >> \"headgear\"),\n    getArray(_gearConfig >> \"facewear\"),\n    getArray(_gearConfig >> \"vests\"),\n    getArray(_gearConfig >> \"backpacks\"),\n    getArray(_gearConfig >> \"primaryWeapons\"),\n    getArray(_gearConfig >> \"handguns\"),\n    getArray(_gearConfig >> \"secondaryWeapons\")\n] call KISKA_fnc_randomGear;\n\n\nnil\n",
    "fileName": "fn_randomGearFromConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Loadouts/fn_randomGearFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomLoadout\n\nDescription:\n    Randomly assigns a loadout from the inputed array to the unit(s) provided.\n\nParameters:\n    0: _units <OBJECT, GROUP, or ARRAY> - The unit or units you want to select the\n        random loadout for. If array, accepts and array of objects.\n    1: _loadoutArray <ARRAY> - An array containing each loadout array.\n        Same syntax as getUnitLoadout return.\n\nReturns:\n    _unitsChanged <ARRAY> - All the units changed\n\nExamples:\n    (begin example)\n        [guy,[globalLoadout1,globalLoadout2]] call KISKA_fnc_randomLoadout;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomLoadout\";\n\nparams [\n    [\"_units\",objNull,[objNull,grpNull,[]]],\n    [\"_loadoutArray\",[],[[]]]\n];\n\nif (_units isEqualType grpNull) then {\n    _units = units _units;\n};\n\nif (_units isEqualType objNull) then {\n    _units = [_units];\n};\n\nprivate _unitsChanged = [];\n\n_units apply {\n    if (alive _x AND {!isNull _x}) then {\n        _x setUnitLoadout (selectRandom _loadoutArray);\n        _x pushBack _unitsChanged;\n    };\n};\n\n_unitsChanged\n",
    "fileName": "fn_randomLoadout.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Loadouts/fn_randomLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_savePlayerLoadout\n\nDescription:\n    Adds a kill and respawn eventhandler to the player object that restores\n     saves and restores the player loadout (if set in CBA menu settings).\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_savePlayerLoadout\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_savePlayerLoadout;\n};\n\nwaitUntil {\n    if !(isNull player) then { breakWith true };\n    sleep 1;\n    false\n};\n\nplayer addEventHandler [\"KILLED\", {\n    params [\"_unit\"];\n\n    private _loadout = getUnitLoadout _unit;\n    localNamespace setVariable [\"KISKA_loadout\",_loadout];\n    localNamespace setVariable [\"KISKA_playersBody\",_unit];\n}];\n\nplayer addEventHandler [\"RESPAWN\", {\n    private _doRestoreLoadout = missionNamespace getVariable [\"KISKA_CBA_restorePlayerLoadout\",false];\n    if (_doRestoreLoadout AND !(isNil {localNamespace getVariable \"KISKA_loadout\"})) then {\n        [\n            {\n                player setUnitLoadout (localNamespace getVariable \"KISKA_loadout\");\n            },\n            [],\n            0.5\n        ] call CBA_fnc_waitAndExecute;\n    };\n\n    private _doDeleteBody = missionNamespace getVariable [\"KISKA_CBA_deleteBody\",false];\n    private _playerBody = localNamespace getVariable \"KISKA_playersBody\";\n    if (_doDeleteBody AND !(isNil \"_playerBody\")) then {\n        deleteVehicle _playerBody;\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_savePlayerLoadout.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Loadouts/fn_savePlayerLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_managedRun_execute\n\nDescription:\n    Allows multiple systems to manage a particular functionality or subset of code\n     by restricting runs to only the latest id for a given namespace\n\n    The code must be added with KISKA_fnc_managedRun_updateCode.\n\n    An example is having competing systems that need to adjust the damage of the player\n     at different times an perhaps with delays. Perhaps one system starts by taking ownership\n     of this functionality to not allow the player to be damaged, however, later this system\n     will reset wether or not the player has damage allowed after some delay.\n    If another system (or the same one again in the future) wants to take ownership of this\n     functionality to also set the player to not allow damage BEFORE the previous system\n     has reset the player's isDamageAllowed state, it could become complex to try and handle\n     the reset vs continuing to allow the player to not take damage. Instead, the previous\n     system's code will now be blocked from running, as another id has taken ownership.\n\nParameters:\n    0: _nameOfCode : <STRING> - The name of the code to run previously added with\n        KISKA_fnc_managedRun_updateCode\n    1: _args : <ARRAY> - An array of arguments that will be `_this` within the\n        code to run\n    2: _idNamespace : <GROUP, OBJECT, LOCATION, NAMESPACE, CONTROL, DISPLAY, TASK, TEAM-MEMBER> - \n        The namespace to restrict the id to. This is used to manage runs on two different\n         objects for example\n    3: _idToRunAgainst : <NUMBER> - The id the code is restricted to run against\n    4: _isScheduled : <BOOL> - Whether the code will be executed in a scheduled environment\n\nReturns:\n    <NUMBER> - The id of the run made, `-1` if code was not run or a new id to make future runs\n        against for a particular system.\n\nExamples:\n    (begin example)\n        // add code for given id\n        [\n            \"KISKA_manage_allowDamage\",\n            {\n                params [\"_unit\",\"_isDamageAllowed\"];\n                _unit allowDamage _isDamageAllowed;\n            }\n        ] call KISKA_fnc_managedRun_updateCode;\n\n        // initial run\n        private _idOfRun = [\n            \"KISKA_manage_allowDamage\",\n            [player, false],\n            player\n        ] call KISKA_fnc_managedRun_execute;\n\n        // try to change in the future\n        [_idOfRun] spawn {\n            params [\"_idOfRun\"];\n            sleep 3;\n            // does nothing because id was overwritten in the meantime\n            [\n                \"KISKA_manage_allowDamage\",\n                [player, true],\n                player,\n                _idOfRun\n            ] call KISKA_fnc_managedRun_execute;\n\n            hint str (isDamageAllowed player) // false\n        };\n\n        private _idOfADifferentRun = [\n            \"KISKA_manage_allowDamage\",\n            [player, false],\n            player\n        ] call KISKA_fnc_managedRun_execute;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_managedRun_execute\";\n\nparams [\n    [\"_nameOfCode\",\"\",[\"\"]],\n    [\"_args\",[],[[]]],\n    [\"_idNamespace\",localNamespace,[grpNull,objNull,locationNull,controlNull,displayNull,taskNull,teamMemberNull,localNamespace]],\n    [\"_idToRunAgainst\",-1,[123]],\n    [\"_isScheduled\",false,[true]]\n];\n\nprivate _codeMap = localNamespace getVariable [\"KISKA_managedRun_codeMap\",-1];\nif (_codeMap isEqualTo -1) exitWith { \n    [\n        [\n            \"KISKA_managedRun_codeMap is not defined, did you add \",\n            _nameOfCode,\n            \" with KISKA_fnc_managedRun_updateCode?\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n    -1 \n};\n\nif !(_nameOfCode in _codeMap) exitWith { \n    [\n        [\n            \"KISKA_managedRun_codeMap does not contain key for \",\n            _nameOfCode,\n            \". Did you add \",\n            _nameOfCode,\n            \" with KISKA_fnc_managedRun_updateCode?\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n    -1 \n};\n\n\nprivate _isNewManagement = _idToRunAgainst isEqualTo -1;\nprivate _currentAdjustmentId = _idNamespace getVariable [\"KISKA_managedRun_latestId\",-1];\nprivate _idToAdjustIsCurrent = _currentAdjustmentId isEqualTo _idToRunAgainst;\nprivate _newAdjustmentIdExists = (!_isNewManagement) AND (!_idToAdjustIsCurrent) AND (_currentAdjustmentId isNotEqualTo -1);\n// new id was made, don't run code\nif (_newAdjustmentIdExists) exitWith { -1 };\n\nprivate _idOfRun = -1;\nif (_isNewManagement) then {\n    // assign new adjusment id as latest\n    _idOfRun = [\"KISKA_managedRun_latestId\",_idNamespace] call KISKA_fnc_idCounter;\n} else {\n    _idOfRun = _idToRunAgainst;\n};\n\nprivate _code = _codeMap get _nameOfCode;\n[_args,_code,_isScheduled] call KISKA_fnc_callBack;\n\n\n_idOfRun\n",
    "fileName": "fn_managedRun_execute.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Managed Run/fn_managedRun_execute.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_managedRun_isDefined\n\nDescription:\n    Checks if a given name is currently defined in the managedRun code map.\n\nParameters:\n    0: _nameOfCode : <STRING> - The name of the code to update\n\nReturns:\n    <BOOL> - Whether or not the managed run code is defined\n    \nExamples:\n    (begin example)\n        // false\n        private _isDefined = [\"KISKA_test\"] call KISKA_fnc_managedRun_isDefined;\n        [\"KISKA_test\",{hint \"Hello World\"}] call KISKA_fnc_managedRun_updateCode;\n        // true now\n        _isDefined = [\"KISKA_test\"] call KISKA_fnc_managedRun_isDefined;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_managedRun_isDefined\";\n\nparams [\n    [\"_nameOfCode\",\"\",[\"\"]]\n];\n\nprivate _codeMap = localNamespace getVariable [\"KISKA_managedRun_codeMap\",-1];\nif (_codeMap isEqualTo -1) exitWith { false };\n\n\n_nameOfCode in _codeMap\n",
    "fileName": "fn_managedRun_isDefined.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Managed Run/fn_managedRun_isDefined.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_managedRun_updateCode\n\nDescription:\n    Adjusts the code for a given ID that will run when called \n     from KISKA_fnc_managedRun_execute\n\nParameters:\n    0: _nameOfCode : <STRING> - The name of the code to update\n    1: _code : <CODE, STRING, ARRAY> - The code to run when ID is called \n        (see KISKA_fnc_callBack). Use `{}` to remove the handler all together.\n\nReturns:\n    NOTHING\n    \nExamples:\n    (begin example)\n        [\"KISKA_test\",{hint \"Hello World\"}] call KISKA_fnc_managedRun_updateCode;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_managedRun_updateCode\";\n\nparams [\n    [\"_nameOfCode\",\"\",[\"\"]],\n    [\"_code\",{},[{},[],\"\"]]\n];\n\nprivate _codeMap = localNamespace getVariable [\"KISKA_managedRun_codeMap\",-1];\nif (_codeMap isEqualTo -1) then {\n    _codeMap = createHashMap;\n    localNamespace setVariable [\"KISKA_managedRun_codeMap\",_codeMap];\n};\n\nif ((_nameOfCode in _codeMap) AND (_code call KISKA_fnc_isEmptyCode)) exitWith {\n    _codeMap deleteAt _nameOfCode;\n    nil\n};\n\n_codeMap set [_nameOfCode,_code];\n\n\nnil\n",
    "fileName": "fn_managedRun_updateCode.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Managed Run/fn_managedRun_updateCode.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_addObjects\n\nDescription:\n    Adds objects to the list that must be killed for a multi kill event to complete.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n    1: _objects <OBJECT | OBJECT[]> - The objects to add to the multi kill event.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            MyObject\n        ] call KISKA_fnc_multiKillEvent_addObjects;\n    (end)\n    \n    (begin example)\n        [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            [MyObject_1,MyObject_2]\n        ] call KISKA_fnc_multiKillEvent_addObjects;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_addObjects\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_objects\",objNull,[[],objNull]]\n];\n\nif (_objects isEqualType objNull) then { _objects = [_objects]; };\nif (_objects isEqualTo []) exitWith {};\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {\n    [[\"Event \",_id,\" does not exist\"],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_eventMap getOrDefaultCall [\"thresholdMet\",{true}]) exitWith {\n    [[\"Event \",_id,\" was already completed\"],false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _eventHandlerCode = _eventMap get \"eventHandlerCode\";\nprivate _previousTotal = _eventMap getOrDefaultCall [\"total\",{0}];\nprivate _objectHashSet = _eventMap get \"objectHashSet\";\nprivate _eventType = _eventMap get \"type\";\nprivate _useMpKilled = _eventType == \"MPKILLED\";\nprivate _eventVar = _id + \"_killedEventId\";\nprivate _numberAdded = 0;\n_objects apply {\n    if (\n        !(_x isEqualType objNull) OR \n        { !(alive _x) } OR\n        // already part of multi kill event\n        { !(isNil {_x getVariable _eventVar}) }\n    ) then { continue };\n\n    private \"_killedEventId\";\n    if (_useMPKilled) then {\n        _killedEventId = _x addMPEventHandler [\"MPKILLED\", _eventHandlerCode];\n    } else {\n        _killedEventId = _x addEventHandler [\"KILLED\", _eventHandlerCode];\n    };\n\n    _x setVariable [_eventVar,_killedEventId];\n    [_objectHashSet, _x, _x] call KISKA_fnc_hashmap_set;\n    _numberAdded = _numberAdded + 1;\n};\n_eventMap set [\"total\",_previousTotal + _numberAdded];\n\n\nnil\n// To solve issue, simply have a hashmap that effectively is a set\n// So all the keys are the objects and their values are also the objects\n// that way you can just use the values command.",
    "fileName": "fn_multiKillEvent_addObjects.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_addObjects.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_create\n\nDescription:\n    Sets up an event that will fire when a percentage of objects are killed.\n    Uses `\"KILLED\"` or `\"MPKILLED\"` eventhandlers.\n\n    This should be called where the arguments are local if `_useMPKilled` is `false`\n    or on the server if `_useMPKilled` is `true`.\n\nParameters:\n    0: _objects <OBJECT[]> - An array of objects to add some form of killed event handlers to.\n    1: _onThresholdMet <CODE, ARRAY, or STRING> - Code that executes once the \n        given threshold have been killed (executed after the `onKilled` of whatever \n        the last killed object was). (See `KISKA_fnc_callBack`)\n                \n        Params:\n        - 0. <ARRAY> - The default arguments passed to either the MPKILLED or KILLED\n            event handler.\n        - 1. <STRING> - The ID of the multi kill event.\n\n    2: _threshold <NUMBER> - A number between `0` and `1` that denotes the percentage \n        of objects that must've been killed to trigger the `_onThresholdMet`.\n        (e.g. `1` means 100% of them need to be killed, `0.5` means 50%, etc.)\n    3: _onKilled <CODE, ARRAY, or STRING> - Code that executes each time a unit has been\n        killed (after the `_onThresholdMet` if threshold has been met). (See `KISKA_fnc_callBack`)\n                \n        Params:\n        - 0. <ARRAY> - the killed evenhandler params\n        - 1. <HASHMAP> - the hashmap described below in \"Returns\"\n\n    4: _useMPKilled <BOOL> - Whether or not to use `\"MPKILLED\"` events instead of `\"KILLED\"`.\n        IF TRUE, MUST BE RUN ON THE SERVER\n\nReturns:\n    <STRING> - An ID to identify the multi kill event.\n\nExamples:\n    (begin example)\n        private _id = [\n            [someObject, anotherObject],\n            {\n                params [\"_killedEventParams\",\"_eventId\"];\n                _killedEventParams params [\"_killedObject\"];\n                hint str _this;\n            }\n        ] call KISKA_fnc_multiKillEvent_create;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_create\";\n\nparams [\n    [\"_objects\",[],[[]]],\n    [\"_onThresholdMet\",{},[[],{},\"\"]],\n    [\"_threshold\",1,[123]],\n    [\"_onKilled\",{},[{},[],\"\"]],\n    [\"_useMPKilled\",false,[true]]\n];\n\n\nif (_useMPKilled AND (!isServer)) exitWith {\n    [\"If using MPKILLED eventhandlers, this must be executed on the server!\",true] call KISKA_fnc_log;\n    \"\"\n};\n\n\nprivate _eventId = [\"KISKA_multiKillEvent\"] call KISKA_fnc_generateUniqueId;\nprivate _eventMap = createHashMap;\n_eventMap set [\"id\", _eventId];\n_eventMap set [\"killedCount\", 0];\n_eventMap set [\"thresholdMet\", false];\n\nprivate _onEventTriggered = {\n    params [\"_killedEventArgs\",\"_eventMap\",\"_eventId\"];\n    private _onKilled = _eventMap getOrDefault [\"onKilled\",{}];\n    [[_killedEventArgs,_eventId], _onKilled] call KISKA_fnc_callBack;\n\n    if (_eventMap getOrDefaultCall [\"thresholdMet\",{false}]) exitWith {};\n\n    private _total = _eventMap getOrDefaultCall [\"total\",{0}];\n    private _killedCount = _eventMap getOrDefaultCall [\"killedCount\",{0}];\n    _killedCount = _killedCount + 1;\n    _eventMap set [\"killedCount\", _killedCount];\n\n    private _threshold = _eventMap getOrDefaultCall [\"threshold\",{1}];\n    private _metThreshold = (_killedCount / _total) >= _threshold;\n    if !(_metThreshold) exitWith {};\n\n    _eventMap set [\"thresholdMet\", true];\n    private _onThresholdMet = _eventMap getOrDefault [\"onThresholdMet\",{}];\n    [[_killedEventArgs,_eventId], _onThresholdMet] call KISKA_fnc_callBack;\n};\n_eventMap set [\"onEventTriggered\", _onEventTriggered];\n\nprivate _eventHandlerCode = [\n    \"private _eventId =\",[_eventId] call KISKA_fnc_str,\";\",\n    \"private _eventMap = [_eventId] call KISKA_fnc_multiKillEvent_getEventMap;\",\n    \"private _onEventTriggered = _eventMap getOrDefault ['onEventTriggered',{}];\",\n    \"[_this,_eventMap,_eventId] call _onEventTriggered;\"\n] joinString \" \";\nprivate _type = \"\";\nif (_useMPKilled) then {\n    _type = \"MPKILLED\";\n    _eventHandlerCode = \"if (isServer) then { \" + _eventHandlerCode + \" };\";\n} else {\n    _type = \"KILLED\";\n};\n_eventMap set [\"eventHandlerCode\", _eventHandlerCode];\n_eventMap set [\"type\", _type];\n_eventMap set [\"objectHashSet\", createHashMap];\n\n\nprivate _containerMap = call KISKA_fnc_multiKillEvent_getContainerMap;\n_containerMap set [_eventId,_eventMap];\n\n[_eventId,_objects] call KISKA_fnc_multiKillEvent_addObjects;\n[_eventId,_threshold] call KISKA_fnc_multiKillEvent_threshold;\n[_eventId,_onThresholdMet] call KISKA_fnc_multiKillEvent_onThresholdMet;\n[_eventId,_onKilled] call KISKA_fnc_multiKillEvent_onKilled;\n\n\n_eventId\n",
    "fileName": "fn_multiKillEvent_create.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_create.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_delete\n\nDescription:\n    Removes all traces of a multi kill event.\n\n    This can only be performed on an event that has not had its threshold met.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <BOOL> - `true` if the event was deleted or does not exist. \n        `false` if the event exists but its threshold was met and therefore\n        it will not be deleted.\n\nExamples:\n    (begin example)\n        private _wasDeleted = \"KISKA_multiKillEvent_uid_0_0\" \n            call KISKA_fnc_multiKillEvent_delete;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_delete\";\n\nparams [\n    [\"_id\",\"\",[\"\"]]\n];\n\nprivate _containerMap = _id call KISKA_fnc_multiKillEvent_getContainerMap;\nif !(_id in _containerMap) exitWith { true };\n\nprivate _eventMap = _containerMap get _id;\n_containerMap deleteAt _id;\nif (_eventMap getOrDefaultCall [\"thresholdMet\",{false}]) exitWith { false };\n\nprivate _objectHashSet = _eventMap get \"objectHashSet\";\n[_id,(values _objectHashSet)] call KISKA_fnc_multiKillEvent_removeObjects;\n\n\ntrue\n",
    "fileName": "fn_multiKillEvent_delete.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_delete.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_getContainerMap\n\nDescription:\n    Returns the map that contains the event maps\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <HASHMAP> - A hashmap for all the event maps\n\nExamples:\n    (begin example)\n        private _containerMap = call KISKA_fnc_multiKillEvent_getContainerMap;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_getContainerMap\";\n\nprivate _containerMap = localNamespace getVariable \"KISKA_multiKillEvent_containerMap\";\nif (isNil \"_containerMap\") then {\n    _containerMap = createHashMap;\n    localNamespace setVariable [\"KISKA_multiKillEvent_containerMap\",_containerMap];\n};\n\n\n_containerMap\n",
    "fileName": "fn_multiKillEvent_getContainerMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_getContainerMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_getEventMap\n\nDescription:\n    Returns the metadata map for a multi kill event. Ideally should not be modified\n    directly as it may create unintended behaviour.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <HASHMAP | NIL> - A hashmap containing info about the event:\n\n    - `id`: <STRING> - The ID of the multi kill event.\n    - `total`: <NUMBER> - The total number of objects that have this killed event.\n    - `killedCount`: <NUMBER> - The total number of objects that have been killed \n        with this event.\n    - `threshold`: <NUMBER> - A number that indicates the percentage of objects that\n        must be killed (relative to the total) for this event to fire\n        (e.g. `1` means 100% of them need to be killed, `0.5` means 50%, etc.)\n    - `thresholdMet`: <BOOL> - Whether or not the threshold has been met and therefore\n        onThresholdMet has fired\n    - `onKilled`: <CODE, ARRAY, or STRING> - Code that executes each time an object \n        has been killed (executed before the `onThresholdMet` if threshold has been met). \n        (See `KISKA_fnc_callBack`)\n                \n        Params:\n        - 0. <ARRAY> - The default arguments passed to either the MPKILLED or KILLED\n            event handler.\n        - 1. <STRING> - The ID of the multi kill event.\n\n    - `onThresholdMet`: <CODE, ARRAY, or STRING> - Code that executes once the \n        given threshold have been killed (executed after the `onKilled` of whatever \n        the last killed object was). (See `KISKA_fnc_callBack`)\n                \n        Params:\n        - 0. <ARRAY> - The default arguments passed to either the MPKILLED or KILLED\n            event handler.\n        - 1. <STRING> - The ID of the multi kill event.\n\n    - `eventCode`: <CODE> - The code that is attached to the killed eventhandler\n    - `type`: <STRING> - Type of event, (`\"KILLED\"` or `\"MPKILLED\"`)\n    - `objectHashSet`: <HASHMAP> - A hashmap that effectively acts as a hash set that\n        contains all the objects in the multi kill event. This is meant to be used with\n        the KISKA hashmap function family. The values are all the objects and the keys\n        are effectively the objects themselves.\n\nExamples:\n    (begin example)\n        private _eventMap = \"KISKA_multiKillEvent_uid_0_0\" call KISKA_fnc_multiKillEvent_getEventMap;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_getEventMap\";\n\nparams [\n    [\"_id\",\"\",[\"\"]]\n];\n\n\n(call KISKA_fnc_multiKillEvent_getContainerMap) get _id\n",
    "fileName": "fn_multiKillEvent_getEventMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_getEventMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_getKilledCount\n\nDescription:\n    Returns the number of objects that have been killed throughout the course of\n     the multi kill event's lifetime.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <NUMBER | NIL>\n\nExamples:\n    (begin example)\n        private _numberOfKilledObjects = [\n            \"KISKA_multiKillEvent_uid_0_0\"\n        ] call KISKA_fnc_multiKillEvent_getKilledCount;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_getKilledCount\";\n\nparams [\n    [\"_id\",\"\",[\"\"]]\n];\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {};\n\n_eventMap get \"killedCount\"\n",
    "fileName": "fn_multiKillEvent_getKilledCount.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_getKilledCount.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_getTotal\n\nDescription:\n    Returns the total number of objects that have been assigned to the multi kill \n     event at the current moment.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <NUMBER | NIL> - The total number of objects assigned to the multi kill event.\n\nExamples:\n    (begin example)\n        private _totalNumberOfObjects = [\n            \"KISKA_multiKillEvent_uid_0_0\"\n        ] call KISKA_fnc_multiKillEvent_getTotal;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_getTotal\";\n\nparams [\n    [\"_id\",\"\",[\"\"]]\n];\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {};\n\n_eventMap get \"total\"\n",
    "fileName": "fn_multiKillEvent_getTotal.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_getTotal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_getType\n\nDescription:\n    Returns the event type for the given multi kill event. Whether or not the event\n     is a MPKILLED or KILLED event.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <STRING | NIL> - The type of kill event (`\"KILLED\"` or `\"MPKILLED\"`)\n\nExamples:\n    (begin example)\n        private _type = [\n            \"KISKA_multiKillEvent_uid_0_0\"\n        ] call KISKA_fnc_multiKillEvent_getType;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_getType\";\n\nparams [\n    [\"_id\",\"\",[\"\"]]\n];\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {};\n\n_eventMap get \"type\"\n",
    "fileName": "fn_multiKillEvent_getType.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_getType.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_isObjectInEvent\n\nDescription:\n    Checks whether or not the threshold of the given multi kill event has been met.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <BOOL> - Whether the object is part of the multi kill event. If the event of\n        the given ID does not exist or the given `_object` is null `false` will\n        also be returned.\n\nExamples:\n    (begin example)\n        private _isInMultiKillEvent = [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            MyObject\n        ] call KISKA_fnc_multiKillEvent_isObjectInEvent;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_isObjectInEvent\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_object\",objNull,[objNull]]\n];\n\nif (isNull _object) exitWith { false };\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith { false };\n\nprivate _objectHashSet = _eventMap get \"objectHashSet\";\n[_objectHashSet, _object] call KISKA_fnc_hashmap_in\n",
    "fileName": "fn_multiKillEvent_isObjectInEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_isObjectInEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_isThresholdMet\n\nDescription:\n    Checks whether or not the threshold of the given multi kill event has been met.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n\nReturns:\n    <BOOL> - Whether the threshold for the kill event has been met. Also will \n        return `false` if the event does not exist.\n\nExamples:\n    (begin example)\n        private _thresholdMet = [\n            \"KISKA_multiKillEvent_uid_0_0\"\n        ] call KISKA_fnc_multiKillEvent_isThresholdMet;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_isThresholdMet\";\n\nparams [\n    [\"_id\",\"\",[\"\"]]\n];\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith { false };\n\n_eventMap get \"thresholdMet\"\n",
    "fileName": "fn_multiKillEvent_isThresholdMet.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_isThresholdMet.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_onKilled\n\nDescription:\n    Gets or sets the code that is executed when a given object is killed that \n     is part of the given multi kill event.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n    1: _onKilled <CODE, ARRAY, or STRING> - Code that executes each time an object \n        has been killed (executed before the `onThresholdMet` if threshold has been met). \n        (See `KISKA_fnc_callBack`)\n                \n        Params:\n        - 0. <ARRAY> - The default arguments passed to either the MPKILLED or KILLED\n            event handler.\n        - 1. <STRING> - The ID of the multi kill event.\n\nReturns:\n    <CODE, ARRAY, STRING, or NIL> - The current value of the onKilled property.\n\nExamples:\n    (begin example)\n        private _newOnKilled = [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            {hint \"hello\"}\n        ] call KISKA_fnc_multiKillEvent_onKilled;\n    (end)\n\n    (begin example)\n        private _currentOnKilled = [\n            \"KISKA_multiKillEvent_uid_0_0\",\n        ] call KISKA_fnc_multiKillEvent_onKilled;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_onKilled\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_onKilled\",nil,[{},[],\"\"]]\n];\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {};\nif (isNil \"_onKilled\") exitWith { _eventMap get \"onKilled\" };\n\n_eventMap set [\"onKilled\",_onKilled];\n_onKilled\n",
    "fileName": "fn_multiKillEvent_onKilled.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_onKilled.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_onThresholdMet\n\nDescription:\n    Gets or sets the code that is executed when the threshold of objects required to\n     complete the multi kill event have been killed.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n    1: _onThresholdMet <CODE, ARRAY, or STRING> - Code that executes once the \n        given threshold have been killed (executed after the `onKilled` of whatever \n        the last killed object was). (See `KISKA_fnc_callBack`)\n                \n        Params:\n        - 0. <ARRAY> - The default arguments passed to either the MPKILLED or KILLED\n            event handler.\n        - 1. <STRING> - The ID of the multi kill event.\n\nReturns:\n    <CODE, ARRAY, STRING, or NIL> - The current value of the onThresholdMet property.\n\nExamples:\n    (begin example)\n        private _newOnThresholdMet = [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            {hint \"hello\"}\n        ] call KISKA_fnc_multiKillEvent_onThresholdMet;\n    (end)\n\n    (begin example)\n        private _currentOnThresholdMet = [\n            \"KISKA_multiKillEvent_uid_0_0\",\n        ] call KISKA_fnc_multiKillEvent_onThresholdMet;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_onThresholdMet\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_onThresholdMet\",nil,[{},[],\"\"]]\n];\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {};\nif (isNil \"_onThresholdMet\") exitWith { _eventMap get \"onThresholdMet\" };\n\n_eventMap set [\"onThresholdMet\",_onThresholdMet];\n_onThresholdMet\n",
    "fileName": "fn_multiKillEvent_onThresholdMet.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_onThresholdMet.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_removeObjects\n\nDescription:\n    Removes objects from the list that must be killed for a multi kill event \n     to complete.\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n    1: _objects <OBJECT | OBJECT[]> - The objects to remove from the multi kill event.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            MyObject\n        ] call KISKA_fnc_multiKillEvent_removeObjects;\n    (end)\n    \n    (begin example)\n        [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            [MyObject_1,MyObject_2]\n        ] call KISKA_fnc_multiKillEvent_removeObjects;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_removeObjects\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_objects\",objNull,[[],objNull]]\n];\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_objects\",objNull,[[],objNull]]\n];\n\nif (_objects isEqualType objNull) then { _objects = [_objects]; };\nif (_objects isEqualTo []) exitWith {};\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {\n    [[\"Event \",_id,\" does not exist\"],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_eventMap getOrDefaultCall [\"thresholdMet\",{true}]) exitWith {\n    [[\"Event \",_id,\" was already completed\"],false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _previousTotal = _eventMap getOrDefaultCall [\"total\",{0}];\nprivate _objectHashSet = _eventMap get \"objectHashSet\";\nprivate _useMpKilled = (_eventMap get \"type\") == \"MPKILLED\";\nprivate _eventVar = _id + \"_killedEventId\";\nprivate _numberRemoved = 0;\n_objects apply {\n    private \"_killedEventId\";\n    if (\n        !(_x isEqualType objNull) OR \n        { !(alive _x) } OR\n        // not part of multi kill event\n        { (isNil {_killedEventId = _x getVariable _eventVar; _killedEventId}) }\n    ) then { continue };\n\n    if (_useMPKilled) then {\n        _x removeMPEventHandler [\"MPKILLED\", _killedEventId];\n    } else {\n        _x removeEventHandler [\"KILLED\", _killedEventId];\n    };\n\n    _x setVariable [_eventVar,nil];\n    [_objectHashSet, _x] call KISKA_fnc_hashmap_deleteAt;\n    _numberRemoved = _numberRemoved + 1;\n};\n_eventMap set [\"total\",_previousTotal - _numberRemoved];\n\n\nnil\n",
    "fileName": "fn_multiKillEvent_removeObjects.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_removeObjects.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_multiKillEvent_threshold\n\nDescription:\n    Gets or sets the threshold of the multi kill event which is the percentage of\n     killed objects that must be met in order for the event to be considered complete.\n     (e.g. 1 means 100% of them need to be killed, 0.5 means 50%, etc.)\n\nParameters:\n    0: _id <STRING> - The multi kill event ID.\n    1: _threshold <NUMBER | NIL> - Default: `nil` - What to set the threshold to.\n        The number will be clamped to be between `0` and `1`. If `nil`, the function\n        will act as a getter for the current value.\n\nReturns:\n    <NUMBER | NIL> - The current threshold of the event or `nil` if the event does not exist.\n\nExamples:\n    (begin example)\n        private _newThreshold = [\n            \"KISKA_multiKillEvent_uid_0_0\",\n            1\n        ] call KISKA_fnc_multiKillEvent_threshold;\n    (end)\n\n    (begin example)\n        private _currentThreshold = [\n            \"KISKA_multiKillEvent_uid_0_0\",\n        ] call KISKA_fnc_multiKillEvent_threshold;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_multiKillEvent_threshold\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_threshold\",nil,[123]]\n];\n\nprivate _eventMap = _id call KISKA_fnc_multiKillEvent_getEventMap;\nif (isNil \"_eventMap\") exitWith {};\nif (isNil \"_threshold\") exitWith { _eventMap get \"threshold\" };\n\nif (_threshold > 1) then {\n    [[\"Provided invalid threshold (must be between 0 and 1): \",_threshold,\" and clamped to 1\"],false] call KISKA_fnc_log;\n    _threshold = 1;\n};\nif (_threshold < 0) then {\n    [[\"Provided invalid threshold (must be between 0 and 1): \",_threshold,\" and clamped to 0\"],false] call KISKA_fnc_log;\n    _threshold = 0;\n};\n_eventMap set [\"threshold\",_threshold];\n\n\n_threshold\n",
    "fileName": "fn_multiKillEvent_threshold.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Multi Kill Event/fn_multiKillEvent_threshold.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic\n\nDescription:\n    Starts playing a random assortment of curated music tracks to all players on a server.\n    This is essentially a multiplayer jukebox. Should only be executed on the server.\n\n    All songs will be played in a random order and then loop back to play in another random order infinitely.\n\n    It will not interrupt music commanded to play by other means.\n\n    You can define quiet time space between tracks.\n\nParameters:\n    0: _musicTracks <STRING[]> - An array of classnames for music defined in `CfgMusic`\n    1: _interval <ARRAY or NUMBER> - A random or set time between tracks. Formats are `[min,mid,max]` & `[max]` for random numbers and\n        just a single number for a set time between (see example)\n    2: _canInterrupt <BOOL> - If this is a new random music set, will the initial song\n        be able to interrupt any playing music.\n    3: _tickId <NUMBER> - Used to superceed another random music loop, passs -1 to start a new one\n    4: _usedMusicTracks <STRING[]> - An array of already used music tracks, don't bother manually entering anyhting, this is for looping purposes\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // space tracks by 20 seconds exactly each\n        [-1,arrayOfTracks,20] call KISKA_fnc_randomMusic;\n    (end)\n\n    (begin example)\n        // space tracks by UP TO 20 seconds each\n        [-1,arrayOfTracks,[20]] call KISKA_fnc_randomMusic;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic\";\n\n#define SLEEP_BUFFER 3\n\nif !(isServer) exitWith {\n    [\"Was not executed on server, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    Params\n---------------------------------------------------------------------------- */\nparams [\n    [\"_musicTracks\",call KISKA_fnc_randomMusic_getUnusedTracks,[[]]],\n    [\"_interval\",call KISKA_fnc_randomMusic_getTrackInterval,[[],123]],\n    [\"_canInterrupt\",true,[true]],\n    [\"_tickId\",-1,[123]],\n    [\"_usedMusicTracks\",call KISKA_fnc_randomMusic_getUsedTracks,[[]]]\n];\n\nprivate _latestTickID = GET_MUSIC_RANDOM_START_TIME;\nprivate _isNewRandomMusicSet = _tickId isEqualTo -1;\nif ((!_isNewRandomMusicSet) AND (_tickId < _latestTickID)) exitWith {\n    [[\"Tick ID: \",_tickId,\" was thrown out in favor of ID: \",_latestTickID],false] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_musicTracks isEqualTo [] AND (_usedMusicTracks isEqualTo [])) exitWith {\n    [\"No music tracks were passed! Can't start.\",true] call KISKA_fnc_log;\n    nil\n};\n\n// check if _interval is an array AND if it is the correct formats OR if it is just a single number\nif !([_interval] call KISKA_fnc_randomMusic_setTrackInterval) exitWith {\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    Select & Play Track\n---------------------------------------------------------------------------- */\nif (_musicTracks isEqualTo []) then {\n    _musicTracks = +_usedMusicTracks;\n    _usedMusicTracks = [];\n};\n\n\nprivate _selectedTrack = [_musicTracks] call KISKA_fnc_deleteRandomIndex;\n// get defined volume for random music system\nprivate _volume = call KISKA_fnc_randomMusic_getVolume;\n_canInterrupt = _canInterrupt AND _isNewRandomMusicSet;\n[\n    _selectedTrack,\n    0,\n    _canInterrupt,\n    _volume,\n    3,\n    true\n] remoteExec [\"KISKA_fnc_playMusic\",[0,-2] select isDedicated];\n\n\nif !(call KISKA_fnc_randomMusic_isSystemRunning) then {\n    [true] call KISKA_fnc_randomMusic_setSystemRunning;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Cleanup\n---------------------------------------------------------------------------- */\n[_musicTracks] call KISKA_fnc_randomMusic_setUnusedTracks;\n\n// store track as used\n_usedMusicTracks pushBackUnique _selectedTrack;\n[_usedMusicTracks] call KISKA_fnc_randomMusic_setUsedTracks;\n\n/* ----------------------------------------------------------------------------\n    Get Wait Time\n---------------------------------------------------------------------------- */\nprivate _durationOfTrack = [_selectedTrack] call KISKA_fnc_getMusicDuration;\n// decide how much time should be between tracks\nprivate \"_randomWaitTime\";\nif (_interval isEqualType []) then {\n    if (_interval isEqualTypeArray [1,2,3]) then {\n        _randomWaitTime = round (random _interval);\n\n    } else {\n        _randomWaitTime = round (random (_interval select 0));\n\n    };\n\n} else {\n    _randomWaitTime = _interval;\n\n};\n\n\n// track durations are not (always) exact enough, so there needs to be a bit of a buffer\n// else, if the time between tracks is something like 0 or 1, the sleep will be done,\n// and music will try to play, but because it does not interrupt,\n// and the previous track will not actually be done, no music will play until the next sleep is done\nif (_randomWaitTime < SLEEP_BUFFER) then {\n    _randomWaitTime = SLEEP_BUFFER;\n};\nprivate _waitTime = _durationOfTrack + _randomWaitTime;\n\n\n/* ----------------------------------------------------------------------------\n    Sleep till next track\n---------------------------------------------------------------------------- */\n/*\n    this is used with the intention of if another random music list is started (or multiple)\n    the latest one will take over this time slot forcing the others after their wait time to\n    not continue their own loops\n*/\n\nif (_isNewRandomMusicSet) then {\n    _tickId = diag_tickTime;\n    SET_MUSIC_VAR(MUSIC_RANDOM_START_TIME_VAR_STR,_tickId);\n};\n\n[\n    {\n        _this call KISKA_fnc_randomMusic;\n    },\n    [\n        _musicTracks,\n        _interval,\n        false,\n        _tickId,\n        _usedMusicTracks\n    ],\n    _waitTime\n] call CBA_fnc_waitAndExecute;\n\n\nnil\n",
    "fileName": "fn_randomMusic.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getCurrentTrack\n\nDescription:\n    Returns the most recent track selected by the random music system.\n    Will be an empty string \"\" if none is defined.\n\n    This is regardless of whether the song is actually playing.\n\nParameters:\n    NONE\n\nReturns:\n    <STRING> - The current randomly selected track\n\nExamples:\n    (begin example)\n        _mostRecentRandomTrack = call KISKA_fnc_randomMusic_getCurrentTrack;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getCurrentTrack\";\n\nGET_MUSIC_CURRENT_RANDOM_TRACK;\n",
    "fileName": "fn_randomMusic_getCurrentTrack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_getCurrentTrack.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getTrackInterval\n\nDescription:\n    Retrieves the current tracks in the random music system that could play.\n\n    Possible Values:\n        [NUMBER,NUMBER,NUMBER] - used with the \"random\" command's [min,mid,max]\n            to get a uniform random space between tracks.\n        [NNUMBER] - used with denotes that the space between tracks can be UP TO this number.\n        NUMBER - the exact time between tracks that will be the same every time.\n\nParameters:\n    NONE\n\nReturns:\n    <ARRAY or NUMBER> - see Description for details\n\nExamples:\n    (begin example)\n        private _interval = call KISKA_fnc_randomMusic_getTrackInterval;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getTrackInterval\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    -1\n};\n\nGET_MUSIC_RANDOM_TIME_BETWEEN\n",
    "fileName": "fn_randomMusic_getTrackInterval.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_getTrackInterval.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getUnusedTracks\n\nDescription:\n    Retrieves the current tracks in the random music system that could play.\n\nParameters:\n    NONE\n\nReturns:\n    <ARRAY> - An array of strings of the unused classnames of tracks\n\nExamples:\n    (begin example)\n        private _arrayOfTracks = call KISKA_fnc_randomMusic_getUnusedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getUnusedTracks\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    []\n};\n\nGET_MUSIC_RANDOM_UNUSED_TRACKS\n",
    "fileName": "fn_randomMusic_getUnusedTracks.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_getUnusedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getUsedTracks\n\nDescription:\n    Retrieves the tracks in the random music system that have already been played\n\nParameters:\n    NONE\n\nReturns:\n    <ARRAY> - An array of strings of the used classnames of tracks\n\nExamples:\n    (begin example)\n        private _arrayOfTracks = call KISKA_fnc_randomMusic_getUsedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getUsedTracks\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    []\n};\n\nGET_MUSIC_RANDOM_USED_TRACKS\n",
    "fileName": "fn_randomMusic_getUsedTracks.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_getUsedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getVolume\n\nDescription:\n    Retrieves the current volume that random music system plays tracks at\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - the volume\n\nExamples:\n    (begin example)\n        private _volume = call KISKA_fnc_randomMusic_getVolume;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getVolume\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    -1\n};\n\n\nGET_MUSIC_RANDOM_VOLUME\n",
    "fileName": "fn_randomMusic_getVolume.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_getVolume.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_isSystemRunning\n\nDescription:\n    Retrieves whether or not the random music system is currently running\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - True for running, false for not\n\nExamples:\n    (begin example)\n        private _isRunning = call KISKA_fnc_randomMusic_isSystemRunning;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_isSystemRunning\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    false\n};\n\n\nGET_MUSIC_RANDOM_SYS_RUNNING\n",
    "fileName": "fn_randomMusic_isSystemRunning.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_isSystemRunning.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setCurrentTrack\n\nDescription:\n    Sets the current random track from the random music system.\n\nParameters:\n    0: _trackClass <STRING> - a classname to check the duration of or its config path\n\nReturns:\n    <BOOL> - True when set\n\nExamples:\n    (begin example)\n        [\"Some_Music_Track\"] call KISKA_fnc_randomMusic_setCurrentTrack;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setCurrentTrack\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server, exiting...\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_trackClass\",\"\",[\"\"]]\n];\n\nSET_MUSIC_VAR(MUSIC_CURRENT_RANDOM_TRACK_VAR_STR,_trackClass);\n[[\"Set Current Random Track \",_trackClass]] call KISKA_fnc_log;\n\n\ntrue\n",
    "fileName": "fn_randomMusic_setCurrentTrack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_setCurrentTrack.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setSystemRunning\n\nDescription:\n    Sets the boolean for determining if the random music system is running.\n\nParameters:\n    0: _setting <BOOL> - True for running, false for not\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // set to running\n        [true] call KISKA_fnc_randomMusic_setSystemRunning;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setSystemRunning\";\n\nif (!isServer) exitWith {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_setting\",true,[true]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_SYS_RUNNING_VAR_STR,true);\n\n\nnil\n",
    "fileName": "fn_randomMusic_setSystemRunning.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_setSystemRunning.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setTrackInterval\n\nDescription:\n    Sets the dwell time variable that handles the time between random music tracks\n     being played.\n\nParameters:\n    0: _interval <ARRAY or NUMBER> - A random or set time between tracks.\n        Formats are [min,mid,max] & [max] for random numbers and just a single\n         number for a set time between.\n\nReturns:\n    <BOOL> - true if updated, false if not\n\nExamples:\n    (begin example)\n        [20] remoteExecCall [\"KISKA_fnc_randomMusic_setTrackInterval\",2];\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setTrackInterval\";\n\nif (!isServer) exitWith {\n    [\"Needs to be executed on the server, exiting...\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_interval\",3,[123,[]]]\n];\n\n\nif (\n    (_interval isEqualType []) AND\n    {\n        !((count _interval) isEqualTo 1) AND\n        {\n            !((count _interval) isEqualTo 3) OR !(_interval isEqualTypeParams [1,2,3])\n        }\n    }\n) exitWith {\n    [[_interval,\" is not the correct format for _interval\"],true] call KISKA_fnc_log;\n    false\n\n};\n\n\n// update to new timebetween if needed\nif ((GET_MUSIC_RANDOM_TIME_BETWEEN) isNotEqualTo _interval) then {\n    SET_MUSIC_VAR(MUSIC_RANDOM_TIME_BETWEEN_VAR_STR,_interval);\n};\n\n\ntrue\n",
    "fileName": "fn_randomMusic_setTrackInterval.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_setTrackInterval.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setUnusedTracks\n\nDescription:\n    Sets the current tracks in the random music system that could play.\n\nParameters:\n    0: _musicTracks <ARRAY> - An array of strings (music tracks) to use\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [[\"someTrack\",\"anotherTrack\"]] call KISKA_fnc_randomMusic_setUnusedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setUnusedTracks\";\n\nif (!isServer) exitWith {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_musicTracks\",call KISKA_fnc_randomMusic_getUnusedTracks,[[]]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_UNUSED_TRACKS_VAR_STR,_musicTracks);\n\n\nnil\n",
    "fileName": "fn_randomMusic_setUnusedTracks.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_setUnusedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setUsedTracks\n\nDescription:\n    Sets the tracks in the random music system that have already been played\n\nParameters:\n    0: _usedMusicTracks <ARRAY> - An array of already used music tracks\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [[\"SomeTrack\",\"AnotherTrack\"]] call KISKA_fnc_randomMusic_setUsedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setUsedTracks\";\n\nif (!isServer) exitWith {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_usedMusicTracks\",call KISKA_fnc_randomMusic_getUsedTracks,[[]]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_USED_TRACKS_VAR_STR,_usedMusicTracks);\n\n\nnil\n",
    "fileName": "fn_randomMusic_setUsedTracks.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_setUsedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setVolume\n\nDescription:\n    Changes the volume at which random music specifically will play at (on all clients).\n\n    Only executes on server.\n\nParameters:\n    0: _volume <NUMBER> - volume to set\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [1] remoteExecCall [\"KISKA_fnc_randomMusic_setVolume\",2];\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setVolume\";\n\nif (!isServer) exitWith {\n    [\"Needs to be executed on the server. There is no affect on clients.\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_volume\",0.5,[123]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_VOLUME_VAR_STR,_volume)\n",
    "fileName": "fn_randomMusic_setVolume.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_setVolume.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_stopClient\n\nDescription:\n    The clientside part of stopping random music system.\n    Ideally, should not be called on its own but used from KISKA_fnc_randomMusic_stopServer\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - True if done, false if nothing done\n\nExamples:\n    (begin example)\n        call KISKA_fnc_randomMusic_stopClient;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_stopClient\";\n\nif (!hasInterface) exitWith {false};\n\nif ((call KISKA_fnc_getPlayingMusic) == (call KISKA_fnc_randomMusic_getCurrentTrack)) then {\n    /*\n        there should in the future be a more robust way of determining if a track did indeed come\n         from KISKA_fnc_randomMusic. As it stands, if a manual song is playing that is ALSO in the list\n         and was played from random music, then it will still stop it\n    */\n    [] spawn KISKA_fnc_stopMusic;\n    \n    true\n} else {\n    false\n};",
    "fileName": "fn_randomMusic_stopClient.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_stopClient.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_stopServer\n\nDescription:\n    Stops the random music system either abrubtly or allows the last song to play.\n\nParameters:\n    0: _playLastSong <BOOL> - Should the last song play or not\n\nReturns:\n    <BOOL> - True if done, false if nothing done\n\nExamples:\n    (begin example)\n        call KISKA_fnc_randomMusic_stopServer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_stopServer\";\n\nif (!isServer) exitWith {\n    [\"Needs to only be run on server, exiting...\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_playLastSong\",false,[true]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_SYS_RUNNING_VAR_STR,false);\nSET_MUSIC_VAR(MUSIC_RANDOM_START_TIME_VAR_STR,nil);\nif (!_playLastSong) then {\n    remoteExecCall [\"KISKA_fnc_randomMusic_stopClient\",[0,-2] select isDedicated];\n};\n\ntrue\n",
    "fileName": "fn_randomMusic_stopServer.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/Random Music/fn_randomMusic_stopServer.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getLatestPlayedMusicID\n\nDescription:\n    Returns the latest track ID of music that played (each song played increments)\n     the ID by one.\n\n    This DOES NOT indicated whether or not this ID is still playing.\n     See KISKA_fnc_getPlayingMusic to check what track is present (if any).\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The highest incremented track \"ID\". -1 indicates no music has ever been played\n\nExamples:\n    (begin example)\n        private _id = call KISKA_fnc_getLatestPlayedMusicID;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getLatestPlayedMusicID\";\n\nGET_MUSIC_CURRENT_TRACK_ID;\n",
    "fileName": "fn_getLatestPlayedMusicID.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_getLatestPlayedMusicID.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMusicDuration\n\nDescription:\n    Returns the duration of a track of music. Will return 0 if undefined duration or class.\n\nParameters:\n    0: _track <STRING or CONFIG> - a classname to check the duration of or its config path\n\nReturns:\n    <NUMBER> - The duration of the requested track\n\nExamples:\n    (begin example)\n        _duration = [\"LeadTrack01_F_Curator\"] call KISKA_fnc_getMusicDuration;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMusicDuration\";\n\nparams [\n    [\"_track\",\"\",[\"\",configNull]]\n];\n\nprivate _duration = 0;\n\nif (_track isEqualTo \"\") exitWith {\n    [\"_track is empty string\",true] call KISKA_fnc_log;\n    _duration\n};\n\nprivate \"_config\";\nif (_track isEqualType configNull) then {\n    _config = _track;\n} else {\n    _config = [[\"cfgMusic\",_track]] call KISKA_fnc_findConfigAny;\n};\n\nif (isNull _config) exitWith {\n    [[\"_track \",_track,\" is not defined in any CfgMusic class\"],true] call KISKA_fnc_log;\n    _duration\n};\n\n_duration = getNumber(_config >> \"duration\");\n\n\n_duration\n",
    "fileName": "fn_getMusicDuration.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_getMusicDuration.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMusicFromClass\n\nDescription:\n    Returns an array of track names for the given class of music.\n\nParameters:\n    0: _musicClass <STRING> - a class of music to search for (e.g. \"stealth\")\n\nReturns:\n    <ARRAY> - list of tracks names from the class\n\nExamples:\n    (begin example)\n        [\"stealth\"] call KISKA_fnc_getMusicFromClass;\n    (end)\n\nAuthor(s):\n    Ansible2 (modified by)\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMusicFromClass\";\n\nparams [\n    [\"_musicClass\",\"\",[\"\"]]\n];\n\nif (_musicClass isEqualTo \"\") exitWith {\n    [\"_musicClass is empty. Exiting...\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _configCondition = [\"getText (_x >> 'musicClass') == \",str _musicClass] joinString \"\";\nprivate _configs = _configCondition configClasses (configFile >> \"CfgMusic\");\nprivate _trackNames = [];\n\n_configs apply {\n    private _class = configName _x;\n    _trackNames pushBackUnique _class;\n};\n\n\n_trackNames\n",
    "fileName": "fn_getMusicFromClass.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_getMusicFromClass.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getPlayingMusic\n\nDescription:\n    Returns the current playing tracks class name.\n\nParameters:\n    NONE\n\nReturns:\n    <STRING> - The class name of music. Will be \"\" if nothing is playing.\n\nExamples:\n    (begin example)\n        private _track = call KISKA_fnc_getPlayingMusic;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getPlayingMusic\";\n\nGET_MUSIC_CURRENT_TRACK;\n",
    "fileName": "fn_getPlayingMusic.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_getPlayingMusic.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isMusicPlaying\n\nDescription:\n    Returns whether or not music is currently playing\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - false if nothing is playing, true if something is\n\nExamples:\n    (begin example)\n        _isSomethingPlaying = call KISKA_fnc_isMusicPlaying;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isMusicPlaying\";\n\nGET_MUSIC_IS_PLAYING;\n",
    "fileName": "fn_isMusicPlaying.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_isMusicPlaying.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_musicEventHandlers\n\nDescription:\n    A preInit function to create the required music event handlers for\n     KISKA music functions\n\nParameters:\n    NONE\n\nReturns:\n    NONE\n\nExamples:\n    (begin example)\n        PREINIT FUNCTION\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_musicEventHandlers\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\n[\"Added KISKA music event handlers\",false] call KISKA_fnc_log;\n\naddMusicEventHandler [\"MusicStart\", {\n    _this call KISKA_fnc_musicStartEvent;\n}];\n\n\naddMusicEventHandler [\"MusicStop\", {\n    [false] call KISKA_fnc_musicStopEvent;\n}];\n\n\nnil\n",
    "fileName": "fn_musicEventHandlers.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_musicEventHandlers.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_musicStartEvent\n\nDescription:\n    The function that should be activated when music starts playing.\n\nParameters:\n    0: _trackClassname <STRING> - The classname of the track that started playing\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"trackThatStarted\"] call KISKA_fnc_musicStartEvent;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_musicStartEvent\";\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_trackClassname\",\"\",[\"\"]]\n];\n\n\nSET_MUSIC_VAR(MUSIC_IS_PLAYING_VAR_STR,true);\nSET_MUSIC_VAR(MUSIC_CURRENT_TRACK_VAR_STR,_trackClassName);\nSET_MUSIC_VAR(MUSIC_CURRENT_TRACK_ID_VAR_STR,(GET_MUSIC_CURRENT_TRACK_ID) + 1);\n// clear out any track. Any new MUSIC_CURRENT_RANDOM_TRACK_VAR_STR will be set to the new track in KISKA_fnc_playMusic after this event has fired\n// this is to avoid a track random music track not being cleared\n//[\"\"] call KISKA_fnc_randomMusic_setCurrentTrack;\n\n\n[[\"Started playing track: \", _trackClassname],false] call KISKA_fnc_log;\n\n\nnil\n",
    "fileName": "fn_musicStartEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_musicStartEvent.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_musicStopEvent\n\nDescription:\n    The function that should be activated when music stops playing.\n\n    It can also be manually triggered and a param is added to stop the music audio\n     by playing an empty track (\"\").\n\nParameters:\n    0: _stopAudio <BOOL> - Play and empty track (\"\") to actually stop the audio\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_musicStopEvent;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_musicStopEvent\";\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_stopAudio\",false,[true]]\n];\n\nif (_stopAudio) then {\n    playMusic \"\";\n};\n\n\nSET_MUSIC_VAR(MUSIC_IS_PLAYING_VAR_STR,false);\nSET_MUSIC_VAR(MUSIC_CURRENT_TRACK_VAR_STR,\"\");\n[\"\"] call KISKA_fnc_randomMusic_setCurrentTrack;\n\n[\"Music stopped\",false] call KISKA_fnc_log;\n\n\nnil\n",
    "fileName": "fn_musicStopEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_musicStopEvent.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playMusic\n\nDescription:\n    Plays music with smooth fade between tracks. Must be run in scheduled environment (spawn)\n\nParameters:\n    0: _track <STRING> - Music to play\n    1: _startTime <NUMBER OR ARRAY> - Starting time of music. -1 for random start time.\n        If array, duration of track can also be specified (SEE EXAMPLE 2).\n        THIS INCLUDES FADE TIME\n    2: _canInterrupt <BOOL> - Interrupt playing music\n    3: _volume <NUMBER> - Volume to play at\n    4: _fadeTime <NUMBER> - Time to fade tracks down & up\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"track\", 0, true, 1, 3] spawn KISKA_fnc_playMusic;\n    (end)\n\n    (begin example)\n        [\n            \"track\",\n            [10,60]    // start ten seconds into the song, and play for 60 seconds\n        ] spawn KISKA_fnc_playMusic;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playMusic\";\n\nif !(hasInterface) exitWith {};\n\nif !(canSuspend) exitWith {\n    [\"Wasn't run in scheduled environment, executing in scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_playMusic;\n};\n\n\nparams [\n    [\"_track\",\"\",[\"\"]],\n    [\"_startTime\",0,[123,[]]],\n    [\"_canInterrupt\",true,[true]],\n    [\"_volume\",1,[123]],\n    [\"_fadeTime\",3,[123]],\n    [\"_isRandomTrack\",false,[true]]\n];\n\nprivate _trackConfig = [[\"cfgMusic\",_track]] call KISKA_fnc_findConfigAny;\nif (isNull _trackConfig) exitWith {\n    [[_track,\" is not a defined track in any CfgMusic\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _musicPlaying = call KISKA_fnc_isMusicPlaying;\nprivate _exit = false;\nprivate _fadeDown = false;\nif (_musicPlaying) then {\n    if (_isRandomTrack) then {\n        private _playingMusicIsRandom = (call KISKA_fnc_randomMusic_getCurrentTrack) isNotEqualTo \"\";\n        if (_playingMusicIsRandom OR _canInterrupt) then {\n            _fadeDown = true;\n\n        } else {\n            _exit = true;\n\n        };\n\n    } else {\n        if (_canInterrupt) then {\n            _fadeDown = true;\n\n        } else {\n            _exit = true;\n\n        };\n\n    };\n\n};\n\n\nif (_exit) exitWith {};\n\n// handle end specified track duration\nprivate _durationToPlayTrack = -1;\nif (_startTIme isEqualType []) then {\n    _durationToPlayTrack = (_startTIme select 1) - (_fadeTime * 2);\n    _startTIme = _startTIme select 0;\n};\n\n// random start time\nif (_startTime < 0) then {\n    private _totalTrackDuration = [_track] call KISKA_fnc_getMusicDuration;\n    _startTIme = round (random [0, _totalTrackDuration / 2, _totalTrackDuration]);\n\n};\n\n\nif (_fadeDown) then {\n    // give the previous track time to fade out if required\n    _fadeTime fadeMusic 0;\n    sleep (_fadeTime + 0.1);\n\n} else {\n    // only need this setting of volume to 0 if there was no fade above that already set it to 0\n    0 fadeMusic 0;\n\n};\n\nprivate _previousTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n// clear out any track. Any new MUSIC_CURRENT_RANDOM_TRACK_VAR_STR will be set to the new track in KISKA_fnc_playMusic after this event has fired\n// this is to avoid a track random music track not being cleared\n[] call KISKA_fnc_musicStopEvent;\nplayMusic [_track,_startTime];\n_fadeTime fadeMusic _volume;\n\n\n\nif (_durationToPlayTrack > 0) then {\n    // it takes more then one frame after playing music for the eventhandler to be called/complete\n    // e.g. the music id will not be updated to the latest\n    [\n        {\n            call KISKA_fnc_getLatestPlayedMusicID > (_this select 3)\n        },\n        {\n            private _currentTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n            _this set [3,_currentTrackID];\n\n            // the primary concern of needing to wait for the fade time here is\n            /// to account for the fading out of the music.\n            // the _durationToPlayTrack includes the time to fade out\n            private _fadeTime = _this select 2;\n            [\n                {\n                    params [\n                        \"_durationToPlayTrack\",\n                        \"_track\",\n                        \"_fadeTime\",\n                        \"_trackID\"\n                    ];\n\n                    private _currentTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n                    private _currentTrackName = call KISKA_fnc_getPlayingMusic;\n                    if (_trackID isEqualTo _currentTrackID AND (_currentTrackName == _track)) then {\n                        [\n                            {\n                                params [\n                                    \"_track\",\n                                    \"_fadeTime\",\n                                    \"_trackID\"\n                                ];\n\n                                private _currentTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n                                private _currentTrackName = call KISKA_fnc_getPlayingMusic;\n                                if (_trackID isEqualTo _currentTrackID AND (_currentTrackName == _track)) then {\n                                    [_fadeTime] spawn {\n                                        _this spawn KISKA_fnc_stopMusic;\n                                    };\n                                };\n                            },\n                            [\n                                _track,\n                                _fadeTime,\n                                _currentTrackID\n                            ],\n                            _durationToPlayTrack\n                        ] call CBA_fnc_waitAndExecute;\n                    };\n                },\n                _this,\n                _fadeTime\n            ] call CBA_fnc_waitAndExecute;\n\n        },\n        [\n            _durationToPlayTrack,\n            _track,\n            _fadeTime,\n            _previousTrackID\n        ]\n    ] call CBA_fnc_waitUntilAndExecute;\n};\n\n\n\nif (_isRandomTrack) then {\n    [_track] call KISKA_fnc_randomMusic_setCurrentTrack;\n\n};\n\n\nif (GET_MUSIC_SHOW_SONG_NAMES) then {\n    private _trackName = getText(_trackConfig >> \"name\");\n    if (_trackName isNotEqualTo \"\") then {\n        [\n            parseText (\"<t font='PuristaBold' size='1.6'>\" + _trackName + \"</t>\"),\n            true,\n            nil,\n            7,\n            0.7,\n            0\n        ] spawn BIS_fnc_textTiles;\n    };\n};\n\n\nnil\n",
    "fileName": "fn_playMusic.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_playMusic.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopMusic\n\nDescription:\n    Stops the currently playing music with a fade if desired.\n\nParameters:\n    0: _fadeTime <NUMBER> - How long to fade out\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] spawn KISKA_fnc_stopMusic;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopMusic\";\n\nif (!hasInterface) exitWith {};\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled environment, executing in scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_stopMusic;\n};\n\nparams [\n    [\"_fadeTime\",3,[123]]\n];\n\nif !(call KISKA_fnc_isMusicPlaying) exitWith {};\n\nif (_fadeTime > 0) then {\n    _fadeTime fadeMusic 0;\n    sleep _fadeTime;\n};\n\n// reset event handler values as playMusic \"\" does not activate music events\n[true] call KISKA_fnc_musicStopEvent;\n",
    "fileName": "fn_stopMusic.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Music/fn_stopMusic.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_drawBoundingBox\n\nDescription:\n    Draws the given bounding box of _corner_a specified object.\n\nParameters:\n    0: _object : <OBJECT> - The object to draw the box around.\n    1: _color : <NUMBER[]> Default: `[1,0,1,1]` - The color of the boundingBox in RGBA format.\n    2: _lod : <NUMBER | STRING> Default: `0` - See `boundingBoxReal` for valid args.\n\nReturns:\n    <STRING> - The id of the bounding box for removal\n\nExamples:\n    (begin example)\n        [] spawn {\n            private _boundingBoxId = [\n                myObject,\n                [1,0,1,1],\n                0\n            ] call KISKA_fnc_drawBoundingBox;\n            \n            sleep 10;\n            \n            [_boundingBoxId] call KISKA_fnc_removeBoundingBoxDraw;\n        };\n    (end)\n\nAuthor(s):\n    Bohemia Interactive,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_drawBoundingBox\";\n\nparams [\n    [\"_object\",objNull,[objNull]],\n    [\"_color\",[1,0,1,1],[[]],4],\n    [\"_lod\",0,[\"\",123]]\n];\n\nif (isNull _object) exitWith {\n    [\"_object is null\",true] call KISKA_fnc_log;\n    -1\n};\n\nprivate \"_boundingBox\";\nif (_lod isEqualType \"\") then {\n    _boundingBox = boundingBoxReal [_object,_lod];\n} else {\n    _boundingBox = _lod boundingBoxReal _object;\n};\n_boundingBox params [\"_mins\",\"_maxes\"];\n\nprivate _id = addMissionEventHandler [\n    \"Draw3D\",\n    {\n        _thisArgs params [\"_object\",\"_color\",\"_mins\",\"_maxes\"];\n\n        if (isNull _object) then {\n            removeMissionEventHandler [_thisEvent,_thisEventHandler];\n        } else {\n            _mins params [\"_xMin\",\"_yMin\",\"_zMin\"];\n            _maxes params [\"_xMax\",\"_yMax\",\"_zMax\"];\n\n            private _corner_a = _object modelToWorldVisual [_xMin,_yMin,_zMin];\n            private _corner_b = _object modelToWorldVisual [_xMax,_yMin,_zMin];\n            private _corner_c = _object modelToWorldVisual [_xMax,_yMin,_zMax];\n            private _corner_d = _object modelToWorldVisual [_xMin,_yMin,_zMax];\n            private _corner_e = _object modelToWorldVisual [_xMin,_yMax,_zMin];\n            private _corner_f = _object modelToWorldVisual [_xMax,_yMax,_zMin];\n            private _corner_G = _object modelToWorldVisual [_xMax,_yMax,_zMax];\n            private _corner_h = _object modelToWorldVisual [_xMin,_yMax,_zMax];\n            [\n                [_corner_a, _corner_b, _color],\n                [_corner_b, _corner_c, _color],\n                [_corner_c, _corner_d, _color],\n                [_corner_d, _corner_a, _color],\n                [_corner_e, _corner_f, _color],\n                [_corner_f, _corner_G, _color],\n                [_corner_G, _corner_h, _color],\n                [_corner_h, _corner_e, _color],\n                [_corner_a, _corner_e, _color],\n                [_corner_b, _corner_f, _color],\n                [_corner_c, _corner_G, _color],\n                [_corner_d, _corner_h, _color] \n            ] apply { \n                drawLine3D _x;\n            };\n        };\n    },\n    [_object,_color,_mins,_maxes]\n];\n\nprivate _drawIds = _object getVariable \"KISKA_drawnBoundingBoxIds\";\nif (isNil \"_drawIds\") then {\n    _drawIds = createHashMap;\n    _object setVariable [\"KISKA_drawnBoundingBoxIds\",_drawIds];\n};\n\nprivate _boundingBoxDrawId = [\"KISKA_drawnBoundingBox\"] call KISKA_fnc_generateUniqueId;\n_drawIds set [_boundingBoxDrawId,_id];\n\n\n_boundingBoxDrawId\n",
    "fileName": "fn_drawBoundingBox.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_drawBoundingBox.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_drawLookingAtMarker_start\n\nDescription:\n    Draws a 3D marker to indicate where the player is currently looking.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_drawLookingAtMarker_start;\n        // some time later\n        call KISKA_fnc_drawLookingAtMarker_stop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_drawLookingAtMarker_start\";\n\n#define MARKER_CLASS \"Sign_Sphere200cm_F\"\n\nprivate _eventId = localNamespace getVariable \"KISKA_lookingAtMarker_eventId\";\nif !(isNil \"_eventId\") then {\n    call KISKA_fnc_drawLookingAtMarker_stop;\n    nil\n};\n\nprivate _marker = MARKER_CLASS createVehicleLocal [0,0,0];\nprivate _markerColor = missionNamespace getVariable [\"KISKA_CBA_lookingAtMarker_color\",[1,0.6,1,1]];\n_markerColor params [\"_r\",\"_g\",\"_b\",\"_alpha\"];\n_marker setObjectTexture [0,format[\"#(rgb,8,8,3)color(%1,%2,%3,%4)\",_r,_g,_b,_alpha]];\nlocalNamespace setVariable [\"KISKA_lookingAtMarker_marker\",_marker];\n\n_eventId = addMissionEventHandler [\"Draw3D\", {\n    if (!(alive player) OR ((incapacitatedState player) == \"INCAPACITATED\")) then {\n        call KISKA_fnc_drawLookingAtMarker_stop;\n    } else {\n        _thisArgs params [\"_marker\"];\n        _marker setPosASL (call KISKA_fnc_getPositionPlayerLookingAt);\n    };\n},[_marker]]; \nlocalNamespace setVariable [\"KISKA_lookingAtMarker_eventId\",_eventId];\n\n\nnil",
    "fileName": "fn_drawLookingAtMarker_start.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_drawLookingAtMarker_start.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_drawLookingAtMarker_stop\n\nDescription:\n    Stops a marker being drawn that was started with `KISKA_fnc_drawLookingAtMarker_start`.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_drawLookingAtMarker_start;\n        // some time later\n        call KISKA_fnc_drawLookingAtMarker_stop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_drawLookingAtMarker_stop\";\n\nprivate _eventId = localNamespace getVariable \"KISKA_lookingAtMarker_eventId\";\nif !(isNil \"_eventId\") then {\n    removeMissionEventHandler [\"Draw3D\",_eventId];\n};\n\nprivate _marker = localNamespace getVariable [\"KISKA_lookingAtMarker_marker\",objNull];\nif !(isNull _marker) then {\n    deleteVehicle _marker;\n};\n\n\nnil\n",
    "fileName": "fn_drawLookingAtMarker_stop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_drawLookingAtMarker_stop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getBoundingBoxCenter\n\nDescription:\n    Gets the center of a given object's bounding box.\n\nParameters:\n    0: _object : <OBJECT> - The object to get the bounding box center of.\n    1: _lod : <NUMBER | STRING> Default: `0` - The lod to get the bounding box of.\n        See `boundingBoxReal` for valid args.\n\nReturns:\n    <PositionWorld[]> - The center position of the bounding box.\n\nExamples:\n    (begin example)\n        private _centerPositionWorld = [myObject] call KISKA_fnc_getBoundingBoxCenter;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getBoundingBoxCenter\";\n\nparams [\n    [\"_object\",objNull,[objNull]],\n    [\"_lod\",0,[\"\",123]]\n];\n\nif (isNull _object) exitWith {\n    [\"_object is null\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate \"_boundingBox\";\nif (_lod isEqualType \"\") then {\n    _boundingBox = boundingBoxReal [_object,_lod];\n} else {\n    _boundingBox = _lod boundingBoxReal _object;\n};\n\n\nprivate _relativeCenter = ((_boundingBox select 1) vectorAdd (_boundingBox select 0)) vectorMultiply 0.5;\n_object modelToWorldVisualWorld _relativeCenter\n",
    "fileName": "fn_getBoundingBoxCenter.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_getBoundingBoxCenter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMapCursorPosition\n\nDescription:\n    Gets the ASL position that corresponds to the player's map cursor position.\n\nParameters:\n    NONE\n\nReturns:\n    <PostionASL[] | NIL> - The position that the player's cursor is on the map.\n        Will be `nil` in the event that the map is not open.\n\nExamples:\n    (begin example)\n        private _position = call KISKA_fnc_getMapCursorPosition;\n    (end)\n\nAuthors:\n    Commy2,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMapCursorPosition\";\n\nif (!visibleMap) exitWith { nil };\n\nprivate _display = findDisplay 12;\nif (isNull _display) exitWith { nil };\n\nprivate _ctrlMap = _display displayCtrl 51;\nif (isNull _ctrlMap) exitWith { nil };\n\ngetMousePosition params [\"_mouseX\", \"_mouseY\"];\nprivate _position = _ctrlMap ctrlMapScreenToWorld [_mouseX, _mouseY];\n_position pushBack (abs (getTerrainHeight _position));\n\n\n_position\n",
    "fileName": "fn_getMapCursorPosition.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_getMapCursorPosition.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getPosRelativeASL\n\nDescription:\n    Returns a position relative to another. Same as `getPos` alternative syntax\n     but the returned position is in ASL format.\n\nParameters:\n    0: _origin <OBJECT or Position> - The center position to find a relative position to.\n    1: _distance <NUMBER> Default: `0` - The distance away from the `_origin` \n        to get the position.\n    2: _bearing <NUMBER> Default: `0` - The direction relative to the `_origin` \n        to find the new position.\n    3: _aglOffset <NUMBER> Default: `0` - An offset to add to the Z-axis above \n        ground level of the found position.\n\nReturns:\n    PositionASL[] - the new position\n\nExamples:\n    (begin example)\n        private _positon = [\n            player,\n            100,\n            180\n        ] call KISKA_fnc_getPosRelativeASL;\n    (end)\n\n    (begin example)\n        private _position = [\n            player,\n            100,\n            180,\n            10 // 10 meters above whatever AGL surface is at the \n        ] call KISKA_fnc_getPosRelativeASL;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getPosRelativeASL\";\n\nparams [\n    [\"_origin\",[],[objNull,[]],[2,3]],\n    [\"_distance\",0,[123]],\n    [\"_bearing\",0,[123]],\n    [\"_aglOffset\",0,[123]]\n];\n\nprivate _relativePosition = _origin getPos [_distance,_bearing];\nAGLToASL (_relativePosition vectorAdd [0,0,_aglOffset])\n",
    "fileName": "fn_getPosRelativeASL.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_getPosRelativeASL.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getPositionPlayerLookingAt\n\nDescription:\n    Gets the ASL position that the player is currently looking at. Moves with a player's\n    head position and collides with objects in the path of their vision. Works\n    up to a maximum of 5000m given the limitations of `lineIntersectsSurfaces`, \n    however, will use the player's `viewDistance` if it is less than that.\n\nParameters:\n    NONE\n\nReturns:\n    <PostionASL[]> - The position the player is currently looking\n\nExamples:\n    (begin example)\n        private _position = call KISKA_fnc_getPositionPlayerLookingAt;\n    (end)\n\nAuthors:\n    Commy2,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getPositionPlayerLookingAt\";\n\n#define MAX_LINE_INTERSECT_DISTANCE 5000\n\nprivate _distance = viewDistance min MAX_LINE_INTERSECT_DISTANCE;\nprivate _origin = AGLToASL (positionCameraToWorld [0, 0, 0]);\nprivate _target = AGLToASL (positionCameraToWorld [0, 0, _distance]);\n\nprivate _default = _origin vectorAdd (_origin vectorFromTo (_target vectorMultiply _distance));\nprivate _intersects = lineIntersectsSurfaces [_origin, _target, cameraOn];\n\n(_intersects param [0, [_default]]) select 0",
    "fileName": "fn_getPositionPlayerLookingAt.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_getPositionPlayerLookingAt.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeBoundingBoxDraw\n\nDescription:\n    Removes a select or all boudning boxes drawn with `KISKA_fnc_drawBoundingBox`.\n\nParameters:\n    0: _object : <OBJECT> - The object to draw the box around.\n    1: _id : <STRING> Default: `\"all\"` - The bounding box Id to remove.\n        If the ID is `\"all\"`, all bounding boxes will be removed from the object.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] spawn {\n            private _boundingBoxId = [\n                myObject,\n                [1,0,1,1],\n                0\n            ] call KISKA_fnc_drawBoundingBox;\n            \n            sleep 10;\n            \n            [_boundingBoxId] call KISKA_fnc_removeBoundingBoxDraw;\n        };\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeBoundingBoxDraw\";\n\n#define ALL_BOXES \"all\"\n\nparams [\n    [\"_object\",objNull,[objNull]],\n    [\"_id\",ALL_BOXES,[\"\"]]\n];\n\nif (isNull _object) exitWith {\n    [\"_object is null, no need to remove\",false] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _boxIdMap = _object getVariable \"KISKA_drawnBoundingBoxIds\";\nif (isNil \"_boxIdMap\") exitWith {\n    [\"Did not find any value in KISKA_drawnBoundingBoxIds\",false] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_id != ALL_BOXES) exitWith {\n    private _missionEventId = _boxIdMap getOrDefaultCall [_id,{-1}];\n    removeMissionEventHandler [\"Draw3D\",_missionEventId];\n};\n\n\n_boxIdMap apply { removeMissionEventHandler [\"Draw3D\",_y] };\n_object setVariable [\"KISKA_drawnBoundingBoxIds\",nil];\n\n\nnil\n",
    "fileName": "fn_removeBoundingBoxDraw.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Positions/fn_removeBoundingBoxDraw.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addRallyPointDiaryEntry\n\nDescription:\n    Adds a rally point diary entry to the local player. Pressing it enables the\n     player to drop a rally point if their group is registered as allowed to and\n     they are the leader of the group.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addRallyPointDiaryEntry\";\n\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!isMultiplayer) exitWith {\n    [\"KISKA rally point system does not run in singlePlayer\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_addRallyPointDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n\n[\n    [\n        \"Rally Point\",\n        \"<execute expression='call KISKA_fnc_updateRespawnMarkerQuery'>Set Rally Point At Current Position</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_addRallyPointDiaryEntry.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Rally/fn_addRallyPointDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_allowGroupRally\n\nDescription:\n    Adds group's ability to place rally points by setting \"KISKA_canRally\" in\n     the group space to true.\n\nParameters:\n    0: _groupToAdd <GROUP or OBJECT> - The group or the unit whose group to add\n\nReturns:\n    <BOOL> - True if allowed, false if not allowed or error\n\nExamples:\n    (begin example)\n        // allows player's group to drop a rally point (if they're the server)\n        [player] call KISKA_fnc_allowGroupRally;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_allowGroupRally\";\n\nif !(isServer) exitWith {\n    [\"Needs to be run on the server\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_groupToAdd\",grpNull,[objNull,grpNull]]\n];\n\n_groupToAdd = [_groupToAdd] call CBA_fnc_getGroup;\n\nif (isNull _groupToAdd) exitWith {\n    [\"_groupToAdd was null\",true] call KISKA_fnc_log;\n\n    false\n};\n\n_groupToAdd setVariable [\"KISKA_canRally\",true];\n\n\ntrue\n",
    "fileName": "fn_allowGroupRally.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Rally/fn_allowGroupRally.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_disallowGroupRally\n\nDescription:\n    Removes a groups ability to rally an deletes its marker if requested.\n\nParameters:\n    0: _groupToRemove <GROUP or OBJECT> - The group or the unit whose group to remove\n    1: _deleteMarker <BOOL> - Should the group's latest rally marker (if present) be deleted\n\nReturns:\n    <BOOL> - True if no longer allowed or never was, false if error\n\nExamples:\n    (begin example)\n        // disallows player's group to drop a rally point (if they're the server)\n        [player] call KISKA_fnc_disallowGroupRally;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_disallowGroupRally\";\n\nif !(isServer) exitWith {\n    [\"Needs to be run on the server\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_groupToRemove\",grpNull,[objNull,grpNull]],\n    [\"_deleteMarker\",true,[true]]\n];\n\n_groupToRemove = [_groupToRemove] call CBA_fnc_getGroup;\n\nif (isNull _groupToRemove) exitWith {\n    [\"_groupToRemove was null\",true] call KISKA_fnc_log;\n    false\n};\n\n_groupToRemove setVariable [\"KISKA_canRally\",false];\n\nif (_deleteMarker) then {\n    private _markerID = _groupToRemove getVariable [\"KISKA_groupRespawnMarkerID\",[]];\n    // if marker ID exitsts\n    if !(_markerID isEqualTo []) then {\n        private _marker = _groupToRemove getVariable \"KISKA_groupRespawnMarker\";\n        [[\"Found marker id \",_markerID,\" for group \",_groupToRemove,\" ---Will remove marker \",_marker],false] call KISKA_fnc_log;\n\n        _markerID call BIS_fnc_removeRespawnPosition;\n        deleteMarker _marker;\n\n        _groupToRemove setVariable [\"KISKA_groupRespawnMarker\",nil];\n        _groupToRemove setVariable [\"KISKA_groupRespawnMarkerID\",nil];\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_disallowGroupRally.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Rally/fn_disallowGroupRally.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isGroupRallyAllowed\n\nDescription:\n    Checks if a group is has KISKA_canRally saved to its namespace on the server\n     which allows its members to place down rally points.\n\nParameters:\n    0: _groupToCheck <GROUP or OBJECT> - The group or the unit whose group you want to check\n\nReturns:\n    <BOOL> - True if allowed, false if not or error\n\nExamples:\n    (begin example)\n        // checks if player's group can use the rally system (if they're the server)\n        [player] call KISKA_fnc_isGroupRallyAllowed;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isGroupRallyAllowed\";\n\nif !(isServer) exitWith {\n    [\"Needs to be run on server for proper returns\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_groupToCheck\",grpNull,[objNull,grpNull]]\n];\n\n_groupToCheck = [_groupToCheck] call CBA_fnc_getGroup;\n\nif (isNull _groupToCheck) exitWith {\n    [\"_groupToCheck was null\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _isRallyAllowed = _groupToCheck getVariable [\"KISKA_canRally\",false];\n\n\n_isRallyAllowed\n",
    "fileName": "fn_isGroupRallyAllowed.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Rally/fn_isGroupRallyAllowed.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateRallyPointNotification\n\nDescription:\n    Informs the player that their rally point was updated\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        remoteExec [\"KISKA_fnc_updateRallyPointNotification\",somePlayer];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateRallyPointNotification\";\n\n#define HEADER_COLOR [0,0.3,0.6,1]\n\nif (!hasInterface) exitWith {};\n\n[[\"MESSAGE\",1.1,HEADER_COLOR],\"Rally Point Was Updated\",false] call CBA_fnc_notify;\n\n\nnil\n",
    "fileName": "fn_updateRallyPointNotification.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Rally/fn_updateRallyPointNotification.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateRespawnMarker\n\nDescription:\n    Deletes the old respawn marker and makes a new one.\n\nParameters:\n    0: _caller <OBJECT> - The person calling the respawn update action\n    1: _marker <MARKER> - The old marker to delete\n    2: _markerText <STRING> - The text of the new marker\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [player,myMarker,myMarkerText] call KISKA_fnc_updateRespawnMarker;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateRespawnMarker\";\n\nif !(isMultiplayer) exitWith {};\n\nif (!isServer) exitWith {\n    [\"This function is supposed to only run on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_caller\",objNull,[objNull]],\n    [\"_marker\",\"\",[\"\"]],\n    [\"_markerText\",\"\",[\"\"]]\n];\n\nprivate _callerGroup = group _caller;\nif !([_callerGroup] call KISKA_fnc_isGroupRallyAllowed) exitWith {\n    [[\"Got marker request for \",_callerGroup,\" --- Did not create marker\"],true] call KISKA_fnc_log;\n    [\"Your group is not registered to allow for rally points\"] remoteExecCall [\"KISKA_fnc_notification\",_caller];\n};\n\nprivate _markerID = _callerGroup getVariable [\"KISKA_groupRespawnMarkerID\",[]];\n// if the group already has a rally point down, get rid of it before making a new one\nif !(_markerID isEqualTo []) then {\n    // delete map marker\n    private _currentMarker = (_callerGroup getVariable \"KISKA_groupRespawnMarker\");\n    deleteMarker _currentMarker;\n\n    // remove respawn position\n    private _wasRemoved = (_callerGroup getVariable \"KISKA_groupRespawnMarkerID\") call BIS_fnc_removeRespawnPosition;\n};\n\nprivate _position = ASLToAGL (getPosASL _caller);\nprivate _id = [missionNamespace,_position, _markerText] call BIS_fnc_addRespawnPosition;\n\n// set id to be used in this function in the future\n_callerGroup setVariable [\"KISKA_groupRespawnMarkerID\",_id];\n\n// check if marker is created already\nif (getMarkerType _marker isEqualTo \"\") then {\n    ([\"|\",_marker,\"|\",_position,\"|respawn_inf|ICON|[1,1]|0|Solid|\",\"color\",(side _caller),\"|1|\",_markerText] joinString \"\") call BIS_fnc_stringToMarker;\n\n    _callerGroup setVariable [\"KISKA_groupRespawnMarker\",_marker];\n\n} else {\n    _marker setMarkerPos _caller;\n};\n\n// send update message back to caller\nremoteExec [\"KISKA_fnc_updateRallyPointNotification\",_caller];\n",
    "fileName": "fn_updateRespawnMarker.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Rally/fn_updateRespawnMarker.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateRespawnMarkerQuery\n\nDescription:\n    Acts as a go between for use inside of a string in a diary entry expression.\n    (You can't use remoteExecCall with a string inside of double strings)\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_updateRespawnMarkerQuery;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateRespawnMarkerQuery\";\n\n#define KISKA_DIARY \"KISKA Systems\"\n\nif !(hasInterface) exitWith {};\n\nprivate _group = group player;\nif (isNull _group) exitWith {\n    [\"_group was found to be null\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _groupLeader = leader _group;\nif !(_groupLeader isEqualTo player) exitWith {\n    private _string = [\"You are not the leader of the group. \",name _groupLeader,\" is your group leader.\"] joinString \"\";\n    [_string] call KISKA_fnc_notification;\n};\n\nprivate _groupName = groupId _group;\n[\n    _groupLeader,\n    ([_groupName,\"spawnMarker\"] joinString \"_\"),\n    ([_groupName,\"Respawn Beacon\"] joinString \" \")\n] remoteExecCall [\"KISKA_fnc_updateRespawnMarker\",2];\n\n\nnil\n",
    "fileName": "fn_updateRespawnMarkerQuery.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Rally/fn_updateRespawnMarkerQuery.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_keepInGroup\n\nDescription:\n    Attempts to keep a player in the same group and team after they respawn.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_keepInGroup\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_keepInGroup;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\nlocalNamespace setVariable [\"KISKA_playerGroup\",grpNull];\nlocalNamespace setVariable [\"KISKA_team\",\"\"];\n\nplayer addEventHandler [\"KILLED\", {\n    params [\"_corpse\"];\n    // set values player had just before death\n    localNamespace setVariable [\"KISKA_playerGroup\",group _corpse];\n    localNamespace setVariable [\"KISKA_team\",assignedTeam _corpse];\n}];\n\nplayer addEventHandler [\"RESPAWN\", {\n    params [\"_unit\"];\n\n    private _previousGroup = localNamespace getVariable [\"KISKA_playerGroup\",grpNull];\n    if (\n        !isNull _previousGroup AND\n        {(group _unit) isNotEqualTo _previousGroup}\n    ) then {\n        [_unit] joinSilent _previousGroup;\n\n        private _previousTeam = localNamespace getVariable [\"KISKA_team\",\"\"];\n        if (\n            _previousTeam isNotEqualTo \"\" AND\n            {_previousTeam isNotEqualTo \"MAIN\"}\n        ) then {\n            [_unit,_previousTeam] spawn {\n                (_this select 0) assignTeam (_this select 1);\n            };\n        };\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_keepInGroup.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Respawn/fn_keepInGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientNewsRadio\n\nDescription:\n    Plays a selection of news sounds from the vanilla game at a given position.\n\nParameters:\n    0: _origin <OBJECT or ARRAY> - The position the sound will play at. If array\n        position is format ASL\n    1: _duration <NUMBER> - How long should this broadcast last. Negative value\n        will go on forever.\n    2: _distance <NUMBER> - How far away the sound can be heard\n    3: _volume <NUMBER> - The volume of the sounds (0-5).\n    3: _isInside <BOOL> - Are these sounds being played indoors\n\n\nReturns:\n    <NUMBER> - The KISKA_fnc_playRandom3dSoundLoop Handler ID for stopping the sound \n        with KISKA_fnc_stopRandom3dSoundLoop\n\nExamples:\n    (begin example)\n        [myRadio] call KISKA_fnc_ambientNewsRadio;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientNewsRadio\";\n\nparams [\n    [\"_origin\",objNull,[[],objNull]],\n    [\"_duration\",60,[123]],\n    [\"_distance\",500,[[],123],[3]],\n    [\"_volume\",1,[123]],\n    [\"_isInside\",false,[true]]\n];\n\nprivate _sounds = [\n    \"News_arrest\",\n    \"News_BackOnline\",\n    \"News_checkpoints\",\n    \"News_CSAT_convoy_attacked\",\n    \"News_depot_success\",\n    \"News_execution\",\n    \"News_hostels\",\n    \"News_house_destroyed\",\n    \"News_idap\",\n    \"News_Infection01\",\n    \"News_Jingle\",\n    \"News_malaria_galili_secured\",\n    \"News_malaria_luganville_secured\",\n    \"News_malaria_savaka_secured\",\n    \"News_outbreak_Boise\",\n    \"News_power_plant\",\n    \"News_radar_destroyed\",\n    \"News_rebels_attack_Lugganville\",\n    \"News_rescued\",\n    \"News_weapons_prohibited\",\n    [\"radio_dialogues_042_am_radio_broadcast_news_first_in_BROADCASTER_0\",3],\n    [\"radio_dialogues_043_am_radio_broadcast_news_malaria_luganville_BROADCASTER_1\",7],\n    [\"radio_dialogues_044_am_radio_broadcast_news_malaria_luganville_secured_BROADCASTER_0\",7.5],\n    [\"radio_dialogues_045_am_radio_broadcast_news_malaria_savaka_BROADCASTER_2\",6],\n    [\"radio_dialogues_046_am_radio_broadcast_news_malaria_savaka_secured_BROADCASTER_0\",6],\n    [\"radio_dialogues_047_am_radio_broadcast_news_malaria_galili_BROADCASTER_2\",6],\n    [\"radio_dialogues_051_am_radio_broadcast_news_arrest_BROADCASTER_0\",6],\n    [\"radio_dialogues_052_am_radio_broadcast_news_execution_BROADCASTER_2\",10],\n    [\"radio_dialogues_027_am_radio_broadcast_forecast_rain_c_BROADCASTER_0\",6],\n    [\"radio_dialogues_024_am_radio_broadcast_forecast_cloud_staying_BROADCASTER_0\",6]\n];\n\n\n\nprivate _3dSoundLoopId = [\n    _origin,\n    _sounds,\n    5,\n    [\n        _distance,\n        _volume,\n        _isInside\n    ]\n] call KISKA_fnc_playRandom3dSoundLoop;\n\nif (_duration > 0) then {\n    [\n        {\n            params [\"_3dSoundLoopId\"];\n            hint \"timed stop\";\n            [_3dSoundLoopId] call KISKA_fnc_stopRandom3dSoundLoop;\n        },\n        [_3dSoundLoopId],\n        _duration\n    ] call CBA_fnc_waitAndExecute;\n};\n\n\n_3dSoundLoopId",
    "fileName": "fn_ambientNewsRadio.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_ambientNewsRadio.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_battleSound\n\nDescription:\n    Create ambient battlefield sounds for a specified duration\n\nParameters:\n    0: _source <OBJECT or ARRAY> - Where the sound is coming from. Can be an object or positions array (ASL)\n    1: _distance <NUMBER or ARRAY> - Distance at which the sounds can be heard,\n        if an array, will be used with the \"random\" command (random _distance)\n        for getting a random value between the numbers.\n    2: _duration <NUMBER> - How long the sounds should play for in seconds\n    3: _intensity <NUMBER> - Value between 1-5 that determines how frequent these sounds are played (5 being the fastest)\n\nReturns:\n    <NUMBER> - The Handler ID for stopping the sound with KISKA_fnc_stopBattleSound\n\nExamples:\n    (begin example)\n        [player,20,10] call KISKA_fnc_battleSound;\n    (end)\n    (begin example)\n        // distance will be between 10-30m, leaning towards 20m\n        [player,[10,20,30],10] call KISKA_fnc_battleSound;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_battleSound\";\n\n#define MAX_INTENSITY 5\n#define MIN_INTENSITY 1\n#define EXPLOSION_WEIGHT 0.25\n#define FIREFIGHT_WEIGHT 1\n\nparams [\n    [\"_source\",objNull,[objNull,[]],[3]],\n    [\"_distance\",500,[[],123],[3]],\n    [\"_duration\",60,[123]],\n    [\"_intensity\",1,[123]],\n    [\"_battleSoundId\",-1,[123]]\n];\n\nprivate _hasBattleSoundId = _battleSoundId > -1;\nprivate _idIsPlaying = localNamespace getVariable [\"KISKA_battleSoundIsPlaying_\" + (str _battleSoundId), false];\nif (\n    _hasBattleSoundId AND\n    (!_idIsPlaying)\n) exitWith {\n    -1\n};\n\nprivate _sourceIsObject = _source isEqualType objNull;\nif (_sourceIsObject AND {isNull _source}) exitWith {\n    [\"_source isNull\",true] call KISKA_fnc_log;\n    nil\n};\nif ((_distance isEqualType 123) AND {_distance <= 0}) exitWith {\n    [[\"_distance is: \",_distance,\". It must be higher then 0\"],true] call KISKA_fnc_log;\n    nil\n};\nprivate _sourceIsArray = _distance isEqualType [];\nif (_sourceIsArray AND {!(_distance isEqualTypeParams [0,0,0])}) exitWith {\n    [\"_distance random array is not configured properly\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _actualSource = _source;\nif (_sourceIsObject) then {\n    _actualSource = getPosASL _source;\n};\n\nif (_intensity > MAX_INTENSITY) then {\n    _intensity = MAX_INTENSITY;\n} else {\n    if (_intensity < MIN_INTENSITY) then {\n        _intensity = MIN_INTENSITY;\n    };\n};\n\nprivate _intensities = localNamespace getVariable [\"KISKA_battleSoundIntensities\",[]];\nif (_intensities isEqualTo []) then {\n    _intensities = [\n        [2.5,3,3.5],\n        [2,2.5,3],\n        [1.5,2,2.5],\n        [1,1.5,2],\n        [0.5,1,1.5]\n    ];\n    localNamespace setVariable [\"KISKA_battleSoundIntensities\",_intensities];\n};\nprivate _intensityArray = _intensities select (_intensity - 1);\n\n\nprivate _soundsArray = localNamespace getVariable [\"KISKA_battleSounds\",[]];\nif (_soundsArray isEqualTo []) then {\n    _soundsArray = [\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions1.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions2.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions3.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions4.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions5.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight1.wss\",FIREFIGHT_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight2.wss\",FIREFIGHT_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight3.wss\",FIREFIGHT_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight4.wss\",FIREFIGHT_WEIGHT\n    ];\n    localNamespace setVariable [\"KISKA_battleSounds\",_soundsArray];\n};\n\n\nprivate _distanceIsArray = _distance isEqualType [];\nprivate _volume = floor (random [3,4,5]);\nplaySound3D [\n    selectRandomWeighted _soundsArray,\n    objNull,\n    false,\n    _actualSource,\n    _volume,\n    random [-2,0,1],\n    [_distance,random _distance] select _distanceIsArray\n];\n\n\nif !(_hasBattleSoundId) then {\n    _battleSoundId = [\"KISKA_battleSoundId_latestIndex\"] call KISKA_fnc_idCounter;\n    private _stringBattleSoundId = str _battleSoundId;\n    localNamespace setVariable [(\"KISKA_battleSoundIsPlaying_\" + _stringBattleSoundId), true];\n};\n\nif (_duration > 0) then {\n    [\n        KISKA_fnc_stopBattleSound,\n        [_battleSoundId],\n        _duration\n    ] call CBA_fnc_waitAndExecute;\n\n    _duration = -1;\n};\n\n\nprivate _timeUntilSecondSound = random _intensityArray;\nprivate _timeBetweenNextCall = _intensityArray vectorMultiply 4;\n[\n    {\n        params [\n            \"_soundsArray\",\n            \"_actualSource\",\n            \"_volume\",\n            \"_distance\"\n        ];\n        playSound3D [\n            selectRandomWeighted _soundsArray,\n            objNull,\n            false,\n            _actualSource,\n            _volume,\n            random [-2,0,1],\n            _distance\n        ];\n    },\n    [\n        _soundsArray,\n        _actualSource,\n        _volume,\n        [_distance,random _distance] select _distanceIsArray\n    ],\n    _timeUntilSecondSound\n] call CBA_fnc_waitAndExecute;\n\n\n[\n    {\n        _this call KISKA_fnc_battleSound;\n    },\n    [\n        _source,\n        _distance,\n        _duration,\n        _intensity,\n        _battleSoundId\n    ],\n    (_timeUntilSecondSound + (random _timeBetweenNextCall))\n] call CBA_fnc_waitAndExecute;\n\n\n_battleSoundId\n",
    "fileName": "fn_battleSound.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_battleSound.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playRandom3dSoundLoop\n\nDescription:\n    Randomly plays sounds (or music) in 3d space from a given list at one or multiple \n     origins.\n    \n    This function will produce synchronized audio on all machines.\n\nParameters:\n    0: _origin <OBJECT or ARRAY> - The position (ASL), object from which the sound comes from, \n        or an array of any combination of the two (effectively multiple origins)\n    1: _sounds <ARRAY> - An array of sounds to play randomly with any combination of three formats:\n        - <STRING>: A config name of a sound in either CfgSounds and/or CfgMusic. This config Must\n            have a \"duration\" number property. \n        - [<STRING>,<NUMBER>] ([<configClassName>,<duration>]): a config class name that is in CfgSounds \n            and/or CfgMusic and the duration the sound lasts.\n        - <CONFIG>: a config path to a class with a \"sound[]\" array property that has it's first entry\n            as a sound file path, and has a \"duration\" number property.\n    2: _timeBetweenSounds <NUMBER or ARRAY> - A buffer time between each sound once one completes. \n        If array, random syntax of random [min,mid,max] is used to get buffer each time a sound completes.\n    3: _soundParams <ARRAY> - An array of parameters for playSound3D:\n        \n        - 0. _distance <NUMBER> - Distance at which the sound can be heard\n        - 1. _volume <NUMBER> - Range from 0-5\n        - 2. _isInside <BOOL> - Is _origin inside\n        - 3. _pitch <NUMBER> - Range from 0-5\n\n    4: _onSoundPlayed <ARRAY, CODE, STRING> - A callback function that executes each time a sound is played\n        (See KISKA_fnc_callback). Parameters are:\n\n        - 0. <NUMBER> - An id that can be used with KISKA_fnc_stopRandom3dSoundLoop to stop sounds\n        - 1. <OBJECT or ARRAY> - The position the sound is playing at\n        - 2. <CONFIG> - The config of the current sound being played\n\nReturns:\n    <NUMBER> - An id that can be used with KISKA_fnc_stopRandom3dSoundLoop to stop\n        the sound loop.\n\nExamples:\n    (begin example)\n        [\n            player,\n            [],\n            5,\n            [],\n            {hint str _this}\n        ] call KISKA_fnc_playRandom3dSoundLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playRandom3dSoundLoop\";\n\nparams [\n    [\"_origin\",objNull,[objNull,[]]],\n    [\"_sounds\",[],[[]]],\n    [\"_timeBetweenSounds\",5,[[],123],[3]],\n    [\"_soundParams\",[],[[]]],\n    [\"_onSoundPlayed\",{},[[],{},\"\"]]\n];\n\n// verify params\n_soundParams params [\n    [\"_distance\",20,[123]],\n    [\"_volume\",1,[123]],\n    [\"_isInside\",false,[true]],\n    [\"_pitch\",1,[123]]\n];\n\n\nprivate _soundsParsed = _sounds apply {\n    private _sound = _x;\n    private [\"_soundConfig\",\"_duration\"];\n\n    if (_sound isEqualType []) then {\n        if ((count _sound) < 2) then {continue};\n        _soundConfig = _sound select 0;\n\n        if !(_soundConfig isEqualTypeAny [\"\",configNull]) then {continue};\n        if (_soundConfig isEqualType \"\") then {\n            private _soundConfigName = _soundConfig;\n            [\"CfgSounds\",\"CfgMusic\"] apply {\n                _soundConfig = [[_x,_soundConfigName]] call KISKA_fnc_findConfigAny;\n                if !(isNull _soundConfig) then {break};\n            };\n        };\n        _duration = _sound select 1;\n\n\n    } else {\n        if (_sound isEqualType \"\") then {\n            [\"CfgSounds\",\"CfgMusic\"] apply {\n                _soundConfig = [[_x,_sound]] call KISKA_fnc_findConfigAny;\n                if !(isNull _soundConfig) then {break};\n            };\n        } else {\n            _soundConfig = _sound;\n        };\n\n        _duration = getNumber(_soundConfig >> \"duration\");\n\n    };\n\n    if (isNull _soundConfig OR _duration <= 0) then {continue};\n    [_soundConfig,_duration]\n};\n\n\nprivate _playNextSound = {\n    params [\n        \"_origin\",\n        \"_unusedSounds\",\n        \"_usedSounds\",\n        \"_playNextSound\",\n        \"_timeBetweenSounds\",\n        \"_soundParams\",\n        \"_onSoundPlayed\",\n        \"_id\"\n    ];\n\n    private _isPlaying = localNamespace getVariable [(\"KISKA_random3dSoundLoopIsPlaying_\" + (str _id)), false];\n    if (!_isPlaying) exitWith {};\n\n    private _params = _this;\n    private _unusedIsEmpty = _unusedSounds isEqualTo [];\n    if (_unusedIsEmpty AND (_usedSounds isEqualTo [])) exitWith {\n        [\"Both _unusedSounds and _usedSounds were empty arrays. Exited loop...\",true] call KISKA_fnc_log;\n        nil\n    };\n\n    if (_unusedIsEmpty) then {\n        _unusedSounds = _usedSounds;\n        _usedSounds = [];\n        _params set [1,_unusedSounds];\n        _params set [2,_usedSounds];\n    };\n\n    private _selectedSound = [_unusedSounds] call KISKA_fnc_deleteRandomIndex;\n    private _soundConfig = _selectedSound select 0;\n    _soundParams params [\n        [\"_distance\",20,[123]],\n        [\"_volume\",1,[123]],\n        [\"_isInside\",false,[true]],\n        [\"_pitch\",1,[123]]\n    ];\n\n    [\n        _soundConfig,\n        _origin,\n        _distance,\n        _volume,\n        _isInside,\n        _pitch\n    ] call KISKA_fnc_playSound3d;\n    \n    [\n        [_id,_origin,_soundConfig],\n        _onSoundPlayed\n    ] call KISKA_fnc_callBack;\n\n    _usedSounds pushBack _selectedSound;\n\n    private _interval = [_timeBetweenSounds,random _timeBetweenSounds] select (_timeBetweenSounds isEqualType []);\n    private _soundDuration = _selectedSound select 1;\n    private _timeUntilNextSound = _soundDuration + _interval;\n    [\n        _playNextSound,\n        _params,\n        _timeUntilNextSound\n    ] call CBA_fnc_waitAndExecute;\n};\n\nprivate _id = [\"KISKA_random3dSoundLoop\"] call KISKA_fnc_idCounter;\nlocalNamespace setVariable [(\"KISKA_random3dSoundLoopIsPlaying_\" + (str _id)), true];\n\n[\n    _origin,\n    _soundsParsed,\n    [],\n    _playNextSound,\n    _timeBetweenSounds,\n    _soundParams,\n    _onSoundPlayed,\n    _id\n] call _playNextSound;\n\n\n_id\n",
    "fileName": "fn_playRandom3dSoundLoop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_playRandom3dSoundLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playSound2D\n\nDescription:\n    Plays a 2D sound if a player is within a given area.\n    Used due to say2D's broken \"maxTitlesDistance\".\n\nParameters:\n    0: _sound <STRING> - The sound name to play\n    1: _center <OBJECT or ARRAY> - The center position of the radius to search around\n    2: _radius <NUMBER> - How far can the player be from the _center and still \"hear\" the sound\n    3: _threeDimensional <BOOL> - Whether to measure the distance to the player in 2d or 3d space\n\nReturns:\n    <BOOL> - True if played, false if did not\n\nExamples:\n    (begin example)\n        [\"alarm\",player,20] call KISKA_fnc_playSound2D;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nif !(hasInterface) exitWith {false};\n\nparams [\n    [\"_sound\",\"alarm\",[\"\"]],\n    [\"_center\",player,[objNull,[]]],\n    [\"_radius\",10,[123]],\n    [\"_threeDimensional\",false,[true]]\n];\n\nif ((_center isEqualtype objNull) AND {isNull _center}) exitWith {\n    [\"Center object isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_radius isEqualTo 0) exitWith {\n    playsound _sound;\n    true\n};\n\nif (_radius < 0) exitWith {\n    [[\"Raidus is: \",_radius,\" ...less then 0. Must be more then 0\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate \"_distanceToPlayer\";\nif (_threeDimensional) then {\n    _distanceToPlayer = _center distance player;\n} else {\n    _distanceToPlayer = _center distance2D player;\n};\n\nif (_distanceToPlayer <= _radius) then {\n    playsound _sound;\n    true\n\n} else {\n    false\n\n};\n",
    "fileName": "fn_playSound2D.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_playSound2D.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playSound3D\n\nDescription:\n    Plays a sound 3D but the function accepts the CFGSounds name rather then the file path.\n\nParameters:\n    0: _sound <STRING or CONFIG> - The sound to play. The classname of a CfgSounds entry (if string)\n        or any config class that has a \"sound[]\" array and \"duration\" number property (such as CfgMusic classes)\n    1: _origin <OBJECT or ARRAY> - The position (ASL), object from which the sound comes from, \n        or an array of any combination of the two (effectively multiple origins)\n    2: _distance <NUMBER> - Distance at which the sound can be heard\n    3: _volume <NUMBER> - Range from 0-5\n    4: _isInside <BOOL> - Is _origin inside\n    5: _pitch <NUMBER> - Range from 0-5\n\nReturns:\n    <BOOL> - True if sound found and played, false if error\n\nExamples:\n    (begin example)\n        [\n            \"BattlefieldJet1_3D\",\n            (getPosASL player) vectorAdd [50,50,100],\n            2000\n        ] call KISKA_fnc_playSound3D;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playSound3D\";\n\n#define FILE_EXTENSIONS [\".wss\",\".ogg\",\".wav\"]\n\nparams [\n    [\"_sound\",\"\",[\"\",configNull]],\n    [\"_origin\",objNull,[objNull,[]]],\n    [\"_distance\",20,[123]],\n    [\"_volume\",1,[123]],\n    [\"_isInside\",false,[true]],\n    [\"_pitch\",1,[123]]\n];\n\nprivate _soundIsConfig = _sound isEqualType configNull;\nif (_soundIsConfig AND {isNull _sound}) exitWith {\n    [[\"_sound: \", _sound,\" is null config\"],true] call KISKA_fnc_log;\n    false\n};\n\n/* -----------------------------------\n    Verify Params\n----------------------------------- */\nif (_sound isEqualTo \"\") exitWith {\n    [\"_sound is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _originIsObject = _origin isEqualType objNull;\nif (_originIsObject AND {isNull _origin}) exitWith {\n    [\"_origin object isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _originIsArray = _origin isEqualType [];\nif (_originIsArray AND {_origin isEqualTo []}) exitWith {\n    [\"_origin is empty array\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_distance < 0) exitWith {\n    [[\"_distance is: \",_distance,\" and cannot be negative\"],true] call KISKA_fnc_log;\n    false\n};\n\n\n/* -----------------------------------\n    Verify Sound configuration\n----------------------------------- */\nprivate _soundConfig = configNull;\nif (_soundIsConfig) then {\n    _soundConfig = _sound;\n} else {\n    _soundConfig = [[\"CfgSounds\",_sound]] call KISKA_fnc_findConfigAny;\n};\n\nif (isNull _soundConfig) exitWith {\n    [[\"Could not find a config for the sound: \",_sound],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _soundArray = getArray(_soundConfig >> \"sound\");\nif (_soundArray isEqualTo []) exitWith {\n    [[\"'sound' property in config: \",_soundConfig,\" is either empty array or undefined\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _soundPath = _soundArray select 0;\nif ([_soundConfig, missionConfigFile] call CBA_fnc_inheritsFrom) then {\n    _soundPath = getMissionPath + _soundPath;\n};\n\nif (!(_soundPath isEqualType \"\") OR (_soundPath isEqualTo \"\")) exitWith {\n    [\"_sound: \",_sound,\" is configed incorrectly\",true] call KISKA_fnc_log;\n    false\n};\n\n\n/* -----------------------------------\n    Verify Audio file\n----------------------------------- */\n// Some Bohmemia sound paths had a \"@\" or \"\\\" at the front\n// playSound3D will not find the file if this is the case\nprivate _firstChar = _soundPath select [0,1];\nif (_firstChar in [\"@\",\"\\\"]) then {\n    _soundPath = _soundPath trim [_firstChar,1];\n};\nprivate _fileNotFound = false;\nprivate _tempPath = \"\";\nif !(fileExists _soundPath) then {\n    private _hasFileExtension = (toLowerANSI (_soundPath select [(count _soundPath) - 4,4])) in FILE_EXTENSIONS;\n    if !(_hasFileExtension) then {\n        _fileNotFound = true;\n\n        FILE_EXTENSIONS apply {\n            _tempPath = _soundPath + _x;\n            if (fileExists _tempPath) then {\n                _fileNotFound = false;\n                _soundPath = _tempPath;\n                break;\n            };\n\n        };\n\n    } else {\n        _fileNotFound = true;\n\n    };\n\n};\nif (_fileNotFound) exitWith {\n    [[\"Could not find file at path: \", _soundPath],true] call KISKA_fnc_log;\n    false\n};\n\n\n\n/* -----------------------------------\n    Playsound\n----------------------------------- */\nif (_originIsObject) exitWith {\n    playSound3D [\n        _soundPath,\n        objNull,\n        _isInside,\n        getPosASL _origin,\n        _volume,\n        _pitch,\n        _distance\n    ];\n\n    true\n};\n\nprivate _positionCompareArray = [1,2,3];\nif (_origin isEqualTypeParams _positionCompareArray) exitWith {\n    playSound3D [\n        _soundPath,\n        objNull,\n        _isInside,\n        _origin,\n        _volume,\n        _pitch,\n        _distance\n    ];\n\n    true\n};\n\n\nprivate _origins = _origin;\n_origins apply {\n    if (_x isEqualTypeParams _positionCompareArray) then {\n        playSound3D [\n            _soundPath,\n            objNull,\n            _isInside,\n            _x,\n            _volume,\n            _pitch,\n            _distance\n        ];\n        continue;\n    };\n\n    if ((_x isEqualType objNull) AND {!(isNull _x)}) then {\n        playSound3D [\n            _soundPath,\n            objNull,\n            _isInside,\n            getPosASL _x,\n            _volume,\n            _pitch,\n            _distance\n        ];\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_playSound3D.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_playSound3D.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_radioChatter\n\nDescription:\n    Plays a random radio ambient at the specified position.\n\n    This has a global effect now and should be executed on one machine.\n\nParameters:\n    0: _followSource <BOOL> - Should the radio audio be attached to the _source object?\n        This will use say3D instead of playSound3d.\n    1: _soundParams <ARRAY> - An array of parameters that are slightly different depending on the _followSource value\n        If _followSource is true:\n            - 0: _source <OBJECT> - Where the sound is coming from\n            - 1: _distance <NUMBER> - Max distance at which the sound can be heard\n            - 2: _offset <ARRAY> - AttachTo coordinates that can be used to offset the sound\n        If _followSource is false:\n            - 0: _source <OBJECT or ARRAY> - Where the sound is coming from.\n                If array format positionASL.\n            - 1: _distance <NUMBER> - Max distance at which the sound can be heard\n            - 2: _volume <NUMBER> - How loud the sound plays\n\nReturns:\n    <NUMBER> - the \"chatter ID\" that can be used with KISKA_fnc_stopRadioChatter. -1 if error\n\nExamples:\n    (begin example)\n        // radio sound follows player\n        [\n            true,\n            [player]\n        ] call KISKA_fnc_radioChatter;\n    (end)\n    (begin example)\n        // radio sound follows front of player\n        [\n            true,\n            [player,5,[0,1,0]]\n        ] call KISKA_fnc_radioChatter;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_radioChatter\";\n\n#define SOUND_PITCH 1\n#define HELPER_OBJECT_CLASS \"Sign_Arrow_Cyan_F\"\n#define DEFAULT_OFFSET [0,0,0]\n\nparams [\n    [\"_followSource\",false,[true]],\n    [\"_soundParams\",[],[[]]],\n    [\"_chatterId\",-1,[123]]\n];\n\nprivate _hasChatterId = _chatterId > -1;\nprivate _idIsPlaying = localNamespace getVariable [\"KISKA_radioChatterIsPlaying_\" + (str _chatterId), false];\nif (\n    _hasChatterId AND\n    (!_idIsPlaying)\n) exitWith {\n    -1\n};\n\nif (_soundParams isEqualTo []) exitWith {\n    [\"_soundParams is empty!\"] call KISKA_fnc_log;\n    -1\n};\n\n\nprivate _numberStr = str ([2,30] call BIS_fnc_randomInt);\nprivate _radioSound = \"KISKA_radioAmbient\" + _numberStr;\nprivate _soundCreated = false;\nprivate _helperObject = objNull;\nif (_followSource) then {\n    _soundParams params [\n        [\"_source\",objNull,[objNull]],\n        [\"_distance\",20,[123]],\n        [\"_offset\",DEFAULT_OFFSET,[[]],[3]]\n    ];\n\n    if (isNull _source) exitWith {\n        [\"Sound source isNull\"] call KISKA_fnc_log;\n        if (_hasChatterId) then {\n            // delete helper object if source is dead\n            [_chatterId] call KISKA_fnc_stopRadioChatter;\n        };\n    };\n\n    private _actualSource = objNull;\n    if (_hasChatterId) then {\n        _actualSource = localNamespace getVariable [\"KISKA_radioChatter_offsetObject_\" + (str _chatterId), objNull];\n    };\n\n    private _hasOffsetObject = !(isNull _actualSource);\n    if !(_hasOffsetObject) then {\n        _actualSource = _source;\n        if (_offset isNotEqualTo DEFAULT_OFFSET) then {\n            _actualSource = HELPER_OBJECT_CLASS createVehicle [0,0,0];\n            _helperObject = _actualSource;\n            [_actualSource, true] remoteExec [\"hideObjectGlobal\", 2];\n            _actualSource attachTo [_source,_offset];\n        };\n\n    };\n\n\n    [_actualSource, [_radioSound, _distance, SOUND_PITCH, true]] remoteExec [\"say3D\",0];\n    _soundCreated = true;\n\n} else {\n    _soundParams params [\n        [\"_source\",[],[objNull,[]],[3]],\n        [\"_distance\",20,[123]],\n        [\"_volume\",1,[123]]\n    ];\n\n    private _sourceIsObject = _source isEqualType objNull;\n    if (_sourceIsObject AND {isNull _source}) exitWith {\n        [\"Sound source isNull\"] call KISKA_fnc_log;\n        if (_hasChatterId) then {\n            [_chatterId] call KISKA_fnc_stopRadioChatter;\n        };\n    };\n\n    private _actualSource = _source;\n    if !(_sourceIsObject) then {\n        _actualSource = getPosASL _source;\n    };\n\n    [_radioSound,_actualSource,_distance,_volume] call KISKA_fnc_playSound3D;\n    _soundCreated = true;\n\n};\n\n\nif !(_soundCreated) exitWith {\n    [\"Failed to create radio chatter!\"] call KISKA_fnc_log;\n    -1\n};\n\nif !(_hasChatterId) then {\n    _chatterId = [\"KISKA_radioChatterId_latestIndex\"] call KISKA_fnc_idCounter;\n\n    private _stringChatterId = str _chatterId;\n    localNamespace setVariable [(\"KISKA_radioChatterIsPlaying_\" + _stringChatterId), true];\n    if !(isNull _helperObject) then {\n        localNamespace setVariable [\"KISKA_radioChatter_offsetObject_\" + _stringChatterId, _helperObject];\n    };\n};\n\n\nprivate _soundDuration = getNumber (configFile >> \"CfgSounds\" >> _radioSound >> \"duration\");\nprivate _randomBuffer = random [1,5,10];\n[\n    {\n        _this call KISKA_fnc_radioChatter;\n    },\n    [_followSource, _soundParams, _chatterId],\n    (_soundDuration + _randomBuffer)\n] call CBA_fnc_waitAndExecute;\n\n\n_chatterId\n",
    "fileName": "fn_radioChatter.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_radioChatter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopBattleSound\n\nDescription:\n    Stops battle sounds playing for the given id.\n\nParameters:\n    0: _chatterId <OBJECT> - Where the sound is coming from\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_stopBattleSound;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopBattleSound\";\n\nparams [\n    [\"_id\",-1,[123]]\n];\n\nif (_id < 0) exitWith {\n    [\"Invalid _id given!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _idAsString = str _id;\nlocalNamespace setVariable [(\"KISKA_battleSoundIsPlaying_\" + _idAsString), nil];\n",
    "fileName": "fn_stopBattleSound.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_stopBattleSound.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopRadioChatter\n\nDescription:\n    Stops radio chatter playing for the given id.\n\nParameters:\n    0: _chatterId <OBJECT> - Where the sound is coming from\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_radioChatter;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopRadioChatter\";\n\nparams [\n    [\"_chatterId\",-1,[123]]\n];\n\nif (_chatterId < 0) exitWith {\n    [\"Invalid _chatterId given!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _stringChatterId = str _chatterId;\nlocalNamespace setVariable [(\"KISKA_radioChatterIsPlaying_\" + _stringChatterId), nil];\n\nprivate _offsetObjectVar = \"KISKA_radioChatter_offsetObject_\" + _stringChatterId;\nprivate _offsetObject = localNamespace getVariable [_offsetObjectVar, objNull];\nif (isNull _offsetObject) exitWith {};\n\ndetach _offsetObject;\ndeleteVehicle _offsetObject;\nlocalNamespace setVariable [_offsetObjectVar, nil];\n",
    "fileName": "fn_stopRadioChatter.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_stopRadioChatter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopRandom3dSoundLoop\n\nDescription:\n    Stops a 3d sound loop created with KISKA_fnc_playRandom3dSoundLoop;\n\nParameters:\n    0: _id <NUMBER> - The id returned from KISKA_fnc_playRandom3dSoundLoop\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_stopRandom3dSoundLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopRandom3dSoundLoop\";\n\nparams [\n    [\"_id\",-1,[123]]\n];\n\nif (_id < 0) exitWith {\n    [\"Invalid _id given!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _idAsString = str _id;\nlocalNamespace setVariable [(\"KISKA_random3dSoundLoopIsPlaying_\" + _idAsString), nil];\n",
    "fileName": "fn_stopRandom3dSoundLoop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Sound/fn_stopRandom3dSoundLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_addSignal\n\nDescription:\n    Adds a signal that can be seen on a spectrum device. \n\nParameters:\n    0: _signalProperties : <ARRAY> - The all the properites of the signal\n\n        `_signalProperties` Layout:\n        - 0: _frequency <NUMBER> - The frequency of the signal in MHz\n        - 1: _origin <OBJECT or PositionASL[]> - The position of the signal\n        - 2: _decibels <NUMBER> - The base signal decibel level when when near the origin\n        - 3: _maxDistance <NUMBER> - The max distance that the signal can be seen on the spectrum\n        analyzer. This will be what governs how the signal strength increases/decreases depending\n        on the user's position. Default is `worldSize`.\n\n    1: _global : <BOOL> - `true` to broadcast the changes to all machines including JIP\n\nReturns:\n    <STRING> - The corresponding ID for the signal\n\nExamples:\n    (begin example)\n        private _signalId = [\n            [100,[0,0,0],100]\n        ] call KISKA_fnc_spectrum_addSignal;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_addSignal\";\n\nparams [\n    [\"_signalProperties\",[],[[]]],\n    [\"_global\",true,[true]]\n];\n\n_signalProperties params [\n    [\"_frequency\",100,[123]],\n    [\"_origin\",objNull,[[],objNull],[3]],\n    [\"_decibels\",-100,[123]],\n    [\"_maxDistance\",worldSize,[123]]\n];\n\n\nif (_frequency <= 0) exitWith {\n    [[\"Signal can't be added, must have a frequency above 0, current is: \",_frequency],true] call KISKA_fnc_log;\n    \"\"\n};\n\nif ((_origin isEqualType objNull) AND {isNull _origin}) exitWith {\n    [\"Provided origin is null object\",true] call KISKA_fnc_log;\n    \"\"\n};\n\nif (_maxDistance <= 0) exitWith {\n    [\"Max distance must be positive number\",true] call KISKA_fnc_log;\n    \"\"\n};\n\n\nprivate _tag = [\"KISKA\",\"spectrumSignal\",clientOwner] joinString \"_\";\nprivate _id = [_tag] call KISKA_fnc_generateUniqueId;\n\n[\n    [\n        _id,\n        _frequency,\n        _origin,\n        _decibels,\n        _maxDistance\n    ],\n    _global\n] call KISKA_fnc_spectrum_updateSignal;\n\n\n_id\n",
    "fileName": "fn_spectrum_addSignal.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_addSignal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_deleteSignal\n\nDescription:\n    Deletes a signal with the given id.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to remove\n    1: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\tNOTHING\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\"] call KISKA_fnc_spectrum_deleteSignal;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_deleteSignal\";\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_global\",true,[true]]\n];\n\nif (_global AND isMultiplayer) then {\n    [\n        _id,\n        false\n    ] remoteExecCall [\"KISKA_fnc_spectrum_deleteSignal\",-clientOwner];\n\tremoteExec [\"\", \"JIPid\"];\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n_signalMap deleteAt (toLowerANSI _id);\n\n\nnil\n",
    "fileName": "fn_spectrum_deleteSignal.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_deleteSignal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMaxDecibels\n\nDescription:\n    Gets the current max decibel level scale of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The max viewable decibel level of the spectrum device\n\nExamples:\n    (begin example)\n        private _max = call KISKA_fnc_spectrum_getMaxDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMaxDecibels\";\n\nmissionNamespace getVariable [\"#EM_SMax\", -10]\n",
    "fileName": "fn_spectrum_getMaxDecibels.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_getMaxDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMaxFrequency\n\nDescription:\n    Gets the current max frequency of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The max viewable frequency (MHz) of the spectrum device\n\nExamples:\n    (begin example)\n        private _max = call KISKA_fnc_spectrum_getMaxFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMaxFrequency\";\n\nmissionNamespace getVariable [\"#EM_FMax\", 125]\n",
    "fileName": "fn_spectrum_getMaxFrequency.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_getMaxFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMinDecibels\n\nDescription:\n    Gets the current min decibel level scale of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The min viewable decibel level of the spectrum device\n\nExamples:\n    (begin example)\n        private _min = call KISKA_fnc_spectrum_getMinDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMinDecibels\";\n\nmissionNamespace getVariable [\"#EM_SMin\", -60]\n",
    "fileName": "fn_spectrum_getMinDecibels.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_getMinDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMinFrequency\n\nDescription:\n    Gets the current min frequency of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The min viewable frequency (MHz) of the spectrum device\n\nExamples:\n    (begin example)\n        private _min = call KISKA_fnc_spectrum_getMinFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMinFrequency\";\n\nmissionNamespace getVariable [\"#EM_FMin\", 100]\n",
    "fileName": "fn_spectrum_getMinFrequency.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_getMinFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getSelection\n\nDescription:\n    Provides the current MHz area selected on the local machine. This is where the\n     blue bar that the player manipulates with the scroll wheel is positioned.\n\nParameters:\n    NONE\n\nReturns:\n    <[NUMBER,NUMBER]> - The min and max of the player's currently selected area\n\nExamples:\n    (begin example)\n        private _selection = call KISKA_fnc_spectrum_getSelection;\n        // _selection params [\"_min\",\"_max\"];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getSelection\";\n\n[\n    missionNamespace getVariable [\"#EM_SelMin\", 100],\n    missionNamespace getVariable [\"#EM_SelMax\", 102.5]\n]\n",
    "fileName": "fn_spectrum_getSelection.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_getSelection.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getSignalMap\n\nDescription:\n    Returns a map of all the signals and their corresponding ids that have been\n\t added on the local machine. \n\nParameters:\n\tNONE\n\nReturns:\n    <HASHMAP<STRING,ARRAY>> - A hashmap where a signal id as key will provide an\n\t \tarray of that signals base properties:\n\n\t \t- 0. <NUMBER> : The frequency of the signal in MHz\n\t \t- 1. <PositionASL[]> : The position of the signal\n\t \t- 2. <NUMBER> : The base signal decibel level when when near the origin\n\t \t- 3. <NUMBER> : The max distance that the signal can be seen on the spectrum analyzer\n\nExamples:\n    (begin example)\n        private _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getSignalMap\";\n\nprivate _signalMap = localNamespace getVariable [\"KISKA_spectrum_signalMap\",-1];\nif (_signalMap isEqualTo -1) then {\n\t_signalMap = createHashMap;\n\tlocalNamespace setVariable [\"KISKA_spectrum_signalMap\",_signalMap];\n};\n\n\n_signalMap\n",
    "fileName": "fn_spectrum_getSignalMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_getSignalMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_isInitialized\n\nDescription:\n    Determines whether the spectrum device display has been initialized.\n\n    This display will be created once a player has added the device to their\n     inventory. They do not have to equip the device.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - `true` if the spectrum device has been initialized, `false` if not\n\nExamples:\n    (begin example)\n        private _isInitialized = call KISKA_fnc_spectrum_isInitialized\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_isInitialized\";\n\n!(isNil { uiNamespace getVariable \"rscweaponspectrumanalyzergeneric\" })",
    "fileName": "fn_spectrum_isInitialized.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_isInitialized.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_isTransmitting\n\nDescription:\n    Checks whether or not the local machine is transimitting on the spectrum device.\n\n    This shows as a green tint to the player's selection area with the full spectrum\n     device ui open, and as a wifi esque signal when merely holding the spectrum device.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - `true` if transmitting, `false` if not\n\nExamples:\n    (begin example)\n        private _isTransmitting = call KISKA_fnc_spectrum_isTransmitting\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_isTransmitting\";\n\nmissionNamespace getVariable [\"#EM_Transmit\",false];\n",
    "fileName": "fn_spectrum_isTransmitting.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_isTransmitting.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMaxDecibels\n\nDescription:\n    Sets the current max decibel range of spectrum device for the local machine.\n\nParameters:\n    0: _max : <NUMBER> - The decibel level\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [-10] call KISKA_fnc_spectrum_setMaxDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMaxDecibels\";\n\nparams [\n\t[\"_max\",-10,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_maxDecibels\",_max];\n};\n\nmissionNamespace setVariable [\"#EM_SMax\", _max];\n",
    "fileName": "fn_spectrum_setMaxDecibels.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setMaxDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMaxFrequency\n\nDescription:\n    Sets the current max frequency of the spectrum device for the local machine.\n\nParameters:\n    0: _max : <NUMBER> - The frequency in MHz\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [125] call KISKA_fnc_spectrum_setMaxFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMaxFrequency\";\n\nparams [\n\t[\"_max\",100,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_maxFreq\",_max];\n};\n\nmissionNamespace setVariable [\"#EM_FMax\", _max]\n",
    "fileName": "fn_spectrum_setMaxFrequency.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setMaxFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMinDecibels\n\nDescription:\n    Sets the current min decibel range of spectrum device for the local machine.\n\nParameters:\n    0: _min : <NUMBER> - The decibel level\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [-60] call KISKA_fnc_spectrum_setMinDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMinDecibels\";\n\nparams [\n\t[\"_min\",-60,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_minDecibels\",_min];\n};\n\nmissionNamespace setVariable [\"#EM_SMin\", _min];\n",
    "fileName": "fn_spectrum_setMinDecibels.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setMinDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMinFrequency\n\nDescription:\n    Sets the current min frequency of the spectrum device for the local machine.\n\nParameters:\n    0: _min : <NUMBER> - The frequency in MHz\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [80] call KISKA_fnc_spectrum_setMinFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMinFrequency\";\n\nparams [\n\t[\"_min\",80,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_minFreq\",_min];\n};\n\nmissionNamespace setVariable [\"#EM_FMin\", _min]\n",
    "fileName": "fn_spectrum_setMinFrequency.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setMinFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSelectionWidth\n\nDescription:\n    Sets the selection area of the local machine's spectrum device. This is the\n\t bar that a user can \"scroll\" around the spectrum with.\n\nParameters:\n    0: _width : <NUMBER> - The width of the bar in MHz\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t// bar is 2 MHz wide\n        [2] call KISKA_fnc_spectrum_setSelectionWidth;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSelectionWidth\";\n\nparams [\n\t[\"_width\",2,[123]]\n];\n\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_selectionWidth\",_width];\n};\n\nprivate _currentSelectionMin = missionNamespace getVariable [\"#EM_SelMin\", \"\"];\n\n// selection adjusments do not stick if set outside of the frequency AND the spectrum device ui is NOT open\nprivate _minFrequency = call KISKA_fnc_spectrum_getMinFrequency;\nif ((_currentSelectionMin isEqualTo \"\") OR {_currentSelectionMin < _minFrequency}) then {\n    missionNamespace setVariable [\"#EM_SelMin\",_minFrequency];\n    _currentSelectionMin = _minFrequency;\n};\n\nmissionNamespace setVariable [\"#EM_SelMax\", _currentSelectionMin + _width];\n",
    "fileName": "fn_spectrum_setSelectionWidth.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setSelectionWidth.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalDecibels\n\nDescription:\n    Sets the signal's decibel level.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _decibels : <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",-100] call KISKA_fnc_spectrum_setSignalDecibels;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalDecibels\";\n\n#define ORIGIN_KEY \"_origin\"\n#define FREQUENCY_KEY \"_frequency\"\n#define DISTANCE_KEY \"_maxDistance\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_decibels\",-100,[123]],\n    [\"_global\",true,[true]]\n];\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_signalPropertiesMap get FREQUENCY_KEY,\n\t\t_signalPropertiesMap get ORIGIN_KEY,\n\t\t_decibels,\n\t\t_signalPropertiesMap get DISTANCE_KEY\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalDecibels.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setSignalDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalDistance\n\nDescription:\n    Sets the signal's distance that it can be heard from.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _maxDistance : <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",1000] call KISKA_fnc_spectrum_setSignalDistance;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalDistance\";\n\n#define ORIGIN_KEY \"_origin\"\n#define FREQUENCY_KEY \"_frequency\"\n#define DECIBEL_KEY \"_decibels\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_maxDistance\",1000,[123]],\n    [\"_global\",true,[true]]\n];\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_signalPropertiesMap get FREQUENCY_KEY,\n\t\t_signalPropertiesMap get ORIGIN_KEY,\n\t\t_signalPropertiesMap get DECIBEL_KEY,\n\t\t_maxDistance\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalDistance.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setSignalDistance.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalFrequency\n\nDescription:\n    Sets the signal's frequency.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _frequency : <NUMBER> - The frequency of the signal in MHz\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",100] call KISKA_fnc_spectrum_setSignalFrequency;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalFrequency\";\n\n#define ORIGIN_KEY \"_origin\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_frequency\",100,[123]],\n    [\"_global\",true,[true]]\n];\n\n\nif (_frequency <= 0) exitWith {\n    [\n        [\n            \"Signal can't be added, must have a frequency above 0, current is: \",\n            _frequency,\n            \". Signal being updated: \",\n            _id\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_frequency,\n\t\t_signalPropertiesMap get ORIGIN_KEY,\n\t\t_signalPropertiesMap get DECIBEL_KEY,\n\t\t_signalPropertiesMap get DISTANCE_KEY\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalFrequency.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setSignalFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalPosition\n\nDescription:\n    Sets the signal's origin position.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _origin : <OBJECT or PositionASL[]> - The position of the signal\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",myOrigin] call KISKA_fnc_spectrum_setSignalPosition;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalPosition\";\n\n#define FREQUENCY_KEY \"_frequency\"\n#define ORIGIN_KEY \"_origin\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_origin\",objNull,[[],objNull],[3]],\n    [\"_global\",true,[true]]\n];\n\n\nprivate _originIsObject = _origin isEqualType objNull;\nif (_originIsObject AND {isNull _origin}) exitWith {\n    [[\"Provided origin is null object; attempting to update signal: \",_id],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_signalPropertiesMap get FREQUENCY_KEY,\n\t\t_origin,\n\t\t_signalPropertiesMap get DECIBEL_KEY,\n\t\t_signalPropertiesMap get DISTANCE_KEY\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalPosition.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setSignalPosition.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setTransmitting\n\nDescription:\n    Adjusts whether or not the spectrum device is in transmit mode.\n\n    This shows as a green tint to the player's selection area with the full spectrum\n     device ui open, and as a wifi esque signal when merely holding the spectrum device.\n\nParameters:\n    0: _isTransmitting : <BOOL> - `true` to set the spectrum device as being in transmit mode\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [true] call KISKA_fnc_spectrum_setTransmitting;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setTransmitting\";\n\nparams [\n    [\"_isTransmitting\",true,[true]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_fnc_spectrum_setTransmitting\",_isTransmitting];\n};\n\nmissionNamespace setVariable [\"#EM_Transmit\",_isTransmitting];\n",
    "fileName": "fn_spectrum_setTransmitting.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_setTransmitting.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_signalExists\n\nDescription:\n    Checks if a given spectrum signal exists on the local machine.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to check\n\nReturns:\n    <BOOL> - `true` if the signal exists on the local machine, `false` if not\n\nExamples:\n    (begin example)\n        private _signalExists = [\"KISKA_spectrumSignal_2_1\"] call KISKA_fnc_spectrum_signalExists\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_signalExists\";\n\nparams [\n\t[\"_id\",\"\",[\"\"]]\n];\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n(toLowerANSI _id) in _signalMap\n",
    "fileName": "fn_spectrum_signalExists.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_signalExists.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_startSignalLoop\n\nDescription:\n    Handles starting a (sort of infinite) loop that will update a player's\n     spectrum device readings.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_spectrum_startSignalLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_startSignalLoop\";\n\n#define SPECTRUM_WEAPON_CLASS \"hgun_esd_01\"\n#define SPECTRUM_GENERAL_CTRL_IDC 1999\n#define FREQUENCY_KEY \"_frequency\"\n#define ORIGIN_KEY \"_origin\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n#define DISTANCE_RATIO 0.65\n#define LOOP_TIME_WHEN_SEARCHING_FOR_DEVICE 3\n#define UPDATE_SIGNAL_EVERY 0.25\n\n// This function is less than ideal, but blame Bohemia's pretty abysmal implementation\n//  of the scripting interfaces with the spectrum analyzer.\n// And no, `destroy` and `unload` eventhandlers can not be used to mitigate this on the controls/displays for the thing.\n\nif (\n    !(hasInterface) OR \n    (localNamespace getVariable [\"KISKA_spectrum_updateLoopRunning\",false])\n) exitWith {};\n\nlocalNamespace setVariable [\"KISKA_spectrum_updateLoopRunning\",true];\n\n[\n    {\n        SPECTRUM_WEAPON_CLASS in (toLowerANSI (currentWeapon player))\n    },\n    {\t\n\n\n        [\n            [\"KISKA_spectrum_staged_transmit\",KISKA_fnc_spectrum_setTransmitting],\n            [\"KISKA_spectrum_staged_selectionWidth\",KISKA_fnc_spectrum_setSelectionWidth],\n            [\"KISKA_spectrum_staged_minFreq\",KISKA_fnc_spectrum_setMinFrequency],\n            [\"KISKA_spectrum_staged_minDecibels\",KISKA_fnc_spectrum_setMinDecibels],\n            [\"KISKA_spectrum_staged_maxFreq\",KISKA_fnc_spectrum_setMaxFrequency],\n            [\"KISKA_spectrum_staged_maxDecibels\",KISKA_fnc_spectrum_setMaxDecibels]\n        ] apply {\n            _x params [\"_varName\",\"_setter\"];\n            private _stagedValue = localNamespace getVariable [_varName,\"\"];\n            if (_stagedValue isEqualTo \"\") then { continue };\n\n            localNamespace setVariable [_varName,nil];\n            [_stagedValue] call _setter;\n        };\n \n\n        [\n            {\n                private _hasSpectrumDeviceEquipped = SPECTRUM_WEAPON_CLASS in (toLowerANSI (currentWeapon player));\n                if (!(alive player) OR !_hasSpectrumDeviceEquipped) exitWith {\n                    private _perframeId = _this select 1;\n                    [_perframeId] call CBA_fnc_removePerFrameHandler;\n                    localNamespace setVariable [\"KISKA_spectrum_updateLoopRunning\",false];\n                    call KISKA_fnc_spectrum_startSignalLoop;\n                };\n                \n                private _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n                private _generatedSignalValues = [];\n                private _playerPositionASL = getPosASL player;\n                private _minDecibels = call KISKA_fnc_spectrum_getMinDecibels;\n                private _maxDecibels = call KISKA_fnc_spectrum_getMaxDecibels;\n                private _overallSignalRatioForDirection = 1 - DISTANCE_RATIO;\n                \n                _signalMap apply {\n                    private _maxDistance = _y get DISTANCE_KEY;\n                    private _origin = _y get ORIGIN_KEY;\n                    private _playerDistanceToSource = _playerPositionASL vectorDistance _origin;\n                    if (_playerDistanceToSource > _maxDistance) then {\n                        continue;\n                    };\n\n                    private _relativeDir = player getRelDir _origin;\n                    if ((_relativeDir > 90) AND (_relativeDir < 270)) then { continue };\n                    \n                    private \"_relativeDirScale\";\n                    if (_relativeDir <= 90) then {\n                        _relativeDirScale = _relativeDir\n                    } else {\n                        _relativeDirScale = 360 - _relativeDir;\n                    };\n\n                    private _frequency = _y get FREQUENCY_KEY;\n                    _generatedSignalValues pushBack _frequency;\n\n                    // Get the signal percentage of max based upon player's relative direction and distance\n                    private _percentageOfDistance = (1 - (_playerDistanceToSource / _maxDistance));\n                    private _percentageOfDirection = (1 - (_relativeDirScale / 90));\n                    \n                    private _percentageOfDistanceRatioed = _percentageOfDistance * DISTANCE_RATIO;\n                    private _percentageOfDirectionRatioed = _percentageOfDirection * _overallSignalRatioForDirection;\n\n                    private _currentSignalPercentage = _percentageOfDistanceRatioed + _percentageOfDirectionRatioed;\n                    \n                    private _baseSignalLevel = _y get DECIBEL_KEY;\n                    private _signalDecibelRange = _baseSignalLevel - _minDecibels;\n                    private _relativeSignalLevel = (_signalDecibelRange * _currentSignalPercentage) + _minDecibels;\n\n                    _generatedSignalValues pushBack _relativeSignalLevel;\n                };\n\n                missionNamespace setVariable [\"#EM_Values\", _generatedSignalValues];\n            },\n            UPDATE_SIGNAL_EVERY\n        ] call CBA_fnc_addPerFrameHandler;\n    },\n    LOOP_TIME_WHEN_SEARCHING_FOR_DEVICE\n] call KISKA_fnc_waitUntil;\n\n\nnil\n\n\n",
    "fileName": "fn_spectrum_startSignalLoop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_startSignalLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_updateSignal\n\nDescription:\n    Updates a signal's base properties for the local machine or creates it if it\n     did not exist prior. It is not recommended to directly create a signal with this\n     function. Rather use `KISKA_fnc_spectrum_addSignal`.\n\n    WARNING, this function updats ALL base properties. Meaning if you intend to\n     a single property, use the corresponding setter function. For example, to update\n     the origin position only and not every signal property, use \n     `KISKA_fnc_spectrum_setSignalPosition`.\n\nParameters:\n    0: _signalProperties : <ARRAY> - The all the properites of the signal\n\n        `_signalProperties` Layout:\n        - 0: _id <STRING> - The id of the signal to update\n        - 1: _frequency <NUMBER> - The frequency of the signal in MHz\n        - 2: _origin <OBJECT or PositionASL[]> - The position of the signal\n        - 3: _decibels <NUMBER> - The base signal decibel level when when near the origin\n        - 4: _maxDistance <NUMBER> - The max distance that the signal can be seen on the spectrum analyzer\n    \n    1: _global : <BOOL> - `true` to broadcast the changes to all machines including JIP\n\nReturns:\n    <HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        // should use KISKA_fnc_spectrum_updateSignal for snyched updates\n        // but if you only want a subset of machines:\n        [\n            [\n                \"KISKA_spectrumSignal_2_1\",\n                100,\n                [0,0,0],\n                100\n            ],\n            false\n        ] remoteExecCall [\n            \"KISKA_fnc_spectrum_updateSignal\",\n            [3,4]\n        ];\n    (end)\n\n    (begin example)\n        // broadcast to all machines by default\n        [\n            [\n                \"KISKA_spectrumSignal_2_1\",\n                100,\n                [0,0,0],\n                100\n            ]\n        ] call KISKA_fnc_spectrum_updateSignal;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_updateSignal\";\n\n#define FREQUENCY_KEY \"_frequency\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n#define ORIGIN_KEY \"_origin\"\n\nparams [\n    [\"_signalProperties\",[],[[]]],\n    [\"_global\",true,[true]]\n];\n\n_signalProperties params [\n    [\"_id\",\"\",[\"\"]],\n    [\"_frequency\",100,[123]],\n    [\"_origin\",objNull,[[],objNull],[3]],\n    [\"_decibels\",-100,[123]],\n    [\"_maxDistance\",worldSize,[123]]\n];\n\nif (_frequency <= 0) exitWith {\n    [\n        [\n            \"Signal can't be added, must have a frequency above 0, current is: \",\n            _frequency,\n            \". Signal being updated: \",\n            _id\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\nprivate _originIsObject = _origin isEqualType objNull;\nif (_originIsObject AND {isNull _origin}) exitWith {\n    [[\"Provided origin is null object; attempting to update signal: \",_id],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_maxDistance <= 0) exitWith {\n    [[\"Max distance must be positive number; attempting to update signal: \",_id],true] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_global AND isMultiplayer) then {\n    [\n        _signalProperties,\n        false\n    ] remoteExecCall [\"KISKA_fnc_spectrum_updateSignal\",-clientOwner,_id];\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _idLowered = toLowerANSI _id;\nif (_originIsObject) then {\n    _origin = getPosASL _origin;\n};\n\n\nprivate _signalPropertyMap = _signalMap getOrDefaultCall [_idLowered,{-1}];\nprivate _signalExists = _signalPropertyMap isNotEqualTo -1;\nif (!_signalExists) then {\n    private _signalPropertyMap = createHashMapFromArray [\n        [FREQUENCY_KEY,_frequency],\n        [ORIGIN_KEY,_origin],\n        [DECIBEL_KEY,_decibels],\n        [DISTANCE_KEY,_maxDistance]\n    ];\n\n    _signalMap set [_idLowered,_signalPropertyMap];\n\n} else {\n    _signalPropertyMap set [FREQUENCY_KEY, _frequency];\n    _signalPropertyMap set [ORIGIN_KEY, _origin];\n    _signalPropertyMap set [DECIBEL_KEY, _decibels];\n    _signalPropertyMap set [DISTANCE_KEY, _maxDistance];\n\n};\n\ncall KISKA_fnc_spectrum_startSignalLoop;\n\n\n_signalMap\n",
    "fileName": "fn_spectrum_updateSignal.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Spectrum Device/fn_spectrum_updateSignal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_addTopic\n\nDescription:\n    Adds a configured topic to a given list of units.\n\nParameters:\n    0: _config <CONFIG or STRING> - A config path to the topic config or if a string\n        the class name of a topic config located in the default root KISKA config.\n    1: _units <OBJECT[]> - The units to add the topic to.\n\nReturns:\n    <STRING> - The topic's name.\n\nExamples:\n    (begin example)\n        [\"MyTopicClassInDefaultRoot\",[player]] call KISKA_fnc_speech_addTopic;\n    (end)\n\n    (begin example)\n        [\n            configFile >> \"MySpeechConfigs\" >> \"MyTopicConfig\",\n            [player]\n        ] call KISKA_fnc_speech_addTopic;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_addTopic\";\n\nparams [\n    [\"_config\",configNull,[configNull,\"\"]],\n    [\"_units\",[],[[]]]\n];\n\nif (_config isEqualType \"\") then {\n    private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    _config = _defaultConfig >> _config;\n};\n\nif (isNull _config) exitWith {\n    [\"null config passed\",true] call KISKA_fnc_log;\n    \"\"\n};\n\nif (_units isEqualTo []) exitWith {\n    [[\"No units to add the topic to! \",_config],true] call KISKA_fnc_log;\n    \"\"\n};\n\n\nprivate _topicName = [_config] call KISKA_fnc_speech_getTopicName;\nprivate _bikbPath = [_config] call KISKA_fnc_speech_getBikbPath;\nprivate _fsmPath = [_config] call KISKA_fnc_speech_getFsmPath;\nprivate _topicEventHandler = [_config] call KISKA_fnc_speech_getTopicEventHandler;\nprivate _topic = [\n    _topicName,\n    _bikbPath,\n    _fsmPath,\n    _topicEventHandler\n];\n_units apply {\n    _x kbAddTopic _topic;\n};\n\n\n_topicName\n",
    "fileName": "fn_speech_addTopic.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_addTopic.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_getBikbPath\n\nDescription:\n    Gets the configured bikb file path of a given speech topic config.\n\nParameters:\n    0: _topicConfig <CONFIG or STRING> - A config path to the topic config or if a string\n        the class name of a topic config located in the default root KISKA config.\n\nReturns:\n    <STRING> - The configured file path.\n\nExamples:\n    (begin example)\n        private _path = [\"MyTopicClassInDefaultRoot\"] call KISKA_fnc_speech_getBikbPath;\n    (end)\n\n    (begin example)\n        private _path = [\n            configFile >> \"MySpeechConfigs\" >> \"MyTopicConfig\"\n        ] call KISKA_fnc_speech_getBikbPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_getBikbPath\";\n\nparams [\n    [\"_topicConfig\",configNull,[configNull,\"\"]]\n];\n\nif (_topicConfig isEqualType \"\") then {\n    private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    _topicConfig = _defaultConfig >> _topicConfig;\n};\n\nif (isNull _topicConfig) exitWith {\n    [\"null config passed\",true] call KISKA_fnc_log;\n    nil\n};\n\n\ngetText(_topicConfig >> \"bikb\")",
    "fileName": "fn_speech_getBikbPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_getBikbPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_getDefaultConfigRoot\n\nDescription:\n    Returns the default config path of where configuration for KISKA speeches can\n\t go.\n\nParameters:\n    NONE\n\nReturns:\n    <CONFIG> - The default config path\n\nExamples:\n    (begin example)\n        private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_getDefaultConfigRoot\";\n\nmissionConfigFile >> \"KISKA_speech\"\n",
    "fileName": "fn_speech_getDefaultConfigRoot.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_getDefaultConfigRoot.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_getFsmPath\n\nDescription:\n    Gets the configured FSM file path of a given speech topic config.\n\nParameters:\n    0: _config <CONFIG or STRING> - A config path to the topic config or if a string\n        the class name of a topic config located in the default root KISKA config.\n\nReturns:\n    <STRING> - The configured file path.\n\nExamples:\n    (begin example)\n        private _path = [\"MyTopicClassInDefaultRoot\"] call KISKA_fnc_speech_getFsmPath;\n    (end)\n\n    (begin example)\n        private _path = [\n            configFile >> \"MySpeechConfigs\" >> \"MyTopicConfig\"\n        ] call KISKA_fnc_speech_getFsmPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_getFsmPath\";\n\nparams [\n    [\"_config\",configNull,[configNull,\"\"]]\n];\n\nif (_config isEqualType \"\") then {\n    private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    _config = _defaultConfig >> _config;\n};\n\nif (isNull _config) exitWith {\n    [\"null config passed\",true] call KISKA_fnc_log;\n    nil\n};\n\n\ngetText(_config >> \"fsm\")\n",
    "fileName": "fn_speech_getFsmPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_getFsmPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_getTopicEventHandler\n\nDescription:\n    Gets the configured eventhandler code of a given speech topic config.\n\nParameters:\n    0: _config <CONFIG or STRING> - A config path to the topic config or if a string\n        the class name of a topic config located in the default root KISKA config.\n\nReturns:\n    <CODE> - The compiled eventhandler code.\n\nExamples:\n    (begin example)\n        private _eventHandler = [\"MyTopicClassInDefaultRoot\"] call KISKA_fnc_speech_getTopicEventHandler;\n    (end)\n\n    (begin example)\n        private _eventHandler = [\n            configFile >> \"MySpeechConfigs\" >> \"MyTopicConfig\"\n        ] call KISKA_fnc_speech_getTopicEventHandler;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_getTopicEventHandler\";\n\nparams [\n    [\"_config\",configNull,[configNull,\"\"]]\n];\n\nif (_config isEqualType \"\") then {\n    private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    _config = _defaultConfig >> _config;\n};\n\nif (isNull _config) exitWith {\n    [\"null config passed\",true] call KISKA_fnc_log;\n    {}\n};\n\n\nprivate _eventHandlerMap = localNamespace getVariable \"KISKA_speech_topicEventHandlerMap\";\nif (isNil \"_eventHandlerMap\") then {\n\t_eventHandlerMap = createHashMap;\n\tlocalNamespace setVariable [\"KISKA_speech_topicEventHandlerMap\",_eventHandlerMap];\n};\n\n\nif (_config in _eventHandlerMap) exitWith { _eventHandlerMap get _config };\n\nprivate _uncompiledCode = getText(_config >> \"eventHandler\");\nprivate _compiled = compileFinal _uncompiledCode;\n_eventHandlerMap set [_config,_compiled];\n\n\n_compiled\n",
    "fileName": "fn_speech_getTopicEventHandler.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_getTopicEventHandler.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_getTopicName\n\nDescription:\n    Gets the configured topic name of a given speech topic config.\n\nParameters:\n    0: _config <CONFIG or STRING> - A config path to the topic config or if a string\n        the class name of a topic config located in the default root KISKA config.\n\nReturns:\n    <STRING> - The configured topic name.\n\nExamples:\n    (begin example)\n        private _name = [\"MyTopicClassInDefaultRoot\"] call KISKA_fnc_speech_getTopicName;\n    (end)\n\n    (begin example)\n        private _name = [\n            configFile >> \"MySpeechConfigs\" >> \"MyTopicConfig\"\n        ] call KISKA_fnc_speech_getTopicName;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_getTopicName\";\n\nparams [\n    [\"_config\",configNull,[configNull,\"\"]]\n];\n\nif (_config isEqualType \"\") then {\n    private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    _config = _defaultConfig >> _config;\n};\n\nif (isNull _config) exitWith {\n    [\"null config passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _nameConfig = _config >> \"topicName\";\nif (isNull _nameConfig) exitWith { configName _config };\n\ngetText _nameConfig\n",
    "fileName": "fn_speech_getTopicName.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_getTopicName.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_say\n\nDescription:\n    Speaks the given line of dialogue for all to hear.\n\nParameters:\n    0: _topicConfig <CONFIG or STRING> - A config path to the topic config or if a string\n        the class name of a topic config located in the default root KISKA config.\n    1: _lines <STRING or STRING[]> - The class name(s) of the line(s) in the \n        `_topicConfig >> \"lines\" >> \"Sentences\"` class to speak.\n    2: _speaker <OBJECT> - The unit to speak the line. Does not necessarily need be a man unit.\n    3: _listener <OBJECT> - The unit that the line is meant to be spoken to.\n        Does not necessarily need be a man unit.\n    4: _optionsMap <HASHMAP> - Default: `nil` - An optional hashmap of options \n        that will overwrite any configured options.\n        \n        - `radioChannel`: <STRING, NUMBER, or BOOL> - Either a radio channel name or a custom radio\n            channel number. `true` or `false` can be used to simply force a radio effect to the \n            listener or have no affect respectively. (see `kbTell` for more details)\n        - `maxRange`: <number> - The maximum allowable distance between the `_speaker` \n            and `_listener`. Should the distance be exceeded, the line does not play.\n        - `subtitle`: <STRING> - Text to display that is what the speaker said.\n        - `speakerName`: <STRING> - The name of the speaker. If no name is provided here or\n            in the config the `name _speaker` is used instead.\n        - `onLineSaid`: <CODE> - An eventhandler that will activate after the line is spoken\n\n            Parameters:\n                - 0: <CONFIG> - The config path of the topic.\n                - 1: <CONFIG> - The config path of the line.\n    \n    5: _onAllLinesSaid <CODE, STRING, ARRAY> - Default: `{}` - Code to execute once all \n        the lines have been said. (see `KISKA_fnc_callBack` for examples).\n        \n        Parameters:\n            - 0: <CONFIG> - The config path of the topic.\n            - 1: <OBJECT> - The speaker.\n\nReturns:\n    <STRING> - the topic name\n\nExamples:\n    (begin example)\n        [\n            \"MyTopicClassInDefaultRoot\",\n            \"MyLine\",\n            player,\n            BIS_HQ\n        ] call KISKA_fnc_speech_say;\n    (end)\n\n    (begin example)\n        [\n            configFile >> \"MySpeechConfigs\" >> \"MyTopicConfig\",\n            \"MyLine\",\n            player,\n            BIS_HQ,\n            createHashMapFromArray [\n                [\"radioChannel\",true]\n            ]\n        ] call KISKA_fnc_speech_say;\n    (end)\n\n    (begin example)\n        [\n            configFile >> \"MySpeechConfigs\" >> \"MyTopicConfig\",\n            [\"MyLine\",\"MyOtherLine\"],\n            player,\n            BIS_HQ,\n            createHashMapFromArray [\n                [\"radioChannel\",true] // applies to all lines\n            ]\n        ] call KISKA_fnc_speech_say;\n    (end)\n\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_say\";\n\n#define SUBTITLE_PROPERTY_KEY \"subtitle\"\n#define RADIO_CHANNEL_PROPERTY_KEY \"radioChannel\"\n#define MAX_RANGE_PROPERTY_KEY \"maxRange\"\n#define SPEAKER_NAME_PROPERTY_KEY \"speakerName\"\n#define ON_LINE_SAID_PROPERTY_KEY \"onLineSaid\"\n#define CHECK_LINE_SPOKEN_INTERVAL 0.1\n\nparams [\n    [\"_topicConfig\",configNull,[configNull,\"\"]],\n    [\"_lines\",\"\",[\"\",[]]],\n    [\"_speaker\",objNull,[objNull]],\n    [\"_listener\",objNull,[objNull]],\n    [\"_optionsMap\",nil],\n    [\"_onAllLinesSaid\",{},[{},\"\",[]]]\n];\n\n\nif (_topicConfig isEqualType \"\") then {\n    private _defaultConfig = call KISKA_fnc_speech_getDefaultConfigRoot;\n    _topicConfig = _defaultConfig >> _topicConfig;\n};\n\nif (isNull _topicConfig) exitWith {\n    [\"null topic config passed\",true] call KISKA_fnc_log;\n    \"\"\n};\n\nif (isNull _speaker) exitWith {\n    [\"null speaker passed\",true] call KISKA_fnc_log;\n    \"\"\n};\nif (isNull _listener) exitWith {\n    [\"null listener passed\",true] call KISKA_fnc_log;\n    \"\"\n};\n\nif (_lines isEqualType \"\") then {\n    _lines = [_lines];\n};\nprivate _lineDetails = [];\n_lines apply {\n    private _lineName = _x;\n    private _lineConfig = _topicConfig >> \"lines\" >> \"Sentences\" >> _lineName;\n    if (isNull _lineConfig) then {\n        [\n            [\n                \"null line config does not exist for \",\n                _lineName,\" in \",_topicConfig\n            ],\n            true\n        ] call KISKA_fnc_log;\n        continue;\n    };\n\n    /* ----------------------------------------------------------------------------\n        Parse Optional Params\n    ---------------------------------------------------------------------------- */\n    private \"_lineOptionsMap\";\n    if (isNil \"_optionsMap\") then { \n        _lineOptionsMap = createHashMap; \n    } else {\n        _lineOptionsMap = _optionsMap;\n    };\n    private _optionalMapParams = [\n        _lineOptionsMap,\n        [\n            [\n                MAX_RANGE_PROPERTY_KEY, \n                {\n                    import \"_lineConfig\";\n                    private _maxRangeConfig = _lineConfig >> MAX_RANGE_PROPERTY_KEY;\n                    if (isNull _maxRangeConfig) exitWith { -1 };\n                    getNumber _maxRangeConfig\n                },\n                [123]\n            ],\n            [\n                RADIO_CHANNEL_PROPERTY_KEY,\n                {\n                    import \"_lineConfig\";\n                    private _radioConfig = _lineConfig >> RADIO_CHANNEL_PROPERTY_KEY;\n                    if (isNull _radioConfig) exitWith { false };\n\n                    private _configValue = [_radioConfig,false,\"false\"] call KISKA_fnc_getConfigData;\n                    if (_configValue isEqualType 123) exitWith { _configValue };\n                    if (_configValue == \"false\") exitWith { false };\n                    if (_configValue == \"true\") exitWith { true };\n\n                    _configValue;\n                },\n                [true,123,\"\"]\n            ],\n            [\n                SUBTITLE_PROPERTY_KEY,\n                {\n                    import \"_lineConfig\";\n                    getText(_lineConfig >> SUBTITLE_PROPERTY_KEY)\n                },\n                [\"\"]\n            ],\n            [\n                SPEAKER_NAME_PROPERTY_KEY,\n                {\n                    import \"_lineConfig\";\n                    private _name = getText(_lineConfig >> SPEAKER_NAME_PROPERTY_KEY);\n                    if (_name isNotEqualTo \"\") exitWith { _name };\n\n                    import \"_speaker\";\n                    name _speaker;\n                },\n                [\"\"]\n            ],\n            [\n                ON_LINE_SAID_PROPERTY_KEY,\n                {\n                    import \"_lineConfig\";\n                    private _onLineSaidConfig = _lineConfig >> ON_LINE_SAID_PROPERTY_KEY;\n                    compileFinal (getText _onLineSaidConfig)\n                },\n                [{}]\n            ]\n        ]\n    ] call KISKA_fnc_hashMapParams;\n    if (_optionalMapParams isEqualType \"\") then {\n        [_optionalMapParams,true] call KISKA_fnc_log;\n        continue;\n    };\n\n    (_optionalMapParams select 0) params (_optionalMapParams select 1);\n    if (_speakerName isEqualTo \"\") then {\n        _speakerName = name _speaker;\n    };\n    _lineDetails pushBack [\n        _lineConfig,\n        _lineName,\n        _speakerName,\n        _maxRange,\n        _radioChannel,\n        _subtitle,\n        _onLineSaid\n    ];\n};\n\n\nprivate _topicName = [_topicConfig] call KISKA_fnc_speech_getTopicName;\nprivate _addTopicTo = [];\nif !(_speaker kbHasTopic _topicName) then { _addTopicTo pushBack _speaker; };\nif !(_listener kbHasTopic _topicName) then { _addTopicTo pushBack _listener; };\nif (_addTopicTo isNotEqualTo []) then {\n    [_topicConfig, _addTopicTo] call KISKA_fnc_speech_addTopic;\n};\n\n[_topicConfig,_speaker,_listener,_topicName,_onAllLinesSaid,_lineDetails] spawn {\n    params [\"_topicConfig\",\"_speaker\",\"_listener\",\"_topicName\",\"_onAllLinesSaid\",\"_lineDetails\"];\n\n    _lineDetails apply {\n        _x params [\n            \"_lineConfig\",\n            \"_lineName\",\n            \"_speakerName\",\n            \"_maxRange\",\n            \"_radioChannel\",\n            \"_subtitle\",\n            \"_onLineSaid\"\n        ];\n\n        if ((_maxRange isNotEqualTo -1) AND ((_speaker distance _listener) > _maxRange)) then {\n            [[\"_maxRange exceeded of -> \",_maxRange,\" has been exceeded\"],false] call KISKA_fnc_log;\n            continue;\n        };\n\n        /* ----------------------------------------------------------------------------\n            Speak Line\n        ---------------------------------------------------------------------------- */\n        if (_subtitle isNotEqualTo \"\") then {\n            [_subtitle,_speakerName] call KISKA_fnc_speech_showSubtitles;\n        };\n\n        _speaker kbTell [_listener, _topicName, _lineName, _radioChannel];\n        \n        private _wasSaid = false;\n        private _isAlive = true;\n        waitUntil { \n            sleep CHECK_LINE_SPOKEN_INTERVAL; \n            _isAlive = alive _speaker;\n            _wasSaid = _speaker kbWasSaid [_listener, _topicName, _lineName, 1];\n\n            !_isAlive OR _wasSaid\n        };\n\n        if (_wasSaid AND {_onLineSaid isNotEqualTo {}}) then {\n            [[_topicConfig,_lineConfig],_onLineSaid] call KISKA_fnc_callBack;\n        };\n\n        if !(_isAlive) then { break };\n    };\n\n    if (_onAllLinesSaid isEqualTo {}) exitWith {};\n    [[_topicConfig,_speaker],_onAllLinesSaid] call KISKA_fnc_callBack;\n};\n\n\n_topicName\n",
    "fileName": "fn_speech_say.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_say.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_speech_showSubtitles\n\nDescription:\n    Shows subtitles for a given line of text.\n\nParameters:\n    0: _subtitle <STRING> - The text of what's being said.\n    1: _speakerName <STRING> - Default: `\"unknown\"` - The name of the speaker.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"Hello World\",\"someone\"] call KISKA_fnc_speech_showSubtitles;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_speech_showSubtitles\";\n\nparams [\n    [\"_subtitle\",\"\",[\"\"]],\n    [\"_speakerName\",\"unknown\",[\"\"]]\n];\n\n\n[_speakerName,_subtitle] spawn BIS_fnc_showSubtitle;\n\nnil",
    "fileName": "fn_speech_showSubtitles.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Speech/fn_speech_showSubtitles.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_detectControlKeys\n\nDescription:\n    Arma 3's support system currently has a bug that allows players to call in\n     multiple supports by having the map open and holding down a ctrl key and left\n     - clicking while in the support menu. Each click will call in a support.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT Function\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_detectControlKeys\";\n\n#define LEFT_CTRL_CODE 29\n#define RIGHT_CTRL_CODE 157\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled, exiting to scheduled...\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_commMenu_detectControlKeys;\n};\n\n\nif ([\"ace_interact_menu\"] call KISKA_fnc_isPatchLoaded) then {\n    [\n        \"ace_interactMenuClosed\",\n        {\n            params [\"_menuType\"];\n\n            //diag_log \"(ACE EVENT) ACE interact menu is closed\";\n\n            // making sure _menuType is the seld interact menu\n            if (missionNamespace getVariable [\"KISKA_ctrlDown\",false] AND {_menuType isEqualTo 1}) then {\n                //hint \"(ACE EVENT) KISKA_ctrlDown is true, setting to false\";\n                //diag_log \"(ACE EVENT) KISKA_ctrlDown is true, setting to false\";\n\n                missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n            };\n        }\n    ] call CBA_fnc_addeventhandler;\n};\n\n\nwaitUntil {\n    if !(isNull (findDisplay 46)) exitWith {true};\n    [\"Looping for Display\",false] call KISKA_fnc_log;\n    sleep 0.1;\n    false\n};\n\n[\"Found display, loop ended\",false] call KISKA_fnc_log;\n\n\n(findDisplay 46) displayAddEventHandler [\"KeyDown\",{\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    // if a key other then a ctrl is pressed without ctrl down\n    if (!_ctrl AND {_key isNotEqualTo LEFT_CTRL_CODE} AND {_key isNotEqualTo RIGHT_CTRL_CODE}) then {\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        };\n\n    } else { // if ctrl is pressed\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        };\n    };\n\n\n    nil\n}];\n\n(findDisplay 46) displayAddEventHandler [\"KeyUp\",{\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    // if a key other then a ctrl is released without ctrl down OR the released key is a ctrl key\n    if (!_ctrl OR {_key isEqualTo LEFT_CTRL_CODE} OR {_key isEqualTo RIGHT_CTRL_CODE}) then {\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        };\n    } else { // if ctrl is still down or the released key is not a ctrl key\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        };\n    };\n\n\n    nil\n}];\n\n\n\n\n\n\n\n\n// debug code\n/*\n(findDisplay 46) displayAddEventHandler [\"KeyDown\",{\n    //params [\"\", \"_key\", \"\", \"_ctrl\", \"\"];\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    hint \"key down\";\n    diag_log \"------------------------------------------\";\n    diag_log \"Key down\";\n\n    // if a key other then a ctrl is pressed without ctrl down\n    if (!_ctrl AND {_key isNotEqualTo LEFT_CTRL_CODE} AND {_key isNotEqualTo RIGHT_CTRL_CODE}) then {\n        hint \"_ctrl is false (key-down)\";\n        diag_log \"_ctrl is false (key-down)\";\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            hint \"KISKA_ctrlDown is true (key-down), setting it to false\";\n            diag_log \"KISKA_ctrlDown is true (key-down), setting it to false\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        } else {\n            hint \"KISKA_ctrlDown is false (key-down) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is false (key-down) and it will remain so\";\n        };\n    } else { // if ctrl is pressed\n        hint \"_ctrl is true (key-down)\";\n        diag_log \"_ctrl is true (key-down)\";\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            hint \"KISKA_ctrlDown is false (key-down), setting it to true\";\n            diag_log \"KISKA_ctrlDown is false (key-down), setting it to true\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        } else {\n            hint \"KISKA_ctrlDown is true (key-down) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is true (key-down) and it will remain so\";\n        };\n    };\n\n\n    nil\n}];\n\n(findDisplay 46) displayAddEventHandler [\"KeyUp\",{\n    //params [\"\", \"_key\", \"\", \"_ctrl\", \"\"];\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    hint \"key up\";\n    diag_log \"------------------------------------------\";\n    diag_log \"Key up\";\n\n    // if a key other then a ctrl is released without ctrl down OR the released key is a ctrl key\n    if (!_ctrl OR {_key isEqualTo LEFT_CTRL_CODE} OR {_key isEqualTo RIGHT_CTRL_CODE}) then {\n        hint \"_ctrl is false (key-up)\";\n        diag_log \"_ctrl is false (key-up)\";\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            hint \"KISKA_ctrlDown is true (key-up), setting it to false\";\n            diag_log \"KISKA_ctrlDown is true (key-up), setting it to false\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        } else {\n            hint \"KISKA_ctrlDown is false (key-up) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is false (key-up) and it will remain so\";\n        };\n    } else { // if ctrl is still down or the released key is not a ctrl key\n        hint \"_ctrl is true (key-up)\";\n        diag_log \"_ctrl is true (key-up)\";\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            hint \"KISKA_ctrlDown is false (key-up), setting it to true\";\n            diag_log \"KISKA_ctrlDown is false (key-up), setting it to true\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        } else {\n            hint \"KISKA_ctrlDown is true (key-up) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is true (key-up) and it will remain so\";\n        };\n    };\n\n\n    nil\n}];\n*/\n",
    "fileName": "fn_commMenu_detectControlKeys.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_detectControlKeys.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_onSupportAdded\n\nDescription:\n    Designed to be an event handler for when a support that's meant to be used in\n    the event a support item that is part of the comm menu is added.\n    \nParameters:\n    0: _supportId <STRING> - The support's id\n    1: _supportConfig <CONFIG> - The support config\n    2: _numberOfUsesLeft <NUMBER> - The number of support uses left or rounds\n        available to use.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_supports_1\",\n            missionConfigFile >> \"CfgCommunicationMenu\" >> \"MySupport\",\n            1\n        ] call KISKA_fnc_commMenu_onSupportAdded;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_onSupportAdded\";\n\n#define DEFAULT_SUPPORT_CURSOR \"\\a3\\Ui_f\\data\\IGUI\\Cfg\\Cursors\\iconCursorSupport_ca.paa\"\n#define DEFAULT_ENABLE_EXPRESSION \"cursorOnGround\"\n\nparams [\n    [\"_supportId\",\"\",[\"\"]],\n    [\"_supportConfig\",configNull,[configNull]]\n];\n\nprivate _commMenuDetailsConfig = _supportConfig >> \"KISKA_commMenuDetails\";\nif (isNull _commMenuDetailsConfig) exitWith {\n    [\"_supportConfig has no KISKA_commMenuDetails class defined\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _commMenuSupportDetailsMap = [\n    localNamespace,\n    \"KISKA_commMenu_configToDetailsMap\",\n    {createHashMap}\n] call KISKA_fnc_getOrDefaultSet;\nprivate _commMenuSupportDetails = _commMenuSupportDetailsMap getOrDefault [_supportConfig,[]];\n_commMenuSupportDetails params [\n    \"_text\",\n    \"_icon\",\n    \"_iconText\",\n    \"_cursor\",\n    \"_enableExpression\"\n];\nif (_commMenuSupportDetails isEqualTo []) then {\n    _text = getText(_commMenuDetailsConfig >> \"text\");\n    _icon = getText(_commMenuDetailsConfig >> \"icon\");\n    _iconText = getText(_commMenuDetailsConfig >> \"iconText\");\n    _cursor = getText(_commMenuDetailsConfig >> \"cursor\");\n    if (_cursor isEqualTo \"\") then {\n        _cursor = DEFAULT_SUPPORT_CURSOR;\n    };\n    _enableExpression = getText(_commMenuDetailsConfig >> \"enableExpression\");\n    if (_enableExpression isEqualTo \"\") then {\n        _enableExpression = DEFAULT_ENABLE_EXPRESSION;\n    };\n\n    _commMenuSupportDetailsMap set [\n        _supportConfig,\n        [\n            _text,\n            _icon,\n            _iconText,\n            _cursor,\n            _enableExpression\n        ]\n    ];\n};\n\n\nprivate _commMenuExpression = format [\"['%1',AGLToASL _pos,_target,_is3D] call KISKA_fnc_commMenu_onSupportSelected;\",_supportId];\nprivate _idToDetailsMap = [\n    localNamespace,\n    \"KISKA_commMenu_supportIdToDetailsMap\",\n    {createHashMap}\n] call KISKA_fnc_getOrDefaultSet;\n_idToDetailsMap set [\n    _supportId,\n    [\n        _supportId,\n        _text,\n        \"\", // subMenu unused\n        _commMenuExpression,\n        _enableExpression,\n        _cursor,\n        _icon,\n        _iconText\n    ]\n];\n\ncall KISKA_fnc_commMenu_refresh;\n\n// Close the menu when opened\nif (commandingMenu == \"#User:BIS_fnc_addCommMenuItem_menu\") then {\n    showcommandingmenu \"\";\n};\n\n\nnil\n",
    "fileName": "fn_commMenu_onSupportAdded.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_onSupportAdded.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_onSupportRemoved\n\nDescription:\n    Called when a comm menu support is removed be it through a manual process\n    or when a player uses all of a given support.\n    \nParameters:\n    0: _supportId <STRING> - The support's id\n    1: _supportConfig <CONFIG> - The support's config\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_supports_1\",\n            missionConfigFile >> \"CfgCommunicationMenu\" >> \"MySupport\",\n            1\n        ] call KISKA_fnc_commMenu_onSupportRemoved;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_onSupportRemoved\";\n\nparams [\"_supportId\"];\n\nprivate _idToDetailsMap = localNamespace getVariable \"KISKA_commMenu_supportIdToDetailsMap\";\n_idToDetailsMap deleteAt _supportId;\n\ncall KISKA_fnc_commMenu_refresh;\n\n\nnil\n",
    "fileName": "fn_commMenu_onSupportRemoved.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_onSupportRemoved.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_onSupportSelected\n\nDescription:\n    Triggers when a communication menu item is selected from the commanding menu.\n\n    Activates the given support's `onSupportSelected` event.\n\nParameters:\n    0: _supportId <STRING> - The KISKA support id of the selected support.\n    1: _targetPosition <PositionASL[]> - The position of the player's cursor in the map\n        or where they are looking if it is 3d.\n    2: _cursorTarget <OBJECT> - The `cursorTarget` at the time of the selection.\n    3: _is3D <BOOL> - Whether or not the support was selected in the map or while\n        not looking at the map.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"myClass\",_this] call KISKA_fnc_commMenu_onSupportSelected;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_onSupportSelected\";\n\nparams [\n    \"_supportId\",\n    \"_targetPosition\",\n    \"_cursorTarget\",\n    \"_is3D\"\n];\n\nprivate _supportMap = call KISKA_fnc_supports_getMap;\nprivate _supportInfo = _supportMap get _supportId;\n_supportInfo params [\"_supportConfig\",\"_numberOfUsesLeft\"];\n\nprivate _onSupportSelectedMap = [\n    localNamespace,\n    \"KISKA_commMenu_onSupportSelectedMap\",\n    {createHashMap}\n] call KISKA_fnc_getOrDefaultSet;\n\nprivate _onSupportSelectedCompiled = _onSupportSelectedMap get _supportConfig;\nif (isNil \"_onSupportSelectedCompiled\") then {\n    private _onSupportSelected = getText(_supportConfig >> \"KISKA_commMenuDetails\" >> \"onSupportSelected\");\n    _onSupportSelectedCompiled = compileFinal _onSupportSelected;\n    _onSupportSelectedMap set [_supportConfig,_onSupportSelectedCompiled];\n};\n\n[\n    _onSupportSelectedCompiled,\n    [\n        _supportId,\n        _supportConfig,\n        _targetPosition,\n        _numberOfUsesLeft,\n        _is3D,\n        _cursorTarget\n    ]\n] call CBA_fnc_directCall;\n\n\nnil\n",
    "fileName": "fn_commMenu_onSupportSelected.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_onSupportSelected.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_openArty\n\nDescription:\n   Opens a commanding menu that will allow the player to select the parameters\n   of an artillery strike.\n\nParameters:\n    0: _supportId <STRING> - The ID of the specific support.\n    1: _supportConfig <CONFIG> - The support's config path.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_support_1\",\n            configFile >> \"MyArtillerySupport\"\n        ] call KISKA_fnc_commMenu_openArty;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_openArty\";\n\n#define MIN_RADIUS 0\n\nparams [\n    [\"_supportId\",\"\",[\"\"]],\n    [\"_supportConfig\",configNull,[configNull]]\n];\n\n\nif (isNull _supportConfig) exitWith {\n    [\"null _supportConfig used!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _commMenuDetailsConfig = _supportConfig >> \"KISKA_commMenuDetails\";\n\n/* ----------------------------------------------------------------------------\n    Radius Menu\n---------------------------------------------------------------------------- */\nprivate _selectableRadiuses = getArray(_commMenuDetailsConfig >> \"radiuses\");\nif (_selectableRadiuses isEqualTo []) then {\n    _selectableRadiuses = missionNamespace getVariable [\"KISKA_CBA_supp_radiuses_arr\",[]];\n\n    if (_selectableRadiuses isEqualTo []) then {\n        _selectableRadiuses = [200];\n    };\n};\n_selectableRadiuses sort true;\n\nprivate _radiusMenuOptions = [];\nprivate _pushedMinRadius = false;\n_selectableRadiuses apply {\n    private _radius = _x;\n    private _isMinRadius = _radius <= MIN_RADIUS;\n    if (_pushedMinRadius AND _isMinRadius) then { continue };\n    if (_isMinRadius) then {\n        _pushedMinRadius = true;\n        _radius = MIN_RADIUS;\n    };\n    _radiusMenuOptions pushBack [ [_radius,\"m\"] joinString \"\", _radius ];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Round Count Menu\n---------------------------------------------------------------------------- */\nprivate _roundsMenuOptions = [];\nprivate _canSelectRounds = [_commMenuDetailsConfig >> \"canSelectRounds\",true,true] call KISKA_fnc_getConfigData;\nprivate _numberOfRoundsLeft = [_supportId] call KISKA_fnc_supports_getNumberOfUsesLeft;\nif (_canSelectRounds) then {\n    for \"_i\" from 1 to _numberOfRoundsLeft do {\n        _roundsMenuOptions pushBack [[_i,\"Round(s)\"] joinString \" \",_i]; \n    };\n} else {\n    _roundsMenuOptions pushBack [[_numberOfRoundsLeft,\"Round(s)\"] joinString \" \",_numberOfRoundsLeft]; \n};\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu\n---------------------------------------------------------------------------- */\nprivate _draw3dMarker = [_commMenuDetailsConfig >> \"draw3dMarker\",true,true] call KISKA_fnc_getConfigData;\nif (_draw3dMarker) then {\n    call KISKA_fnc_drawLookingAtMarker_start;\n};\n\n[\n    [\n        [\"Select Ammo\", getArray(_commMenuDetailsConfig >> \"ammoTypes\")],\n        [\"Area Spread\", _radiusMenuOptions],\n        [\"Number of Rounds\", _roundsMenuOptions]\n    ],\n    [[_supportId], {\n        params [\"_ammoClass\",\"_radiusOfFire\",\"_numberOfRoundsToFire\"];\n        _thisArgs params [\"_supportId\"];\n        [\n            _supportId,\n            call KISKA_fnc_supports_getCommonTargetPosition,\n            _numberOfRoundsToFire,\n            [_ammoClass,_radiusOfFire]\n        ] call KISKA_fnc_supports_call;\n    }],\n    {},\n    [[_draw3dMarker],{\n        _thisArgs params [\"_draw3dMarker\"];\n        if !(_draw3dMarker) exitWith {};\n        \n        call KISKA_fnc_drawLookingAtMarker_stop \n    }]\n] spawn KISKA_fnc_openCommandingMenuPath;\n\n\nnil\n",
    "fileName": "fn_commMenu_openArty.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_openArty.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_openCAS\n\nDescription:\n   Opens a commanding menu that will allow the player to select the parameters\n   of a CAS strike.\n\nParameters:\n    0: _supportId <STRING> - The ID of the specific support.\n    1: _supportConfig <CONFIG> - The support's config path.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_support_1\",\n            configFile >> \"MyCASSupport\"\n        ] call KISKA_fnc_commMenu_openCAS;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_openCAS\";\n\n#define MY_DIRECTION_VALUE \"my direction\"\n#define MIN_RADIUS 0\n\nparams [\n    [\"_supportId\",\"\",[\"\"]],\n    [\"_supportConfig\",configNull,[configNull]]\n];\n\nif (isNull _supportConfig) exitWith {\n    [\"null _supportConfig used!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _commMenuDetailsConfig = _supportConfig >> \"KISKA_commMenuDetails\";\nprivate _aircraftClass = getText(_commMenuDetailsConfig >> \"aircraftClass\");\nif (_aircraftClass isEqualTo \"\") exitWith {\n    [[\"`aircraftClass` is not defined in \",_commMenuDetailsConfig],true] call KISKA_fnc_log;\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    Attack Type Options\n---------------------------------------------------------------------------- */\nprivate _attackTypeClasses = configProperties [_commMenuDetailsConfig >> \"AttackTypes\",\"isClass _x\"];\nif (_attackTypeClasses isEqualTo []) exitWith {\n    [[\"No AttackTypes defined in \",_commMenuDetailsConfig],true] call KISKA_fnc_log;\n    nil\n};\nprivate _attackTypeOptions = _attackTypeClasses apply { [getText(_x >> \"label\"),_x] };\n\nprivate _menuPath = [\n    [\"Attack Type\",_attackTypeOptions]\n];\n\n\n/* ----------------------------------------------------------------------------\n    Attack Direction Options\n---------------------------------------------------------------------------- */\nprivate _canSelectIngress = [_commMenuDetailsConfig >> \"canSelectIngress\",true,true] call KISKA_fnc_getConfigData;\nif (_canSelectIngress) then {\n    private _attackDirectionOptions = [\n        [0,\"N\"],\n        [45,\"NE\"],\n        [90,\"E\"],\n        [135,\"SE\"],\n        [180,\"S\"],\n        [225,\"SW\"],\n        [270,\"W\"],\n        [315,\"NW\"]\n    ] apply {\n        _x params [\"_bearing\",\"_cardinal\"];\n        private _label = [_bearing,_cardinal] joinString \" - \";\n        [_label,_bearing]\n    };\n    _attackDirectionOptions pushBack [\"My Direction\",MY_DIRECTION_VALUE];\n    _menuPath pushBack [\"Attack Direction\",_attackDirectionOptions];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu\n---------------------------------------------------------------------------- */\nprivate _draw3dMarker = [_commMenuDetailsConfig >> \"draw3dMarker\",true,true] call KISKA_fnc_getConfigData;\nif (_draw3dMarker) then { call KISKA_fnc_drawLookingAtMarker_start };\n\n[\n    _menuPath,\n    [[_supportId,_aircraftClass,_supportConfig], {\n        private _playerDirection = getDir player;\n        params [\n            \"_attackTypeConfig\",\n            [\"_attackDirection\",_playerDirection]\n        ];\n\n        if (_attackDirection isEqualTo MY_DIRECTION_VALUE) then {\n            _attackDirection = _playerDirection;\n        };\n\n        _thisArgs params [\"_supportId\",\"_aircraftClass\",\"_supportConfig\"];\n        private _argsMap = [\n            localNamespace,\n            \"KISKA_commMenu_parsedCloseAirSupportArgsMap\",\n            {createHashMap}\n        ] call KISKA_fnc_getOrDefaultSet;\n\n        private \"_fireOrders\";\n        private _aircraftParamsMapInitializer = [\n            [\"aircraftClass\",_aircraftClass],\n            [\"side\",side player],\n            [\"attackPosition\",call KISKA_fnc_supports_getCommonTargetPosition],\n            [\"directionOfAttack\",_attackDirection]\n        ];\n\n        if (_supportConfig in _argsMap) then {\n            private _cachedArgs = _argsMap get _supportConfig;\n            _aircraftParamsMapInitializer append (_cachedArgs select 0);\n            _fireOrders = _cachedArgs select 1;\n        } else {\n            private _cachedAircraftArgs = [];\n            [\n                [\"allowDamage\",true],\n                \"initialHeightAboveTarget\",\n                \"initialDistanceToTarget\",\n                \"breakOffDistance\",\n                \"numberOfFlaresToDump\",\n                \"approachSpeed\",\n                \"vectorToTargetOffset\",\n                \"fireDistance\"\n            ] apply {\n                _x params [\"_paramName\",[\"_isBool\",false]];\n\n                private _cfgData = [_attackTypeConfig >> _paramName,_isBool] call KISKA_fnc_getConfigData;\n                if (isNil \"_cfgData\") then { continue };\n                _cachedAircraftArgs pushBack [_paramName, _cfgData];\n            };\n            _aircraftParamsMapInitializer append _cachedAircraftArgs;\n\n            private _fireOrderConfigs = configProperties [_attackTypeConfig >> \"FireOrders\",\"isClass _x\",true];\n            _fireOrders = _fireOrderConfigs apply {\n                [\n                    getText(_x >> \"weapon\"),\n                    getText(_x >> \"mag\"),\n                    [_x >> \"numberOfTriggerPulls\",false,-1] call KISKA_fnc_getConfigData,\n                    [_x >> \"timeBetweenShots\",false,0.05] call KISKA_fnc_getConfigData,\n                    getText(_x >> \"weaponProfile\"),\n                    [_x >> \"strafeIncrement\",false,0] call KISKA_fnc_getConfigData\n                ]\n            };\n\n            _argsMap set [_supportConfig,[_cachedAircraftArgs,_fireOrders]];\n        };\n\n        [\n            _supportId,\n            call KISKA_fnc_supports_getCommonTargetPosition,\n            1,\n            [\n                createHashMapFromArray _aircraftParamsMapInitializer,\n                _fireOrders\n            ]\n        ] call KISKA_fnc_supports_call;\n    }],\n    {},\n    [[_draw3dMarker],{\n        _thisArgs params [\"_draw3dMarker\"];\n        if !(_draw3dMarker) exitWith {};\n        \n        call KISKA_fnc_drawLookingAtMarker_stop \n    }]\n] spawn KISKA_fnc_openCommandingMenuPath;\n\n\nnil\n",
    "fileName": "fn_commMenu_openCAS.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_openCAS.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_openHelicopterCAS\n\nDescription:\n    Opens a commanding menu that will allow the player to select the parameters\n    of a helicopter version 1 CAS support.\n\nParameters:\n    0: _supportId <STRING> - The ID of the specific support.\n    1: _supportConfig <CONFIG> - The support's config path.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_support_1\",\n            configFile >> \"MyHelicopterCAS\"\n        ] call KISKA_fnc_commMenu_openHelicopterCAS;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_openHelicopterCAS\";\n\n#define DEFAULT_PATROL_RADIUS 200\n#define DEFAULT_PATROL_ALTITUDE 50\n#define SPEED_LIMIT 10\n#define MY_DIRECTION_VALUE \"my direction\"\n\nparams [\n    [\"_supportId\",\"\",[\"\"]],\n    [\"_supportConfig\",configNull,[configNull]]\n];\n\nif (isNull _supportConfig) exitWith {\n    [\"null _supportConfig used!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _commMenuDetailsConfig = _supportConfig >> \"KISKA_commMenuDetails\";\nprivate _aircraftClass = getText(_commMenuDetailsConfig >> \"aircraftClass\");\nif (_aircraftClass isEqualTo \"\") exitWith {\n    [[\"`aircraftClass` is not defined in \",_commMenuDetailsConfig],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _menuPath = [];\n\n/* ----------------------------------------------------------------------------\n    Ingress Direction Options\n---------------------------------------------------------------------------- */\nprivate _canSelectIngressDirection = [_commMenuDetailsConfig >> \"canSelectIngress\",true,true] call KISKA_fnc_getConfigData;\nif (_canSelectIngressDirection) then {\n    private _ingressDirectionOptions = [\n        [0,\"N\"],\n        [45,\"NE\"],\n        [90,\"E\"],\n        [135,\"SE\"],\n        [180,\"S\"],\n        [225,\"SW\"],\n        [270,\"W\"],\n        [315,\"NW\"]\n    ] apply {\n        _x params [\"_bearing\",\"_cardinal\"];\n        private _label = [_bearing,_cardinal] joinString \" - \";\n        [_label,_bearing]\n    };\n    _ingressDirectionOptions pushBack [\"My Direction\",MY_DIRECTION_VALUE];\n    _menuPath pushBack [\"Ingress Direction\",_ingressDirectionOptions];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Patrol Zone Radius Menu\n---------------------------------------------------------------------------- */\nprivate _selectableRadiuses = getArray(_commMenuDetailsConfig >> \"patrolRadiuses\");\nif (_selectableRadiuses isEqualTo []) then {\n    _selectableRadiuses = missionNamespace getVariable [\"KISKA_CBA_supp_radiuses_arr\",[]];\n\n    if (_selectableRadiuses isEqualTo []) then {\n        _selectableRadiuses = [DEFAULT_PATROL_RADIUS];\n    };\n};\nprivate _patrolZoneOptions = _selectableRadiuses apply {\n    private _label = [_x,\"m\"] joinString \"\";\n    [_label,_x]\n};\n_menuPath pushBack [\"Patrol Zone Radius\",_patrolZoneOptions];\n\n\n/* ----------------------------------------------------------------------------\n    Patrol Altitude\n---------------------------------------------------------------------------- */\nprivate _selectableAltitudes = getArray(_commMenuDetailsConfig >> \"patrolAltitudes\");\nif (_selectableAltitudes isEqualTo []) then {\n    _selectableAltitudes = missionNamespace getVariable [\"KISKA_CBA_supp_flyInHeights_arr\",[]];\n\n    if (_selectableAltitudes isEqualTo []) then {\n        _selectableAltitudes = [DEFAULT_PATROL_ALTITUDE];\n    };\n};\nprivate _patrolAltitudeOptions = _selectableAltitudes apply {\n    private _label = [_x,\"m\"] joinString \"\";\n    [_label,_x]\n};\n_menuPath pushBack [\"Patrol Altitude\",_patrolAltitudeOptions];\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu\n---------------------------------------------------------------------------- */\nprivate _patrolDuration = getNumber(_commMenuDetailsConfig >> \"patrolDuration\");\nprivate _draw3dMarker = [_commMenuDetailsConfig >> \"draw3dMarker\",true,true] call KISKA_fnc_getConfigData;\nif (_draw3dMarker) then { call KISKA_fnc_drawLookingAtMarker_start };\n\n[\n    _menuPath,\n    [[_supportId,_aircraftClass,_patrolDuration], {\n        private _playerDirection = getDir player;\n        params [\n            [\"_ingressDirection\",_playerDirection],\n            \"_patrolZoneRadius\",\n            \"_patrolAltitude\"\n        ];\n        if (_ingressDirection isEqualTo MY_DIRECTION_VALUE) then {\n            _ingressDirection = _playerDirection;\n        };\n        _thisArgs params [\"_supportId\",\"_aircraftClass\",\"_patrolDuration\"];\n\n        [\n            _supportId,\n            call KISKA_fnc_supports_getCommonTargetPosition,\n            1,\n            [\n                call KISKA_fnc_supports_getCommonTargetPosition,\n                _patrolZoneRadius,\n                _aircraftClass,\n                _patrolDuration,\n                SPEED_LIMIT,\n                _patrolAltitude,\n                _ingressDirection,\n                side player\n            ]\n        ] call KISKA_fnc_supports_call;\n    }],\n    {},\n    [[_draw3dMarker],{\n        _thisArgs params [\"_draw3dMarker\"];\n        if !(_draw3dMarker) exitWith {};\n        \n        call KISKA_fnc_drawLookingAtMarker_stop \n    }]\n] spawn KISKA_fnc_openCommandingMenuPath;\n\n\nnil\n",
    "fileName": "fn_commMenu_openHelicopterCAS.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_openHelicopterCAS.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_openSupplyDrop\n\nDescription:\n    Opens a commanding menu that will allow the player to select the parameters\n    of a supply drop.\n\nParameters:\n    0: _supportId <STRING> - The ID of the specific support.\n    1: _supportConfig <CONFIG> - The support's config path.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            \"KISKA_support_1\",\n            configFile >> \"MySupplyDrop\"\n        ] call KISKA_fnc_commMenu_openSupplyDrop;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_openSupplyDrop\";\n\n#define DEFAULT_DROP_ALTITUDE 100\n#define MY_DIRECTION_VALUE \"my direction\"\n\nparams [\n    [\"_supportId\",\"\",[\"\"]],\n    [\"_supportConfig\",configNull,[configNull]]\n];\n\nif (isNull _supportConfig) exitWith {\n    [\"null _supportConfig used!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _commMenuDetailsConfig = _supportConfig >> \"KISKA_commMenuDetails\";\nprivate _menuPath = [];\n\n/* ----------------------------------------------------------------------------\n    Ingress Direction Options\n---------------------------------------------------------------------------- */\nprivate _canSelectIngressDirection = [_commMenuDetailsConfig >> \"canSelectIngress\",true,true] call KISKA_fnc_getConfigData;\nif (_canSelectIngressDirection) then {\n    private _ingressDirectionOptions = [\n        [0,\"N\"],\n        [45,\"NE\"],\n        [90,\"E\"],\n        [135,\"SE\"],\n        [180,\"S\"],\n        [225,\"SW\"],\n        [270,\"W\"],\n        [315,\"NW\"]\n    ] apply {\n        _x params [\"_bearing\",\"_cardinal\"];\n        private _label = [_bearing,_cardinal] joinString \" - \";\n        [_label,_bearing]\n    };\n    _ingressDirectionOptions pushBack [\"My Direction\",MY_DIRECTION_VALUE];\n    _menuPath pushBack [\"Ingress Direction\",_ingressDirectionOptions];\n};\n\n/* ----------------------------------------------------------------------------\n    Drop Altitude\n---------------------------------------------------------------------------- */\nprivate _selectableAltitudes = getArray(_commMenuDetailsConfig >> \"dropAltitudes\");\nif (_selectableAltitudes isEqualTo []) then {\n    _selectableAltitudes = missionNamespace getVariable [\"KISKA_CBA_supp_flyInHeights_arr\",[]];\n\n    if (_selectableAltitudes isEqualTo []) then {\n        _selectableAltitudes = [DEFAULT_DROP_ALTITUDE];\n    };\n};\nprivate _dropAltitudeOptions = _selectableAltitudes apply {\n    private _label = [_x,\"m\"] joinString \"\";\n    [_label,_x]\n};\n_menuPath pushBack [\"Drop Altitude\",_dropAltitudeOptions];\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu\n---------------------------------------------------------------------------- */\nprivate _draw3dMarker = [_commMenuDetailsConfig >> \"draw3dMarker\",true,true] call KISKA_fnc_getConfigData;\nif (_draw3dMarker) then { call KISKA_fnc_drawLookingAtMarker_start };\n\n[\n    _menuPath,\n    [[_supportId,_commMenuDetailsConfig], {     \n        private _playerDirection = getDir player;\n        params [\n            [\"_ingressDirection\",_playerDirection],\n            \"_dropAltitude\"\n        ];\n        if (_ingressDirection isEqualTo MY_DIRECTION_VALUE) then {\n            _ingressDirection = _playerDirection;\n        };\n        private _dropPosition = call KISKA_fnc_supports_getCommonTargetPosition;\n        private _argsMapInit = [\n            [\"dropPosition\",_dropPosition],\n            [\"dropAltitude\",_dropAltitude],\n            [\"directionOfAircraft\",_ingressDirection],\n            [\"side\",side player]\n        ];\n        \n        _thisArgs params [\"_supportId\",\"_commMenuDetailsConfig\"];\n        \n        [\n            \"aircraftClass\",\n            \"spawnDistance\",\n            \"objectClassNames\",\n            \"dropPositionRadius\",\n            \"parachuteClass\",\n            \"dropZVelocity\",\n            \"velocityUpdateFrequency\",\n            \"distanceToStopVelocityUpdates\",\n            [\"allowDamage\",true],\n            [\"addArsenals\",true],\n            [\"clearCargo\",true]\n        ] apply {\n            _x params [\"_paramName\",[\"_isBool\",false]];\n            private _value = [_commMenuDetailsConfig >> _paramName,_isBool] call KISKA_fnc_getConfigData;\n            [[_commMenuDetailsConfig,\" \",_paramName,\" \",_value]] call KISKA_fnc_log;\n            if (isNil \"_value\") then { continue };\n            _argsMapInit pushBack [_paramName,_value];\n        };\n\n        [\n            _supportId,\n            _dropPosition,\n            1,\n            createHashMapFromArray _argsMapInit\n        ] call KISKA_fnc_supports_call;\n    }],\n    {},\n    [[_draw3dMarker],{\n        _thisArgs params [\"_draw3dMarker\"];\n        if !(_draw3dMarker) exitWith {};\n        \n        call KISKA_fnc_drawLookingAtMarker_stop \n    }]\n] spawn KISKA_fnc_openCommandingMenuPath;",
    "fileName": "fn_commMenu_openSupplyDrop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_openSupplyDrop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commMenu_refresh\n\nDescription:\n    Redefines the global `BIS_fnc_addCommMenuItem_menu` array with all the player's\n    current comm menu supports.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_commMenu_refresh;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commMenu_refresh\";\n\nprivate _selectionMenu = [\n    [localize \"STR_rscMenu.hppRscGroupRootMenu_Items_Communication0\",true]\n];\nprivate _playerMenu = [];\n\nprivate _idToDetailsMap = [\n    localNamespace,\n    \"KISKA_commMenu_supportIdToDetailsMap\",\n    {createHashMap}\n] call KISKA_fnc_getOrDefaultSet;\n{\n    _y params [\n        \"\",\n        \"_text\",\n        \"_submenu\",\n        \"_commMenuExpression\",\n        \"_enableExpression\",\n        \"_cursor\",\n        \"_icon\",\n        \"_iconText\"\n    ];\n    private _keyboardShortcutKey = _foreachindex + 2;\n    _selectionMenu pushBack [_text,[_keyboardShortcutKey],_submenu,-5,[[\"expression\",_commMenuExpression]],\"1\",_enableExpression,_cursor];\n    _playerMenu pushBack [\n        _forEachIndex,\n        _text,\n        _submenu,\n        _commMenuExpression,\n        _enableExpression,\n        _cursor,\n        _icon,\n        _iconText\n    ];\n} foreach _idToDetailsMap;\n\nmissionnamespace setvariable [\"BIS_fnc_addCommMenuItem_menu\", _selectionMenu];\n// used in \\A3\\Ui_f\\scripts\\IGUI\\RscCommMenuItems.sqf\nplayer setvariable [\"BIS_fnc_addCommMenuItem_menu\",_playerMenu];\n(\"BIS_fnc_addCommMenuItem\" call bis_fnc_rscLayer) cutrsc [\"RscCommMenuItems\",\"plain\"];\n\n\nnil\n",
    "fileName": "fn_commMenu_refresh.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Command Menu Support Caller/fn_commMenu_refresh.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_add\n\nDescription:\n    Adds a support to the local player's support KISKA support pool.\n\nParameters:\n    0: _supportConfig <CONFIG | STRING> - Config entry of the support. If a string,\n        the config is expected to be located under a `\"KISKA_Supports\"` config\n        (e.g. `missionConfigFile >> \"KISKA_Supports\" >> \"MySupport\"`) and will\n        be found with `KISKA_fnc_findConfigAny`.\n    1: _numberOfUsesLeft <NUMBER> - Default: `-1` - The number of support uses left \n        or rounds available to use. If less than 0, the configed value will be used.\n\nReturns:\n    <STRING> - The supports id\n\nExamples:\n    (begin example)\n        [\n            \"MySupport\" // MySupport class is defined in \"KISKA_Supports\"\n        ] call KISKA_fnc_supports_add;\n    (end)\n\n    (begin example)\n        private _supportId = [\n            missionConfigFile >> \"CustomSupports >> \"MySupport\",\n            20\n        ] call KISKA_fnc_supports_add;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_add\";\n\nparams [\n    [\"_supportConfig\",configNull,[configNull,\"\"]],\n    [\"_numberOfUsesLeft\",-1,[123]]\n];\n\nprivate _maxAllowedSupports = missionNamespace getVariable [\"KISKA_CBA_supportManager_maxSupports\",10];\nprivate _supportMap = call KISKA_fnc_supports_getMap;\nif ((count _supportMap) >= _maxAllowedSupports) exitWith {\n    [[\"player already has the max number of supports ->\",_maxAllowedSupports],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_supportConfig isEqualType \"\") then {\n    _supportConfig = [[\"KISKA_Supports\",_supportConfig]] call KISKA_fnc_findConfigAny;\n};\nif (isNull _supportConfig) exitWith {\n    [\"Could not find _supportConfig\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _supportDetailsConfig = _supportConfig >> \"KISKA_supportDetails\";\nif (_numberOfUsesLeft < 0) then {\n    private _useCountConfig = _supportDetailsConfig >> \"numberOfUses\";\n    if (isNumber _useCountConfig) exitWith { _numberOfUsesLeft = getNumber(_useCountConfig); };\n    \n    _numberOfUsesLeft = 1;\n};\nif (_numberOfUsesLeft isEqualTo 0) exitWith {\n    [\n        [\n            \"Trying to add a support with zero uses left -> \",\n            _supportConfig\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _id = [\"KISKA_support\"] call KISKA_fnc_generateUniqueId;\nprivate _onSupportAddedMap = [\n    localNamespace,\n    \"KISKA_supports_onSupportAddedMap\",\n    {createHashMap}\n] call KISKA_fnc_getOrDefaultSet;\n\nprivate _onSupportAddedCompiled = _onSupportAddedMap get _supportConfig;\nif (isNil \"_onSupportAddedCompiled\") then {\n    private _onSupportAdded = getText(_supportDetailsConfig >> \"onSupportAdded\");\n    _onSupportAddedCompiled = compileFinal _onSupportAdded;\n    _onSupportAddedMap set [_supportConfig,_onSupportAddedCompiled];\n};\n\nif (_onSupportAddedCompiled isNotEqualTo {}) then {\n    [_id,_supportConfig,_numberOfUsesLeft] call _onSupportAddedCompiled;\n};\n\n_supportMap set [_id, [_supportConfig,_numberOfUsesLeft]];\n\nprivate _notificationClass = _supportDetailsConfig >> \"AddedNotifcation\";\nif (isClass _notificationClass) then {\n    [_notificationClass] call KISKA_fnc_showNotification;\n};\n\n_id\n",
    "fileName": "fn_supports_add.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_add.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_call\n\nDescription:\n    Triggers a given support's on call event by it's ID and will decrement its \n    number of uses left and remove it if the remaining uses is less than or equal\n    to 0.\n\nParameters:\n    0: _supportId <STRING> - The ID of the support to use.\n    1: _targetPosition <PositionASL[]> - The position for the support to target.\n    2: _numberOfTimesUsed <NUMBER> - Default: `1` - The number of times the support\n        uses are to be decremented. A value below zero will be interpreted as zero.\n    3: _onCallArgs <ANY> - Default: `[]` - Any additional arguments to provide to the\n        support's configured `onSupportCalled` event. \n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // marked as using one time\n        [\"KISKA_support_1\",[0,0,0]] call KISKA_fnc_supports_call;\n    (end)\n\n    (begin example)\n        [\n            \"KISKA_support_1\",\n            getPosASL MyTarget,\n            1,\n            [\"some_additional_args\"] // additional onSupportCalled event args\n        ] call KISKA_fnc_supports_call;\n    (end)\n\n    (begin example)\n        // infinite uses\n        [\"KISKA_support_1\",[0,0,0],0] call KISKA_fnc_supports_call;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_call\";\n\nparams [\n    [\"_supportId\",\"\",[\"\"]],\n    [\"_targetPosition\",[],[[]],3],\n    [\"_numberOfTimesUsed\",1,[123]],\n    [\"_onCallArgs\",[],[]]\n];\n\nprivate _supportMap = call KISKA_fnc_supports_getMap;\nprivate _supportInfo = _supportMap get _supportId;\nif (isNil \"_supportInfo\") exitWith {\n    [\n        [\n            \"Support id \",\n            _supportId,\n            \" does not exist in kiska support map\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (_numberOfTimesUsed < 0) then { _numberOfTimesUsed = 0 };\n\n_supportInfo params [\"_supportConfig\",\"_numberOfUsesLeft\"];\n\nif (_numberOfUsesLeft < _numberOfTimesUsed) exitWith {\n    [\n        [\n            \"Support id \",\n            _supportId,\n            \" has only \",\n            _numberOfUsesLeft,\n            \" but was used \",\n            _numberOfTimesUsed,\n            \" times\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nprivate _onCalledMap = [\n    localNamespace,\n    \"KISKA_supports_onSupportCalledMap\",\n    {createHashMap}\n] call KISKA_fnc_getOrDefaultSet;\nprivate _onSupportCalledCompiled = _onCalledMap get _supportConfig;\nif (isNil \"_onSupportCalledCompiled\") then {\n    private _onSupportCalled = getText(_supportConfig >> \"KISKA_supportDetails\" >> \"onSupportCalled\");\n    _onSupportCalledCompiled = compileFinal _onSupportCalled;\n    _onCalledMap set [_supportConfig,_onSupportCalledCompiled];\n};\n\nprivate _successfullyCalled = [\n    _onSupportCalledCompiled,\n    [\n        _onCallArgs,\n        _supportId,\n        _supportConfig,\n        _targetPosition,\n        _numberOfTimesUsed\n    ]\n] call CBA_fnc_directCall;\nif (!_successfullyCalled) exitWith {\n    [[_supportId,\" was not successfully called.\"], false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _notificationClass = _supportDetailsConfig >> \"CalledNotifcation\";\nif (isClass _notificationClass) then {\n    private _genericNotification = [_notificationClass >> \"genericMessageId\"] call KISKA_fnc_getConfigData;\n    if !(isNil \"_genericNotification\") then {\n        [_genericNotification] call KISKA_fnc_supports_genericNotification;\n    };\n};\n\n_numberOfUsesLeft = _numberOfUsesLeft - _numberOfTimesUsed;\nif (_numberOfUsesLeft <= 0) exitWith {\n    [_supportId] call KISKA_fnc_supports_remove;\n    nil\n};\n\n_supportMap set [_supportId,[_supportConfig,_numberOfUsesLeft]];\n\n\nnil\n",
    "fileName": "fn_supports_call.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_call.sqf"
  },
  {
    "text": "#include \"..\\..\\..\\Headers\\Support Framework\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_genericNotification\n\nDescription:\n    Gives the player a sound or text notification that they called in a support\n     from the KISKA systems. Just used for feedback to know a call was placed.\n\n    Players can adjust the notifcation settings in the CBA addon menu.\n\nParameters:\n    0: _supportTypeId <NUMBER> - The support type that was called\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_supports_genericNotification;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_genericNotification\";\n\n#define NONE 0\n#define RADIO_ONLY 1\n#define TEXT_ONLY 2\n#define BOTH 3\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_supportTypeId\",0,[123]]\n];\n\n\nprivate _notificationSpecifics = switch (_supportTypeId) do\n{\n    case SUPPORT_TYPE_ARTY: { [\"KISKA_CBA_suppNotif_arty\",\"artillery\"] };\n    case SUPPORT_TYPE_CAS: { [\"KISKA_CBA_suppNotif_cas\",\"cas request\"] };\n    case SUPPORT_TYPE_HELI_CAS;\n    case SUPPORT_TYPE_ATTACKHELI_CAS: { [\"KISKA_CBA_suppNotif_heliCas\",\"cas request\"] };\n    case SUPPORT_TYPE_SUPPLY_DROP_AIRCRAFT;\n    case SUPPORT_TYPE_ARSENAL_DROP: { [\"KISKA_CBA_suppNotif_supplyDrop\",\"supply drop requested\"] };\n    case SUPPORT_TYPE_SUPPLY_DROP: { [\"KISKA_CBA_suppNotif_supplyDrop\",\"supply drop\"] };\n    default { \n        [[\"_supportTypeId \",_supportTypeId,\" is not valid\"],true] call KISKA_fnc_log;\n        []\n    };\n};\nif (_notificationSpecifics isEqualTo []) exitWith {};\n\n\n_notificationSpecifics params [\"_notificationSettingVariable\",\"_radioMessagetype\"];\nprivate _notificationSetting = missionNamespace getVariable [_notificationSettingVariable,0];\n\nif (_notificationSetting isEqualTo NONE) exitWith {};\n\nif (_notificationSetting isEqualTo RADIO_ONLY) exitWith {\n    [_radioMessagetype,player,side player] call KISKA_fnc_supports_genericRadioMessage;\n};\n\nif (_notificationSetting isEqualTo TEXT_ONLY) exitWith {\n    [\"Support Request Received\",5] call KISKA_fnc_notification;\n};\n\nif (_notificationSetting isEqualTo BOTH) exitWith {\n    [_radioMessagetype,player,side player] call KISKA_fnc_supports_genericRadioMessage;\n    [\"Support Request Received\",5] call KISKA_fnc_notification;\n};\n\n\nnil\n",
    "fileName": "fn_supports_genericNotification.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_genericNotification.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_genericRadioMessage\n\nDescription:\n    Decides what radio message to play to provided targets.\n\nParameters:\n    0: _messageType <STRING> - The type of radio message to send. An invalid \n        type will result in a default message being played.\n        \n        Valid Options:\n        - \"artillery\"\n        - \"strike\"\n        - \"supply drop\"\n        - \"supply drop requested\"\n        - \"cas request\"\n        - \"cas abort\"\n        - \"uav request\"\n        - \"helo down\"\n        - \"transport request\"\n\n    1: _caller <OBJECT> - Default: `player` - The person sending the call\n    2: _targets <NUMBER, OBJECT, STRING, GROUP, SIDE, ARRAY> - Default: `clientOwner` - \n        The remoteExec targets for the radio call.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"artillery\"] call KISKA_fnc_supports_genericRadioMessage;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_genericRadioMessage\";\n\nparams [\n    [\"_messageType\",\"\",[\"\"]],\n    [\"_caller\",player,[objNull]],\n    [\"_targets\",clientOwner,[123,objNull,\"\",BLUFOR,grpNull,[]]]\n];\n\nprivate _possibleMessages = switch (toLowerANSI _messageType) do\n{\n    case \"artillery\": {\n        [\n            \"mp_groundsupport_45_artillery_BHQ_0\",\n            \"mp_groundsupport_45_artillery_BHQ_1\",\n            \"mp_groundsupport_45_artillery_BHQ_2\",\n            \"mp_groundsupport_45_artillery_IHQ_0\",\n            \"mp_groundsupport_45_artillery_IHQ_1\",\n            \"mp_groundsupport_45_artillery_IHQ_2\"\n        ]\n    };\n    case \"strike\": { \n        [\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_0\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_1\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_2\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_3\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_4\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_0\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_1\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_2\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_3\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_4\"\n        ]  \n    };\n    case \"supply drop\": {\n        [\n            \"mp_groundsupport_10_slingloadsucceeded_BHQ_0\",\n            \"mp_groundsupport_10_slingloadsucceeded_BHQ_1\",\n            \"mp_groundsupport_10_slingloadsucceeded_BHQ_2\",\n            \"mp_groundsupport_10_slingloadsucceeded_IHQ_0\",\n            \"mp_groundsupport_10_slingloadsucceeded_IHQ_1\",\n            \"mp_groundsupport_10_slingloadsucceeded_IHQ_2\"\n        ]\n    };\n    case \"supply drop requested\": {\n        [\n            \"mp_groundsupport_01_slingloadrequested_BHQ_0\",\n            \"mp_groundsupport_01_slingloadrequested_BHQ_1\",\n            \"mp_groundsupport_01_slingloadrequested_BHQ_2\",\n            \"mp_groundsupport_01_slingloadrequested_IHQ_0\",\n            \"mp_groundsupport_01_slingloadrequested_IHQ_1\",\n            \"mp_groundsupport_01_slingloadrequested_IHQ_2\"\n        ]\n    };\n    case \"cas request\": {\n        [\n            \"mp_groundsupport_01_casrequested_BHQ_0\",\n            \"mp_groundsupport_01_casrequested_BHQ_1\",\n            \"mp_groundsupport_01_casrequested_BHQ_2\",\n            \"mp_groundsupport_01_casrequested_IHQ_0\",\n            \"mp_groundsupport_01_casrequested_IHQ_1\",\n            \"mp_groundsupport_01_casrequested_IHQ_2\",\n            \"mp_groundsupport_50_cas_BHQ_0\",\n            \"mp_groundsupport_50_cas_BHQ_1\",\n            \"mp_groundsupport_50_cas_BHQ_2\",\n            \"mp_groundsupport_50_cas_IHQ_0\",\n            \"mp_groundsupport_50_cas_IHQ_1\",\n            \"mp_groundsupport_50_cas_IHQ_2\"\n        ]\n    };\n    case \"cas abort\": {\n        [\n            \"mp_groundsupport_05_casaborted_BHQ_0\",\n            \"mp_groundsupport_05_casaborted_BHQ_1\",\n            \"mp_groundsupport_05_casaborted_BHQ_2\",\n            \"mp_groundsupport_05_casaborted_IHQ_0\",\n            \"mp_groundsupport_05_casaborted_IHQ_1\",\n            \"mp_groundsupport_05_casaborted_IHQ_2\"\n        ]\n    };\n    case \"uav request\": {\n        [\n            \"mp_groundsupport_60_uav_BHQ_0\",\n            \"mp_groundsupport_60_uav_BHQ_1\",\n            \"mp_groundsupport_60_uav_BHQ_2\",\n            \"mp_groundsupport_60_uav_IHQ_0\",\n            \"mp_groundsupport_60_uav_IHQ_1\",\n            \"mp_groundsupport_60_uav_IHQ_2\"\n        ]\n    };\n    case \"helo down\": {\n        [\n            \"mp_groundsupport_65_chopperdown_BHQ_0\",\n            \"mp_groundsupport_65_chopperdown_BHQ_1\",\n            \"mp_groundsupport_65_chopperdown_BHQ_2\",\n            \"mp_groundsupport_65_chopperdown_IHQ_0\",\n            \"mp_groundsupport_65_chopperdown_IHQ_1\",\n            \"mp_groundsupport_65_chopperdown_IHQ_2\"\n        ]\n    };\n    case \"transport request\": {\n        [\n            \"mp_groundsupport_01_transportrequested_BHQ_0\",\n            \"mp_groundsupport_01_transportrequested_BHQ_1\",\n            \"mp_groundsupport_01_transportrequested_BHQ_2\",\n            \"mp_groundsupport_01_transportrequested_IHQ_0\",\n            \"mp_groundsupport_01_transportrequested_IHQ_1\",\n            \"mp_groundsupport_01_transportrequested_IHQ_2\"\n        ]\n    };\n    default { \n        [[\"Unrecognized _messageType \",_messageType],true] call KISKA_fnc_log;\n        [\"mp_groundsupport_70_tacticalstrikeinbound_BHQ_0\"]\n    };\n};\n\n\nprivate _message = selectRandom _possibleMessages;\nif (_targets isEqualTo clientOwner) exitWith {\n    _caller globalRadio _message\n};\n\n[_caller,_message] remoteExecCall [\"globalRadio\",_targets];\n\n\nnil\n",
    "fileName": "fn_supports_genericRadioMessage.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_genericRadioMessage.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_getCommonTargetPosition\n\nDescription:\n    Retrieves either the position the player is currently looking at or if the \n    map is open, their cursor position.\n\nParameters:\n    NONE\n\nReturns:\n    <PositionASL[]> - The common target point.\n\nExamples:\n    (begin example)\n        private _positionToTarget = call KISKA_fnc_supports_getCommonTargetPosition;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_getCommonTargetPosition\";\n\nif (visibleMap) exitWith { call KISKA_fnc_getMapCursorPosition };\n\ncall KISKA_fnc_getPositionPlayerLookingAt\n",
    "fileName": "fn_supports_getCommonTargetPosition.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_getCommonTargetPosition.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_getMap\n\nDescription:\n    Retrieves the hashmap that contains a players current supports.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - The hashmap containing information about the player's supports.\n\nExamples:\n    (begin example)\n        private _supportMap = call KISKA_fnc_supports_getMap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_getMap\";\n\nprivate _map = localNamespace getVariable \"KISKA_supports_playerMap\";\nif !(isNil \"_map\") exitWith { _map };\n\n_map = createHashMap;\nlocalNamespace setVariable [\"KISKA_supports_playerMap\",_map];\n\n\n_map\n",
    "fileName": "fn_supports_getMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_getMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_getNumberOfUsesLeft\n\nDescription:\n    Gets the specific number of uses left for a given support by its ID\n\nParameters:\n    0: _supportId <STRING> - The ID of the support to check.\n\nReturns:\n    <NUMBER | NIL> - the number of support uses left or `nil` if the support ID is not found\n\nExamples:\n    (begin example)\n        private _numberLeft = [\"KISKA_support_1\"] call KISKA_fnc_supports_getNumberOfUsesLeft;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_getNumberOfUsesLeft\";\n\nparams [\n    [\"_supportId\",\"\",[\"\"]]\n];\n\nprivate _supportMap = call KISKA_fnc_supports_getMap;\nprivate _supportInfo = _supportMap get _supportId;\nif (isNil \"_supportInfo\") exitWith { nil };\n_supportInfo params [\"\",\"_numberOfUsesLeft\"];\n\n\n_numberOfUsesLeft\n",
    "fileName": "fn_supports_getNumberOfUsesLeft.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_getNumberOfUsesLeft.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_remove\n\nDescription:\n    Removes a support from the local player's support KISKA support pool.\n\n    Also calls the supports configured `onSupportRemoved` event.\n\nParameters:\n    0: _supportId <STRING> - The ID of the support to remove.\n\nReturns:\n    <[CONFIG,NUMBER]> - The support config and the number of uses left.\n\nExamples:\n    (begin example)\n        [\"KISKA_support_1\"] call KISKA_fnc_supports_remove;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_remove\";\n\nparams [\n    [\"_supportId\",\"\",[\"\"]]\n];\n\nprivate _supportMap = call KISKA_fnc_supports_getMap;\nprivate _supportInfo = _supportMap get _supportId;\nif (isNil \"_supportInfo\") exitWith {\n    [\n        [\n            \"Support id \",\n            _supportId,\n            \" does not exist in kiska support map\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\n_supportInfo params [\"_supportConfig\"];\nprivate _onSupportRemovedMap = [\n    localNamespace,\n    \"KISKA_supports_onSupportRemovedMap\",\n    {createHashMap}\n] call KISKA_fnc_getOrDefaultSet;\nprivate _onSupportRemovedCompiled = _onSupportRemovedMap get _supportConfig;\nif (isNil \"_onSupportRemovedCompiled\") then {\n    private _onSupportRemoved = getText(_supportConfig >> \"KISKA_supportDetails\" >> \"onSupportRemoved\");\n    _onSupportRemovedCompiled = compileFinal _onSupportRemoved;\n    _onSupportRemovedMap set [_supportConfig,_onSupportRemovedCompiled];\n};\n\n[\n    _onSupportRemovedCompiled,\n    [_supportId,_supportConfig]\n] call CBA_fnc_directCall;\n\n_supportMap deleteAt _supportId\n",
    "fileName": "fn_supports_remove.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Common/fn_supports_remove.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_onCalledCloseAirSupport\n\nDescription:\n    The standard translator to handle a close air support configured support's\n     `onSupportCalled` event that is triggered by `KISKA_fnc_supports_call`.\n     This standard handler then translates that to and actual call of\n     `KISKA_fnc_closeAirSupport`.\n\nParameters:\n    0: _onCallArgs <[HASHMAP,ARRAY]> - An array of the aircraft params map\n        and the fire orders to give to the aircraft. See `KISKA_fnc_closeAirSupport`\n        for more details.\n\nReturns:\n    <BOOL>\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_onCalledCloseAirSupport\";\n\nparams [\n    [\"_onCallArgs\",[],[[]],2]\n];\n\n_onCallArgs call KISKA_fnc_closeAirSupport;\n\n\ntrue\n",
    "fileName": "fn_supports_onCalledCloseAirSupport.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Standard Support Events/fn_supports_onCalledCloseAirSupport.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_onCalledHelicopterGunner\n\nDescription:\n    The standard translator to handle a helicopter gunner configured support's\n     `onSupportCalled` event that is triggered by `KISKA_fnc_supports_call`.\n     This standard handler then translates that to and actual call of\n     `KISKA_fnc_helicopterGunner`.\n\nParameters:\n    0: _onCallArgs <ARRAY> - An array of parameters to pass to `KISKA_fnc_helicopterGunner`\n\nReturns:\n    <BOOL>\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_onCalledHelicopterGunner\";\n\nparams [\n    [\"_onCallArgs\",[],[[]]]\n];\n\n_onCallArgs call KISKA_fnc_helicopterGunner;\n\n\ntrue",
    "fileName": "fn_supports_onCalledHelicopterGunner.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Standard Support Events/fn_supports_onCalledHelicopterGunner.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_onCalledSupplyDrop\n\nDescription:\n    The standard translator to handle a supply drop configured support's\n     `onSupportCalled` event that is triggered by `KISKA_fnc_supports_call`.\n    \n    This standard handler then translates that to and actual call of\n     `KISKA_fnc_supplyDrop` or `KISKA_fnc_supplyDropWithAircraft` depending\n     on whether the `_argsMap` contains an `aircraftClass` key.\n\nParameters:\n    0: _argsMap <HASHMAP> - The hashmap of args to provide to the supply drop function.\n\nReturns:\n    <BOOL>\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_onCalledSupplyDrop\";\n\nparams [\n    [\"_argsMap\",nil,[createHashMap]]\n];\n\nif (\"aircraftClass\" in _argsMap) then {\n    [_argsMap] call KISKA_fnc_supplyDropWithAircraft;\n} else {\n    [_argsMap] call KISKA_fnc_supplyDrop;\n};\n\n\ntrue\n",
    "fileName": "fn_supports_onCalledSupplyDrop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Standard Support Events/fn_supports_onCalledSupplyDrop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supports_onCalledVirtualArty\n\nDescription:\n    The standard translator to handle a virtual artillery configured support's\n     `onSupportCalled` event that is triggered by `KISKA_fnc_supports_call`.\n     This standard handler then translates that to and actual call of\n     `KISKA_fnc_virtualArty`.\n\nParameters:\n    0: _onCallArgs <[STRING,NUMBER]> - An array in the shape of `[ammo class, radius of fire]`.\n    1: _supportId <STRING> - The ID of the specific support.\n    2: _supportConfig <CONFIG> - The support's config path.\n    3: _targetPosition <PositionASL[]> - The position to target.\n    4: _numberOfRoundsToFire <NUMBER> - How many rounds to fire\n\nReturns:\n    <BOOL>\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supports_onCalledVirtualArty\";\n\nparams [\n    [\"_onCallArgs\",[],[[]],2],\n    \"\",\n    \"\",\n    [\"_targetPosition\",[],[[]],3],\n    [\"_numberOfRoundsToFire\",0,[123]]\n];\n\n_onCallArgs params [\n    [\"_ammoType\",\"\",[\"\"]],\n    [\"_radiusOfFire\",25,[123]]\n];\n\n[\n    _targetPosition,\n    _ammoType,\n    _radiusOfFire,\n    _numberOfRoundsToFire\n] spawn KISKA_fnc_virtualArty;\n\n\ntrue\n",
    "fileName": "fn_supports_onCalledVirtualArty.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Support Framework/Standard Support Events/fn_supports_onCalledVirtualArty.sqf"
  },
  {
    "text": "#include \"..\\..\\Headers\\Support Framework\\CAS Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_CAS\n\nDescription:\n    Completes either a gun run, bomb run, rockets, or rocket and gun strike.\n\nParameters:\n    0: _attackPosition : <OBJECT or PositionASL[]> - ASL position or object to attack\n    1: _attackTypeID : <NUMBER or ARRAY> - See CAS Type IDs.hpp .\n        If an array, format needs to be [attackTypeId,pylonMagazineClass].\n        Custom mag classes, when used for napalm or UGB ids, will drop the ENTIRE payload\n         of that mag. e.g. mag class \"vn_bomb_f4_out_500_blu1b_fb_mag_x1\" is 1 bomb dropped,\n         \"vn_bomb_f4_out_500_blu1b_fb_mag_x4\" will be 4 dropped\n    2: _attackDirection : <NUMBER> - The direction the aircraft should approach from relative to North\n    3: _planeClass : <STRING> - The className of the aircraft\n    4: _side : <SIDE> - The side of the plane\n    5: _spawnHeight : <NUMBER> - At what height should the aircraft start firing\n    6: _spawnDistance : <NUMBER> - How far away to spawn the aircraft\n    7: _breakOffDistance : <NUMBER> - The distance to target at which the aircraft should definately disengage and fly away (to not crash)\n    8: _attackPositionOffset : <NUMBER> - This will offset the _attackPosition in meters and in the direction of the attack.\n        So for instance, if I wanted a gun run to be aimed 20m further in the _attackDirection from the _attackPosition, I'd\n         set this to 20\n    9: _attackDistance : <NUMBER> - The distance to target at which the aircraft can start completeing its attack\n    10: _allowDamage : <BOOL> - Allow damage of both the crew and aircraft\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myTarget] call KISKA_fnc_CAS;\n    (end)\n\nAuthor(s):\n    Bohemia Interactive,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_CAS\";\n\n#define DEFAULT_CANNON_CLASS \"Twin_Cannon_20mm\"\n#define DEFAULT_CANNON_MAG_CLASS \"PylonWeapon_300Rnd_20mm_shells\"\n\n#define DEFAULT_AIRCRAFT \"B_Plane_CAS_01_dynamicLoadout_F\"\n\n#define PLANE_SPEED 75// m/s\n#define PLANE_VELOCITY(THE_SPEED) [0,THE_SPEED,0]\n\n#define CUSTOM_OR_DEFAULT_MAG(defaultClass) [_customMagClass,defaultClass] select (_customMagClass isEqualTo \"\")\n\n#define STRAFE_INCREMENT 0.1\n#define FLARE_COUNT 4\n#define TIME_TILL_DELETE 64\n\nparams [\n    [\"_attackPosition\",objNull,[[],objNull]],\n    [\"_attackTypeID\",0,[123,[]]],\n    [\"_attackDirection\",0,[123]],\n    [\"_planeClass\",DEFAULT_AIRCRAFT,[\"\"]],\n    [\"_side\",BLUFOR,[sideUnknown]],\n    [\"_spawnHeight\",1300,[123]],\n    [\"_spawnDistance\",2000,[123]],\n    [\"_breakOffDistance\",500,[123]],\n    [\"_attackPositionOffset\",0,[123]],\n    [\"_attackDistance\",1200,[123]],\n    [\"_allowDamage\",false,[true]]\n];\n\n\nif (\n\t(_attackPosition isEqualType objNull) AND \n\t{isNull _attackPosition} OR \n\t{_attackPosition isEqualTo []}\n) exitWith {\n    [[_attackPosition,\" is an invalid target\"],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _planeCfg = configfile >> \"cfgvehicles\" >> _planeClass;\nif !(isclass _planeCfg) exitwith {\n    [[_planeClass,\" Vehicle class not found, moving to default aircraft...\"],true] call KISKA_fnc_log;\n    _this set [3,DEFAULT_AIRCRAFT];\n    _this call KISKA_fnc_CAS;\n};\n\n\n/* ----------------------------------------------------------------------------\n    select weapons to use\n---------------------------------------------------------------------------- */\nprivate _attackMagazines = [];\nprivate _customMagClass = \"\";\n\nif (_attackTypeID isEqualType []) then {\n    _customMagClass = _attackTypeID select 1;\n    _attackTypeID = _attackTypeID select 0;\n};\n\n_attackMagazines = switch _attackTypeID do {\n    case GUN_RUN_ID: {\n        [CANNON_TYPE]\n    };\n    case GUNS_AND_ROCKETS_ARMOR_PIERCING_ID: {\n        [\n\t\t\tCANNON_TYPE,\n\t\t\t[ROCKETS_AP_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_AP_F\")]\n\t\t]\n    };\n    case GUNS_AND_ROCKETS_HE_ID: {\n        [\n\t\t\tCANNON_TYPE,\n\t\t\t[ROCKETS_HE_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_HE_F\")]\n\t\t]\n    };\n    case ROCKETS_ARMOR_PIERCING_ID: {\n        [[ROCKETS_AP_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_AP_F\")]]\n    };\n    case ROCKETS_HE_ID: {\n        [[ROCKETS_HE_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_HE_F\")]]\n    };\n    case AGM_ID: {\n        [[AGM_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_1Rnd_Missile_AGM_02_F\")]]\n    };\n    case BOMB_LGB_ID: {\n        [[BOMB_LGB_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonMissile_1Rnd_Bomb_04_F\")]]\n    };\n    case BOMB_CLUSTER_ID: {\n        [[BOMB_UGB_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonMissile_1Rnd_BombCluster_01_F\")]]\n    };\n    case BOMB_NAPALM_ID: {\n        [[BOMB_UGB_TYPE, CUSTOM_OR_DEFAULT_MAG(\"vn_bomb_f4_out_500_blu1b_fb_mag_x1\")]]\n    };\n};\n\n\nprivate _exitToDefault = false;\n\n\n////// Verify the plane has the right weapons for what is asked of it and adjust if it doesn't //////\nprivate _weaponsToUse = [];\nprivate _planeClassWeapons = _planeClass call BIS_fnc_weaponsEntityType;\nprivate _pylonConfig = _planeCfg >> \"Components\" >> \"TransportPylonsComponent\" >> \"pylons\";\n\n// if the plane has pylons\nif (isClass _pylonConfig) then {\n\n    private _allVehiclePylons = (\"true\" configClasses _pylonConfig) apply {configName _x};\n\n    // some planes (Buzzard) have their cannon as a pylon, don't want to replace it if needed\n    if (CANNON_TYPE in _attackMagazines) then {\n\n        // find the cannon weapon in the planes default loadout\n        private _cannonIndex = _planeClassWeapons findIf {\n            [\n                (configFile >> \"cfgWeapons\" >> _x),\n                (configFile >> \"cfgWeapons\" >> \"cannonCore\")\n            ] call CBA_fnc_inheritsFrom;\n        };\n\n        private _cannonClass = \"\";\n        // if a cannon is found, use it, else add one\n        private _canonPylonData = [];\n        if (_cannonIndex != -1) then {\n            _cannonClass = _planeClassWeapons select _cannonIndex;\n\n            // if the cannon is on a pylon delete the pylon from the list so it's not changed\n            private _cannonPylonIndex = _allVehiclePylons findIf {\n                getText(_pylonConfig >> _x >> \"attachment\") == _cannonClass;\n            };\n            if (_cannonPylonIndex isNotEqualTo -1) then {\n                _allVehiclePylons deleteAt _cannonPylonIndex;\n            };\n\n        } else {\n            _cannonClass = DEFAULT_CANNON_CLASS;\n            _canonPylonData pushBack DEFAULT_CANNON_MAG_CLASS;\n            private _pylonToUse = _allVehiclePylons deleteAt 0; // set the first pylon as the cannon\n            _canonPylonData pushBack _pylonToUse;\n\n        };\n\n        _weaponsToUse pushBack [CANNON_TYPE,_cannonClass,_canonPylonData];\n        // remove cannon so we don't need to check it later\n        _attackMagazines deleteAt (_attackMagazines find CANNON_TYPE);\n\n    };\n\n    // if there was more then just the cannon in the _attackMagazines array\n    if (_attackMagazines isNotEqualTo []) then {\n        {\n\t\t\t_x params [\"_attackTypeString\",\"_attackMagazineClass\"];\n            private _attackWeaponClass = [\n\t\t\t\tconfigFile >> \"cfgMagazines\" >> _attackMagazineClass >> \"pylonWeapon\"\n\t\t\t] call BIS_fnc_getCfgData;\n\n            // pushBack string for attack type, the weapon used, the mag for adding a pylon, and what pylon to add it to\n\t\t\tprivate _nextPylon = _allVehiclePylons deleteAt 0;\n            _weaponsToUse pushBack [\n\t\t\t\t_attackTypeString,\n\t\t\t\t_attackWeaponClass,\n\t\t\t\t[_attackMagazineClass, _nextPylon]\n\t\t\t];\n        } forEach _attackMagazines;\n    };\n\n} else {\n    _exitToDefault = true;\n\n};\n\n\nif (_exitToDefault) exitwith {\n    [\n\t\t[\n\t\t\t\"Weapon types of \",\n\t\t\t_attackMagazines,\n\t\t\t\" for plane class: \",\n\t\t\t_planeClass,\n\t\t\t\" not entirely found, moving to default Aircraft...\"\n\t\t],\n\t\ttrue\n\t] call KISKA_fnc_log;\n\n    // exit to default aircraft type\n    _this set [3,DEFAULT_AIRCRAFT];\n    _this call KISKA_fnc_CAS;\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Position plane towards target\n---------------------------------------------------------------------------- */\n// angling the plane towards the target\nif (_attackPosition isEqualType objNull) then {\n    _attackPosition = getPosASL _attackPosition;\n};\nprivate _planeSpawnPosition = [\n    _attackPosition,\n    _spawnDistance,\n    _attackDirection + 180,\n    _spawnHeight\n] call KISKA_fnc_getPosRelativeASL;\nprivate _planeArray = [\n\t_planeSpawnPosition,\n\t_attackDirection,\n\t_planeClass,\n\t_side\n] call KISKA_fnc_spawnVehicle;\n_planeArray params [\"_plane\",\"_crew\",\"_planeGroup\"];\n[_planeGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\nif !(_allowDamage) then {\n    _plane allowDamage false;\n    _crew apply {\n        _x allowDamage false;\n    };\n};\n\n\n// update the planes pylons\n_weaponsToUse apply {\n    private _pylonData = _x select 2;\n    // the cannon may not have any pylon data and therefore _pylonData will be []\n    if !(_pylonData isEqualTo []) then {\n        (_x select 2) params [\"_magClass\",\"_pylon\"];\n        _plane setPylonLoadout [_pylon,_magClass,true];\n    };\n};\n\n\n\n_plane setPosASL _planeSpawnPosition;\n_plane setDir _attackDirection;\n_plane disableAi \"autotarget\";\n_plane setCombatMode \"blue\";\n\nif (_attackPositionOffset isNotEqualTo 0) then {\n    _attackPosition = AGLToASL(_attackPosition getPos [_attackPositionOffset,_attackDirection]);\n};\n\n\n\nprivate _planePositionASL = getPosASLVisual _plane;\nprivate _vectors = [_planePositionASL,_attackPosition] call KISKA_fnc_getVectorToTarget;\n_plane setVectorDirAndUp _vectors;\n_vectors params [\"_planeVectorDirTo\",\"_planeVectorUp\"];\n\n/* ----------------------------------------------------------------------------\n    Fix planes velocity towards the target\n---------------------------------------------------------------------------- */\n// get flight characteristics to steer the plane onto target\nprivate _vectorDistanceToTarget = _attackPosition vectorDistance _planePositionASL;\nprivate _flightTime = (_vectorDistanceToTarget - _breakOffDistance) / PLANE_SPEED;\nprivate _startTime = time;\nprivate _timeAfterFlight = time + _flightTime;\n\n[\n\t{\n\t\tparams [\"_args\",\"_id\"];\n\t\t_args params [\n\t\t\t\"_plane\",\n\t\t\t\"_originalAttackPosition\",\n\t\t\t\"_attackDirection\",\n\t\t\t\"_breakOffDistance\",\n\t\t\t\"_planeSpawnPosition\",\n\t\t\t\"_startTime\",\n\t\t\t\"_timeAfterFlight\",\n\t\t\t\"_planeSpawnPosition\",\n\t\t\t\"_planeArray\",\n\t\t\t\"_weaponsToUse\",\n\t\t\t\"_attackTypeID\",\n\t\t\t\"_planeVectorDirTo\",\n\t\t\t\"_planeVectorUp\",\n\t\t\t\"_side\",\n\t\t\t\"_attackDistance\",\n\t\t\t\"_spawnHeight\"\n\t\t];\n\n\t\tprivate _attackPosition = _plane getVariable [\"KISKA_CAS_attackPosition\",_originalAttackPosition];\n\t\tprivate _planePositionASL = getPosASLVisual _plane;\n\t\tprivate _vectorDistanceToTarget = _attackPosition vectorDistance _planePositionASL;\n\n\t\tif (\n\t\t\tisNull _plane OR\n\t\t\t{_plane getVariable [\"KISKA_CAS_completedFiring\",false]} OR\n\t\t\t{_vectorDistanceToTarget <= _breakOffDistance}\n\t\t)\n\t\texitWith {\n\t\t\t/* ----------------------------------------------------------------------------\n\t\t\t\tHandle After CAS complete\n\t\t\t---------------------------------------------------------------------------- */\n\t\t\t// telling the plane to ultimately fly past the target after we're done controlling it\n\t\t\t_plane move (_attackPosition getPos [5000,_attackDirection]);\n\n\t\t\t// after fire is complete\n\t\t\t_plane flyInHeight (_spawnHeight * 2);\n\n\t\t\t// pop flares\n\t\t\tprivate _pilot = currentPilot _plane;\n\t\t\tfor \"_i\" from 1 to FLARE_COUNT do {\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tparams [\"_pilot\"];\n\t\t\t\t\t\t_pilot forceweaponfire [\"CMFlareLauncher\",\"Burst\"];\n\t\t\t\t\t},\n\t\t\t\t\t[_pilot],\n\t\t\t\t\t_i\n\t\t\t\t] call CBA_fnc_waitAndExecute;\n\t\t\t};\n\n\t\t\t// give the plane some time to get out of audible distance before deletion\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tparams [\"_plane\",\"_crew\",\"_group\"];\n\n\t\t\t\t\t_crew apply {\n\t\t\t\t\t\tif (!isNull _x) then {\n\t\t\t\t\t\t\t_plane deleteVehicleCrew _x;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tif (alive _plane) then {\n\t\t\t\t\t\tdeleteVehicle _plane;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (!isNull _group) then {\n\t\t\t\t\t\tdeleteGroup _group;\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t_planeArray,\n\t\t\t\tTIME_TILL_DELETE\n\t\t\t] call CBA_fnc_waitAndExecute;\n\n\t\t\t[_id] call CBA_fnc_removePerFrameHandler;\n\t\t};\n\n\t\t//--- Set the plane approach vector\n\t\tprivate _interval = linearConversion [_startTime,_timeAfterFlight,time,0,1];\n\t\tprivate _velocity = (vectorNormalized (_attackPosition vectorDiff _planePositionASL)) vectorMultiply PLANE_SPEED;\n\t\t_plane setVelocityTransformation [\n\t\t\t_planeSpawnPosition, _attackPosition,\n\t\t\t_velocity, _velocity,\n\t\t\t_planeVectorDirTo, _planeVectorDirTo,\n\t\t\t_planeVectorUp, _planeVectorUp,\n\t\t\t_interval\n\t\t];\n\n\t\t// start firing\n\t\t// check if plane is from target and hasn't already started shooting\n\t\tif (_vectorDistanceToTarget > _attackDistance) exitWith {};\n\n\t\tif !(_plane getVariable [\"KISKA_CAS_startedFiring\",false]) then {\n\t\t\t_plane setVariable [\"KISKA_CAS_startedFiring\",true];\n\t\t\t// create a target to shoot at\n\t\t\tprivate _dummyTargetClass = [\"LaserTargetE\",\"LaserTargetW\"] select ((_side getfriend west) > 0.6);\n\t\t\tprivate _dummyTarget = createvehicle [_dummyTargetClass,[0,0,0],[],0,\"NONE\"];\n\t\t\t_plane setVariable [\"KISKA_CAS_dummyTarget\",_dummyTarget];\n\t\t\t_dummyTarget setPosASL _attackPosition;\n\t\t\tprivate _laserTarget = laserTarget _dummyTarget;\n\t\t\t_plane reveal _laserTarget;\n\t\t\t_plane dowatch _laserTarget;\n\t\t\t_plane dotarget _laserTarget;\n\n\t\t\t[\n\t\t\t\t_plane,\n\t\t\t\t_dummyTarget,\n\t\t\t\t_weaponsToUse,\n\t\t\t\t_attackTypeID,\n\t\t\t\t_attackPosition,\n\t\t\t\t_breakOffDistance\n\t\t\t] spawn KISKA_fnc_CASAttack;\n\n\t\t} else {\n\t\t\t// ensures strafing effect with the above setVelocityTransformation\n\t\t\tprivate _dummyTarget = _plane getVariable \"KISKA_CAS_dummyTarget\";\n\t\t\tprivate _nextAttackPostition = _dummyTarget getPos [STRAFE_INCREMENT,(getDirVisual _plane)];\n\t\t\t// did this here for readability\n\t\t\t_nextAttackPostition = AGLToASL _nextAttackPostition;\n\t\t\t\n\t\t\t_plane setVariable [\"KISKA_CAS_attackPosition\",_nextAttackPostition];\n\t\t\t_dummyTarget setPosASL _nextAttackPostition;\n\t\t};\n\n\t},\n\t0.01,\n\t[\n\t\t_plane,\n\t\t_attackPosition,\n\t\t_attackDirection,\n\t\t_breakOffDistance,\n\t\t_planeSpawnPosition,\n\t\t_startTime,\n\t\t_timeAfterFlight,\n\t\t_planeSpawnPosition,\n\t\t_planeArray,\n\t\t_weaponsToUse,\n\t\t_attackTypeID,\n\t\t_planeVectorDirTo,\n\t\t_planeVectorUp,\n\t\t_side,\n\t\t_attackDistance,\n\t\t_spawnHeight\n\t]\n] call CBA_fnc_addPerframeHandler;\n\n\nnil\n",
    "fileName": "fn_CAS.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_CAS.sqf"
  },
  {
    "text": "#include \"..\\..\\Headers\\Support Framework\\CAS Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_CASAttack\n\nDescription:\n    Fires off the various weapons of a CAS strike.\n\nParameters:\n    0: _plane : <OBJECT> -\n    1: _dummyTarget : <OBJECT> -\n    2: _weaponsToUse : <OBJECT> -\n    3: _attackTypeID : <NUMBER> -\n    4: _attackPosition : <ARRAY> -\n    5: _breakOffDistance : <NUMBER> -\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        Should not be called on its own but in KISKA_fnc_CAS\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_CASAttack\";\n\n#define FIRE_GUN_INTERVAL 0.03\n#define FIRE_ROCKET_INTERVAL 0.5\n#define FIRE_BOMB_INTERVAL 0.5\n#define GUIDE_WEAPON_INTERVAL 0.05\n\nparams [\n    \"_plane\",\n    \"_dummyTarget\",\n    \"_weaponsToUse\",\n    \"_attackTypeID\",\n    \"_attackPosition\",\n    \"_breakOffDistance\"\n];\n\n_plane setVariable [\"KISKA_CAS_guidedFireEvent\",{\n    params [\"_plane\",\"_projectile\"];\n\n    private _projectileStartPosASL = getPosASLVisual _projectile;\n    private _dummyTarget = _plane getVariable [\"KISKA_CAS_dummyTarget\",objNull];\n    private _attackPosition = getPosASLVisual _dummyTarget;\n    private _vectors = [_projectileStartPosASL,_attackPosition] call KISKA_fnc_getVectorToTarget;\n\n    private _speed = speed _projectile;\n    _projectile setVectorDirAndUp _vectors;\n    _projectile setVelocityModelSpace [0,_speed,0];\n\n    _vectors params [\"_vectorDir\",\"_vectorUp\"];\n    private _vectorDistanceToTarget = _attackPosition vectorDistance _projectileStartPosASL;\n    private _flightTime = _vectorDistanceToTarget / _speed;\n    private _startTime = time;\n    private _timeAfterFlight = time + _flightTime;\n\n    [\n        {\n            params [\"_args\",\"_id\"];\n\n            _args params [\n                \"_projectile\",\n                \"_projectileStartPosASL\",\n                \"_vectorDir\",\n                \"_vectorUp\",\n                \"_startTime\",\n                \"_timeAfterFlight\",\n                \"_attackPosition\"\n            ];\n\n            if (isNull _projectile) exitWith { \n                [_id] call CBA_fnc_removePerFrameHandler;\n            };\n\n            private _interval = linearConversion [_startTime,_timeAfterFlight,time,0,1];\n            private _velocity = velocity _projectile;\n            _projectile setVelocityTransformation [\n                _projectileStartPosASL, _attackPosition,\n                _velocity, _velocity,\n                _vectorDir,_vectorDir,\n                _vectorUp, _vectorUp,\n                _interval\n            ];\n        },\n        GUIDE_WEAPON_INTERVAL,\n        [\n            _projectile,\n            _projectileStartPosASL,\n            _vectorDir,\n            _vectorUp,\n            _startTime,\n            _timeAfterFlight,\n            _attackPosition\n        ]\n    ] call CBA_fnc_addPerFrameHandler;\n}];\n\n\n// CUP planes in particular have an issue with rocket fire not being accurate\n// This will guide projectiles to where they should go\n_plane addEventHandler [\"Fired\", {\n    params [\"_plane\", \"_weapon\", \"\", \"\", \"\", \"\", \"_projectile\"];\n\n    private _isGuidedWeapon = _weapon == (_plane getVariable \"KISKA_CAS_guidedWeapon\");\n    if (_isGuidedWeapon) then {\n        [\n            _plane getVariable [\"KISKA_CAS_guidedFireEvent\",{}],\n            [_plane, _projectile],\n            0.1  // allow the projectile to get some speed\n        ] call CBA_fnc_waitAndExecute;\n    };\n}];\n\n\nprivate _fn_generateQueuedFireItems = {\n    params [\n        [\"_numberOfRounds\",-1,[123]],\n        [\"_weaponType\",\"\",[\"\"]],\n        [\"_fireInterval\",0.5,[123]],\n        [\"_isGuided\",false,[false]]\n    ];\n\n    private _indexOfWeaponInfoForType = _weaponsToUse findIf {(_x select 0) == _weaponType};\n    private _weaponArray = _weaponsToUse select _indexOfWeaponInfoForType;\n    _weaponArray params [\"\",\"_weaponClass\",\"_pylonInfo\"];\n    private _weaponMagClass = _pylonInfo select 0;\n\n    if (_numberOfRounds < 1) then {\n        private _configedNumberOfRoundsInMag = getNumber(configFile >> \"CfgMagazines\" >> _weaponMagClass >> \"count\");\n        if (_configedNumberOfRoundsInMag isEqualTo 0) then {\n            _numberOfRounds = 1;\n        } else {\n            _numberOfRounds = _configedNumberOfRoundsInMag;\n        };\n    };\n\n    private _fireModes = getArray(configFile >> \"CfgWeapons\" >> _weaponClass >> \"modes\");\n    private _primaryFireMode = _fireModes param [0,\"\"];\n\n    private _fireWeaponArgs = [\n        _fireInterval, \n        [_weaponClass, _primaryFireMode, _isGuided]\n    ];\n    private _queuedFireItems = [];\n    for \"_i\" from 1 to _numberOfRounds do { _queuedFireItems pushBack _fireWeaponArgs };\n\n\n    _queuedFireItems\n};\n\n\nprivate \"_fireQueue\";\n// decide how to fire\nswitch (_attackTypeID) do {\n    case GUN_RUN_ID: {\n        _fireQueue = [200, CANNON_TYPE, FIRE_GUN_INTERVAL] call _fn_generateQueuedFireItems;\n    };\n    case GUNS_AND_ROCKETS_ARMOR_PIERCING_ID: {\n        _fireQueue = [100, CANNON_TYPE, FIRE_GUN_INTERVAL] call _fn_generateQueuedFireItems;\n        _fireQueue append ([6, ROCKETS_AP_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems);\n    };\n    case GUNS_AND_ROCKETS_HE_ID: {\n        _fireQueue = [100, CANNON_TYPE, FIRE_GUN_INTERVAL] call _fn_generateQueuedFireItems;\n        _fireQueue append ([6, ROCKETS_HE_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems);\n    };\n    case ROCKETS_ARMOR_PIERCING_ID: {\n        _fireQueue = [8, ROCKETS_AP_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems;\n    };\n    case ROCKETS_HE_ID: {\n        _fireQueue = [8, ROCKETS_HE_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems;\n    };\n    case AGM_ID: {\n        _fireQueue = [1, AGM_TYPE, 0, true] call _fn_generateQueuedFireItems;\n    };\n    case BOMB_LGB_ID: {\n        _fireQueue = [1, BOMB_LGB_TYPE, 0] call _fn_generateQueuedFireItems;\n    };\n    case BOMB_NAPALM_ID;\n    case BOMB_CLUSTER_ID: {\n        _fireQueue = [-1, BOMB_UGB_TYPE, FIRE_BOMB_INTERVAL] call _fn_generateQueuedFireItems;\n    };\n};\n\nprivate _fireIntervalTotal = 0;\nprivate _maxFireQueueIndex = (count _fireQueue) - 1;\nprivate _planeInfo = [\n    _plane,\n    _attackPosition,\n    _breakOffDistance,\n    _dummyTarget,\n    currentPilot _plane\n];\n\n_plane setVariable [\"KISKA_CAS_completedFiring\",false];\n\n\n{\n    _x params [\"_fireInterval\",\"_fireInfo\"];\n\n    private _isFinal = _forEachIndex isEqualTo _maxFireQueueIndex;\n    [\n        {\n            // split in two so that constant info (_planeInfo) can remain the same array \n            // and only the dynamic info (_fireInfo) will be new arrays for each fire\n            params [\n                [\"_planeInfo\",[],[[]],5],\n                [\"_fireInfo\",[],[[]],3],\n                [\"_isFinal\",false,[false]]\n            ];\n            \n            _planeInfo params [\n                [\"_plane\",objNull,[objNull]],\n                [\"_attackPosition\",[],[[]],3],\n                [\"_breakOffDistance\",1,[123]],\n                [\"_dummyTarget\",objNull,[objNull]],\n                [\"_pilot\",objNull,[objNull]]\n            ];\n            \n            if (_plane getVariable [\"KISKA_CAS_completedFiring\",true]) exitWith {};\n\n\n            _fireInfo params [\n                [\"_weaponClass\",\"\",[\"\"]],\n                [\"_primaryFireMode\",\"\",[\"\"]],\n                [\"_isGuided\",false,[false]]\n            ];\n\n            if (_isGuided) then {\n                _plane setVariable [\"KISKA_CAS_guidedWeapon\",_weaponClass];\n            };\n\n            // certain vehicles seem to not work with fireAtTarget on the cannon (\"vn_b_air_f4c_cas\" from CDLC SOGPF)\n            private _canFireAtTarget = _pilot fireAtTarget [_dummyTarget,_weaponClass];\n            if (!_canFireAtTarget) then {\n                _pilot forceWeaponFire [_weaponClass,_primaryFireMode];\n            };\n\n            if (_isFinal OR ((_plane distance _attackPosition) < _breakOffDistance)) exitWith {\n                _plane setVariable [\"KISKA_CAS_completedFiring\",true];\n            };\n        },\n        [_planeInfo, _fireInfo, _isFinal],\n        _fireIntervalTotal\n    ] call CBA_fnc_waitAndExecute;\n\n    _fireIntervalTotal = _fireIntervalTotal + _fireInterval;\n} forEach _fireQueue;\n\n\nnil\n",
    "fileName": "fn_CASAttack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_CASAttack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_closeAirSupport\n\nDescription:\n    A more detailed version of KISKA_fnc_CAS that allows the caller to specify\n     a number of parameters.\n\nParameters:\n    0: _aircraftParams : <HASHMAP> - A hashmap of various parameters that affect\n        ther aircraft.\n\n        - `aircraftClass`: <STRING> Default: `\"\"` - the class of aircraft to spawn.\n        - `side`: <SIDE> Default: `BLUFOR` - The side of the aircraft to spawn.\n        - `allowDamage`: <BOOLEAN> Default: `false` - Whether or not the aircraft and crew take damage.\n        - `attackPosition`: <PositionASL[] | OBJECT> Default: `objNull` - The primary position to fire at.\n        - `directionOfAttack`: <NUMBER> Default: `0` - The direction the aircraft will be facing during it's attack run.\n        - `fireDistance`: <NUMBER> Default: `initialDistanceToTarget` - The distance to the\n            target at which the aircraft will begin firing.\n        - `initialHeightAboveTarget`: <NUMBER> Default: `1300` - The aircraft's initial altitude.\n        - `initialDistanceToTarget`: <NUMBER> Default: `2000` - The distance from the `_attackPosition` the aircraft will spawn.\n        - `breakOffDistance`: <NUMBER> Default: `500` - The three dimensional distance between the `_attackPosition` \n            and the aircraft at which point it will abandon it's firing orders and egress.\n        - `numberOfFlaresToDump`: <NUMBER> Default: `4` - The number of flares to fire off after breaking off.\n        - `approachSpeed`: <NUMBER> Default: `75` - How many meters per second will the \n            aircraft be flying while approaching the `_attackPosition`.\n        - `vectorToTargetOffset`: <NUMBER[]> Default: `[0,0,0]` - Used with `vectorAdd` on the aircraft's\n            starting position to get the vector it will follow to engage the target.\n            This can be used if an aircraft seems to be firing off target.\n\n    1: _fireOrders : <[STRING,STRING,NUMBER,NUMBER,STRING,NUMBER][]> - An array of firing orders\n        that determine how an aircraft will fire at the target.\n        See `KISKA_fnc_closeAirSupport_parseFireOrders` for more detail. \n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // fire gun\n        [\n            createHashMapFromArray [\n                [\"aircraftClass\",\"B_Plane_CAS_01_dynamicLoadout_F\"],\n                [\"numberOfFlaresToDump\",4],\n                [\"attackPosition\",theTarget]\n            ],\n            [\n                [\n                    \"Gatling_30mm_Plane_CAS_01_F\",\n                    \"\",\n                    50,\n                    0.05,\n                    \"\",\n                    0.1\n                ]\n            ]\n        ] call KISKA_fnc_closeAirSupport;\n    (end)\n\n    (begin example)\n        // drop napalm\n        [\n            createHashMapFromArray [\n                [\"aircraftClass\",\"B_Plane_CAS_01_dynamicLoadout_F\"],\n                [\"numberOfFlaresToDump\",0],\n                [\"attackPosition\",theTarget]\n            ],\n            [\n                [\n                    \"pylon\",\n                    \"vn_bomb_f4_out_500_blu1b_fb_mag_x4\",\n                    4,\n                    0.5,\n                    \"guide_to_strafe_target\",\n                    1\n                ]\n            ]\n        ] call KISKA_fnc_closeAirSupport;\n    (end)\n\n    (begin example)\n        // shoot gun and fire rockets\n        [\n            createHashMapFromArray [\n                [\"aircraftClass\",\"B_Plane_CAS_01_dynamicLoadout_F\"],\n                [\"numberOfFlaresToDump\",0],\n                [\"attackPosition\",theTarget]\n            ],\n            [\n                [\n                    \"Gatling_30mm_Plane_CAS_01_F\",\n                    \"\",\n                    50,\n                    0.05,\n                    \"\",\n                    0\n                ],\n                [\n                    \"pylon\",\n                    \"PylonRack_7Rnd_Rocket_04_HE_F\",\n                    7,\n                    0.5,\n                    \"guide_to_strafe_target\",\n                    0.01\n                ]\n            ]\n        ] call KISKA_fnc_closeAirSupport;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_closeAirSupport\";\n\n#define TIME_TILL_DELETE 65\n#define FLARE_LAUNCHER_CLASS \"CMFlareLauncher\"\n#define TARGET_CLASS_NAME \"Sign_Sphere200cm_F\"\n#define BOUNDING_BOX_TYPE \"ViewGeometry\"\n#define DEFAULT_FIRE_DISTANCE -1\n\nparams [\n    [\"_aircraftParams\",[],[createHashMap]],\n    [\"_fireOrders\",[],[[]]]\n];\n\nif (_fireOrders isEqualTo []) exitWith {\n    [\"_fireOrders list is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _paramDetails = [\n    [\"aircraftClass\",{\"\"},[\"\"]],\n    [\"side\",{BLUFOR},[sideUnknown]],\n    [\"allowDamage\",{false},[true]],\n    [\"attackPosition\",{objNull},[[],objNull]],\n    [\"directionOfAttack\",{0},[123]],\n    [\"initialHeightAboveTarget\",{1300},[123]],\n    [\"initialDistanceToTarget\",{2000},[123]],\n    [\"breakOffDistance\",{500},[123]],\n    [\"numberOfFlaresToDump\",{4},[123]],\n    [\"approachSpeed\",{75},[123]],\n    [\"vectorToTargetOffset\",{[0,0,0]},[[]]],\n    [\"fireDistance\",{DEFAULT_FIRE_DISTANCE},[123]]\n];\nprivate _paramValidationResult = [_aircraftParams,_paramDetails] call KISKA_fnc_hashMapParams;\nif (_paramValidationResult isEqualType \"\") exitWith {\n    [_paramValidationResult,true] call KISKA_fnc_log;\n    nil\n};\n(_paramValidationResult select 0) params (_paramValidationResult select 1);\n\nif (_fireDistance isEqualTo DEFAULT_FIRE_DISTANCE) then {\n    _fireDistance = _initialDistanceToTarget;\n};\n\n/* ----------------------------------------------------------------------------\n    Position plane towards target\n---------------------------------------------------------------------------- */\nprivate _attackPositionIsObject = _attackPosition isEqualType objNull;\nif (\n    (_attackPositionIsObject) AND \n    {isNull _attackPosition} OR \n    {_attackPosition isEqualTo []}\n) exitWith {\n    [[_attackPosition,\" is an invalid target\"],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _aircraftCfg = configfile >> \"cfgvehicles\" >> _aircraftClass;\nif !(isclass _aircraftCfg) exitwith {\n    [[\"_aircraftClass -> \", _aircraftClass,\" was not found...\"],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_attackPositionIsObject) then {\n    _attackPosition = getPosASL _attackPosition;\n};\nif ((_attackPosition select 2) < 0) then {\n    _attackPosition set [2,0];\n};\n\nprivate _spawnPosition = [\n    _attackPosition,\n    _initialDistanceToTarget,\n    _directionOfAttack + 180,\n    _initialHeightAboveTarget\n] call KISKA_fnc_getPosRelativeASL;\nprivate _aircraftSpawnInfo = [\n    _spawnPosition,\n    _directionOfAttack,\n    _aircraftClass,\n    _side\n] call KISKA_fnc_spawnVehicle;\n\n_aircraftSpawnInfo params [\"_aircraft\",\"_crew\",\"_aircraftGroup\"];\n\n[_aircraftGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\nif !(_allowDamage) then {\n    _aircraft allowDamage false;\n    _crew apply {\n        _x allowDamage false;\n    };\n};\n_aircraft setPosWorld _spawnPosition;\nprivate _initialPositionWorld = [_aircraft,BOUNDING_BOX_TYPE] call KISKA_fnc_getBoundingBoxCenter;\n_aircraft setDir _directionOfAttack;\n_aircraft disableAi \"autotarget\";\n_aircraft setCombatMode \"blue\";\n\n\n/* ----------------------------------------------------------------------------\n    Check fire orders\n---------------------------------------------------------------------------- */\nprivate _fireOrdersParsed = [\n    _aircraft,\n    _fireOrders\n] call KISKA_fnc_closeAirSupport_parseFireOrders;\n\nprivate _fireOrdersAreInvalid = _fireOrdersParsed isEqualTo [];\nif (_fireOrdersAreInvalid) exitWith {\n    deleteVehicleCrew _aircraft;\n    _crew apply {\n        if (alive _x) then { deleteVehicle _x };\n    };\n\n    if (alive _aircraft) then { deleteVehicle _aircraft; };\n    if (!isNull _aircraftGroup) then { deleteGroup _aircraftGroup; };\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    Fix planes velocity towards the target\n---------------------------------------------------------------------------- */\nprivate _vectors = [_initialPositionWorld vectorAdd _vectorToTargetOffset,_attackPosition] call KISKA_fnc_getVectorToTarget;\n_aircraft setVectorDirAndUp _vectors;\n_vectors params [\"_aircraftVectorDirTo\",\"_aircraftVectorUp\"];\nprivate _vectorDistanceToTarget = _attackPosition vectorDistance _initialPositionWorld;\nprivate _flightTime = (_vectorDistanceToTarget - _breakOffDistance) / _approachSpeed;\nprivate _startTime = time;\nprivate _timeAfterFlight = _startTime + _flightTime;\n\n[\n    \"KISKA_closeAirSupport_originalTarget\",\n    \"KISKA_closeAirSupport_strafeTarget\"\n] apply {\n    private _target = createVehicleLocal [\n        TARGET_CLASS_NAME,\n        [0,0,0],\n        [],\n        0,\n        \"NONE\"\n    ];\n    hideObject _target;\n    _target setPosASL _attackPosition;\n    _aircraft setVariable [_x,_target];\n};\n\n_aircraft addEventHandler [\"killed\",{\n    params [\"_aircraft\"];\n    [\n        \"KISKA_closeAirSupport_originalTarget\",\n        \"KISKA_closeAirSupport_strafeTarget\"\n    ] apply {\n        private _target = _aircraft getVariable [_x,objNull];\n        if !(isNull _target) then { deleteVehicle _target };\n    };\n}];\n\n[\n    {\n        params [\"_args\",\"_id\"];\n        _args params [\n            \"_aircraft\",\n            \"_attackTarget\",\n            \"_strafeTarget\",\n            \"_directionOfAttack\",\n            \"_breakOffDistance\",\n            \"_initialPositionWorld\",\n            \"_startTime\",\n            \"_timeAfterFlight\",\n            \"_aircraftSpawnInfo\",\n            \"_aircraftVectorDirTo\",\n            \"_aircraftVectorUp\",\n            \"_side\",\n            \"_initialDistanceToTarget\",\n            \"_initialHeightAboveTarget\",\n            \"_approachSpeed\",\n            \"_numberOfFlaresToDump\",\n            \"_fireOrders\",\n            \"_fireDistance\"\n        ];\n\n        private _updatedAttackPosition = getPosASLVisual _strafeTarget;\n        private _aircraftPositionWorld = [_aircraft,BOUNDING_BOX_TYPE] call KISKA_fnc_getBoundingBoxCenter;\n        private _vectorDistanceToTarget = _updatedAttackPosition vectorDistance _aircraftPositionWorld;\n\n        /* ----------------------------------------------------------------------------\n            Handle After CAS complete\n        ---------------------------------------------------------------------------- */\n        private _casIsComplete = isNull _aircraft OR\n            {_aircraft getVariable [\"KISKA_closeAirSupport_complete\",false]} OR\n            {_vectorDistanceToTarget <= _breakOffDistance};\n        if (_casIsComplete) exitWith {\n            _aircraft setVariable [\"KISKA_closeAirSupport_complete\",true];\n\n            private _positionPastTarget = _updatedAttackPosition getPos [5000,_directionOfAttack];\n            _aircraft move _positionPastTarget;\n            _aircraft flyInHeight (_initialHeightAboveTarget * 2);\n\n            private _pilot = currentPilot _aircraft;\n            for \"_i\" from 1 to _numberOfFlaresToDump do {\n                [\n                    {\n                        params [\"_pilot\"];\n                        _pilot forceweaponfire [FLARE_LAUNCHER_CLASS,\"Burst\"];\n                    },\n                    [_pilot],\n                    _i\n                ] call CBA_fnc_waitAndExecute;\n            };\n            \n            // give the aircraft some time to get out of audible distance before deletion\n            [\n                {\n                    params [\"_aircraft\",\"_crew\",\"_group\"];\n                    [\n                        \"KISKA_closeAirSupport_originalTarget\",\n                        \"KISKA_closeAirSupport_strafeTarget\"\n                    ] apply {\n                        private _target = _aircraft getVariable [_x,objNull];\n                        if !(isNull _target) then { deleteVehicle _target };\n                    };\n\n                    _crew apply {\n                        if !(isNull _x) then {\n                            _aircraft deleteVehicleCrew _x;\n                        };\n                    };\n\n                    if (alive _aircraft) then { deleteVehicle _aircraft; };\n                    if !(isNull _group) then { deleteGroup _group; };\n                },\n                _aircraftSpawnInfo,\n                TIME_TILL_DELETE\n            ] call CBA_fnc_waitAndExecute;\n\n            [_id] call CBA_fnc_removePerFrameHandler;\n        };\n\n        //--- Set the plane approach vector\n        private _interval = linearConversion [_startTime,_timeAfterFlight,time,0,1];\n        private _velocity = (vectorNormalized (_updatedAttackPosition vectorDiff _aircraftPositionWorld)) vectorMultiply _approachSpeed;\n        _aircraft setVelocityTransformation [\n            _initialPositionWorld, _updatedAttackPosition,\n            _velocity, _velocity,\n            _aircraftVectorDirTo, _aircraftVectorDirTo,\n            _aircraftVectorUp, _aircraftVectorUp,\n            _interval\n        ];\n\n        // if not within range\n        if (_vectorDistanceToTarget > _fireDistance) exitWith {};\n\n        if !(_aircraft getVariable [\"KISKA_closeAirSupport_isFiring\",false]) then {\n            private _laserTarget = laserTarget _attackTarget;\n            _aircraft reveal _laserTarget;\n            _aircraft dowatch _laserTarget;\n            _aircraft dotarget _laserTarget;\n\n  \n            [\n                _aircraft,\n                _attackTarget,\n                _strafeTarget,\n                _fireOrders\n            ] call KISKA_fnc_closeAirSupport_fire;\n        } else {\n            private _strafeIncrement = _aircraft getVariable [\"KISKA_closeAirSupport_strafeIncrement\",0.1];\n            private _nextAttackPostition = AGLToASL (_strafeTarget getPos [_strafeIncrement,_directionOfAttack]);\n            if ((_nextAttackPostition select 2) < 0) then {\n                _nextAttackPostition set [2,0];\n            };\n            _strafeTarget setPosASL _nextAttackPostition;\n        };\n\n    },\n    0.01,\n    [\n        _aircraft,\n        _aircraft getVariable \"KISKA_closeAirSupport_originalTarget\",\n        _aircraft getVariable \"KISKA_closeAirSupport_strafeTarget\",\n        _directionOfAttack,\n        _breakOffDistance,\n        _initialPositionWorld,\n        _startTime,\n        _timeAfterFlight,\n        _aircraftSpawnInfo,\n        _aircraftVectorDirTo,\n        _aircraftVectorUp,\n        _side,\n        _initialDistanceToTarget,\n        _initialHeightAboveTarget,\n        _approachSpeed,\n        _numberOfFlaresToDump,\n        _fireOrdersParsed,\n        _fireDistance\n    ]\n] call CBA_fnc_addPerframeHandler;\n\n\nnil\n",
    "fileName": "fn_closeAirSupport.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_closeAirSupport.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_closeAirSupport_fire\n\nDescription:\n    Instructs the aircraft to fire its weapons for `KISKA_fnc_closeAirSupport`\n     and will guide munitions if needed.\n\nParameters:\n    0: _aircraft : <OBJECT> - The aircraft doing the firing.\n    1: _attackTarget : <OBJECT> - The original target that the aircraft is meant to fire at.\n    2: _strafeTarget : <OBJECT> - A target that will act as a guide for strafing the target.\n    3: _fireOrders : <[STRING,STRING,NUMBER,NUMBER,STRING,NUMBER][]> - List of fire orders.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        Should not be called on its own but in KISKA_fnc_closeAirSupport\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_closeAirSupport_fire\";\n\n#define MIN_TIME_BETWEEN_SHOTS 0.01\n#define GUIDE_WEAPON_INTERVAL 0.05\n#define GUIDED_WEAPON_ACCELERATION_TIME 0.1\n\nparams [\"_aircraft\",\"_attackTarget\",\"_strafeTarget\",\"_fireOrders\"];\n\n_aircraft setVariable [\"KISKA_closeAirSupport_isFiring\",true];\n// CUP planes in particular have an issue with rocket fire not being accurate\n// This will guide projectiles to where they should go\n_aircraft addEventHandler [\"Fired\", {\n    params [\"_aircraft\", \"_weapon\", \"\", \"\", \"\", \"\", \"_projectile\"];\n\n    private _weaponClass = toLowerANSI _weapon;\n    private _guidance = [\n        \"KISKA_fnc_closeAirSupport_strafeTargetGuidedWeapons\",\n        \"KISKA_fnc_closeAirSupport_originalTargetGuidedWeapons\"\n    ] apply {\n        private _guideMap = _aircraft getVariable _x;\n        private _currentNumberOfRoundsToGuide = _guideMap getOrDefaultCall [_weaponClass,{-1}];\n        if (_currentNumberOfRoundsToGuide <= 0) then { continueWith false };\n        \n        _guideMap set [_weaponClass, _currentNumberOfRoundsToGuide - 1];\n        breakWith true;\n    };\n    _guidance params [\n        [\"_guideToStrafeTarget\",false],\n        [\"_guideToOriginalTarget\",false]\n    ];\n        \n    if (_guideToOriginalTarget OR _guideToStrafeTarget) then {\n        private \"_targetToGuideTo\";\n        if (_guideToStrafeTarget) then {\n            _targetToGuideTo = _aircraft getVariable [\"KISKA_closeAirSupport_strafeTarget\",objNull];\n        } else {\n            _targetToGuideTo = _aircraft getVariable [\"KISKA_closeAirSupport_originalTarget\",objNull];\n        };\n\n        [\n            {\n                params [\"_aircraft\",\"_projectile\",\"_targetToGuideTo\"];\n\n                if (isNull _targetToGuideTo) exitWith {};\n\n                private _projectileStartPosWorld = getPosWorldVisual _projectile;\n                private _positionToGuideTo = getPosWorldVisual _targetToGuideTo;\n                private _vectors = [_projectileStartPosWorld,_positionToGuideTo] call KISKA_fnc_getVectorToTarget;\n\n                private _speed = speed _projectile;\n                _projectile setVectorDirAndUp _vectors;\n                _projectile setVelocityModelSpace [0,_speed,0];\n\n                _vectors params [\"_vectorDir\",\"_vectorUp\"];\n                private _vectorDistanceToTarget = _positionToGuideTo vectorDistance _projectileStartPosWorld;\n                private _flightTime = _vectorDistanceToTarget / _speed;\n                private _startTime = time;\n                private _timeAfterFlight = _startTime + _flightTime;\n\n                [\n                    {\n                        params [\"_args\",\"_id\"];\n\n                        _args params [\n                            \"_projectile\",\n                            \"_projectileStartPosWorld\",\n                            \"_vectorDir\",\n                            \"_vectorUp\",\n                            \"_startTime\",\n                            \"_timeAfterFlight\",\n                            \"_positionToGuideTo\"\n                        ];\n\n                        private _time = time;\n                        if ((isNull _projectile) OR (_time > (_timeAfterFlight + 60))) exitWith {\n                            [_id] call CBA_fnc_removePerFrameHandler;\n                        };\n\n                        private _interval = linearConversion [_startTime,_timeAfterFlight,_time,0,1];\n                        private _velocity = velocity _projectile;\n                        _projectile setVelocityTransformation [\n                            _projectileStartPosWorld, _positionToGuideTo,\n                            _velocity, _velocity,\n                            _vectorDir,_vectorDir,\n                            _vectorUp, _vectorUp,\n                            _interval\n                        ];\n                    },\n                    GUIDE_WEAPON_INTERVAL,\n                    [\n                        _projectile,\n                        _projectileStartPosWorld,\n                        _vectorDir,\n                        _vectorUp,\n                        _startTime,\n                        _timeAfterFlight,\n                        _positionToGuideTo\n                    ]\n                ] call CBA_fnc_addPerFrameHandler;\n            },\n            [_aircraft, _projectile, _targetToGuideTo],\n            GUIDED_WEAPON_ACCELERATION_TIME\n        ] call CBA_fnc_waitAndExecute;\n    };\n}];\n\nprivate _fireIntervalTotal = 0;\nprivate _lastOrderIndex = (count _fireOrders) - 1;\nprivate _pilot = currentPilot _aircraft;\n\nprivate _guideToStrafeTargetWeaponClasses = createHashMap;\n_aircraft setVariable [\"KISKA_fnc_closeAirSupport_strafeTargetGuidedWeapons\",_guideToStrafeTargetWeaponClasses];\nprivate _guideToOriginalTargetWeaponClasses = createHashMap;\n_aircraft setVariable [\"KISKA_fnc_closeAirSupport_originalTargetGuidedWeapons\",_guideToOriginalTargetWeaponClasses];\n\n\n{\n    private _isFinalOrder = _forEachIndex isEqualTo _lastOrderIndex;\n    _x params [\n        \"_weaponClass\",\n        \"_magazineClass\",\n        \"_numberOfTriggerPulls\",\n        \"_timeBetweenShots\",\n        \"_weaponProfile\",\n        \"_strafeIncrement\"\n    ];\n\n    _timeBetweenShots = _timeBetweenShots max MIN_TIME_BETWEEN_SHOTS;\n\n    private _key = toLowerANSI _weaponClass;\n    switch (toLowerANSI _weaponProfile) do\n    {\n        case \"guide_to_original_target\": {\n            private _currentNumberOfRoundsToGuide = _guideToOriginalTargetWeaponClasses getOrDefault [_key,0];\n            _guideToOriginalTargetWeaponClasses set [_key,_currentNumberOfRoundsToGuide + _numberOfTriggerPulls];\n        };\n        case \"guide_to_strafe_target\": { \n            private _currentNumberOfRoundsToGuide = _guideToStrafeTargetWeaponClasses getOrDefault [_key,0];\n            _guideToStrafeTargetWeaponClasses set [_key,_currentNumberOfRoundsToGuide + _numberOfTriggerPulls];\n        };\n        default {};\n    };\n\n    private _fireModes = getArray(configFile >> \"CfgWeapons\" >> _weaponClass >> \"modes\");\n    private _primaryFireMode = _fireModes param [0,\"\"];\n    for \"_i\" from 1 to _numberOfTriggerPulls do {\n        [\n            {\n                params [\n                    \"_aircraft\",\n                    \"_attackTarget\",\n                    \"_weaponClass\",\n                    \"_primaryFireMode\",\n                    \"_pilot\",\n                    [\"_strafeIncrement\",-1],\n                    \"_isDoneFiring\"\n                ];\n\n\n                if (_aircraft getVariable [\"KISKA_closeAirSupport_complete\",false]) exitWith {};\n\n                // certain vehicles seem to not work with fireAtTarget on the cannon (\"vn_b_air_f4c_cas\" from CDLC SOGPF)\n                if (_strafeIncrement >= 0) then {\n                    _aircraft setVariable [\"KISKA_closeAirSupport_strafeIncrement\",_strafeIncrement];\n                };\n\n                private _canFireAtTarget = _pilot fireAtTarget [_attackTarget,_weaponClass];\n                if !(_canFireAtTarget) then {\n                    _pilot forceWeaponFire [_weaponClass,_primaryFireMode];\n                };\n\n                if (_isDoneFiring) then {\n                    _aircraft setVariable [\"KISKA_closeAirSupport_isFiring\",true];\n                    _aircraft setVariable [\"KISKA_closeAirSupport_complete\",true];\n                };\n            },\n            [\n                _aircraft,\n                _attackTarget,\n                _weaponClass,\n                _primaryFireMode,\n                _pilot,\n                _strafeIncrement,\n                _isFinalOrder && (_i isEqualTo _numberOfTriggerPulls)\n            ],\n            _fireIntervalTotal\n        ] call CBA_fnc_waitAndExecute;\n\n        _fireIntervalTotal = _fireIntervalTotal + _timeBetweenShots;\n    };\n\n} forEach _fireOrders;\n\nnil\n",
    "fileName": "fn_closeAirSupport_fire.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_closeAirSupport_fire.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_closeAirSupport_parseFireOrders\n\nDescription:\n    Parses and validates a list of fire orders for an aircraft to follow to do CAS\n     with `KISKA_fnc_closeAirSupport`.\n\nParameters:\n    0: _aircraft : <OBJECT> - The aircraft that will be following the fire orders\n    1: _fireOrders : <[STRING,STRING,NUMBER,NUMBER,STRING,NUMBER][]> - List of fire orders.\n\n        A fire single fire order can consist of the following arguments:\n        - 0. <STRING> - The weapon to fire's className. If this is to be \n            a pylon weapon, simply set to `pylon`.\n        - 1. <STRING> - The weapon to fire's magazine className. If this is\n            to be a pylon magazine, ensure you've set the weapon className to\n            \"pylon\". If no magazine is provided but a weapon is, the default\n            magazine for the weapon will be used.\n        - 2. <NUMBER> - The number of trigger pulls. If less than 0, all rounds\n            in the magazine will be fired.\n        - 3. <NUMBER> - The amount of seconds between each time the AI pulls the trigger.\n        - 4. <STRING> - Either `\"guide_to_original_target\"`, `\"guide_to_strafe_target\"`, or `\"\"`.\n            `guide_to_original_target` will guide each round of the weapon fired directly to the\n            attack position specified. `guide_to_strafe_target` will guide each round onto the\n            stafing target giving the illusion of strafing. Leave empty if no guidance is necessary.\n            This can be performance intensive.\n        - 5. <NUMBER> - For every 0.01 seconds the aircraft is firing these munitions,\n            how much space should there be added to the aicraft's nose position? This\n            will help with strafing a target.\n\nReturns:\n    <[STRING,STRING,NUMBER,NUMBER,STRING,NUMBER][]> - a parsed list of fire orders.\n\nExamples:\n    (begin example)\n        // Should not be called on its own but in `KISKA_fnc_closeAirSupport`\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_closeAirSupport_parseFireOrders\"\n\nparams [\n    [\"_aircraft\",objNull,[objNull]],\n    [\"_fireOrders\",[],[[]]]\n];\n\nprivate _allVehiclePylonNames = (getAllPylonsInfo _aircraft) apply { \n    private _pylon = _x select 1;\n    _aircraft setPylonLoadout [_pylon,\"\"];\n    _pylon\n};\nprivate \"_invalidFireOrdersMessage\";\nprivate _fireOrdersParsed = [];\n{\n    _x params [\n        [\"_weapon\",\"\"],\n        [\"_mag\",\"\"],\n        [\"_numberOfTriggerPulls\",-1],\n        [\"_timeBetweenShots\",0.05],\n        [\"_weaponProfile\",\"\"],\n        [\"_strafeIncrement\",0]\n    ];\n\n    if !(_weapon isEqualType \"\") then {\n        _invalidFireOrdersMessage = [\"_weapon must be a string in fire order index \", _forEachIndex];\n        break;\n    };\n    if !(_mag isEqualType \"\") then {\n        _invalidFireOrdersMessage = [\"_mag must be a string in fire order index \", _forEachIndex];\n        break;\n    };\n    if !(_numberOfTriggerPulls isEqualType 123) then {\n        _invalidFireOrdersMessage = [\"_numberOfTriggerPulls must be a number in fire order index \", _forEachIndex];\n        break;\n    };\n    if !(_timeBetweenShots isEqualType 123) then {\n        _invalidFireOrdersMessage = [\"_timeBetweenShots must be a number in fire order index \", _forEachIndex];\n        break;\n    };\n    if !(_weaponProfile isEqualType \"\") then {\n        _invalidFireOrdersMessage = [\"_weaponProfile must be a string in fire order index \", _forEachIndex];\n        break;\n    };\n    if !(_strafeIncrement isEqualType 123) then {\n        _invalidFireOrdersMessage = [\"_strafeIncrement must be a number in fire order index \", _forEachIndex];\n        break;\n    };\n\n    if (_mag isEqualTo \"\") then {\n        private _defaultMags = getArray(configFile >> \"CfgWeapons\" >> _weapon >> \"magazines\");\n        _mag = _defaultMags select 0;\n        if (_mag isEqualTo \"\") then {\n            _invalidFireOrdersMessage = [\"could not find default mag class for fire order index \", _forEachIndex];\n            break;\n        };\n    };\n\n    if (_numberOfTriggerPulls < 0) then {\n        private _configedNumberOfRoundsInMag = getNumber(configFile >> \"CfgMagazines\" >> _mag >> \"count\");\n        if (_configedNumberOfRoundsInMag isEqualTo 0) then {\n            [[\"Fire order index \",_forEachIndex,\" had no mag count defined for \",_mag],false] call KISKA_fnc_log;\n            _numberOfTriggerPulls = 1;\n        } else {\n            _numberOfTriggerPulls = _configedNumberOfRoundsInMag;\n        };\n    };\n\n    if (_weapon == \"pylon\") then {\n        if (_allVehiclePylonNames isEqualTo []) then {\n            _invalidFireOrdersMessage = [\n                \"_aircraft \",\n                typeOf _aircraft,\n                \" has no pylons configured\"\n            ];\n            break;\n        };\n\n        _weapon = getText(configFile >> \"cfgMagazines\" >> _mag >> \"pylonWeapon\");\n        if (_weapon isEqualTo \"\") then {\n            _invalidFireOrdersMessage = [\n                \"Magazine '\", _mag,\n                \"' has no `pylonWeapon` defined in fire order index \",\n                _forEachIndex\n            ];\n            break;\n        };\n\n        \n        private _pylon = _allVehiclePylonNames deleteAt 0;\n        _aircraft setPylonLoadout [_pylon,_mag,true,[]];\n    };\n\n    _fireOrdersParsed pushBack [_weapon,_mag,_numberOfTriggerPulls,_timeBetweenShots,_weaponProfile,_strafeIncrement];\n} forEach _fireOrders;\n\nif !(isNil \"_invalidFireOrdersMessage\") exitWith {\n    [_invalidFireOrdersMessage,true] call KISKA_fnc_log;\n    []\n};\n\n\n_fireOrdersParsed\n",
    "fileName": "fn_closeAirSupport_parseFireOrders.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_closeAirSupport_parseFireOrders.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_cruiseMissileStrike\n\nDescription:\n    Spawns a cruise missile at designated \"launcher\" and then guides it to a target.\n\n    If you need a missile that terrain follows, see KISKA_fnc_vlsFireAt.\n\nParameters:\n    0: _target <OBJECT or ARRAY> - Target to hit missile with, can also be a position (ASL)\n    1: _side <SIDE> - The side that is launching the missile\n    2: _launchPos <OBJECT or ARRAY> - An object or position ASL to spawn the missile at.\n        If empty array array (default), a random position is chosen 2000m away.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [target_1] call KISKA_fnc_cruiseMissileStrike;\n    (end)\n\nAuthors:\n    Arma 3 Discord,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_cruiseMissileStrike\";\n\n#define VLS_CLASS \"B_Ship_MRLS_01_F\"\n#define MISSILE_CLASS \"ammo_Missile_Cruise_01\"\n#define LASER_TARGET_CLASS \"LaserTargetC\"\n#define LAUNCHER_RAND_SPAWN_DISTANCE 2000\n#define LAUNCHER_RAND_SPAWN_ALT 1000\n\nparams [\n    [\"_target\",objNull,[objNull,[]]],\n    [\"_side\",BLUFOR,[sideUnknown]],\n    [\"_launchPos\",[],[[],objNull]]\n];\n\nprivate _targetIsObject = _target isEqualType objNull;\nif (_targetIsObject AND {isNUll _target}) exitWith {\n    [\"Null _target provided!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _launchPosIsObject =_launchPos isEqualType objNull;\nif (_launchPosIsObject AND {isNUll _launchPos}) exitWith {\n    [\"Null _launchPos provided!\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_launchPos isEqualTo []) then {\n    // get firing position and give it some alititude\n    _launchPos = [_target,LAUNCHER_RAND_SPAWN_DISTANCE] call CBA_fnc_randPos;\n    _launchPos = _launchPos vectorAdd [0,0,LAUNCHER_RAND_SPAWN_ALT];\n};\nif (_launchPosIsObject) then {\n    _launchPos = getPosASL _launchPos;\n};\n\n\n// spawn the launcher a little lower so missile does not collide\nprivate _launcherGroup = createGroup _side;\n// can't use createUnit, causes missile not to track\nprivate _launcher = VLS_CLASS createVehicle [0,0,0];\n_launcher allowDamage false;\n[_launcherGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n_launcher setPosASL (_launchPos vectorDiff [0,0,7]);\nprivate _tempGroup = createVehicleCrew _launcher;\n(units _tempGroup) joinSilent _launcherGroup;\n\n// doesn't need to be simmed to act as shot parent\n_launcher enableSimulationGlobal false;\n\n\n//create Missile\nprivate _missile = MISSILE_CLASS createVehicle [0,0,0];\n_missile setPosASL _launchPos;\n_missile setVectorDirAndUp [[0, 0, 1], [1, 0, 0]];\n\nif (_targetIsObject) then {\n    _target = getPosASL _target;\n};\n// any (implemented) lasertarget will do, and since independent does not have one, just use civilian\nprivate _laserTarget = createVehicle [LASER_TARGET_CLASS,_target,[],0,\"CAN_COLLIDE\"];\n_laserTarget setPosASL _target;\n_side reportRemoteTarget [_laserTarget, 3600];\n\n// Do not remotexec setShotParents on server, causes undefined behaviour\n_missile setShotParents [_launcher,gunner _launcher];\n_missile setMissileTarget _laserTarget;\n\n\n[\n    [[_missile],{\n        _thisArgs params [\"_missile\"];\n\n        !alive _missile\n    }],\n    [[_launcher,_laserTarget],{\n        _thisArgs params [\"_launcher\",\"_laserTarget\"];\n\n        deleteVehicle _laserTarget;\n        deleteVehicleCrew _launcher;\n        deleteVehicle _launcher;\n    }],\n    5\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_cruiseMissileStrike.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_cruiseMissileStrike.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_helicopterGunner\n\nDescription:\n    Spawns a helicopter (or uses an existing one) to partol a given area for a period of time and\n     engage enemy targets in a given area.\n\nParameters:\n    0: _centerPosition : <Position[], OBJECT> - The position around which the helicopter will patrol\n    1: _radius : <NUMBER> - The size of the radius to patrol around\n    2: _aircraftType : <STRING or OBJECT> - The class of the helicopter to spawn\n        If object, it is expected that this is a helicopter with crew\n    3: _timeOnStation : <NUMBER> - How long will the aircraft be supporting\n    4: _supportSpeedLimit : <NUMBER> - The max speed the aircraft can fly while in the support radius\n    5: _flyinHeight : <NUMBER> - The altittude the aircraft flys at\n    6: _approachBearing : <NUMBER> - The bearing from which the aircraft will approach from (if below 0, it will be random)\n        This has no effect if an object is used for _aircraftType\n    7: _side : <SIDE> - The side of the created helicopter\n    8: _postSupportCode : <CODE, ARRAY, or STRING> - Code to execute after the support completes.\n            See KISKA_fnc_callBack.\n            The default behaviour is for the aircraft to move 2000 meters away and for\n             its complete crew and self to be deleted. The _postSupportCode should return a `BOOL`\n             that if `false` will NOT perform the default behaviour in addition to the callback.\n        \n        Parameters:\n        - 0: <OBJECT> - The helicopter confucting support\n        - 1: <GROUP> - The group the pilot belongs to\n        - 2: <OBJECT[]> - The full vehicle crew\n        - 3: <OBJECT> - The unit that *should* be the pilot of the helicopter\n        - 4: <ARRAY> - The position the helicopter was supporting\n\nReturns:\n    ARRAY - The vehicle info\n        0: <OBJECT> - The vehicle created\n        1: <OBJECT[]> - The vehicle crew\n        2: <GROUP> - The group the crew is a part of\n\nExamples:\n    (begin example)\n        [\n            player,\n            250,\n            \"B_Heli_Attack_01_dynamicLoadout_F\"\n        ] call KISKA_fnc_helicopterGunner;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_helicopterGunner\";\n\n#define SPAWN_DISTANCE 2000\n#define DETECT_ENEMY_RADIUS 700\n#define MIN_RADIUS 200\n#define STAR_BEARINGS [0,144,288,72,216]\n\nparams [\n    [\"_centerPosition\",[],[objNull,[]],[2,3]],\n    [\"_radius\",200,[123]],\n    [\"_aircraftType\",\"\",[\"\",objNull]],\n    [\"_timeOnStation\",180,[123]],\n    [\"_supportSpeedLimit\",10,[123]],\n    [\"_flyInHeight\",30,[123]],\n    [\"_approachBearing\",-1,[123]],\n    [\"_side\",BLUFOR,[sideUnknown]],\n    [\"_postSupportCode\",{},[\"\",{},[]]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    verify vehicle has turrets that are not fire from vehicle and not copilot positions\n---------------------------------------------------------------------------- */\nprivate _vehicleArray = [];\nprivate _vehicleExistedBeforeFunction = _aircraftType isEqualType objNull;\nif (_vehicleExistedBeforeFunction) then {\n    private _aircraft = _aircraftType;\n    _aircraftType = typeOf _aircraft;\n\n    _vehicleArray pushBack _aircraft;\n    _vehicleArray pushBack (crew _aircraft);\n    _vehicleArray pushBack (group (currentPilot _aircraft));\n};\nprivate _turretsWithWeapons = [_aircraftType] call KISKA_fnc_classTurretsWithGuns;\n\nif (_turretsWithWeapons isEqualTo []) exitWith {\n    [[_aircraftType,\" does not meet standards for function!\"],true] call KISKA_fnc_log;\n    []\n};\n\n\n/* ----------------------------------------------------------------------------\n    Create vehicle\n---------------------------------------------------------------------------- */\nif (!_vehicleExistedBeforeFunction) then {\n    if (_approachBearing < 0) then {\n        _approachBearing = round (random 360);\n    };\n\n    private _spawnPosition = [\n        _centerPosition,\n        SPAWN_DISTANCE,\n        _approachBearing + 180,\n        _flyInHeight\n    ] call KISKA_fnc_getPosRelativeASL;\n    _vehicleArray = [\n        _spawnPosition,\n        0,\n        _aircraftType,\n        _side\n    ] call KISKA_fnc_spawnVehicle;\n};\n\n_vehicleArray params [\"_heli\",\"_heliCrew\",\"_pilotsGroup\"];\nprivate _pilot = currentPilot _heli;\n\n[_pilotsGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n// if using an already exisiting aircraft, the enigne must be on prior to getting a \"move\" command\nif !(isEngineOn _heli) then {\n    _heli engineOn true;\n};\n_heli flyInHeight _flyInHeight;\n\n\n_heli setVariable [\"KISKA_helicopterGunner_vehicleInfo\",[_heli,_pilotsGroup,_heliCrew,_pilot]];\n_pilot setVariable [\"KISKA_helicopterGunner_vehicleInfo\",[_heli,_pilotsGroup,_heliCrew,_pilot]];\n\n/* ----------------------------------------------------------------------------\n    Eventhandlers\n---------------------------------------------------------------------------- */\n/* ---------------------------------------\n    Heli Killed Event\n--------------------------------------- */\nprivate _heliKilledEventId = _heli addEventHandler [\"KILLED\", {\n    params [\"_heli\"];\n\n    private _args = _heli getVariable [\"KISKA_helicopterGunner_vehicleInfo\",[]];\n    [\n        _heli, \n        \"KISKA_helicopterGunner_event_heliKilled\", \n        _args, \n        false\n    ] call BIS_fnc_callScriptedEventHandler;\n\n    [_heli,\"KISKA_helicopterGunner_event_heliKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    _heli setVariable [\"KISKA_helicopterGunner_stop\",true];\n}];\n_heli setVariable [\"KISKA_helicopterGunner_heliKilledEventId\",_heliKilledEventId];\n\n\n/* ---------------------------------------\n    Pilot Killed Event\n--------------------------------------- */\nprivate _pilotKilledEventId = _pilot addEventHandler [\"KILLED\", {\n    params [\"_pilot\"];\n\n    private _args = _pilot getVariable [\"KISKA_helicopterGunner_vehicleInfo\",[]];\n    [\n        _pilot, \n        \"KISKA_helicopterGunner_event_pilotKilled\", \n        _args, \n        false\n    ] call BIS_fnc_callScriptedEventHandler;\n\n    [_pilot,\"KISKA_helicopterGunner_event_pilotKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    private _heli = _args param [0,objNull];\n    _heli setVariable [\"KISKA_helicopterGunner_stop\",true];\n}];\n_pilot setVariable [\"KISKA_helicopterGunner_pilotKilledEventId\",_pilotKilledEventId];\n\n\n/* ---------------------------------------\n    Pilot Getout Event\n--------------------------------------- */\nprivate _pilotGetOutEventId = _pilot addEventHandler [\"GetOutMan\", {\n    params [\"_pilot\"];\n\n    private _args = _pilot getVariable [\"KISKA_helicopterGunner_vehicleInfo\",[]];\n    [\n        _pilot, \n        \"KISKA_helicopterGunner_event_pilotGotOut\", \n        _args, \n        false\n    ] call BIS_fnc_callScriptedEventHandler;\n\n    [_pilot,\"KISKA_helicopterGunner_event_pilotGotOut\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    private _heli = _args param [0,objNull];\n    _heli setVariable [\"KISKA_helicopterGunner_stop\",true];\n}];\n_pilot setVariable [\"KISKA_helicopterGunner_pilotGotOutEventId\",_pilotGetOutEventId];\n\n\n/* ---------------------------------------\n    Add default events\n--------------------------------------- */\nif (!_vehicleExistedBeforeFunction) then {\n    [\n        _heli,\n        \"KISKA_helicopterGunner_event_heliKilled\",\n        { \n            params [\"_heli\",\"\",\"_heliCrew\"];\n\n            \n            _heliCrew apply {\n                _heli deleteVehicleCrew _x;\n            };\n        }\n    ] call BIS_fnc_addScriptedEventHandler;\n\n    [\n        _heli,\n        \"KISKA_helicopterGunner_event_pilotKilled\",\n        { \n            params [\"_heli\"];\n            _heli setDamage 1;\n        }\n    ] call BIS_fnc_addScriptedEventHandler;\n\n    [\n        _heli,\n        \"KISKA_helicopterGunner_event_pilotGotOut\",\n        { \n            params [\"_heli\"];\n            _heli setDamage 1;\n        }\n    ] call BIS_fnc_addScriptedEventHandler;\n};\n\n/* ----------------------------------------------------------------------------\n    Post Support Function\n---------------------------------------------------------------------------- */\nprivate _fn_supportEnded = {\n    params [\n        [\"_heli\",objNull,[objNull]],\n        [\"_pilotsGroup\",grpNull,[grpNull]],\n        [\"_heliCrew\",[],[[]]],\n        [\"_pilot\",objNull,[objNull]],\n        [\"_centerPosition\",[],[[]]],\n        [\"_postSupportCode\",{},[{},\"\",[]]],\n        [\"_approachBearing\",0,[123]]\n    ];\n\n    private _runDefault = true;\n    private _postSupportCodeIsNotEmpty = (_postSupportCode isNotEqualTo {}) AND (_postSupportCode isNotEqualTo \"\") AND (_postSupportCode isNotEqualTo []);\n    if (_postSupportCodeIsNotEmpty) then {\n        _runDefault = [\n            _this,\n            _postSupportCode\n        ] call KISKA_fnc_callBack;\n    };\n\n\n    if (\n        (!_runDefault) OR \n        (_heli getVariable [\"KISKA_helicopterGunner_stop\",true])\n    ) exitWith {\n        [_heli,\"KISKA_helicopterGunner_event_heliKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n        [_pilot,\"KISKA_helicopterGunner_event_pilotKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n        [_pilot,\"KISKA_helicopterGunner_event_pilotGotOut\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n        _heli removeEventHandler [\n            \"KILLED\",\n            _heli getVariable [\"KISKA_helicopterGunner_heliKilledEventId\",-1]\n        ];\n        _pilot removeEventHandler [\n            \"KILLED\",\n            _pilot getVariable [\"KISKA_helicopterGunner_pilotKilledEventId\",-1]\n        ];\n        _pilot removeEventHandler [\n            \"GetOutMan\",\n            _pilot getVariable [\"KISKA_helicopterGunner_pilotGotOutEventId\",-1]\n        ];\n    };\n\n\n    // get helicopter to disengage and rtb\n    _pilot disableAI \"AUTOTARGET\";\n    _pilotsGroup setCombatMode \"BLUE\";\n\n    // not using waypoints here because they are auto-deleted for an unkown reason a few seconds after being created for the unit\n\n    // return to spawn position area\n    private _deletePosition = _centerPosition getPos [SPAWN_DISTANCE,_approachBearing + 180];\n    _heli doMove _deletePosition;\n\n    waitUntil {\n        private _isOnGround = ((getPosATL _heli) select 2) < 2;\n        if (\n            _isOnGround OR\n            (_heli getVariable [\"KISKA_helicopterGunner_stop\",true]) OR\n            {(_heli distance2D _deletePosition) <= 200}\n        ) then {\n            if (_isOnGround) then {\n                _heli setDamage 1;\n            };\n\n            breakWith true\n        };\n\n        sleep 2;\n        false\n    };\n\n    // killed event shousld have taken care of cleanup\n    if !(alive _heli) exitWith {};\n\n    [_heli,\"KISKA_helicopterGunner_event_heliKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n    [_pilot,\"KISKA_helicopterGunner_event_pilotKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n    [_pilot,\"KISKA_helicopterGunner_event_pilotGotOut\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    _heliCrew apply {\n        _heli deleteVehicleCrew _x;\n    };\n    deleteVehicle _heli;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Move to support zone\n---------------------------------------------------------------------------- */\n// move command only supports position arrays\nif (_centerPosition isEqualType objNull) then {\n    _centerPosition = getPosATL _centerPosition;\n};\n\n_heli setVariable [\"KISKA_helicopterGunner_stop\",false];\n\n\nprivate _params = [\n    _centerPosition,\n    _radius,\n    _timeOnStation,\n    _supportSpeedLimit,\n    _approachBearing,\n    _side,\n    _heli,\n    _pilotsGroup,\n    _heliCrew,\n    _pilot,\n    _postSupportCode,\n    _fn_supportEnded\n];\n\n_params spawn {\n    params [\n        \"_centerPosition\",\n        \"_radius\",\n        \"_timeOnStation\",\n        \"_supportSpeedLimit\",\n        \"_approachBearing\",\n        \"_side\",\n        \"_heli\",\n        \"_pilotsGroup\",\n        \"_heliCrew\",\n        \"_pilot\",\n        \"_postSupportCode\",\n        \"_fn_supportEnded\"\n    ];\n\n    // once you go below a certain radius, it becomes rather unnecessary\n    if (_radius < MIN_RADIUS) then {\n        _radius = MIN_RADIUS;\n    };\n\n    // move to support zone\n    // checking driver instead of cache to see if they got out of the vehicle\n    private _vehicleEffective = true;\n    waitUntil {\n        private _isOnGround = ((getPosATL _heli) select 2) < 2;\n        if (\n            _isOnGround OR \n            (_heli getVariable [\"KISKA_helicopterGunner_stop\",true])\n        ) then {\n            _vehicleEffective = false;\n            breakWith true\n        };\n\n        _pilotsGroup move _centerPosition;\n        sleep 2;\n\n        ((_heli distance2D _centerPosition) <= _radius)\n    };\n\n    \n    if !(_vehicleEffective) exitWith {\n        [\n            _heli,\n            _pilotsGroup,\n            _heliCrew,\n            _pilot,\n            _centerPosition,\n            _postSupportCode,\n            _approachBearing\n        ] call _fn_supportEnded;\n    };\n\n\n    /* ----------------------------------------------------------------------------\n        Do support\n    ---------------------------------------------------------------------------- */\n    [\n        _heli,\n        5,\n        4,\n        _radius * 2,\n        1,\n        true\n    ] spawn KISKA_fnc_engageHeliTurretsLoop;\n\n    // to keep helicopters from just wildly flying around\n    _heli limitSpeed _supportSpeedLimit;\n    private _sleepTime = 20;\n    private _numberOfBearings = count STAR_BEARINGS;\n    private _elapsedTime = 0;\n    private _bearingIndex = 0;\n    while {_timeOnStation > _elapsedTime} do {\n         private _isOnGround = ((getPosATL _heli) select 2) < 2;\n        if (\n            _isOnGround OR \n            (_heli getVariable [\"KISKA_helicopterGunner_stop\",true])\n        ) then {\n            break;\n        };\n\n        private _movePos = _centerPosition getPos [_radius,STAR_BEARINGS select _bearingIndex];\n        _bearingIndex = _bearingIndex + 1;\n        if (_bearingIndex >= _numberOfBearings) then {\n            _bearingIndex = 0;\n        };\n\n        _heli doMove _movePos;\n\n        private _newElapsedTime = _elapsedTime + _sleepTime;\n        private _isLastRotation = _newElapsedTime > _timeOnStation;\n        if (_isLastRotation) then {\n            sleep (_timeOnStation - _elapsedTime);\n        } else {\n            sleep _sleepTime;\n        };\n\n        _elapsedTime = _newElapsedTime;\n    };\n\n    // end engage heli turrets loop\n    _heli setVariable [\"KISKA_heliTurrets_endLoop\",true];\n\n    /* ----------------------------------------------------------------------------\n        After support is done\n    ---------------------------------------------------------------------------- */\n    //[\"cas abort\",_heliCrew select 0,_side] call KISKA_fnc_supports_genericRadioMessage;\n\n    // remove speed limit\n    _heli limitSpeed 99999;\n\n    [\n        _heli,\n        _pilotsGroup,\n        _heliCrew,\n        _pilot,\n        _centerPosition,\n        _postSupportCode,\n        _approachBearing\n    ] call _fn_supportEnded;\n};\n\n\n_vehicleArray\n",
    "fileName": "fn_helicopterGunner.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_helicopterGunner.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_paratroopers\n\nDescription:\n    Takes a set of units and moves them into aircraft to be dropped over a position\n     via parachute from a spawned vehicle\n\nParameters:\n    0: _dropZone : <OBJECT or ARRAY> - Target of where to drop the units\n    1: _unitsThatCanDrop : <ARRAY> - An array of units that can be dropped\n    2: _dropVehicleClass : <STRING> - What vehicle class will drop the units\n    3: _numToDrop : <NUMBER> - The number of units out of the array to drop\n        (if -1, will resize to the amount of units in _unitsToDrop)\n    4: _flyDirection : <NUMBER> - The direction that the aircraft will fly towards _dropZone\n        (if -1, will be random direction)\n    5: _flyInHeight : <NUMBER> - The flyInHeight of the aircraft\n    6: _side : <SIDE> - What side is the drop aircraft\n    7: _spawnDistance : <NUMBER> - How far away should the aircraft spawn\n    8: _invincibleOnDrop : <BOOL> - Should the units be invincible while parachuting down\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] spawn KISKA_fnc_paratroopers;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_paratroopers\";\n\n#define WAIT_TILL_NEAR(pos,dist,checkRate) \\\n    waitUntil { \\\n        if ((_aircraft distance2D pos) <= dist) exitWith {true}; \\\n        if (isNull _aircraft) exitWith {true}; \\\n        sleep checkRate; \\\n        false \\\n    };\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled; Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_paratroopers;\n};\n\nparams [\n    [\"_dropZone\",objNull,[objNull,[]]],\n    [\"_unitsThatCanDrop\",[],[[]]],\n    [\"_dropVehicleClass\",\"\",[\"\"]],\n    [\"_numToDrop\",-1,[123]],\n    [\"_flyDirection\",-1,[123]],\n    [\"_flyInHeight\",200,[123]],\n    [\"_side\",BLUFOR,[BLUFOR]],\n    [\"_spawnDistance\",2000,[123]],\n    [\"_invincibleOnDrop\",false,[true]]\n];\n\n/* ----------------------------------------------------------------------------\n    Check params\n---------------------------------------------------------------------------- */\nif ((_dropZone isEqualType objNull AND {isNull _dropZone}) OR {_dropzone isEqualTo []}) exitWith {\n    [[str _dropZone,\" is an invalid _dropZone\"],true] call KISKA_fnc_log;\n    nil\n};\nif (_dropVehicleClass isEqualTo \"\") exitWith {\n    [\"_dropVehicleClass isEqualTo ''\",true] call KISKA_fnc_log;\n    nil\n};\nif (_unitsThatCanDrop isEqualTo []) exitWith {\n    [\"_unitsThatCanDrop isEqualTo []\",true] call KISKA_fnc_log;\n    nil\n};\nif (_numToDrop < -1 OR {_numToDrop isEqualTo 0}) exitWith {\n    [[\"_numToDrop is improper number: \",_numToDrop],true] call KISKA_fnc_log;\n    nil\n};\nif (_spawnDistance < 0) exitWith {\n    [[\"_spawnDistance can't be a negative number: \",_spawnDistance],true] call KISKA_fnc_log;\n    nil\n};\n\n\n// make sure vehicle can hold the number of units to drop and adjust accordingly\nprivate _unitCount = count _unitsThatCanDrop;\nif (_numToDrop isEqualTo -1 OR {_unitCount < _numToDrop}) then {\n    _numToDrop = _unitCount;\n};\nprivate _vehicleCargoCapacity = ([_dropVehicleClass,true] call BIS_fnc_crewCount) - ([_dropVehicleClass,false] call BIS_fnc_crewCount);\nif (_numToDrop > _vehicleCargoCapacity) then {\n    [[\"vehicle class: \",_dropVehicleClass,\" has \",_vehicleCargoCapacity,\" cargo positions, requested \",_numToDrop,\" to be dropped!\"],false] call KISKA_fnc_log;\n    _numToDrop = _vehicleCargoCapacity;\n};\n\nif (_dropZone isEqualType objNull) then {\n    _dropZone = getPosATL _dropZone;\n};\n\nif (_flyDirection < 0) then {\n    _flyDirection = round (random 360);\n};\n\n\n_dropZone set [2,_flyInHeight];\nprivate _spawnPosition = [\n    _dropZone,\n    _spawnDistance,\n    _flyDirection + 180,\n    _flyInHeight\n] call KISKA_fnc_getPosRelativeASL;\n\n/* ----------------------------------------------------------------------------\n    Create vehicle to drop units\n---------------------------------------------------------------------------- */\nprivate _vehicleArray = [_spawnPosition,_flyDirection,_dropVehicleClass,_side] call KISKA_fnc_spawnVehicle;\nprivate _aircraft = _vehicleArray select 0;\nallCurators apply {\n    [_x,[[_aircraft],true]] remoteExec [\"addCuratorEditableObjects\",2];\n};\n_aircraft flyInHeight _flyInHeight;\nprivate _aircraftGroup = _vehicleArray select 2;\n_aircraftGroup setCombatBehaviour \"CARELESS\";\n\n// move units into vehicle cargo\nprivate _unitsToDrop = [];\n_unitsThatCanDrop apply {\n    if (_numToDrop isEqualTo 0) exitWith {};\n    _x moveInCargo _aircraft;\n    _unitsToDrop pushBack _x;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Move to drop zone\n---------------------------------------------------------------------------- */\nprivate _leader = leader _aircraftGroup;\n_leader doMove _dropZone;\n\n// get the ai near the DZ, if just used a position past the dz (_deletePosition), the AI might veer off course\nWAIT_TILL_NEAR(_dropZone,200,0.25)\nif (isNull _aircraft) exitWith {};\n\n// now fly past the dz and when close enough, drop units so there is a decent spread\nprivate _deletePosition = _dropZone getPos [2000,_flyDirection];\n_leader doMove _deletePosition;\nWAIT_TILL_NEAR(_dropZone,100,0.25)\n// get units out of aircraft\n[_aircraft,_unitsToDrop,_invincibleOnDrop] call KISKA_fnc_staticLine;\n_leader doMove _deletePosition;\n\n\n/* ----------------------------------------------------------------------------\n    Delete Aircraft and Crew\n---------------------------------------------------------------------------- */\nWAIT_TILL_NEAR(_deletePosition,200,2)\n(_vehicleArray select 1) apply {\n    _aircraft deleteVehicleCrew _x;\n};\ndeleteVehicle _aircraft;\n\n\nnil\n",
    "fileName": "fn_paratroopers.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_paratroopers.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supplyDrop\n\nDescription:\n    Creates a number of specified objects and parachutes for them to drop down from\n    the sky.\n\nParameters:\n    0: _argsMap <HASHMAP> - a map of arguments for the supply drop:\n\n        - `objectClassNames`: <STRING[]> - a list of classnames of objects that will\n            be created and parachute down.\n        - `dropPosition`: <PositionASL[] or OBJECT> - The position around which the objects\n            will approximately land.\n        - `dropAltitude`: <NUMBER> Default: `100` - The height that the dropped \n            objects begin their descent.\n        - `dropPositionRadius`: <NUMBER> Default: `50` - A randomization radius \n            around the `dropPosition` in which the objects will be created.\n        - `parachuteClass`: <NUMBER> Default: `b_parachute_02_F` - The classname\n            of the parachute.\n        - `dropZVelocity`: <NUMBER> Default: `-15` - The m/s rate of descent that\n            will be applied to the parachutes while every `velocityUpdateFrequency`\n            denoted time and if the object is above a surface beneath it as defined\n            with `distanceToStopVelocityUpdates`.\n        - `velocityUpdateFrequency`: <NUMBER> Default: `0.1` - How frequently\n            to update the objects downward velocity.\n        - `distanceToStopVelocityUpdates`: <NUMBER> Default: `80` - At what\n            distance to the surface beneath the objects should the velocity\n            stop being applied.\n        - `allowDamage`: <BOOL> Default: `true` - Whether or not to automatically\n            disable damage on the dropped objects.\n        - `addArsenals`: <BOOL> Default: `false` - Whether or not to automatically\n            add arsenals to the dropped objects with `KISKA_fnc_addArsenal`.\n        - `clearCargo`: <BOOL> Default: `false` - Whether or not to automatically\n            globally delete the dropped object's cargo with `KISKA_fnc_clearCargoGlobal`.\n\nReturns:\n    <OBJECT[]> - The created objects that were dropped.\n\nExamples:\n    (begin example)\n        private _argsMap = createHashMapFromArray [\n            [\"objectClassNames\",[\"B_supplyCrate_F\",\"B_supplyCrate_F\"]],\n            [\"dropPosition\",target]\n        ];\n        private _crates = [_argsMap] call KISKA_fnc_supplyDrop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supplyDrop\";\n\n#define MIN_DROP_ALT 1\n#define MIN_DROP_RADIUS 10\n#define DELAY_FOR_CHUTE_DEPLOYMENT 3\n#define MIN_DISTANCE_TO_STOP_VELOCITY_UPDATES 15\n#define DISTANCE_TO_DETACH 5\n#define VELOCITY_RELEASE_THRESHOLD 0.1\n\nparams [\n    [\"_argsMap\",[],[createHashMap]]\n];\n\nprivate _paramDetails = [\n    [\"objectClassNames\",{[]},[[]]],\n    [\"dropPosition\",{objNull},[objNull,[]]],\n    [\"dropAltitude\",{100},[123]],\n    [\"dropPositionRadius\",{50},[123]],\n    [\"parachuteClass\",{\"b_parachute_02_F\"},[\"\"]],\n    [\"dropZVelocity\",{-15},[123]],\n    [\"velocityUpdateFrequency\",{0.1},[123]],\n    [\"distanceToStopVelocityUpdates\",{80},[123]],\n    [\"allowDamage\",{true},[false]],\n    [\"addArsenals\",{false},[false]],\n    [\"clearCargo\",{false},[false]]\n];\nprivate _paramValidationResult = [_argsMap,_paramDetails] call KISKA_fnc_hashMapParams;\nif (_paramValidationResult isEqualType \"\") exitWith {\n    [_paramValidationResult,true] call KISKA_fnc_log;\n    []\n};\n(_paramValidationResult select 0) params (_paramValidationResult select 1);\n\n\nif (_objectClassNames isEqualTo []) exitWith {\n    [\"objectClassNames is empty!\",true] call KISKA_fnc_log;\n    []\n};\nprivate _dropPositionIsObject = _dropPosition isEqualType objNull;\nif (_dropPositionIsObject AND {isNull _dropPosition}) exitWith {\n    [\"dropPosition is null object\",true] call KISKA_fnc_log;\n    []\n};\nif (_dropPositionIsObject) then {\n    _dropPosition = getPosASL _dropPosition;\n};\n\n_dropPositionRadius = _dropPositionRadius max MIN_DROP_RADIUS;\n_dropAltitude = _dropAltitude max MIN_DROP_ALT;\n_velocityUpdateFrequency = _velocityUpdateFrequency max 0;\n_distanceToStopVelocityUpdates = _distanceToStopVelocityUpdates max MIN_DISTANCE_TO_STOP_VELOCITY_UPDATES;\n\nprivate _terrainHeighAtDropPosition = getTerrainHeightASL _dropPosition;\nif (_terrainHeighAtDropPosition < 0) then {_terrainHeighAtDropPosition = 0};\n_dropPosition set [2,_terrainHeighAtDropPosition];\nprivate _aslSpawnHeight = _terrainHeighAtDropPosition + _dropAltitude;\nprivate _objectSpawnCenter = _dropPosition vectorAdd [0,0,_dropAltitude];\n_objectClassNames apply {\n    private _objectDropPosition = [_objectSpawnCenter,_dropPositionRadius] call CBA_fnc_randPos;\n    _objectDropPosition set [2,_aslSpawnHeight];\n    private _object = createVehicle [_x,_objectDropPosition,[],0,\"FLY\"];\n    _object setPosASL _objectDropPosition;\n    if (!_allowDamage) then { _object allowDamage false };\n    if (_addArsenals) then { [_object] call KISKA_fnc_addArsenal };\n    if (_clearCargo) then { [_object] call KISKA_fnc_clearCargoGlobal };\n    \n    private _parachute = createVehicle [_parachuteClass,_objectDropPosition,[],0,\"FLY\"];\n    _parachute setPosASL _objectDropPosition;\n    _object attachTo [_parachute,[0,0,0]];\n\n    [\n        {\n            params [\"\",\"\",\"_velocityUpdateFrequency\"];\n            [\n                {\n                    params [\"_args\",\"_id\"];\n                    _args params [\n                        \"_object\",\n                        \"_parachute\",\n                        \"\",\n                        \"_dropZVelocity\",\n                        \"_distanceToStopVelocityUpdates\"\n                    ];\n\n                    private _distanceToSurface = (getPosVisual _object) select 2;\n                    if (_distanceToSurface >= _distanceToStopVelocityUpdates) exitWith {\n                        private _chuteVelocity = velocity _parachute;\n                        _chuteVelocity set [2,_dropZVelocity];\n                        _parachute setVelocity _chuteVelocity;\n                    };\n\n                    if (\n                        (_distanceToSurface <= DISTANCE_TO_DETACH) OR\n                        {\n                            private _velocity = velocity _object;\n                            (_velocity select 2) <= VELOCITY_RELEASE_THRESHOLD\n                        }\n                    ) exitWith {\n                        detach _object;\n                        [_id] call CBA_fnc_removePerFrameHandler;\n                    };\n                },\n                _velocityUpdateFrequency,\n                _this\n            ] call CBA_fnc_addPerFrameHandler;\n        },\n        [\n            _object,\n            _parachute,\n            _velocityUpdateFrequency,\n            _dropZVelocity,\n            _distanceToStopVelocityUpdates\n        ],\n        DELAY_FOR_CHUTE_DEPLOYMENT\n    ] call CBA_fnc_waitAndExecute;\n\n\n    _object\n};\n",
    "fileName": "fn_supplyDrop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_supplyDrop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supplyDropWithAircraft\n\nDescription:\n    A sub implementation of `KISKA_fnc_supplyDrop` that will in addition to dropping\n    a set of objects, will have an aircraft fly over the drop zone simulating the cargo\n    drop.\n\nParameters:\n    0: _argsMap <HASHMAP> - a map of arguments for the supply drop:\n\n        - `dropPosition`: <PositionASL[] or OBJECT> - See `KISKA_fnc_supplyDrop`.\n        - `dropAltitude`: <NUMBER> - See `KISKA_fnc_supplyDrop`.\n        - `aircraftClass: <STRING> - The class name of the aircraft that will be created\n            to fly over the drop zone.\n        - `side`: <SIDE> Default: `BLUFOR` - The side of the created aircraft.\n        - `directionOfAircraft`: <NUMBER> Default: `-1` - The bearing the aircraft \n            will be flying towards. `-1` denotes a random direction.\n        - `spawnDistance`: <NUMBER> Default: `2000` - How far away from the\n            drop zone to spawn the aircraft.\n        - `objectClassNames`: <STRING[]> - See `KISKA_fnc_supplyDrop`.\n        - `dropPositionRadius`: <NUMBER> - See `KISKA_fnc_supplyDrop`.\n        - `parachuteClass`: <NUMBER> - See `KISKA_fnc_supplyDrop`.\n        - `dropZVelocity`: <NUMBER> - See `KISKA_fnc_supplyDrop`.\n        - `velocityUpdateFrequency`: <NUMBER> - See `KISKA_fnc_supplyDrop`.\n        - `distanceToStopVelocityUpdates`: <NUMBER> - See `KISKA_fnc_supplyDrop`.\n        - `allowDamage`: <BOOL> - See `KISKA_fnc_supplyDrop`.\n        - `addArsenals`: <BOOL> - See `KISKA_fnc_supplyDrop`.\n        - `clearCargo`: <BOOL> - See `KISKA_fnc_supplyDrop`.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _argsMap = createHashMapFromArray [\n            [\"objectClassNames\",[\"B_supplyCrate_F\",\"B_supplyCrate_F\"]],\n            [\"dropPosition\",target],\n            [\"aircraftClass\",\"B_T_VTOL_01_vehicle_F\"]\n        ];\n        [_argsMap] call KISKA_fnc_supplyDropWithAircraft;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supplyDropWithAircraft\";\n\n#define DROP_POSITION_THRESHHOLD 40\n#define DELETION_POSITION_THRESHHOLD 100\n\nparams [\n    [\"_argsMap\",[],[createHashMap]]\n];\n\nprivate _paramDetails = [\n    [\"aircraftClass\",{\"\"},[\"\"]],\n    [\"side\",{BLUFOR},[sideUnknown]],\n    [\"directionOfAircraft\",{-1},[123]],\n    [\"spawnDistance\",{2000},[123]],\n    [\"dropPosition\",{objNull},[objNull,[]]],\n    [\"dropAltitude\",{100},[123]],\n    [\"objectClassNames\",{[]},[[]]]\n];\nprivate _paramValidationResult = [_argsMap,_paramDetails] call KISKA_fnc_hashMapParams;\nif (_paramValidationResult isEqualType \"\") exitWith {\n    [_paramValidationResult,true] call KISKA_fnc_log;\n    []\n};\n(_paramValidationResult select 0) params (_paramValidationResult select 1);\n\nif (_aircraftClass isEqualTo \"\") exitWith {\n    [\"aircraftClass is not provided\",true] call KISKA_fnc_log;\n    []\n};\n\nif (_objectClassNames isEqualTo []) exitWith {\n    [\"objectClassNames is empty!\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _dropPositionIsObject = _dropPosition isEqualType objNull;\nif (_dropPositionIsObject AND {isNull _dropPosition}) exitWith {\n    [\"dropPosition is null object\",true] call KISKA_fnc_log;\n    []\n};\nif (_dropPositionIsObject) then {\n    _dropPosition = getPosASL _dropPosition;\n};\n\n\nprivate _spawnPosition = [\n    _dropPosition,\n    _spawnDistance,\n    _directionOfAircraft + 180,\n    _dropAltitude\n] call KISKA_fnc_getPosRelativeASL;\nprivate _pilotClass = getText(configFile >> \"CfgVehicles\" >> _aircraftClass >> \"Crew\");\nprivate _vehicleArray = [\n    _spawnPosition,\n    _directionOfAircraft,\n    _aircraftClass,\n    _side,\n    [_pilotClass]\n] call KISKA_fnc_spawnVehicle;\n_vehicleArray params [\"_aircraft\",\"_crew\",\"_group\"];\n\n_crew apply { _x setCaptive true; };\n_group setCombatBehaviour \"CARELESS\";\n_group setCombatMode \"BLUE\";\n[_group,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n_aircraft move (ASLToATL _dropPosition);\n_aircraft flyinHeight _dropAltitude;\n\n\nprivate _deletionPosition = AGLToASL (_dropPosition getPos [_spawnDistance,_directionOfAircraft]);\nprivate _start = time;\n[\n    {\n        params [\"_args\",\"_id\"];\n        _args params [\n            \"_aircraft\",\n            \"_deletionPosition\", \n            \"_dropPosition\", \n            \"_objectClassNames\",\n            \"_start\",\n            \"_argsMap\"\n        ];\n\n        private _cargoDropped = _aircraft getVariable [\"KISKA_supplyDrop_isCargoDropped\",false];\n        if (_cargoDropped) exitWith {\n            if (\n                (_aircraft distance2D _deletionPosition) > DELETION_POSITION_THRESHHOLD AND \n                (_start < (_start + 60))\n            ) exitWith {};\n            \n            deleteVehicleCrew _aircraft;\n            deleteVehicle _aircraft;\n            [_id] call CBA_fnc_removePerFrameHandler;\n        };\n\n        if ((_aircraft distance2D _dropPosition) <= DROP_POSITION_THRESHHOLD) then {\n            private _updatedDropPosition = _aircraft getRelPos [10 * (count _objectClassNames),180];\n            _argsMap set [\"dropPosition\",_updatedDropPosition];\n            [_argsMap] call KISKA_fnc_supplyDrop;\n            _aircraft setVariable [\"KISKA_supplyDrop_isCargoDropped\",true];\n            _aircraft move (ASLToATL _deletionPosition);\n        };\n    },\n    0.5,\n    [\n        _aircraft,\n        _deletionPosition, \n        _dropPosition, \n        _objectClassNames,\n        _start,\n        _argsMap\n    ]\n] call CBA_fnc_addPerFrameHandler;\n\n\nnil",
    "fileName": "fn_supplyDropWithAircraft.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_supplyDropWithAircraft.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateFlareEffects\n\nDescription:\n    Due to the local nature of many light commands, this function is used\n     to sync up the brightness increase of the flares launched in the support function.\n\nParameters:\n    0: _light <OBJECT> - The #lightPoint attached to the flare\n    1: _flare <OBJECT> - The flare object\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_light,_flare] remoteExecCall [\"KISKA_fnc_updateFlareEffects\",0,_flare];\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateFlareEffects\";\n\nif (!hasInterface) exitWith {};\n\nparams [\"_light\",\"_flare\"];\n\nif (isNull _flare) exitWith {\n    [\"_flare is null, exiting...\"] call KISKA_fnc_log;\n    nil\n};\n\n_light setLightColor [1, 1, 1];\n_light setLightAmbient [1, 1, 1];\n_light setLightIntensity 100000;\n_light setLightUseFlare true;\n_light setLightFlareSize 10;\n_light setLightFlareMaxDistance 600;\n_light setLightDayLight true;\n_light setLightAttenuation [4, 0, 0, 0.2, 1000, 2000];",
    "fileName": "fn_updateFlareEffects.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_updateFlareEffects.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_virtualArty\n\nDescription:\n    Calls for an artillery or mortar strike at a designated position and marks the spot.\n\nParameters:\n    0: _target <OBJECT, ARRAY, or STRING(marker)> - The target you want to cluter fire around\n    1: _ammoType <STRING> - The ammo type from cfgAmmo \n    2: _radius <NUMER> - Spread of rounds\n    3: _numberOfRounds <NUMER> - The number of rounds to fire\n    4: _delayBetween <NUMER> - Time between shots\n    5: _markPosition <BOOL> - Marks the target position with smoke and chemlight (delete after 20 seconds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [target_1,\"Sh_155mm_AMOS\"] spawn KISKA_fnc_virtualArty;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\n#define FLARE_ALT 200\n#define FLARE_VELOCITY -10\n\nscriptName \"KISKA_fnc_virtualArty\";\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled; Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_virtualArty;\n};\n\nparams [\n    [\"_fireAtPosition\",objNull,[[],objNull]],\n    [\"_ammoType\",\"Sh_155mm_AMOS\",[\"\"]],\n    [\"_radius\",25,[123]],\n    [\"_numberOfRounds\",3,[123]],\n    [\"_delayBetween\",5,[123]],\n    [\"_markPosition\",false,[true]]\n];\n\n// flare round need to fall slower\nif (_ammoType == \"F_20mm_white\") exitWith {\n    // delay for fire\n    sleep 3;\n    \n    private _flare = \"F_20mm_white\" createvehicle (_fireAtPosition vectorAdd [0,0,FLARE_ALT]);  \n    _flare setVelocity [0,0,FLARE_VELOCITY];\n    private _light = \"#lightpoint\" createVehicle (getPosASL _flare);\n    _light attachTo [_flare, [0, 0, 0]];\n    \n    // light characteristic adjustments must be done locally for each player\n    [_light,_flare] remoteExecCall [\"KISKA_fnc_updateFlareEffects\",0,_flare];\n\n    waitUntil {\n        sleep 0.5;\n        !alive _flare;\n    };\n    deletevehicle _light;\n};\n\nif (_markPosition) then {\n    [_fireAtPosition] spawn {\n        params [\"_fireAtPosition\"];        \n        private _chemlight = createvehicle [\"Chemlight_green_infinite\",_fireAtPosition,[],0,\"NONE\"];\n        private _smoke = createvehicle [\"G_40mm_SmokeRed_infinite\",_fireAtPosition,[],0,\"NONE\"];\n        //private _flare = createvehicle [\"F_40mm_Red\",_fireAtPosition,[],0,\"NONE\"];\n        sleep 20;\n        deleteVehicle _chemlight;\n        deleteVehicle _smoke;\n        //deleteVehicle _flare;\n    };\n};\n\n// some delay for \"sim\" purposes\nsleep 5;\n\n[_fireAtPosition,_ammoType,_radius,_numberOfRounds,_delayBetween,{},nil,1300] spawn BIS_fnc_fireSupportVirtual;",
    "fileName": "fn_virtualArty.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Supports/fn_virtualArty.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_createTaskFromConfig\n\nDescription:\n    Creates a task from a config entry. Config should be placed inside KISKA_cfgTasks,\n     just the string is needed to reference the config entry.\n\n    Parameters from index 2 onwards will accept configNull as an alias for retrieving\n     the configed value of the param if it is not changed (see example 2)\n\nParameters:\n    0: _config <STRING or CONFIG> - The config entry to convert to a task\n    1: _owner <BOOL, OBJECT, GROUP, SIDE, or ARRAY> - Whom the task is assigned to\n\n    (OPTIONAL)\n    2: _taskState <STRING, BOOL, or configNull> - The state of the task, will overwrite config entry\n    3: _destination <OBJECT, ARRAY, or configNull> The position of the task. Array can be either\n        [x,y,z] or [OBJECT,precision] (see setSimpleTaskTarget). The destination can be a configed array, however, this will\n        overwrite it if provided here.\n    4: _type <STRING or configNull> - The task type (defined in CfgTaskTypes)\n    5: _notifyOnCreate <BOOL or configNull> - Should a notification pop up when the task is created?\n    6: _visibleIn3D <BOOL or configNull> - Show a 3D task icon\n\nReturns:\n    <STRING> - Created Task Id\n\nExamples:\n    (begin example)\n        // simple task from config\n        [missionConfigFile >> MyTasks >> \"someTaskClass\",true] call KISKA_fnc_createTaskFromConfig;\n    (end)\n\n    (begin example)\n        [\n            \"someTaskClass\", // will search in missionConfigFile >> \"KISKA_cfgTasks\"\n            true,\n            \"ASSIGNED\",\n            configNull, // get configed destination value\n            \"ATTACK\"\n        ] call KISKA_fnc_createTaskFromConfig;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_createTaskFromConfig\";\n\n#define GET_CFG_TEXT(entry) getText(_config >> entry)\n#define GET_CFG_NUMBER(entry) getNumber(_config >> entry)\n#define GET_CFG_BOOL(entry) [_config >> entry] call BIS_fnc_getCfgDataBool\n#define GET_CFG_ARRAY(entry) getArray(_config >> entry)\n#define CHECK_VAR(gvar,taskState) if (missionNamespace getVariable [gvar,false]) exitWith {_setTaskState = taskState; true};\n\nparams [\n    [\"_config\",\"\",[configNull,\"\"]],\n    [\"_owner\",true,[true,objNull,grpNull,sideUnknown,[]]],\n    [\"_taskState\",configNull,[\"\",true,configNull]],\n    [\"_destination\",configNull,[objNull,[],configNull]],\n    [\"_type\",configNull,[\"\",configNull]],\n    [\"_notifyOnCreate\",configNull,[configNull,true]],\n    [\"_visibleIn3D\",configNull,[configNull,true]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    Get Config Values\n---------------------------------------------------------------------------- */\nif (_config isEqualType \"\") then {\n    _config = (missionConfigFile >> \"KISKA_cfgTasks\" >> _config);\n};\n\nif (_config isEqualTo configNull) exitWith {\n    [\"_config is null!\",true] call KISKA_fnc_log;\n    \"\"\n};\n\nprivate _taskId = configName _config;\nif ([_taskId] call BIS_fnc_taskExists) exitWith {\n    [[\"The task with ID: \",_taskId,\" already exists\"],false] call KISKA_fnc_log;\n    \"\"\n};\n\nif (_taskState isEqualTo configNull) then {\n    _taskState = GET_CFG_TEXT(\"defaultState\");\n\n    if (_taskState isEqualTo \"\") then {\n        _taskState = \"CREATED\";\n    };\n};\n\nif (_destination isEqualTo configNull) then {\n\n    private _compiledDestination = GET_CFG_TEXT(\"compiledDestination\");\n    if (_compiledDestination isNotEqualTo \"\") then {\n        _destination = call (compileFinal _compiledDestination);\n    };\n\n    if ((_destination isEqualType objNull) AND {!(isNull _destination)}) exitWith {};\n    if (\n        (_destination isEqualTypeParams [123,123,123]) OR \n        (_destination isEqualTypeParams [objNull,123])\n    ) exitWith {};\n\n\n    _destination = GET_CFG_ARRAY(\"destination\");\n    if (_destination isEqualTo []) then {\n        _destination = objNull;\n    };\n};\n\nif (_type isEqualTo configNull) then {\n    _type = GET_CFG_TEXT(\"type\");\n\n    if (_type isEqualTo \"\") then {\n        _type = \"DEFAULT\";\n    };\n};\n\nif (_notifyOnCreate isEqualTo configNull) then {\n    if !(isNull (_config >> \"notifyOnCreate\")) then {\n        _notifyOnCreate = true;\n    } else {\n        _notifyOnCreate = GET_CFG_BOOL(\"notifyOnCreate\");\n    };\n};\n\nif (_visibleIn3D isEqualTo configNull) then {\n    _visibleIn3D = GET_CFG_BOOL(\"visibleIn3D\");\n};\n\n\nprivate _taskTitle = GET_CFG_TEXT(\"title\");\nprivate _taskDescription = GET_CFG_TEXT(\"description\");\nprivate _priority = GET_CFG_NUMBER(\"priority\");\n\nprivate _parentTaskId = GET_CFG_TEXT(\"parentTask\");\nif (_parentTaskId isNotEqualTo \"\") then {\n    _taskId = [_taskId,_parentTaskId];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Create Task\n---------------------------------------------------------------------------- */\nprivate _createdTask = [\n    _owner,\n    _taskId,\n    [_taskDescription,_taskTitle],\n    _destination,\n    _taskState,\n    _priority,\n    _notifyOnCreate,\n    _type,\n    _visibleIn3D\n] call BIS_fnc_taskCreate;\n\n\nif (_createdTask isNotEqualTo \"\") then {\n    private _onCreateCode = GET_CFG_TEXT(\"onCreate\");\n\n    if (_onCreateCode isNotEqualTo \"\") then {\n        [_taskId,_config,_taskState] call (compile _onCreateCode);\n    };\n\n    // do onComplete code if already ended\n    if (\n        _taskState == \"SUCCEEDED\" OR\n        (_taskState == \"FAILED\") OR\n        (_taskState == \"CANCELED\")\n    ) then {\n        private _onCompleteCode = GET_CFG_TEXT(\"onComplete\");\n        [_taskId,_config,_taskState] call (compile _onCompleteCode);\n    };\n};\n\n\n_createdTask\n",
    "fileName": "fn_createTaskFromConfig.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Tasks/fn_createTaskFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_endTask\n\nDescription:\n    Either completes, cancels, or ends a task and calls the task's onComplete\n     event if it is defined in KISKA_cfgTasks.\n\n    Meant to be paired with KISKA_fnc_createTaskFromConfig.\n\nParameters:\n    0: _taskId <STRING> - The task id/KISKA_cfgTasks class name\n    1: _state <NUMBER> - 0 for SUCCEEDED, 1 for FAILED, 2 for CANCELED\n    2: _notify <BOOL> - Should a nortification be shown\n    4: _owner <BOOL, OBJECT, GROUP, SIDE, or ARRAY> - Whom the task is assigned to\n        (this is only needed in the event that the task is ended without it having been created)\n\nReturns:\n    <BOOL> - Whether or not the state of the task was set to the desired one\n\nExamples:\n    (begin example)\n        private _taskIsSucceeded = [\"mytaskID\",0] call KISKA_fnc_endTask;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_endTask\";\n\n#define STATE_SUCCEEDED 0\n#define STATE_FAILED 1\n#define STATE_CANCELED 2\n\nparams [\n    [\"_taskId\",\"\",[\"\",configNull]],\n    [\"_state\",0,[123]],\n    [\"_notify\",configNull],\n    [\"_owner\",true,[true,objNull,grpNull,sideUnknown,[]]]\n];\n\n\nif (isMultiplayer AND {!isServer}) exitWith {\n    [\"Not Server, remoteExecuting on server...\"] call KISKA_fnc_log;\n    _this remoteExecCall [\"KISKA_fnc_endTask\",2];\n    \"\"\n};\n\n\nprivate _config = _taskId;\nif (_taskId isEqualType \"\") then {\n    _config = missionConfigFile >> \"KISKA_cfgTasks\" >> _taskId;\n} else {\n    _taskId = configName _config;\n};\n\nprivate _taskHasClass = isClass _config;\n// if you want config default value\nif (_notify isEqualTo configNull) then {\n    if (_taskHasClass) then {\n        // if config entry for notifyOnComplete is present\n        if !(isNull (_config >> \"notifyOnComplete\")) then {\n            _notify = true;\n\n        } else {\n            _notify = [_config >> \"notifyOnComplete\"] call BIS_fnc_getCfgDataBool;\n\n        };\n\n    } else {\n        _notify = true;\n\n    };\n};\n\nswitch _state do {\n    case STATE_SUCCEEDED:{\n        _state = \"SUCCEEDED\";\n    };\n\n    case STATE_FAILED:{\n        _state = \"FAILED\";\n    };\n\n    case STATE_CANCELED:{\n        _state = \"CANCELED\";\n    };\n    default {};\n};\n\n\nprivate _taskSet = false;\nif ([_taskId] call BIS_fnc_taskExists) then {\n    _taskSet = [_taskId,_state,_notify] call BIS_fnc_taskSetState;\n\n    if (_taskHasClass) then {\n        private _completeEvent = getText(_config >> \"onComplete\");\n\n        if (_completeEvent isNotEqualTo \"\") then {\n            [_taskId,_config,_state] call (compile _completeEvent);\n        };\n    };\n\n} else {\n    [\n        _config,\n        _owner,\n        _state,\n        configNull,\n        configNull,\n        _notify\n    ] call KISKA_fnc_createTaskFromConfig;\n\n    _taskSet = true;\n};\n\n\n_taskSet\n",
    "fileName": "fn_endTask.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Tasks/fn_endTask.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_executeEvent\n\nDescription:\n    Executes a recursive chain timeline events. This should not be executed on its\n     own but begins from KISKA_fnc_timeline_start.\n\nParameters:\n    0: _timelineEvents <ARRAY> - An array of timeline events that will happen. \n        See KISKA_fnc_timeline_start for formats\n    1: _timelineId <STRING> - The id of the timeline to stop\n    2: _timelineMap <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n    3: _previousReturn <ANY> - The returned value from the previous events function\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_timelineEvents,\"KISKA_timeline_1\"] call KISKA_fnc_timeline_executeEvent\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_executeEvent\";\n\nparams [\n    [\"_timelineEvents\",[],[[]]],\n    [\"_timelineId\",\"\",[\"\"]],\n    \"_timelineMap\",\n    \"_previousReturn\"\n];\n\n\nprivate _timelineIsRunning = [_timelineId,false] call KISKA_fnc_timeline_isRunning;\nif !(_timelineIsRunning) exitWith {\n    // execute call back function for when timeline is stopped here only\n    private _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\n    private _timelineValues = _overallTimelineMap getOrDefault [_timelineId,[]];\n    _timelineValues params [\n        [\"_timelineValueEvents\",[],[[]]],\n        \"_timelineMap\",\n        [\"_onTimelineStopped\",{},[[],{},\"\"]]\n    ];\n\n    if (_onTimelineStopped isNotEqualTo {}) then {\n        [[_timelineValueEvents,_timelineMap],_onTimelineStopped] call KISKA_fnc_callBack;\n    };\n\n    _overAllTimelineMap deleteAt _timelineId;\n\n\n    nil\n};\n\n\nprivate _event = _timelineEvents deleteAt 0;\n_event params [\n    [\"_code\",{},[[],{},\"\"]],\n    [\"_waitFor\",0,[123,{},\"\",[]]],\n    [\"_interval\",0,[123]]\n];\n\nprivate _eventReturn = [_this,_code] call KISKA_fnc_callBack;\n// this is checked right after event call in case timeline was cleared during event\nif (_timelineEvents isEqualTo []) then {\n    [_timelineId] call KISKA_fnc_timeline_stop;\n};\n\n\nprivate _nextEventParams = [_timelineEvents,_timelineId,_timelineMap];\nif !(isNil \"_eventReturn\") then {\n    _nextEventParams pushBack _eventReturn\n};\n\n\nif (_waitFor isEqualType 123) exitWith {\n    [\n        KISKA_fnc_timeline_executeEvent,\n        _nextEventParams,\n        _waitFor\n    ] call CBA_fnc_waitAndExecute;\n\n    nil\n};\n\n\n[\n    _waitFor,\n    KISKA_fnc_timeline_executeEvent,\n    _interval,\n    _nextEventParams\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_timeline_executeEvent.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_executeEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_getInfoMap\n\nDescription:\n    The Individual map defined for a specific timeline of the given ID. This is\n     the hashmap available in each timeline's event's code.\n\nParameters:\n    0: _timelineId <STRING> - The id of the timeline to get\n\nReturns:\n    <HASHMAP> - A hashmap containing information for the timeline events\n\nExamples:\n    (begin example)\n        private _timelineMapForId = [\"KISKA_timeline_1\"] call KISKA_fnc_timeline_getInfoMap;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_getInfoMap\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]]\n];\n\n\nprivate _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\nif !(_timelineId in _overallTimelineMap) then {\n    [[\"_timlineId: \",_timlineId,\" does not exist!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _timelineInfo = _overallTimelineMap get _timelineId;\n_timelineInfo select 1\n",
    "fileName": "fn_timeline_getInfoMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_getInfoMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_getIsRunningMap\n\nDescription:\n    Returns the map that keeps track of whether or not a given KISKA timeline is\n\t currently running.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - The \"is running\" map\n\nExamples:\n    (begin example)\n        private _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_getIsRunningMap\";\n\nprivate _isRunningMap = localNamespace getVariable [\"KISKA_timeline_isRunningMap\",-1];\nif (_isRunningMap isEqualTo -1) then {\n\t_isRunningMap = createHashMap;\n\tlocalNamespace setVariable [\"KISKA_timeline_isRunningMap\",_isRunningMap];\n};\n\n\n_isRunningMap\n",
    "fileName": "fn_timeline_getIsRunningMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_getIsRunningMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_getMainMap\n\nDescription:\n    The map that links a given timeline id to its info map. This is an internal function\n     that you (likely) don't need to use except for altering timelines that have already started.\n     \n    See `KISKA_fnc_timeline_getInfoMap` to retrieve an info map for a given timeline.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - The overall timeline map to get info on certain timelines\n\nExamples:\n    (begin example)\n        private _mainTimelineMap = call KISKA_fnc_timeline_getMainMap;\n        private _timelineId = \"KISKA_timeline_1\";\n        private _timelineValues = _mainTimelineMap get _timelineId;\n        _timelineValues params [\"_timelineEvents\",\"_timelineMap\",\"_onTimelineStopped\"];\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_getMainMap\";\n\nprivate _mainMap = localNamespace getVariable \"KISKA_timeline_mainMap\";\nif (isNil \"_mainMap\") then {\n    _mainMap = createHashMap;\n    localNamespace setVariable [\"KISKA_timeline_mainMap\",_mainMap];\n};\n\n\n_mainMap\n",
    "fileName": "fn_timeline_getMainMap.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_getMainMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_isRunning\n\nDescription:\n    Checks if a timeline has either fully been complete (_checkForFullCompletion = true) \n     or is simply qued for end at the start of its next event (_checkForFullCompletion = false).\n\nParameters:\n    0: _timelineId <STRING> - The id of the timeline to check\n    1: _checkForFullCompletion <BOOL> - Check if the timeline's onComplete function has \n        completed and the timeline is fully done.\n\nReturns:\n    <BOOL> - The state of the timeline\n\nExamples:\n    (begin example)\n        private _isRunning = [\"KISKA_timeline_1\",false] call KISKA_fnc_timeline_isRunning;\n    (end)\n\n    (begin example)\n        private _timelineIsNotComplete = [\"KISKA_timeline_1\",true] call KISKA_fnc_timeline_isRunning;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_isRunning\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]],\n    [\"_checkForFullCompletion\",true,[true]]\n];\n\n\nif (_checkForFullCompletion) exitWith {\n    private _timelineMap = call KISKA_fnc_timeline_getMainMap;\n    _timelineId in _timelineMap\n};\n\n\nprivate _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n_isRunningMap getOrDefault [_timelineId,false]\n",
    "fileName": "fn_timeline_isRunning.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_isRunning.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_setIsRunning\n\nDescription:\n    Sets whether a given timeline is considered to be running.\n\nParameters:\n    0: _timelineId <STRING> - The timeline's id\n    1: _isRunning <BOOL> - `true` to set as running, `false` to set as NOT\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // internal function that should not be directly called\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_setIsRunning\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]],\n    [\"_isRunning\",true,[true]]\n];\n\n\nprivate _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n_isRunningMap set [_timelineId,_isRunning];\n\n\nnil\n",
    "fileName": "fn_timeline_setIsRunning.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_setIsRunning.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_start\n\nDescription:\n    Creates a timeline of events that can happen. Waits/executes in an unscheduled\n     environment. \n    \n    There is a non-trivial amount of overhead to this, however, so\n     do not use with the intention of needing precise events to happen but rather to\n     not clog the scheduler or use a decent interface with smaller units of code.\n\n    (begin example)\n        // A timeline is made up of events:\n        [\n            [], // event 1\n            [] // event 2\n        ]\n    (end)\n\n    (begin example)\n        // Each event is made up of code to execute when the event comes up in the timeline,\n        /// and what to wait for when executing the NEXT event in the timeline AFTER the \n        /// current event completes:\n        [\n            [\n                {\n                    hint \"executed event #1\"\n                },\n                3 // wait 3 seconds AFTER current event to execute event 2\n            ],\n            [\n                {\n                    hint \"executed event #2 3 seconds after event 1 completed\"\n                },\n                1 // wait 1 second to run _onTimelineStopped code\n            ]\n        ]\n    (end)\n    \n    (begin example)\n        // Alternativeley, you can also wait for a condition before proceeeding to the next event:\n        private _endTime = time + 10;\n        [\n            [\n                {hint \"executed event #1\"},\n                3 // wait 3 seconds AFTER current event to execute event 1\n            ],\n            [\n                {hint \"executed event #2 3 seconds after event 1 completed\"},\n                [[_endTime],{\n                    _thisArgs params [\"_endTime\"];\n                    time >= (_endTime) // wait until current time is more than _endTime\n                }],\n                1 // check condition every second\n            ]\n        ]\n    (end)\n\n    (begin example)\n        // You can chain timeline events together by returning\n        [\n            [\n                {\n                    hint \"executed event #1\";\n                    time + 3 // return/send to the next event and current wait condition\n                },\n                {\n                    params [\"\",\"\",\"\",\"_eventReturn\"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                }\n            ],\n            [\n                {hint \"executed event #2 ~3 seconds after event 1 completed\"}\n            ]\n        ]\n    (end)\n\nParameters:\n    0: _timeline <ARRAY> - An array of timeline events that will happen. \n        See description above for formats.\n    1: _onTimelineStopped <CODE, STRING, or ARRAY> - (see KISKA_fnc_callBack),\n        code that will be executed once a timeline is stopped. \n            \n        Parameters:\n        - 0: <ARRAY> - The timeline array in the state when the stoppage actually happens.\n        - 1: <HASHMAP> - The individual map defined for a specific timeline of the given ID.\n\nReturns:\n    <STRING> - The id of the new timeline\n\nExamples:\n    (begin example)\n        private _timeline = [\n            [\n                {\n                    hint \"executed event #1\";\n                    time + 3 // return/send to next and current wait condition\n                },\n                {\n                    params [\"\",\"\",\"_eventReturn\"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint \"executed event #2 ~3 seconds after event 1 completed\"}, 2\n            ]\n        ];\n        private _timelineId = [_timeline,{hint \"timeline end\"}] call KISKA_fnc_timeline_start;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_start\";\n\nparams [\n    [\"_timeline\",[],[[]]],\n    [\"_onTimelineStopped\",{},[[],{},\"\"]]\n];\n\nif (_timeline isEqualTo []) exitWith {\n    [\"Empty _timeline provided\"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _timelineId = [\"KISKA_timeline\"] call KISKA_fnc_generateUniqueId;\n[_timelineId,true] call KISKA_fnc_timeline_setIsRunning;\n\nprivate _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\nprivate _timelineHashmap = createHashMap;\nprivate _timelineValues = [_timeline,_timelineHashmap];\nif (_onTimelineStopped isNotEqualTo {}) then {\n    _timelineValues pushBack _onTimelineStopped;\n};\n\n_overallTimelineMap set [_timelineId,_timelineValues];\n\n[\n    _timeline,\n    _timelineId,\n    _timelineHashmap\n] call KISKA_fnc_timeline_executeEvent;\n\n\n_timelineId\n",
    "fileName": "fn_timeline_start.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_start.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_stop\n\nDescription:\n    Ques a timeline to end on the next execution of an event in it or at the very\n     end of the timeline. This will immediately set KISKA_fnc_timeline_isRunning\n     (where _isFullyComplete-is-false) to be true.\n\nParameters:\n    0: _timelineId <STRING> - The id of the timeline to stop\n    1: _onTimelineStopped <CODE, STRING, or ARRAY> - (see KISKA_fnc_callBack),\n        code that will be executed once a timeline is stopped. \n        \n        Parameters:\n        - 0: <ARRAY> - The timeline array in the state when the stoppage actually happens.\n        - 1: <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"KISKA_timeline_1\"] call KISKA_fnc_timeline_stop;\n    (end)\n\n    (begin example)\n        [\"KISKA_timeline_1\",{hint str [\"timeline stopped!\",_this]}] call KISKA_fnc_timeline_stop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_stop\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]],\n    [\"_onTimelineStopped\",{},[[],{},\"\"]]\n];\n\n\nif (_onTimelineStopped isNotEqualTo {}) then {\n    private _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\n    private _timelineValues = _overallTimelineMap getOrDefault [_timelineId,[]];\n    private _timelineHasNotEnded = _timelineValues isNotEqualTo [];\n    if (_timelineHasNotEnded) then {\n        _timelineValues set [2,_onTimelineStopped];\n    };\n};\n\n\nprivate _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n_isRunningMap deleteAt _timelineId;\n\n\nnil\n",
    "fileName": "fn_timeline_stop.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Timeline/fn_timeline_stop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addArsenal\n\nDescription:\n    Adds both BIS and ACE arsenals to several or a single object.\n    This has a global effect.\n\nParameters:\n    0: _arsenals <ARRAY or OBJECT> - An array of objects or a single one to add arsenals to\n\nReturns:\n    <BOOL> - True if arsenal added, false if not\n\nExamples:\n    (begin example)\n        [[arsenal1, arsenal2]] call KISKA_fnc_addArsenal;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addArsenal\";\n\nparams [\n    [\"_arsenals\",[],[[],objNull]]\n];\n\nif (_arsenals isEqualTo [] OR {(_arsenals isEqualType objNull) AND {isNull _arsenals}}) exitWIth {\n    [[\"_arsenals are invalid: \",str _arsenals],true] call KISKA_fnc_log;\n    false\n};\n\nif !(_arsenals isequalType []) then {\n    _arsenals = [_arsenals];\n};\n\nprivate _aceLoaded = [\"ace_arsenal\"] call KISKA_fnc_isPatchLoaded;\n\n_arsenals apply {\n    \n    if (_aceLoaded) then {\n        [_x, true, true] call ace_Arsenal_fnc_InitBox;\n    };\n    \n    [\"AmmoboxInit\",[_x,true]] call BIS_fnc_arsenal;\n};\n\n\ntrue",
    "fileName": "fn_addArsenal.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_addArsenal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addEntityKilledEventHandler\n\nDescription:\n    Adds a killed event handler to a given entity that will persist even if the\n     unit becomes remote. The order of execution is not guaranteed to be in the\n     order added.\n\nParameters:\n    0: _entity <OBJECT> - The entity to add the object to\n    1: _event <CODE, STRING, or ARRAY> - The code to execute (SEE KISKA_fnc_callBack for array syntax).\n        \n        Parmeters:\n        - 0. <OBJECT> - The killed entity\n        - 1. <OBJECT> - The killer entity (vehicle or person)\n        - 2. <OBJECT> - The instigator entity\n        - 3. <BOOL> - same as useEffects in `setDamage` alt syntax\n\nReturns:\n    <NUMBER> - The entity killed event handler ID for the unit\n\nExamples:\n    (begin example)\n        private _id = [aUnit,{hint _this}] call KISKA_fnc_addEntityKilledEventHandler;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addEntityKilledEventHandler\";\n\nparams [\n    [\"_entity\",objNull,[objNull]],\n    [\"_event\",{},[\"\",{},[]]]\n];\n\n\nif (isNull _entity) exitWith {\n    [\"null _entity was passed\",true] call KISKA_fnc_log;\n    -1\n};\n\n\nif (localNamespace getVariable [\"KISKA_entityKilledHandlerInitialized\",false]) then {\n    localNamespace setVariable [\"KISKA_entityKilledHandlerInitialized\",true];\n    addMissionEventHandler [\"EntityKilled\",{\n        params [\"_unit\"];\n        \n        private _entityKilledEventHashMap = _unit getVariable \"KISKA_entityKilledEventHashMap\";\n        if !(isNil \"_entityKilledEventHashMap\") then {\n            private _codeForEvents = values _entityKilledEventHashMap;\n            _codeForEvents apply {\n                [_this, _x] call KISKA_fnc_callBack;\n            };\n        };\n    }];\n};\n\n\nprivate _eventHashMap = _entity getVariable \"KISKA_entityKilledEventHashMap\";\nif (isNil \"_eventHashMap\") then {\n    _eventHashMap = createHashMap;\n    _entity setVariable [\"KISKA_entityKilledEventHashMap\",_eventHashMap];\n};\n\nprivate _id = [\"KISKA_entityKilledIdCount\",_entity] call KISKA_fnc_idCounter;\n_eventHashMap set [_id,_event];\n\n\n_id\n",
    "fileName": "fn_addEntityKilledEventHandler.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_addEntityKilledEventHandler.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addKiskaDiaryEntry\n\nDescription:\n    Used as a unified point of adding diary entries for KISKA.\n\nParameters:\n    0: _textEntry <STRING or ARRAY> - The text entry in createDiaryRecord.\n        If array, format is [title,description,icon].\n    1: _task <TASK> - A task attached to the diary record\n    2: _taskState <STRING> - The state of the task\n    3: _showTitle <BOOL> - Whether or not to show title in the description section as well\n\nReturns:\n    <DIARY-RECORD> - An entry in the users diary\n\nExamples:\n    (begin example)\n        [[\"test title\",\"test text\"]] call KISKA_fnc_addKiskaDiaryEntry;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\n#define KISKA_DIARY \"KISKA Systems\"\nscriptName \"KISKA_fnc_addKiskaDiaryEntry\";\n\nif !(hasInterface) exitWith {diaryRecordNull};\n\nif !(player diarySubjectExists KISKA_DIARY) then {\n    player createDiarySubject [KISKA_DIARY, KISKA_DIARY];\n};\n\nparams [\n    [\"_textEntry\",\"\",[\"\",[]]],\n    [\"_task\",taskNull,[taskNull]],\n    [\"_taskState\",\"\",[\"\"]],\n    [\"_showTitle\",true,[true]]\n];\n\nplayer createDiaryRecord [KISKA_DIARY,_textEntry,_task,_taskState,_showTitle];\n",
    "fileName": "fn_addKiskaDiaryEntry.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_addKiskaDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addMagRepack\n\nDescription:\n    Adds a mag repack to the player via Ctrl+R.\n    To remove see KISKA_fnc_removeMagRepack.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_addMagRepack;\n    (end)\n\nAuthor(s):\n    Quicksilver,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addMagRepack\";\n\n#define DISPLAY_CODE 46\n#define R_KEY_CODE 19\n\nif (!hasInterface) exitWith {};\n\nif (localNamespace getVariable [\"KISKA_magRepackEventId\",-1] isNotEqualTo -1) exitWith {\n    [\"Mag repack has already been added\",true] call KISKA_fnc_log;\n    nil\n};\n\n[\n    {\n        !(isNull (findDisplay DISPLAY_CODE))\n    },\n    {\n        // possibility of two mag repack waitUntils runnning at once\n        if (localNamespace getVariable [\"KISKA_magRepackEventId\",-1] isNotEqualTo -1) exitWith {\n            [\"Mag repack has already been added\",true] call KISKA_fnc_log;\n            nil\n        };\n\n        private _eventId = (findDisplay DISPLAY_CODE) displayAddEventHandler [\"KeyDown\",{\n            params [\"\", \"_key\", \"\", \"_ctrlPressed\"];\n            // passes the pressed key and whether or not a ctrl key is down. The proper combo is ctrl+R\n            if ((_key isEqualTo R_KEY_CODE) AND (_ctrlPressed)) then {\n                [player] call KISKA_fnc_doMagRepack;\n            };\n\n            false\n        }];\n\n        localNamespace setVariable [\"KISKA_magRepackEventId\",_eventId];\n    },\n    0.1\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_addMagRepack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_addMagRepack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addProximityPlayerAction\n\nDescription:\n    Adds an action to the player that will be activated and deactivated when within\n     a certain radius of a given position.\n\nParameters:\n    0: _center : <OBJECT or ARRAY> - The position the player needs to be close to.\n        If array, format as Postion2D or PositionAGL.\n    1: _radius : <NUMBER> - The max distance the player can be from the _center to\n        get the action.\n    2: _action : <ARRAY> - The action array used with \"addAction\" command\n    3: _refreshInterval : <NUMBER> - How often to look to update action visibility\n\nReturns:\n    <NUMBER> - The porximity action id to be used with KISKA_fnc_removeProximityPlayerAction\n        (-1 if failure)\n\nExamples:\n    (begin example)\n        [\n            cursorObject,\n            15,\n            [\"test\",{hint \"action\"},[]]\n        ] call KISKA_fnc_addProximityPlayerAction\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addProximityPlayerAction\";\n\nif (!hasInterface) exitWith {\n    [\"Can't be added to headless user\", false] call KISKA_fnc_log;\n    -1\n};\n\n\nparams [\n    [\"_center\",objNull,[[],objNull]],\n    [\"_radius\",5,[123]],\n    [\"_action\",[],[[]]],\n    [\"_refreshInterval\",1,[123]]\n];\n\nif (_center isEqualType objNull AND {isNull _center}) exitWith {\n    [\"_center is null object\", true] call KISKA_fnc_log;\n    -1\n};\n\n\nprivate _proximityActionId = [\"KISKA_proximityPlayerActionLatestId\"] call KISKA_fnc_idCounter;\nprivate _varBase = \"KISKA_proximityAction_\" + (str _proximityActionId);\nprivate _actionShouldBeRemovedVar = _varBase + \"_remove\";\nprivate _actionIdVar = _varBase + \"_currentId\";\nlocalNamespace setVariable [_actionShouldBeRemovedVar, false];\nlocalNamespace setVariable [_actionIdVar, -1];\n\n[\n    {\n        params [\n            \"_center\",\n            \"_radius\",\n            \"_action\",\n            \"_refreshInterval\",\n            \"_actionShouldBeRemovedVar\",\n            \"_actionIdVar\"\n        ];\n\n        private _actionId = localNamespace getVariable [_actionIdVar, -1];\n        private _playerInRange = player distance _center <= _radius;\n        private _actionIsVisible = _actionId isNotEqualTo -1;\n\n        if (_playerInRange AND !(_actionIsVisible)) exitWith {\n            _actionId = player addAction _action;\n            localNamespace setVariable [_actionIdVar, _actionId];\n            false;\n        };\n\n        private _endAction = localNamespace getVariable [_actionShouldBeRemovedVar, false];\n        if (\n            _actionIsVisible AND\n            (!_playerInRange OR _endAction)\n        ) then {\n            player removeAction _actionId;\n            localNamespace setVariable [_actionIdVar, -1];\n        };\n\n        _endAction\n    },\n    {\n        params [\"\",\"\",\"\",\"\",\"_actionShouldBeRemovedVar\",\"_actionIdVar\"];\n\n        localNamespace setVariable [_actionShouldBeRemovedVar, nil];\n        localNamespace setVariable [_actionIdVar, nil];\n    },\n    _refreshInterval,\n    [\n        _center,\n        _radius,\n        _action,\n        _refreshInterval,\n        _actionShouldBeRemovedVar,\n        _actionIdVar\n    ]\n] call KISKA_fnc_waitUntil;\n\n\n_proximityActionId\n",
    "fileName": "fn_addProximityPlayerAction.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_addProximityPlayerAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addTeleportAction\n\nDescription:\n    Adds a hold action to an object to teleport to a desired location.\n\nParameters:\n    0: _objectToAddTo <OBJECT> - The object the action will be attached to\n    1: _teleportPosition <ARRAY OR OBJECT> - The position to be teleported to upon completion\n    2: _text <STRING> - The action text, can be structured text\n    3: _conditionShow <STRING> - A string that will compile into an expression that\n        evals to a boolean. True means that the action will be shown.\n\nReturns:\n    <NUMBER> - action id, -1 if not added\n\nExamples:\n    (begin example)\n        [player,[0,0,0],\"go to the Zero\"] call KISKA_fnc_addTeleportAction;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addTeleportAction\";\n\nparams [\n    [\"_objectToAddTo\",objNull,[objNull]],\n    [\"_teleportPosition\",[0,0,0],[objNull,[]]],\n    [\"_text\",\"<t color='#FFAA00'>Teleport</t>\",[\"\"]],\n    [\"_conditionShow\",\"true\",[\"\"]]\n];\n\nif (isNull _objectToAddTo) exitWith {\n    [\"_objectToAddTo is null\"] call KISKA_fnc_log;\n    -1\n};\n\nif (_teleportPosition isEqualType objNull) then {\n    _teleportPosition = getPosWorld _teleportPosition;\n};\n\n[\n    _objectToAddTo,\n    _text,\n    \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_takeOff1_ca.paa\",\n    \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_connect_ca.paa\",\n    _conditionShow,\n    \"true\",\n    {},\n    {},\n    {\n        (_this select 1) setPosWorld ((_this select 3) select 0);\n    },\n    {},\n    [_teleportPosition],\n    0.5,\n    991,\n    false,\n    false,\n    true\n] call BIS_fnc_holdActionAdd;\n",
    "fileName": "fn_addTeleportAction.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_addTeleportAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_alivePlayers\n\nDescription:\n    FInds all alive players with or without headless clients\n\nParameters:\n    0: _noHeadless <BOOL> - Seperate Headless Clients\n\nReturns:\n    _alivePlayers <ARRAY> - All alive players\n\nExamples:\n    (begin example)\n        [true] call KISKA_fnc_alivePlayers;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_alivePlayers\";\n\nparams [\n    [\"_seperateHeadless\",true,[true]]\n];\n\nprivate \"_alivePlayers\";\n\nif (_seperateHeadless) then {\n    _alivePlayers = (call CBA_fnc_players) select {alive _x};\n} else {\n    _alivePlayers = allPlayers select {alive _x};\n};\n\n_alivePlayers\n",
    "fileName": "fn_alivePlayers.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_alivePlayers.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_balanceHeadless\n\nDescription:\n    Balances AI among all logged Headless Clients in a very simple fashion.\n    Designed to be run once and also should only be done when all HC are logged onto the server.\n\n    Excluded groups and units can be added to the array KISKA_hcExcluded.\n\nParameters:\n    0: _checkInterval <NUMBER> - How often to redistribute, if -1, will not loop\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] spawn KISKA_fnc_balanceHeadless;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_balanceHeadless\";\n\nif (!isServer OR {!isMultiplayer}) exitWith {\n    [\"Needs to be run on server in multiplayer\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled; running in scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_balanceHeadless;\n};\n\nparams [\n    [\"_checkInterval\",-1,[123]]\n];\n\nprivate _headlessClients = entities \"HeadlessClient_F\";\n\nif (_headlessClients isEqualTo []) exitWith {\n    if (_checkInterval > 0) then {\n        [\n            {\n                _this spawn KISKA_fnc_balanceHeadless;\n            },\n            [_checkInterval],\n            _checkInterval\n        ] call CBA_fnc_waitAndExecute;\n    };\n};\n\nif !((missionNamespace getVariable [\"KISKA_hcExcluded\",[]]) isEqualTo []) then {\n    private _excluded = missionNamespace getVariable [\"KISKA_hcExcluded\",[]];\n\n    if !(_excluded isEqualTo []) then {\n        {\n            if !(_x isEqualTypeAny [grpNull,objNull]) then {\n                [[_x,\" is not an object or group in KISKA_hcExcluded!\"],true] call KISKA_fnc_log;\n            };\n\n            // replace object excluded with their groups\n            if (_x isEqualType objNull) then {\n                _excluded set [_forEachIndex,group _x];\n            };\n        } forEach _excluded;\n    };\n\n    missionNamespace setVariable [\"KISKA_hcExcluded\",_excluded];\n};\n\n// everyone goes basck to 0 for even redistribution\n_headlessClients apply {\n    _x setVariable [\"KISKA_hcLocalUnitsCount\",0];\n};\n\n[\"Headless ReBalance Is Beginning\"] remoteExecCall [\"hint\",0];\n\nallGroups apply {\n    private _group = _x;\n\n    if !(_group in (missionNamespace getVariable [\"KISKA_hcExcluded\",[]])) then {\n        // each headless client has a count of how many local units it has\n        private _localUnitsCountArray = [];\n        // an array of each of the headless client entities\n        private _headlessArray = [];\n\n        _headlessClients apply {\n            _localUnitsCountArray pushBack (_x getVariable [\"KISKA_hcLocalUnitsCount\",0]);\n            _headlessArray pushBackUnique _x;\n        };\n\n        // see who has the least units\n        private _leastUnits = selectMin _localUnitsCountArray;\n        // get the index of them in _headlessArray so that we can see how many local units they have in _localUnitsCountArray\n        private _index = _localUnitsCountArray findIf {_leastUnits isEqualTo _x};\n        // select that headless client\n        private _bestHeadless = _headlessArray select _index;\n        // And lastly get their actual ID\n        private _bestHeadlessID = owner _bestHeadless;\n\n        // verify units are migrated before proceeding\n        waitUntil {\n            if ((owner _group) isEqualTo _bestHeadlessID) exitWith {true};\n            _group setGroupOwner _bestHeadlessID;\n\n            uiSleep 0.1;\n            false\n        };\n\n        // get the units migrated and how many\n        private _unitsInGroup = units _group;\n        private _newTotal = _leastUnits + (count _unitsInGroup);\n\n        // update HC global count of its local units\n        _bestHeadless setVariable [\"KISKA_hcLocalUnitsCount\",_newTotal];\n\n        // add the units to a global attached to the HC so they can be referenced and subtracted at death\n        private _localUnitsArray = _bestHeadless getVariable [\"KISKA_hcLocalUnits\",[]];\n        _unitsInGroup apply {\n            _localUnitsArray pushBack _x;\n        /*\n            // add a MP eventhandler that runs on the server for when the AI is killed so that they can be subtracted from the count and array of local units\n            _x addMPEventHandler [\"MPKilled\",{\n\n                params [\"_unit\"];\n\n                if (isServer) then {\n                    private _headlessClients = entities \"HeadlessClient_F\";\n\n                    _headlessClients apply {\n                        private _headlessClient = _x;\n                        private _localUnitsArray = _headlessClient getVariable [\"KISKA_hcLocalUnits\",[]];\n\n                        if (_unit in _localUnitsArray) exitWith {\n\n                            // take unit out of array\n                            _localUnitsArray deleteAt (_localUnitsArray findIf {_x isEqualTo _unit});\n\n                            _unit removeMPEventHandler [\"MPKilled\",_thisEventHandler];\n\n                            true\n                        };\n                    };\n                };\n\n            }];\n        */\n        };\n    };\n\n    uiSleep 0.5;\n};\n\naddMissionEventHandler [\"EntityKilled\", {\n    params [\"_unit\"];\n\n    if (_unit isKindOf \"MAN\" AND {!(local _unit)} AND {!(_unit in allPlayers)}) then {\n        private _owner = owner _unit;\n        private _allHeadlessClients = entities \"HeadlessClient_F\";\n        private _index = _allHeadlessClients findIf {_owner isEqualTo (owner _x)};\n\n        if (_index isEqualTo -1) then {\n            private _headlessClient = _allHeadlessClients select _index;\n            private _localUnitsArray = _headlessClient getVariable [\"KISKA_hcLocalUnits\",[]];\n\n            if (_unit in _localUnitsArray) then {\n                private _localUnitsCount = _headlessClient getVariable [\"KISKA_hcLocalUnitsCount\",1];\n                _headlessClient setVariable [\"KISKA_hcLocalUnitsCount\",_localUnitsCount - 1];\n                /*\n                    For eventual smarter redistribution of totals...\n\n                    // get current total local units\n                    private _localUnitsCount = _headlessClient getVariable \"KISKA_hcLocalUnitsCount\";\n                    _localUnitsCount = _localUnitsCount - 1;\n                    // set new total\n                    _headlessClient setVariable [\"KISKA_hcLocalUnitsCount\",_localUnitsCount];\n                */\n\n                // take unit out of array\n                _localUnitsArray deleteAt (_localUnitsArray findIf {_x isEqualTo _unit});\n            };\n        };\n\n    };\n}];\n\n[\"Headless ReBalance Is COMPLETE\"] remoteExec [\"hint\",0];\n\nif (_checkInterval > 0 AND {_checkInterval != -1}) then {\n    sleep _checkInterval;\n\n    [_checkInterval] spawn KISKA_fnc_balanceHeadless;\n};\n",
    "fileName": "fn_balanceHeadless.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_balanceHeadless.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callBack\n\nDescription:\n    Standerdizes a means of passing a callback function to another function\n    along with custom arguments.\n\nParameters:\n    0: _defaultArgs <ANY> - Default arguements. These would be what a function\n        writer would put inside of their code as arguements that will always be passed\n        in the _this magic variable\n    1: _callBackFunction <CODE, STRING, ARRAY> - Code to call, compile and call, and/or\n        arguements to pass to the code (in _thisArgs variable). Array is formatted as\n        [<args array>,code or string (to compile)]\n    2: _runInScheduled <BOOL> - Spawns the code in a scheduled thread\n\nReturns:\n    <ANY> - Whatever the callback function returns or scripthandle if run in scheduled\n\nExamples:\n    (begin example)\n        [\n            [],\n            [\n                // hint player\n                [player],\n                {hint (_thisArgs select 0)}\n            ]\n        ] call KISKA_fnc_callBack\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callBack\";\n\nparams [\n    [\"_defaultArgs\",[]],\n    [\"_callBackFunction\",{},[[],\"\",{}]],\n    [\"_runInScheduled\",false,[true]]\n];\n\n\nprivate \"_actualCallBackFunction\";\nprivate _thisArgs = [];\ncall {\n    if (_callBackFunction isEqualType {}) exitWith {\n        _actualCallBackFunction = _callBackFunction;\n    };\n\n    if (_callBackFunction isEqualType []) exitWith {\n        if (_callBackFunction isEqualTypeParams [[],\"\"]) exitWith {\n            _thisArgs = _callBackFunction select 0;\n            _actualCallBackFunction = compile (_callBackFunction select 1);\n        };\n\n        if (_callBackFunction isEqualTypeParams [[],{}]) exitWith {\n            _thisArgs = _callBackFunction select 0;\n            _actualCallBackFunction = _callBackFunction select 1;\n        };\n    };\n\n    if (_callBackFunction isEqualType \"\") exitWith {\n        _actualCallBackFunction = compile _callBackFunction;\n    };\n};\n\nif (isNil \"_actualCallBackFunction\") exitWith {\n    [\n        [\n            \"_callBackFunction improperly configured:\",\n            _callBackFunction\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\nif !(_runInScheduled) exitWith {\n    [\n        {\n            params [\"_defaultArgs\",\"_thisArgs\",\"_actualCallBackFunction\"];\n            _defaultArgs call _actualCallBackFunction;\n        },\n        [\n            _defaultArgs,\n            _thisArgs,\n            _actualCallBackFunction\n        ]\n    ] call CBA_fnc_directCall;\n};\n\n\n[\n    _defaultArgs,\n    _thisArgs,\n    _callBackFunction\n] spawn {\n    params [\"_defaultArgs\",\"_thisArgs\",\"_actualCallBackFunction\"];\n    _defaultArgs call _actualCallBackFunction;\n};\n",
    "fileName": "fn_callBack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_callBack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_classTurretsWithGuns\n\nDescription:\n    Checks a given vehicle class to see if it has turrets that have guns\n     and returns those turret paths\n\nParameters:\n    0: _classToCheck <STRING> - The vehicle class to check\n\nReturns:\n    <NUMBER[][]> - The turret paths\n\nExamples:\n    (begin example)\n        _turretPaths = [\"B_Heli_Transport_01_F\"] call KISKA_fnc_classTurretsWithGuns;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_classTurretsWithGuns\";\n\nparams [\n    [\"_classToCheck\",\"\",[\"\"]]\n];\n\n\nif (_classToCheck isEqualTo \"\") exitWith {\n    [\"_classToCheck is empty string!\",true] call KISKA_fnc_log;\n    []\n};\n\n\nif !(isClass(configFile >> \"CfgVehicles\" >> _classToCheck)) exitWith {\n    [\"_classToCheck is not defined withing CfgVehicles!\",true] call KISKA_fnc_log;\n    []\n};\n\n\n// excludes fire from vehicle turrets\nprivate _allVehicleTurrets = [_classToCheck, false] call BIS_fnc_allTurrets;\nprivate _turretsWithWeapons =  [];\n\n_allVehicleTurrets apply {\n    private _turretPath = _x;\n    private _turretWeapons = getArray([_classToCheck,_turretPath] call BIS_fnc_turretConfig >> \"weapons\");\n    private _noTurretWeaponsFound = _turretWeapons isEqualTo [];\n    \n    if (_noTurretWeaponsFound) then { continue };\n    \n    // some turrets are just optics, need to see they actually have ammo to shoot\n    private _indexOfValidMagazine = _turretWeapons findIf {\n        private _mags = [_x,true] call BIS_fnc_compatibleMagazines;\n        // some turrets are just laser designators, hence checking that there are no laserbatteries\n        (_mags isNotEqualTo []) AND {!((_mags select 0) == \"laserbatteries\")}\n    };\n\n    private _validTurretMagazineFound = _indexOfValidMagazine isNotEqualTo -1;\n    if (_validTurretMagazineFound) then {\n        _turretsWithWeapons pushBack _turretPath;\n    };\n};\n\n\n_turretsWithWeapons\n",
    "fileName": "fn_classTurretsWithGuns.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_classTurretsWithGuns.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_clearCargoGlobal\n\nDescription:\n    Deletes all cargo from the specified object on all machines.\n\nParameters:\n    0: _object <OBJECT> - The object to delete all cargo from.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myVehicle] call KISKA_fnc_clearCargoGlobal;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_clearCargoGlobal\";\n\nparams [\n    [\"_object\",objNull,[objNull]]\n];\n\nif (isNull _object) exitWith {};\n\nclearMagazineCargoGlobal _object;\nclearWeaponCargoGlobal _object;\nclearBackpackCargoGlobal _object;\nclearItemCargoGlobal _object;\n",
    "fileName": "fn_clearCargoGlobal.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_clearCargoGlobal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_countdown\n\nDescription:\n    Sleeps for a given time and eventually displays a certain amount on screen.\n\nParameters:\n    0: _countDownTotal : <NUMBER> - The amount to countdown from\n    1: _shownCountDown : <NUMBER> - The number at which a print out of the\n        current countdown will show on screen.\n    2: _soundedCountDown : <NUMBER> - The number at which a beep should play for each second\n    3: _soundName : <STRING> - The cfgSournds entry to play for the sound portion of the countdown\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // print numbers when at 15 and play sound at 10\n        [30,15,10] spawn KISKA_fnc_countdown;\n    (end)\n    (begin example)\n        // print numbers when at 15 and play no sound\n        [30,15,-1] spawn KISKA_fnc_countdown;\n    (end)\n\nAuthor(s):\n    Hilltop(Willtop) & omNomios,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_countdown\";\n\nif (!canSuspend) exitWith {\n    [\"Needs to be called from a scheduled environment!\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_countdown;\n};\n\nparams [\n    [\"_countDownTotal\",15,[123]],\n    [\"_shownCountDown\",15,[123]],\n    [\"_soundedCountDown\",10,[123]],\n    [\"_soundName\",\"beep_target\",[\"\"]]\n];\n\nif (_countDownTotal < _shownCountDown) then {\n    [\n        [\n            \"_shownCountDown: \",\n            _shownCountDown ,\n            \" should be less then _countDownTotal: \",\n            _countDownTotal\n        ],\n        false\n    ] call KISKA_fnc_log;\n    _shownCountDown = _countDownTotal;\n};\n\nif (_soundedCountDown > _shownCountDown) then {\n    [\n        [\n            \"_soundedCountDown: \",\n            _soundedCountDown ,\n            \" should be less then _shownCountDown: \",\n            _shownCountDown\n        ],\n        false\n    ] call KISKA_fnc_log;\n    _soundedCountDown = _shownCountDown;\n};\n\n\nif (_countDownTotal < 0) exitWith {\n    [[\"Negative countdown was passed: \",_countDownTotal],true] call KISKA_fnc_log;\n    nil\n};\n\nif (hasInterface) then {\n    private _timeToSleepBeforeShown = _countDownTotal - _shownCountDown;\n    sleep _timeToSleepBeforeShown;\n\n    while {_shownCountDown >= 0} do {\n        if (_shownCountDown <= _soundedCountDown) then {\n            playSound _soundName;\n        };\n\n        [str _shownCountDown, 0, 0, 1, 0] spawn BIS_fnc_dynamicText;\n\n        sleep 1;\n        _shownCountDown = _shownCountDown - 1;\n    };\n\n} else {\n    sleep _countDownTotal;\n\n};\n\n\n\nnil\n",
    "fileName": "fn_countdown.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_countdown.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_createAssetAtPosition\n\nDescription:\n    Creates an asset using `createVehicle` command and places it at the given\n    position, possibly for a temporary amount of time. Ideally used for something\n    like smoke plumes of configured lights for example.\n\nParameters:\n    0: _className <STRING> - A `createVehicle` compatible class name of the asset to create.\n    1: _position <OBJECT or PositionASL[]> - The place to spawn the object.\n    2: _lifetime <NUMBER> - Default: `-1` - How long in seconds until the created \n        object is deleted. A value below `0` indicates it will never be deleted.\n    3: _local <NUMBER> - Default: `false` - Whether or not to create the object on the\n        local machine only.\n\nReturns:\n    <OBJECT> - The created object\n\nExamples:\n    (begin example)\n        private _smokeEmitter = [\n            \"G_40mm_SmokeBlue_infinite\", // defined in CfgAmmo\n            MyPosition,\n            20\n        ] call KISKA_fnc_createAssetAtPosition;\n    (end)\n\n    (begin example)\n        private _chemLight = [\n            \"Chemlight_blue_Infinite\",\n            [0,0,0],\n            -1,\n            true\n        ] call KISKA_fnc_createAssetAtPosition;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_createAssetAtPosition\";\n\nparams [\n    [\"_className\",\"\",[\"\"]],\n    [\"_position\",objNull,[[],objNull],3],\n    [\"_lifetime\",-1,[123]],\n    [\"_local\",false,[true]]\n];\n\nprivate _positionIsAnObject = _position isEqualType objNull;\nif (_positionIsAnObject AND {isNull _position}) exitWith {\n    [\"Null position provided\"] call KISKA_fnc_log;\n    objNull\n};\n\nif (_positionIsAnObject) then {\n    _position = getPosASL _position;\n};\n\nprivate \"_object\";\nif (!_local) then {\n    _object = _className createVehicle _position;\n} else {\n    _object = _className createVehicleLocal _position;\n};\n\n_object setPosASL _position;\n\nif (_lifetime >= 0) then {\n    [\n        {\n            params [\"_object\"];\n            [_object] remoteExecCall [\"deleteVehicle\",_object];\n        },\n        [_object],\n        _lifetime\n    ] call CBA_fnc_waitAndExecute;\n};\n\n\n_object",
    "fileName": "fn_createAssetAtPosition.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_createAssetAtPosition.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_datalinkMsg\n\nDescription:\n    Displays a message to the player and creates a diary entry of that message.\n    Also can play a sound when the notification pops up.\n\nParameters:\n    0: _message : <STRING or ARRAY> - If string, the message to display as title.\n        \n        If array:\n        - 0: _text : <STRING> - Text to display or path to .paa or .jpg\n            image (may be passed directly if only text is required)\n        - 1: _size : <NUMBER> - Scale of text\n        - 2: _color : <ARRAY> - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1])\n\n    1: _canSkip : <BOOL> - Can the notification be skipped when another is in the queue\n    2: _lifetime : <NUMBER> - How long the notification will be visible (min of 2 seconds)\n    3: _sound : <STRING> - A sound\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"this is the message\", 5] call KISKA_fnc_datalinkMsg;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_datalinkMsg\";\n\n#define RED_RGBA [0.75,0,0,1]\n\nif !(hasInterface) exitWith {};\n\n// if function is not run in the same environment, causes an issue where there will be two\n/// at least \"Datalink Messages\" sub-subjects\nif (canSuspend) exitWith {\n    [\n        KISKA_fnc_datalinkMsg,\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_message\",\"\",[\"\",[]]],\n    [\"_canSkip\",false,[true]],\n    [\"_lifetime\",4,[123]],\n    [\"_sound\",\"\",[\"\"]]\n];\n\n\n[\n    {\n        params [\n            \"_message\",\n            \"_sound\"\n        ];\n\n        if (_sound isNotEqualTo \"\") then {\n            playSound _sound;\n        };\n\n        [\n            [\"DATALINK\",1.1,RED_RGBA],\n            _message,\n            _lifetime,\n            _canSkip\n        ] call KISKA_fnc_notify;\n\n        [[\"Datalink Messages\",\"- \" + _message]] call KISKA_fnc_addKiskaDiaryEntry;\n    },\n    [_message,_playSound],\n    _waitTime\n] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_dataLinkMsg.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_dataLinkMsg.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_deleteAtArray\n\nDescription:\n    Removes an index from a global array.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The global array in string format\n    1: _indexToRemove : <ANY> - The index to remove\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL,DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - True if done, false if not\n\nExamples:\n    (begin example)\n        [\"myGlobalArrayVar\",someInfoHere] call KISKA_fnc_deleteAtArray;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_deleteAtArray\";\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_indexToRemove\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\nif (_array isEqualTo []) exitWith {false};\n\n_array deleteAt _indexToRemove;\n\n\ntrue",
    "fileName": "fn_deleteAtArray.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_deleteAtArray.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_deleteAtArray_interface\n\nDescription:\n    Removes an index from a global array. Checks if machine hasInterface before.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The global array in string format\n    1: _indexToRemove : <ANY> - The index to remove\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL,DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - True if done, false if not\n\nExamples:\n    (begin example)\n        [\"myGlobalArrayVar\",someInfoHere] call KISKA_fnc_deleteAtArray;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_deleteAtArray_interface\";\n\nif (!hasInterface) exitWith {false};\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_indexToRemove\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\nif (_array isEqualTo []) exitWith {false};\n\n_array deleteAt _indexToRemove;\n\n\ntrue\n",
    "fileName": "fn_deleteAtArray_interface.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_deleteAtArray_interface.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_deleteRandomIndex\n\nDescription:\n    Removes and returns a random item from an array\n\nParameters:\n    0: _array <ARRAY> - The array to find a random index of.\n\nReturns:\n    <ANY> - The random item removed from the array\n\nExamples:\n    (begin example)\n        private _randomDeletedItem = [[1,2,3]] call KISKA_fnc_deleteRandomIndex;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_deleteRandomIndex\";\n\nparams [\n    [\"_array\",[],[[]]]\n];\n\n\nprivate _randomIndex = floor (random (count _array));\n_array deleteAt _randomIndex",
    "fileName": "fn_deleteRandomIndex.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_deleteRandomIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_doMagRepack\n\nDescription:\n    Completes a repack on the units current weapon.\n\nParameters:\n    0: _unit : <OBJECT> - The person doing the repack\n    1: _doHint : <BOOL> - Should the local client be informed of packs?\n\nReturns:\n    <BOOL> - false if not completed, true if it was\n\nExamples:\n    (begin example)\n        [player] call KISKA_fnc_doMagRepack;\n    (end)\n\nAuthor(s):\n    Quicksilver,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_doMagRepack\";\n\nparams [\n    [\"_unit\",player,[objNull]],\n    [\"_doHint\",true,[true]]\n];\n\n// get all mags except for empty ones\nprivate _unitMags = (magazinesAmmoFull _unit) select {(_x select 1) != 0};\nif (_unitMags isEqualTo []) exitWith {\n    if (_doHint) then {\n     [    \"You have no mags to repack\"] call KISKA_fnc_notification;\n    };\n\n    false\n};\n\nprivate _sortedMagClasses = [];\nprivate [\"_currentMagazineClass_temp\",\"_magType_temp\",\"_numberOfMags_temp\",\"_magInfo_temp\",\"_allMagsOfClass_temp\",\"_totalBulletsForClass_temp\"];\nprivate _fn_pushToSorted = {\n    _sortedMagClasses pushBack _currentMagazineClass_temp;\n};\n\n// sort the mags in on the player to find those that can be repacked\nprivate \"_totalBulletsForClass_temp\";\nprivate _unitMagsSorted = [];\n_unitMags apply {\n    _magInfo_temp = _x;\n    _currentMagazineClass_temp = _magInfo_temp select 0;\n\n    // see if mag class was already sorted\n    if !(_currentMagazineClass_temp in _sortedMagClasses) then {\n        _magType_temp = ([_currentMagazineClass_temp] call BIS_fnc_itemType) select 1;\n        // sort through mags to get those that aren't are grenades, flares, etc.\n        if (_magType_temp == \"Bullet\" OR {_magType_temp == \"Missile\"} OR {_magType_temp == \"Rocket\"}) then {\n            // check to make sure there are multiple mags of this type in the units inventory\n            _allMagsOfClass_temp = _unitMags select {(_x select 0) == _currentMagazineClass_temp};\n            if ((count _allMagsOfClass_temp) > 1) then {\n\n                // get the total number of bullets for this mag className\n                _totalBulletsForClass_temp = 0;\n                _allMagsOfClass_temp apply {\n                    _totalBulletsForClass_temp = _totalBulletsForClass_temp + (_x select 1);\n                };\n                _unitMagsSorted pushBack [_currentMagazineClass_temp,_totalBulletsForClass_temp];\n            };\n        }\n        call _fn_pushToSorted;\n    };\n};\n\n\n\n// if there are no mags to repack, just hint\nif !(_unitMagsSorted isEqualTo []) then {\n    _unit playMove \"AinvPknlMstpSnonWnonDr_medic2\";\n\n    // get mags loaded into current handgun and primary\n    private _primaryMag = primaryWeaponMagazine _unit;\n    private _primaryWeaponMagClass = \"\";\n    if !(_primaryMag isEqualTo []) then { // if there is a primary magazine\n        _primaryWeaponMagClass = _primaryMag select 0;\n    };\n\n    private _handgunMag = handgunMagazine _unit;\n    private _handgunWeaponMagClass = \"\";\n    if !(_handgunMag isEqualTo []) then { // if there is a handgun magazine\n        _handgunWeaponMagClass = _handgunMag select 0;\n    };\n\n    private _secondaryMag = secondaryWeaponMagazine _unit;\n    private _secondaryWeaponMagClass = \"\";\n    if !(_secondaryMag isEqualTo []) then { // if there is a secondary magazine\n        _secondaryWeaponMagClass = _secondaryMag select 0;\n    };\n\n\n    private _fn_magTypeInWeapon = {\n        params [\n            [\"_doAddMag\",true]\n        ];\n\n        if (_magClassnameTemp == _primaryWeaponMagClass) exitWith {\n            if (_doAddMag) then {\n                _unit removePrimaryWeaponItem _magClassnameTemp;\n                _unit addPrimaryWeaponItem _magClassnameTemp;\n            };\n            true\n        };\n        if (_magClassnameTemp == _handgunWeaponMagClass) exitWith {\n            if (_doAddMag) then {\n                _unit removeHandgunItem _magClassnameTemp;\n                _unit addHandgunItem _magClassnameTemp;\n            };\n            true\n        };\n        if (_magClassnameTemp == _secondaryWeaponMagClass) exitWith {\n            if (_doAddMag) then {\n                _unit removeSecondaryWeaponItem _magClassnameTemp;\n                _unit addSecondaryWeaponItem _magClassnameTemp;\n            };\n            true\n        };\n\n        false\n    };\n\n\n    private [\"_magCapacity\",\"_numberOfFullMagsToAdd\",\"_totalBulletCountForClass\",\"_remainderMagBulletCount\",\"_magClassnameTemp\"];\n    _unitMagsSorted apply {\n        _magClassnameTemp = _x select 0;\n        _totalBulletCountForClass = _x select 1;\n        _magCapacity = getNumber (configFile >> \"CfgMagazines\" >> _magClassnameTemp >> \"Count\");\n\n        // remove every mag (that's not in the gun) including empty ones\n        _unit removeMagazines _magClassnameTemp;\n\n        // if the total bullets for the mag are not going to equal more than one mag\n        if (_totalBulletCountForClass <= _magCapacity) then {\n            if ([false] call _fn_magTypeInWeapon) then {\n                private _index = [_primaryWeaponMagClass,_handgunWeaponMagClass,_secondaryWeaponMagClass] findIf {_x == _magClassnameTemp};\n                switch _index do {\n                    case 0: {_unit setAmmo [primaryWeapon _unit,_totalBulletCountForClass]};\n                    case 1: {_unit setAmmo [handgunWeapon _unit,_totalBulletCountForClass]};\n                    case 2: {_unit setAmmo [secondaryWeapon _unit,_totalBulletCountForClass]};\n                };\n            } else {\n                _unit addMagazine [_magClassnameTemp,_totalBulletCountForClass];\n            };\n        } else {\n            _numberOfFullMagsToAdd = floor (_totalBulletCountForClass / _magCapacity);\n\n            // if the mag type is currently inserted into a weapon\n            if ([true] call _fn_magTypeInWeapon) then {\n                _numberOfFullMagsToAdd = _numberOfFullMagsToAdd - 1;\n            };\n\n            _unit addMagazines [_magClassnameTemp,_numberOfFullMagsToAdd];\n\n            // check for if we need that one not full mag to hold the excess ammo\n            _remainderMagBulletCount = _totalBulletCountForClass mod _magCapacity;\n            if !(_remainderMagBulletCount isEqualTo 0) then {\n                _unit addMagazine [_magClassnameTemp,_remainderMagBulletCount];\n            };\n        };\n    };\n\n    true;\n} else {\n    if (_doHint) then {\n        hint \"You have no mags that need to be repacked\";\n    };\n    false\n};\n",
    "fileName": "fn_doMagRepack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_doMagRepack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_errorNotification\n\nDescription:\n    Prints a simple KISKA Notify error notification on screen.\n\nParameters:\n    0: _message : <STRING or ARRAY> - The second line of the notification.\n        Formatted the same as the parameters for CBA_fnc_notify:\n            _lineN - N-th content line (may be passed directly if only 1 line is required). <ARRAY>\n                _text  - Text to display or path to .paa or .jpg image (may be passed directly if only text is required). <STRING, NUMBER>\n                _size  - Text or image size multiplier. (optional, default: 1) <NUMBER>\n                _color - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1]) <ARRAY>\n    1: _lifetime : <NUMBER> - How long the notification lasts in seconds (at least 2)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"You made and error\"] call KISKA_fnc_errorNotification;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_errorNotification\";\n\nparams [\n    [\"_message\",\"\",[\"\",[]]],\n    [\"_lifetime\",4,[123]]\n];\n\n[\n    [\"Error\",1.1,[0.75,0,0,1]],\n    _message,\n    _lifetime,\n    false\n] call KISKA_fnc_notify;\n\n\nnil\n",
    "fileName": "fn_errorNotification.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_errorNotification.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_exportLoadouts\n\nDescription:\n    Exports a given unit or units loadout into an array or loadouts. This can \n     be either a standard array or formatted for config files.\n\nParameters:\n    0: _units <OBJECT[] or OBJECT> - The units to get the loadouts of\n    1: _exportAsConfig <BOOL> - Will export list in config array format ({} instead of [])\n\nReturns:\n    <STRING> - An array of loadouts as a string. This will be either \n\nExamples:\n    (begin example)\n        private _loadouts = [_units,true] call KISKA_fnc_exportLoadouts;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_exportLoadouts\";\n\nparams [\n    [\"_units\",[],[[],objNull]],\n    [\"_exportAsConfig\",true,[false]]\n];\n\nif (_units isEqualType objNull) then {\n    _units = [_units];\n};\n\nprivate _loadoutsAsString = \"[\";\nprivate _loadouts = _units apply {\n    private _loadout = getUnitLoadout _x;\n    if (_loadout isEqualTo []) then {\n        continue;\n    };\n\n    _loadoutsAsString = _loadoutsAsString + (endl + str _loadout + \",\");\n};\n\n_loadoutsAsString = (_loadoutsAsString trim [\",\",2]) + endl + \"]\";\nif (_exportAsConfig) then {\n    _loadoutsAsString = _loadoutsAsString regexReplace [\"\\[\",\"{\"];\n    _loadoutsAsString = _loadoutsAsString regexReplace [\"\\]\",\"}\"];\n};\n\n\n_loadoutsAsString\n",
    "fileName": "fn_exportLoadouts.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_exportLoadouts.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_exportSpawnPositions\n\nDescription:\n    Takes a layer of objects and produces an array of arrays that are their 3d\n     ATL position and current direction ([0,0,0,0]).\n\n    Can also convert the arrays to config compatible format.\n\n    This will copy its output to the clipboard if run on the server;\n\nParameters:\n    0: _layer <STRING or NUMBER> - The name of the layer or if in 3den, its layer id\n    1: _convertToConfig <BOOL> - Change all square brackets ([]) to curly ({})\n\nReturns:\n    <STRING> - The converted Array\n\nExamples:\n    (begin example)\n        [\"someLayer\",true] call KISKA_fnc_exportSpawnPositions;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_exportSpawnPositions\";\n\nparams [\n    [\"_layer\",\"\",[\"\",123]],\n    [\"_convertToConfig\",true,[true]]\n];\n\nprivate _objects = [];\nif (is3den) then {\n    _objects = get3DENLayerEntities _layer;\n\n} else {\n    _objects = (getMissionLayerEntities _layer) select 0;\n\n};\n\n\nif (count _objects < 1) exitWith {\n    [[\"No objects were found in layer: \",_layer],true] call KISKA_fnc_log;\n    \"\"\n};\n\n\nprivate _returnArray = [];\n_objects apply {\n    private _objectArray = getPosATL _x;\n    _objectArray pushBack (getDir _x);\n\n    _returnArray pushBack _objectArray;\n};\n\nprivate _string = _returnArray joinString (\",\" + endl);\n_string = _string trim [\",\",2];\n\nif (_convertToConfig) then {\n    _string = [_string,\"[\",\"{\"] call CBA_fnc_replace;\n    _string = [_string,\"]\",\"}\"] call CBA_fnc_replace;\n};\ncopyToClipboard _string;\n\n\n_string\n",
    "fileName": "fn_exportSpawnPositions.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_exportSpawnPositions.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_findIfBool\n\nDescription:\n    Checks if an array index satisfies the provided code, and returns a BOOL\n     for whether or not one was found.\n\nParameters:\n    0: _array : <ARRAY> - The array to check\n    1: _codeToCheck : <CODE> - The code to check against the array indexes.\n        Needs to return a BOOl.\n        Params are passed within _thisArgs.\n    2: _thisArgs : <ARRAY> - Any local arguements that can be passed\n\nReturns:\n    <BOOL> - True if an index meets the condition, false if not\n\nExamples:\n    (begin example)\n        // returns true if any player is alive\n        [allPlayers,{alive _x}] call KISKA_fnc_findIfBool;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_findIfBool\";\n\nparams [\n    [\"_array\",[],[[]]],\n    [\"_codeToCheck\",{},[{}]],\n    [\"_thisArgs\",[],[[]]]\n];\n\nprivate _index = _array findIf _codeToCheck;\n// if index is found, return true\n_index >= 0\n",
    "fileName": "fn_findIfBool.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_findIfBool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_generateUniqueId\n\nDescription:\n    Creates a unique identifier with a given tag. \n    \n    The id format is: *tag*_*clientOwner*_*increment* which as an example could be\n     `KISKA_uid_0_0` as the first unique id made in a single player scenario.\n\nParameters:\n    0: _tag <STRING> - The tag to assign to the uid\n\nReturns:\n    <STRING> - the unique identifier\n\nExamples:\n    (begin example)\n        call KISKA_fnc_generateUniqueId;\n        // KISKA_uid_0_0\n    (end)\n    \n    (begin example)\n        [\"MYTAG\"] call KISKA_fnc_generateUniqueId;\n        // MYTAG_uid_0_0\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_generateUniqueId\";\n\nparams [\n    [\"_tag\",\"KISKA\",[\"\"]]\n];\n\nif (_tag isEqualTo \"\") then {\n    _tag = \"KISKA\";\n};\n\n// in an effort to avoid confusion between when using KISKA_fnc_idCounter\n// using the \"uid\" tagged on as the counter for consistent counts \n// in case someone uses that tag with KISKA_fnc_idCounter outside of this\n// function\nprivate _idPrepend = [_tag,\"uid\",clientOwner] joinString \"_\";\nprivate _idNumber = [_idPrepend] call KISKA_fnc_idCounter;\n\n\n[_idPrepend,_idNumber] joinString \"_\"\n",
    "fileName": "fn_generateUniqueId.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_generateUniqueId.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getBoundingBoxDimensions\n\nDescription:\n    Returns the length, width, and height of a given object's bounding box, for\n     a given clipping type.\n\nParameters:\n    0: _object <OBJECT> - The object to get the dimensions of\n    1: _boxType <NUMBER or STRING> - The `boundingBoxReal` command's clipping type or\n        the LOD name/resolution if `_isLOD` is true.\n    2: _isLOD <BOOL> - Whether or not to use the LOD syntax of `boundingBoxReal`\n\nReturns:\n    <NUMBER[]> - `[Width,Length,Height]` of the given object's dimensions \n\nExamples:\n    (begin example)\n        private _playerBoxDimensions = [player] call KISKA_fnc_getBoundingBoxDimensions;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getBoundingBoxDimensions\";\n\n#define BOUDNING_BOX_MINS (_boundingBox select 0)\n#define BOUDNING_BOX_MAXES (_boundingBox select 1)\n\nparams [\n    [\"_object\",objNull,[objNull]],\n    [\"_boxType\",0,[123]],\n    [\"_isLOD\",false,[false]]\n];\n\n\nif (isNull _object) exitWith {\n    [\"null object passed\",true] call KISKA_fnc_log;\n    [0,0,0]\n};\n\n\nprivate \"_boundingBox\";\nif (_isLOD) then {\n    _boundingBox = boundingBoxReal [_object,_boxType];\n} else {\n    _boundingBox = _boxType boundingBoxReal _object;\n};\n\n\n(BOUDNING_BOX_MAXES vectorDiff BOUDNING_BOX_MINS) apply { abs _x }\n",
    "fileName": "fn_getBoundingBoxDimensions.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getBoundingBoxDimensions.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getBumperPositionRelative\n\nDescription:\n    Gets the PositionRelative of a vehicles front or rear bumper.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the bumper position of\n    1: _isRearBumper <BOOL> - True for rear bumper, false for front bumper\n\nReturns:\n    <PositionRelative> - The world position of the vehicle's bumper\n\nExamples:\n    (begin example)\n        private _rearBumperPositionRelatives = [vic,true] call KISKA_fnc_getBumperPositionRelative;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getBumperPositionRelative\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_isRearBumper\",false,[true]]\n];\n\nprivate _boundingBoxIndex = 0;\nif (!_isRearBumper) then {\n    _boundingBoxIndex = 1;\n};\n\nprivate _vehicleBoundingBoxes = 0 boundingBoxReal _vehicle;\nprivate _boundingBox = _vehicleBoundingBoxes select _boundingBoxIndex;\nprivate _relativeBumperPosition = [0,_boundingBox select 1,0];\n\n\n_relativeBumperPosition\n",
    "fileName": "fn_getBumperPositionRelative.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getBumperPositionRelative.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getContainerCargo\n\nDescription:\n    Saves the cargo of a container in a formatterd array to be used with\n     KISKA_fnc_pasteContainerCargo for copying cargos of containers.\n\n    Exact ammo counts will be preserved even inside of an item such as magazines\n     inside of a vest or backpack.\n\nParameters:\n    0: _primaryContainer <OBJECT> - The container to save the cargo of\n\nReturns:\n    <ARRAY> - Formatted array of all items in cargo space of a container.\n        Used with KISKA_fnc_setContainerCargo.\n        Will return [] if no cargo is present.\n\nExamples:\n    (begin example)\n        [container] call KISKA_fnc_getContainerCargo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getContainerCargo\";\n\n#define EMPTY_RETURN [[[],[]],[],[],[[],[]],[]]\n\nparams [\n    [\"_primaryContainer\",objNull,[objNull]]\n];\n\nif (isNull _primaryContainer) exitWith {\n    [\"_primaryContainer isNull\",true] call KISKA_fnc_log;\n    []\n};\n\n// for containers within the primary container (vests, backpacks, etc.)\nprivate _containers = everyContainer _primaryContainer;\n\nprivate _containersInfo = [];\nif (_containers isNotEqualTo []) then {\n\n    _containers apply {\n\n        private _container = _x select 1;\n        private _cargoInContainer = [_container] call KISKA_fnc_getContainerCargo;\n\n        if (_cargoInContainer isNotEqualTo []) then {\n            private _containerClass = _x select 0;\n            _containersInfo pushBack [\n                _containerClass,\n                _cargoInContainer\n            ];\n        };\n\n    };\n\n};\n\n// sort through weapons\nprivate _weaponsCargo = [];\nprivate _weaponsInContainer = weaponsItemsCargo _primaryContainer;\nif (_weaponsInContainer isNotEqualTo []) then {\n    _weaponsInContainer apply {\n        _weaponsCargo pushBack [_x,1];\n    };\n};\n\nprivate _totalCargo = [\n\n    getItemCargo _primaryContainer,\n\n    magazinesAmmoCargo _primaryContainer,\n\n    _weaponsCargo,\n\n    getBackpackCargo _primaryContainer,\n    // containers within containers\n    _containersInfo\n];\n\nif (_totalCargo isEqualTo EMPTY_RETURN) exitWith {\n    [[\"No cargo found in \",_primaryContainer],true] call KISKA_fnc_log;\n    []\n};\n\n\n_totalCargo\n",
    "fileName": "fn_getContainerCargo.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getContainerCargo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getCurrentWaypoint\n\nDescription:\n    Returns the units currentWaypoint\n\nParameters:\n    0: _group <GROUP or OBJECT> - The unit to get the currentWaypoint for.\n\nReturns:\n    <ARRAY> - The waypoint\n\nExamples:\n    (begin example)\n        private _waypoint = [myUnit] call KISKA_fnc_getCurrentWaypoint;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getCurrentWaypoint\";\n\n\nparams [\n    [\"_group\",grpNull,[objNull,grpNull]]\n];\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\nif (isNull _group) exitWith {\n    [\"Null group passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\n(waypoints _group) select (currentWaypoint _group)\n",
    "fileName": "fn_getCurrentWaypoint.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getCurrentWaypoint.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getFromNetId\n\nDescription:\n    Gets an object or group from a netId.\n\nParameters:\n    0: _id <STRING> - The id of the object\n    1: _fromObject <BOOL> - false for getting object, true for group\n\nReturns:\n    <OBJECT or GROUP> - The Id of the entity\n\nExamples:\n    (begin example)\n        _entity = [\"0:0\"] call KISKA_fnc_netId;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getFromNetId\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_fromObject\",false,[false]]\n];\n\nif (!isMultiplayer) exitWith {\n    // create map if needed\n    private _map = localNamespace getVariable \"KISKA_objectNetId_map\";\n    if (isNil \"_map\") then {\n        _map = createHashMap;\n        localNamespace setVariable [\"KISKA_objectNetId_map\",_map];\n    };\n\n    _map getOrDefault [_id, [grpNull,objNull] select _fromObject];\n};\n\nif (_fromObject) then {\n    objectFromNetId _id;\n\n} else {\n    groupFromNetId _id;\n\n};\n",
    "fileName": "fn_getFromNetId.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getFromNetId.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getLoadedModsInfo\n\nDescription:\n    An alias for the command `getLoadedModsInfo` but with a caching layer in the\n\t `uiNamespace`.\n\nParameters:\n    NONE\n\nReturns:\n    <ARRAY> - see `getLoadedModsInfo`\n\nExamples:\n    (begin example)\n        private _modsInfo = call KISKA_fnc_getLoadedModsInfo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getLoadedModsInfo\";\n\nprivate _cachedInfo = uiNamespace getVariable \"KISKA_loadedModsInfo\";\nif !(isNil \"_cachedInfo\") exitWith { _cachedInfo };\n\n_cachedInfo = getLoadedModsInfo;\nuiNamespace setVariable [\"KISKA_loadedModsInfo\",_cachedInfo];\n\n\n_cachedInfo\n",
    "fileName": "fn_getLoadedModsInfo.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getLoadedModsInfo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMissionLayerObjects\n\nDescription:\n    Simply returns the objects of a mission layer.\n\nParameters:\n    0: _layer : <STRING or NUMBER> - The name or ID of the mission layer\n\nReturns:\n    <ARRAY> - The layer's objects\n\nExamples:\n    (begin example)\n        _objects = [\"myLayer\"] call KISKA_fnc_getMissionLayerObjects;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMissionLayerObjects\";\n\nparams [\n    [\"_layer\",\"\",[123,\"\"]]\n];\n\nprivate _entities = getMissionLayerEntities _layer;\n\nif (_entities isEqualTo []) exitWith {[]};\n\n\n_entities select 0\n",
    "fileName": "fn_getMissionLayerObjects.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getMissionLayerObjects.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getNearestIncriment\n\nDescription:\n    Rounds off a number to the nearest incriment.\n\nParameters:\n    0: _numberToCheck : <NUMBER> - The number to round off\n    1: _incriment : <NUMBER> - The incriment by which the number should be assessed\n\nReturns:\n    <NUMBER> - The nearest incriment to the given number\n\nExamples:\n    (begin example)\n        // -0.22\n        _nearestIncriment = [-0.223,0.01] call KISKA_fnc_getNearestIncriment;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getNearestIncriment\";\n\nparams [\n    [\"_numberToCheck\",0,[123]],\n    [\"_incriment\",1,[123]]\n];\n\n_incriment = abs _incriment;\nprivate _result = (abs _numberToCheck + (_incriment / 2));\n_result = _result - (_result mod _incriment);\n\nif (_numberToCheck < 0 AND (_result isNotEqualTo 0)) then {\n    _result * -1\n\n} else {\n    _result\n\n};\n",
    "fileName": "fn_getNearestIncriment.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getNearestIncriment.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getOrDefaultSet\n\nDescription:\n    Gets a namespace variable or calls the provided code that will set the default\n    value.\n\nParameters:\n    0: _namespace <NAMESPACE> - Anything that supports `getVariable` and `setVariable`.\n    1: _variableName <STRING> - The name of the variable to get and/or set.\n    2: _getDefault <CODE, STRING, or ARRAY> - Code that must return the default value of the variable.\n        Will only be called in the event that the provided variable `isNil`. See `KISKA_fnc_callBack`\n\nReturns:\n    <ANY> - The value of the variable\n\nExamples:\n    (begin example)\n        private _value = [\n            localNamespace,\n            \"MyVariable\",\n            {[]} // set \"MyVariable\" in localNamespace to [] if it does not exist\n        ] call KISKA_fnc_getOrDefaultSet;\n    (end)\n\n    (begin example)\n        // _value == \"MyString\"\n        private _value = [\n            localNamespace,\n            \"MyVariable\",\n            [[\"MyString\"],{ _thisArgs select 0 }]\n        ] call KISKA_fnc_getOrDefaultSet;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getOrDefaultSet\";\n\nparams [\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,locationNull,grpNull,teamMemberNull,taskNull,controlNull,displayNull]],\n    [\"_variableName\",\"\",[\"\"]],\n    [\"_getDefault\",{},[{},\"\",[]]]\n];\n\nprivate _value = _namespace getVariable _variableName;\nif !(isNil \"_value\") exitWith {_value};\n\n_value = [[],_getDefault,false] call KISKA_fnc_callBack;\n_namespace setVariable [_variableName,_value];\n\n\n_value\n",
    "fileName": "fn_getOrDefaultSet.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getOrDefaultSet.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getRelativeVectorAndPos\n\nDescription:\n    Returns the relative vector dir and up and world position from one object to\n     another.\n\nParameters:\n    0: _parent <OBJECT> - The object to make the coordinates relative to.\n    1: _child <OBJECT> - The object to find coordinates for.\n\nReturns:\n    <ARRAY> -\n        0: <PositionWorld[]> - Relative world pos\n        1: <Vector[]> - Relative vector dir\n        2: <Vector[]> - Relative vector up\n\nExamples:\n    (begin example)\n        private relativeArray = [\n            parentObject,\n            childObject\n        ] call KISKA_fnc_getRelativeVectorAndPos\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getRelativeVectorAndPos\";\n\nparams [\n    [\"_parent\",objNull,[objNull]],\n    [\"_child\",objNull,[objNull]]\n];\n\n\nif (isNull _parent) exitWith {\n    [\"Null parent object passed\",true] call KISKA_fnc_log;\n    []\n};\n\nif (isNull _child) exitWith {\n    [\"Null child object passed\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _relativePosWorld = _parent worldToModel (ASLToAGL (getPosASL _child));\nprivate _relativeVectorDir = _parent vectorWorldToModel (vectorDir _child);\nprivate _relativeVectorUp = _parent vectorWorldToModel (vectorUp _child);\n\n\n[_relativePosWorld,_relativeVectorDir,_relativeVectorUp]\n",
    "fileName": "fn_getRelativeVectorAndPos.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getRelativeVectorAndPos.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getVariableTarget\n\nDescription:\n    Gets a variable from a remote target object, id, or string (uses remoteExec targets)\n\n    Takes a bit of time and therefore needs to be scheduled.\n\nParameters:\n    0: _variableName : <STRING> - The string name of the varaible to get\n    1: _namespace : <NAMESPACE, OBJECT, STRING, CONTROL, GROUP, or LOCATION> - The namespace to get the variable from\n    2: _defaultValue : <ANY> - If the variable does not exist for the target, what should be returned instead\n    3: _target : <NUMBER, OBJECT, or STRING> - Where the _target is local will be where the variable is taken from \n        (the machine to get the variable from)\n    4: _awaitParams : <[NUMBER,NUMBER,BOOL]> - How the get from the target should be awaited\n\n        Parameters:\n        - 0: <NUMBER> - The sleep time between each check for the variable being received\n        - 1: <NUMBER> - The max time to wait for (this is not total game time but time slept)\n        - 2: <BOOL> - Whether or not the sleep time should be exponential (double every iteration)\n\n\nReturns:\n    <ANY> - Whatever the variable is, nil otherwise\n\nExamples:\n    (begin example)\n        [] spawn {\n            // need to call for direct return\n            private _serversSomeVariable = [\n                \"someVariable\",\n                missionNamespace,\n                \"\",\n                2\n            ] call KISKA_fnc_getVariableTarget;\n        };\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getVariableTarget\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled environment\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_variableName\",\"\",[\"\"]],\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,\"\",controlNull,locationNull,grpNull]],\n    [\"_defaultValue\",nil],\n    [\"_target\",2,[123,objNull,\"\"]],\n    [\"_awaitParams\",[],[[]]]\n];\n\nif ((_target isEqualType objNull) AND {isNull _target}) exitWith {\n    [\"_target is null object!\"] call KISKA_fnc_log;\n    _defaultValue\n};\n\nprivate _targetIsNetId = false;\nprivate _targetsMultipleUsers = false;\nprivate _exitForMultiUserTarget = false;\nprivate _regularMultiplayer = isMultiplayer AND (!isMultiplayerSolo);\nif (_regularMultiplayer) then {\n    private _targetsMultipleUsers = (_target isEqualType 123) AND {_target <= 0};\n    if (_targetsMultipleUsers) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n\n    private _targetIsString = _target isEqualType \"\";\n    if (!_targetIsString) exitWith {};\n\n    private _targetIsNetId = _targetIsString AND {\n            private _split = _target splitString \":\";\n            private _splitCount = count _split;\n            (_splitCount isEqualTo 2) AND {\n                private _splitParsed = _split apply {parseNumber _x};\n                private _splitCompare = _splitParsed apply {str _x};\n                _splitCompare isEqualTo _split\n            }\n        };\n\n    if (!_targetIsNetId) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n};\n\nif (_exitForMultiUserTarget) exitWith {\n    [[\"_target: \",_target,\" is invalid as it will be sent to more then one machine!\"],true] call KISKA_fnc_log;\n    _defaultValue\n};\n\nif (_variableName isEqualTo \"\") exitWith {\n    [\"_variableName is empty\",true] call KISKA_fnc_log;\n    _defaultValue\n};\n\n_awaitParams params [\n    [\"_awaitTime\",0.05,[123]],\n    [\"_maxWaitTime\",2,[123]],\n    [\"_exponentialBackOff\",false,[true]]\n];\n\n// create a unique variable ID for network tranfer\nprivate _messageNumber = missionNamespace getVariable [\"KISKA_getVarTargetQueue_count\",0];\n_messageNumber = _messageNumber + 1;\nmissionNamespace setVariable [\"KISKA_getVarTargetQueue_count\",_messageNumber];\nprivate _saveVariable = [\"KISKA_GVT\",clientOwner,\"_\",_messageNumber] joinString \"\";\n\n\n[_namespace,_variableName,_saveVariable,_defaultValue,clientOwner] remoteExecCall [\"KISKA_fnc_getVariableTarget_sendBack\",_target];\n\nprivate _timeWaited = 0;\nwaitUntil {\n    if (_timeWaited >= _maxWaitTime) then {\n        [\n            [\n                \"Max wait time of: \",\n                _maxWaitTime,\n                \" for variable \",\n                _saveVariable,\n                \" from target \",\n                _target,\n                \" was exceeded. Exiting with default value: \",\n                _defaultValue\n            ],\n            false\n        ] call KISKA_fnc_log;\n        breakWith true;\n    };\n\n    if (!isNil _saveVariable) exitWith {\n        [[\"Got variable \",_saveVariable,\" from target \",_target],false] call KISKA_fnc_log;\n        true\n    };\n    \n    sleep _awaitTime;\n    _timeWaited = _timeWaited + _awaitTime;\n    \n    if (_exponentialBackOff) then {\n        _awaitTime = _awaitTime * 2;\n    };\n\n    [[\"Waiting for variable from target: \",_target],false] call KISKA_fnc_log;\n    false\n};\n\nprivate _return = missionNamespace getVariable [_saveVariable,_defaultValue];\nmissionNamespace setVariable [_saveVariable,nil];\n\n\n_return\n",
    "fileName": "fn_getVariableTarget.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getVariableTarget.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getVariableTarget_sendBack\n\nDescription:\n    The send back component of KISKA_fnc_getVariableTarget that is executed on the target.\n    Shouldn't be called on its own.\n\nParameters:\n    0: _namespace : <NAMESPACE, OBJECT, STRING, GROUP, CONTROL, or LOCATION> - The namespace to get the variable from\n    1: _variableName : <STRING> - The string name of the varaible to get\n    2: _saveVariable : <STRING> - A unique string name for the variable to be saved in on the sender's machine\n    3: _defaultValue : <ANY> - If the variable does not exist for the target, what should be returned instead\n    4: _sendBackTarget : <ANY> - The clientOwner id of whoever sent the request\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _namespace,\n            _variableName,\n            _saveVariable,\n            _defaultValue,\n            clientOwner\n        ] remoteExecCall [\"KISKA_fnc_getVariableTarget_sendBack\",_target];\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getVariableTarget_sendBack\";\n\nparams [\"_namespace\",\"_variableName\",\"_saveVariable\",\"_defaultValue\",\"_sendBackTarget\"];\nprivate _getVariableValue = _namespace getVariable [_variableName,_defaultValue];\n\nif (_sendBackTarget isEqualTo 0) then {\n\n    if (remoteExecutedOwner isEqualTo 0) then { // never broadcast to all clients\n        missionNamespace setVariable [_saveVariable,_getVariableValue];\n\n        [\n            [\n                \"Did not send back _saveVariable: \",\n                _saveVariable,\n                \" to 0 target, saved value, which is: \",\n                _getVariableValue,\n                \" locally.\"\n            ],\n            false\n        ] call KISKA_fnc_log;\n    } else {\n        missionNamespace setVariable [_saveVariable,_getVariableValue,remoteExecutedOwner];\n\n        [\n            [\n                \"Sent back _saveVariable: \",\n                _saveVariable,\n                \" to \",\n                remoteExecutedOwner,\n                \" ---Value sent was \",\n                _getVariableValue\n            ],\n            false\n        ] call KISKA_fnc_log;\n    };\n\n} else {\n    // setVariable with a public flag of 2 in singleplayer does not work\n    if (!isMultiplayer AND {_sendBackTarget isEqualTo 2}) then {\n        _sendBackTarget = 0;\n    };\n    missionNamespace setVariable [_saveVariable,_getVariableValue,_sendBackTarget];\n\n    [\n        [\n            \"Sent back _saveVariable: \",\n            _saveVariable,\n            \" to \",\n            _sendBackTarget,\n            \" ---Value sent was \",\n            _getVariableValue\n        ],\n        false\n    ] call KISKA_fnc_log;\n    \n};\n\n\nnil\n",
    "fileName": "fn_getVariableTarget_sendBack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getVariableTarget_sendBack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getVectorToTarget\n\nDescription:\n    Returns vectorDir and vectorUp that should angle the object towards the target.\n\n    E.g. this will point the nose of a plane towards a target if paired with\n     setVector commands.\n\nParameters:\n    0: _object : <OBJECT, ARRAY> - The object to set the vectors of or its ASL position\n    1: _target : <OBJECT, ARRAY> - The target to angle towards or its ASL position\n\nReturns:\n    <ARRAY> - An array of arrays formatted as [directionVector,upVector]\n\nExamples:\n    (begin example)\n        // angles to player\n        myObject setVectorDirAndUp ([myObject,player] call KISKA_fnc_getVectorToTarget);\n    (end)\n\nAuthor(s):\n    Nelson Duarte,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getVectorToTarget\";\n\nparams [\n    [\"_object\",objNull,[objNull,[]]],\n    [\"_target\",objNull,[objNull,[]]]\n];\n\n\nprivate _objectPosition = _object;\nif (_object isEqualType objNull) then {\n    _objectPosition = getPosASLVisual _object;\n};\n\nprivate _targetPosition = _target;\nif (_target isEqualType objNull) then {\n    _targetPosition = getPosASLVisual _target;\n};\n\nprivate _dirVector = vectorNormalized (_targetPosition vectorDiff _objectPosition);\nprivate _rightVector = (_dirVector vectorCrossProduct [0,0,1]) vectorMultiply -1;\nprivate _upVector = _dirVector vectorCrossProduct _rightVector;\n\n\n[_dirVector,_upVector]\n",
    "fileName": "fn_getVectorToTarget.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getVectorToTarget.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmapParams\n\nDescription:\n    Converts a hashmap into a list of validated potential private variables. \n    \n    Similar to the `params` command.\n\nParameters:\n    0: _argsMap : <HASHMAP> - Any hashmap.\n    1: _paramDetails : <[STRING,CODE,ANY[]][]> - An array of \n        [hashmap key, code that returns a default value, an array of valid types]\n\nReturns:\n    [ANY[],STRING[]] or STRING - An array of variable values from the hashmap and their \n        corresponding suggested variable names. Suggested variable names are the\n        key names provided in the `_paramDetails` argument plus a leading underscore \n        `_` should the key not already begin with one. Should a string be returned instead,\n        this means a map value had an incorrect type according to the `_paramDetails`.\n\nExamples:\n    (begin example)\n        private _map = createHashMapFromArray [\n            [\"a\",1],[\"_b\",2],[\"c\",3]\n        ];\n\n        private _mapParams = [\n            _map,\n            [\n                [\"a\",{0},[123]],\n                [\"_b\",{0},[123]]\n            ]\n        ] call KISKA_fnc_hashMapParams;\n        (_mapParams select 0) params (_mapParams select 1);\n        [_a,_b]\n    (end)\n\n    (begin example)\n        private _map = createHashMapFromArray [\n            [\"a\",1],[\"_b\",2],[\"c\",3]\n        ];\n\n        private _error = [\n            _map,\n            [\n                [\"a\",{0},[123]],\n                [\"_b\",{\"bbbb\"},[\"\"]]\n            ]\n        ] call KISKA_fnc_hashMapParams;\n        hint _error; // _b is not the right type\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashMapParams\";\n\nparams [\n    [\"_argsMap\",nil,[createHashMap]],\n    [\"_paramDetails\",[],[[]]]\n];\n\nprivate \"_invalidArgumentMessage\";\nprivate _paramVariableNames = [];\nprivate _paramValues = _paramDetails apply {\n    _x params [\n        [\"_key\",\"\",[\"\"]],\n        [\"_default\",{},[{}]],\n        [\"_types\",[],[[]]]\n    ];\n    _key = trim _key;\n    private _paramValue = _argsMap getOrDefaultCall [_key,{import \"_default\"; call _default}];\n    if ((_types isNotEqualTo []) AND {!(_paramValue isEqualTypeAny _types)}) then {\n        _invalidArgumentMessage = [_key,\" value \",_paramValue,\" is invalid, must be of types -> \",_types] joinString \"\";\n        break;\n    };\n\n    private _variableName = _key;\n    if ((_variableName select [0,1]) isNotEqualTo \"_\") then {\n        _variableName = [\"_\",_key] joinString \"\";\n    };\n\n    _paramVariableNames pushBack _variableName;\n    _paramValue\n};\nif (!isNil \"_invalidArgumentMessage\") exitWith { _invalidArgumentMessage };\n\n\n[_paramValues,_paramVariableNames]\n",
    "fileName": "fn_hashMapParams.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_hashMapParams.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hintDiary\n\nDescription:\n    Displays a hint to the player and (always) creates a chronological\n     diary entry and an entry in the defined subject if desired.\n\nParameters:\n    0: _hintText <STRING> - The actual text shown in the hint\n    1: _subject <STRING> - The subject line in the journal for the hint (OPTIONAL)\n    2: _silent <BOOL> - true for silent hint\n\nReturns:\n    <DIARY-RECORD> - The created diary record.\n    \nExamples:\n    (begin example)\n        [\"this is the message\", \"Subject\"] call KISKA_fnc_hintDiary;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hintDiary\";\n\nif !(hasInterface) exitWith {};\n\n// if function is not run in the same environment, causes an issue where ther will be two\n/// at least \"Chronological Hint List\" sub-subjects\nif (canSuspend) exitWith {\n    [\n        {_this call KISKA_fnc_hintDiary},\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_hintText\",\"This is shown\",[\"\"]],\n    [\"_subject\",\"\",[\"\"]],\n    [\"_silent\",false,[true]]\n];\n\nif (_silent) then {\n    hintSilent _hintText;\n} else {\n    hint _hintText;\n};\n\n[[\"Chronological Hint List\",\"- \" + _hintText]] call KISKA_fnc_addKiskaDiaryEntry;\n\nprivate _diaryRecord = diaryRecordNull;\nif (_subject isNotEqualTo \"\") then {\n    _diaryRecord = [[_subject,\"- \" + _hintText]] call KISKA_fnc_addKiskaDiaryEntry;\n};\n\n\n_diaryRecord\n",
    "fileName": "fn_hintDiary.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_hintDiary.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_idCounter\n\nDescription:\n    For a given string id, return the latest \"index\" for that id.\n     This increments the id by one each time it is called. This function does not\n     check if the provided namespace is not null, so ensure it is checked\n\nParameters:\n    0: _id <string> - The id to increment\n    1: _namespace <GROUP, OBJECT, LOCATION, NAMESPACE, CONTROL, DISPLAY, TASK, TEAM-MEMBER> - The namespace\n     to check the id count in, this is `localNamespace` by default.\n\nReturns:\n    <NUMBER> - the latest index of the given id\n\nExamples:\n    (begin example)\n        private _latesIndexFor_myId = [\"myId\"] call KISKA_fnc_idCounter;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_idCounter\";\n\n#define NULL_TYPES [grpNull,objNull,locationNull,controlNull,displayNull,taskNull,teamMemberNull]\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_namespace\",localNamespace,[grpNull,objNull,locationNull,controlNull,displayNull,taskNull,teamMemberNull,localNamespace]]\n];\n\n\nif ((_namespace isEqualTypeAny NULL_TYPES) AND {isNull _namespace}) exitWith {\n    [[\"Null namespace passed for id \",_id,\" namespace \",_namespace],true] call KISKA_fnc_log;\n    -1\n};\n\nif (_id isEqualTo \"\") exitWith {\n    [\"Empty _id provided\",true] call KISKA_fnc_log;\n    -1\n};\n\n\n_id = toLowerANSI _id;\nprivate _indexMap = _namespace getVariable \"KISKA_indexMap\";\nif (isNil \"_indexMap\") then {\n    _indexMap = createHashMap;\n    _namespace setVariable [\"KISKA_indexMap\",_indexMap];\n};\n\nprivate _latestIndex = _indexMap getOrDefault [_id, 0];\n_indexMap set [_id,_latestIndex + 1];\n\n\n_latestIndex\n",
    "fileName": "fn_idCounter.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_idCounter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isAdminOrHost\n\nDescription:\n    Checks if the machine is an admin or host's.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - True if is, false if not\n\nExamples:\n    (begin example)\n        _isAdminOrHost = call KISKA_fnc_isAdminOrHost;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isAdminOrHost\";\n\n// singleplayer is always true\nif (isServer) exitWith {true};\n\nif (!(call BIS_fnc_admin > 0) AND {clientOwner isNotEqualTo 2}) then {\n    false\n} else {\n    true\n};\n",
    "fileName": "fn_isAdminOrHost.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_isAdminOrHost.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isEmptyCode\n\nDescription:\n    Checks if the provided argument is an empty code block. Also handles the fact\n     that a `compileFinal`'d block is not actually equal to `{}`.\n\nParameters:\n    _this <ANY> - The value to check.\n\nReturns:\n    <BOOL> - Whether or not the given argument is equal to empty code.\n\nExamples:\n    (begin example)\n        {} call KISKA_fnc_isEmptyCode; // true\n        (compileFinal \"\") call KISKA_fnc_isEmptyCode; // true\n        \"\" call KISKA_fnc_isEmptyCode; // false\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isEmptyCode\";\n\n\n_this isEqualTo {} OR { _this isEqualTo (compileFinal \"\") }\n",
    "fileName": "fn_isEmptyCode.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_isEmptyCode.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isGroupAlive\n\nDescription:\n    Checks if any unit in the group is alive.\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group or a unit in that group to check the status for\n\nReturns:\n    <BOOL> - True if a unit in the group is alive, false otherwise\n\nExamples:\n    (begin example)\n        [group player] call KISKA_fnc_isGroupAlive;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isGroupAlive\";\n\nparams [\n    [\"_group\",grpNull,[grpNull,objNull]]\n];\n\n\nif (isNull _group) exitWith {false};\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\nprivate _units = units _group;\nprivate _personInGroupIsAlive = (_units findIf {alive _x}) isNotEqualTo -1;\n\n\n_personInGroupIsAlive\n",
    "fileName": "fn_isGroupAlive.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_isGroupAlive.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isMainMenu\n\nDescription:\n    Checks if loaded mission is main menu.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL>\n\nExamples:\n    (begin example)\n        isMainMenu = call KISKA_fnc_isMainMenu;\n    (end)\n\nAuthor(s):\n    Leopard20\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isMainMenu\";\n\nallDisplays isEqualTo [findDisplay 0]\n",
    "fileName": "fn_isMainMenu.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_isMainMenu.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isPatchLoaded\n\nDescription:\n    Simply checks a config name to see if it is loaded under CFGPatches\n\nParameters:\n    0: _configName <STRING> - The patch config name to check for\n\nReturns:\n    <BOOL> - False if not, true if is loaded\n\nExamples:\n    (begin example)\n\n        [\"OPTRE_Core\"] call KISKA_fnc_isPatchLoaded;\n\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isPatchLoaded\";\n\nparams [\n    [\"_configName\",\"\",[\"\"]]\n];\n\nif (_configName isEqualTo \"\") exitWith {\n    [\"_configName is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _isLoaded = isClass (configFile / \"cfgPatches\" / _configName);\n\n_isLoaded",
    "fileName": "fn_isPatchLoaded.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_isPatchLoaded.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_log\n\nDescription:\n    Prints a log with a script name to console.\n\n    Whether or not something is logged depends on whether the script is set in\n     the KISKA_logScripts array. If the script name (or \"all\") is found in the array\n     a log is printed.\n\nParameters:\n    0: _message <ANY> - The message to send. If array and _joinString is true, will be used with the joinString command\n    1: _logWithError <BOOL> - Show error message on screen (BIS_fnc_error)\n    2: _forceLog <BOOL> - Print log regardless of KISKA_logScripts content\n    3: _joinString <BOOL> - Should this message joined into a string if an array\n    4: _scriptName <STRING> - The name of the script from where this message is being called\n\nReturns:\n    <ANY> - The message sent\n\nExamples:\n    (begin example)\n        missionNamespace setVariable [\"KISKA_doLog\",true];\n        scriptName \"My Script\";\n        private _myvar = 1;\n        [[\"Hello Number\",_myvar]] call KISKA_fnc_log;\n\n        // prints [\"My Script\"] \"Hello Number 1\" to console\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nif !(missionNamespace getVariable [\"KISKA_CBA_log\",true]) exitWith {};\n\nparams [\n    [\"_message\",\"\",[]],\n    [\"_logWithError\",missionNamespace getVariable [\"KISKA_CBA_logWithError\",false],[true]],\n    [\"_forceLog\",true,[true]],\n    [\"_joinString\",true,[true]],\n    [\"_scriptName\",\"\",[\"\"]]\n];\n\nif (_scriptName == \"\" AND {!isNil \"_fnc_scriptNameParent\"}) then {\n    _scriptName = _fnc_scriptNameParent;\n};\n\nif !(_forceLog) then {\n    // set _forceLog to true if the scripts name is in the log array KISKA_logScripts\n    private _scripts = missionNamespace getVariable [\"KISKA_CBA_logScripts_array\",[\"all\"]];\n    if (\"all\" in _scripts OR {(toLowerANSI _scriptName) in _scripts}) then {\n        _forceLog = true;\n    };\n};\n\nif !(_forceLog) exitWith {};\n\n// only start a new header message with script name when another script interrupts\nprivate _currentLoggedScript = missionNamespace getVariable [\"KISKA_currentLoggedScript\",\"\"];\nif (_currentLoggedScript != _scriptName) then {\n    missionNamespace setVariable [\"KISKA_currentLoggedScript\",_scriptName];\n    diag_log text(\"--------- KISKA Log \" + _scriptName + \" ---------\");\n};\n\nif (_message isEqualType [] AND {_joinString}) then {\n    _message = _message joinString \"\";\n};\n\ndiag_log text(\"[\" + _scriptName + \"] \" + _message);\n\nif (_logWithError) then {\n    (_scriptName + \" : \" + _message) call BIS_fnc_error;\n};\n\n\n_message\n",
    "fileName": "fn_log.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_log.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_markBorder\n\nDescription:\n    Places a number of objects around a given radius to mark an area.\n\nParameters:\n    0: _centerPos <POSITION_ASL or OBJECT> - The center of the area to mark\n    1: _radius <NUMBER> - The distance from the center to place markers around\n    2: _markerCount <NUMBER> - The number of markers to use for the area\n    3: _verticalOffset <NUMBER> - Objects will be placed at Z axis of 0, this will offset that position\n    4: _markerObjectClass <STRING> - The classname of the object to place to mark the area\n\nReturns:\n    <ARRAY> - An array of simple objects created to mark the area\n\nExamples:\n    (begin example)\n        _markers = [\n            player\n        ] call KISKA_fnc_markBorder;\n    (end)\n\nAuthor(s):\n    Leopard20\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_markBorder\";\n\nparams [\n    [\"_centerPos\",objNull,[objNull,[]]],\n    [\"_radius\",25,[123]],\n    [\"_markerCount\",10,[123]],\n    [\"_verticalOffset\",0,[123]],\n    [\"_markerObjectClass\",\"Sign_Sphere100cm_F\",[\"\"]]\n];\n\nif (_centerPos isEqualType objNull) then {\n    _centerPos = getPosASL _centerPos;\n};\n\nprivate _markerInterval = 360 / _markerCount;\nprivate _heading = 0;\nprivate _objects = [];\nfor \"_i\" from 1 to _markerCount do {\n    private _pos = AGLToASL(_centerPos getPos [_radius,_heading]) vectorAdd [0,0,_verticalOffset];\n    _heading = _heading + _markerInterval;\n\n    private _object = [_markerObjectClass,_pos,0,false,false] call BIS_fnc_createSimpleObject;\n    _objects pushback _object;\n};\n\n\n_objects\n",
    "fileName": "fn_markBorder.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_markBorder.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_markPositions\n\nDescription:\n    Simply creates a 3d object helper marker on provided postitions. \n    Works in 3den also.\n\nParameters:\n    0: _positions <ARRAY> - An array of positions to place the markers on\n\nReturns:\n    _entities <ARRAY> - all created markers\n\nExamples:\n    (begin example)\n        [[0,0,0],[0,0,0]] call KISKA_fnc_markPositions;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nparams [\n    [\"_positions\",[],[[]]]\n];\n\nif (_positions isEqualTo []) exitWith {\n    []\n};\n\nprivate _entities = [];\n\nif (is3DEN) then {\n    _positions apply {\n        private _entity = create3DENEntity [\"OBJECT\",\"Sign_Arrow_Large_F\",_x];\n        _entities pushBack _entity;\n    };\n\n} else {\n    _positions apply {\n        private _entity = \"Sign_Arrow_Large_F\" createVehicle _x;\n        _entities pushBack _entity;\n    };\n\n};\n\n_entities\n",
    "fileName": "fn_markPositions.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_markPositions.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_monitorFPS\n\nDescription:\n    Keeps track of the local machine's FPS for a given duration and prints\n     data to log file.\n\nParameters:\n    0: _duration <NUMBER> - How long the test will run\n    1: _frequency <NUMBER> - Time between checks\n    2: _print <BOOL> - Shows a hint on screen\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [60] call KISKA_fnc_monitorFPS;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_monitorFPS\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled evnironment, exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_monitorFPS;\n};\n\nparams [\n    [\"_duration\",60,[123]],\n    [\"_frequency\",0.1,[123]],\n    [\"_print\",false,[true]]\n];\n\nprivate _fpsArray = [];\nprivate _fps = 0;\n\nsleep 2; // in case somebody is leaving a menu from execution this gives a small buffer so the the min fps is actually representative\n\nprivate _timeToEnd = time + _duration;\nwhile {time < _timeToEnd} do {\n    _fps = diag_fps;\n    if (_print) then {\n        hint str _fps;\n    };\n\n    _fpsArray pushBack _fps;\n    sleep _frequency;\n};\n\nprivate _high = selectMax _fpsArray;\nprivate _low = selectMin _fpsArray;\n\nprivate _average = -1;\n_fpsArray apply {\n    _average =  _average + _x;\n};\n_average = _average / (count _fpsArray);\n\nprivate _printOut = \"FPS Test has ended: AVERAGE: \" + str _average + \" MAX: \" + str _high + \" MIN: \" + str _low;\nhint _printOut;\ndiag_log _printOut;\n\n\nnil\n",
    "fileName": "fn_monitorFPS.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_monitorFPS.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_netId\n\nDescription:\n    Gets a \"netId\" for singleplayer and a `netId` when in multiplayer.\n\nParameters:\n    0: _entity <OBJECT or GROUP> - The group or object to get the id of\n\nReturns:\n    <STRING> - The Id of the entity\n\nExamples:\n    (begin example)\n        _id = [player] call KISKA_fnc_netId;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_netId\";\n\nif (canSuspend) exitWith {\n    [\n        {_this call KISKA_fnc_netId},\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_entity\",objNull,[grpNull,objNull]]\n];\n\nif (isNull _entity) exitWith {\n    [\"_entity is null!\",true] call KISKA_fnc_log\n    -1\n};\n\n\nif (isMultiplayer) exitWith {netId _entity};\n\nprivate _id = _entity getVariable [\"KISKA_netId\",\"\"];\nif (_id isNotEqualTo \"\") exitWith {_id};\n\n\n// if object is not saved\nprivate _netIdCount = [\"KISKA_netId_counter\"] call KISKA_fnc_idCounter;\n_id = [\"0:\",_netIdCount] joinString \"\";\n_entity setVariable [\"KISKA_netId\",_id];\n\n// create map if needed\nprivate _map = localNamespace getVariable \"KISKA_objectNetId_map\";\nif (isNil \"_map\") then {\n    _map = createHashMap;\n    localNamespace setVariable [\"KISKA_objectNetId_map\",_map];\n};\n\n\nif !(_id in _map) then {\n    _map set [_id,_entity];\n};\n\n\n_id\n",
    "fileName": "fn_netId.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_netId.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_notification\n\nDescription:\n    Prints a simple KISKA Notify notification on screen.\n\nParameters:\n    0: _message : <STRING or ARRAY> - If string, the message to display as title.\n        \n        If array:\n        - 0: _text : <STRING> - Text to display or path to .paa or .jpg\n            image (may be passed directly if only text is required)\n        - 1: _size : <NUMBER> - Scale of text\n        - 2: _color : <NUMBER[]> - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1])\n\n    1: _lifetime : <NUMBER> - How long the notification will be visible (min of 2 seconds)\n    2: _canSkip : <BOOL> - Can the notification be skipped when another is in the queue\n    3: _headerColor : <NUMBER[]> - An array of [R,G,B,A] color values; defaults to green\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"Hello World\"] call KISKA_fnc_notification;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_notification\";\n\n#define GREEN_RBGA [0.21,0.71,0.21,1]\n\nparams [\n    [\"_message\",\"\",[\"\",[]]],\n    [\"_lifetime\",4,[123]],\n    [\"_canSkip\",true,[true]],\n    [\"_headerColor\",GREEN_RBGA,[[]],[3,4]]\n];\n\n[\n    [\"Notification:\",1.1,_headerColor],\n    _message,\n    _lifetime,\n    _canSkip\n] call KISKA_fnc_notify;\n\n\nnil\n",
    "fileName": "fn_notification.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_notification.sqf"
  },
  {
    "text": "#include \"\\a3\\ui_f\\hpp\\defineCommonGrids.inc\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_notify\n\nDescription:\n    Display a text message. Multiple incoming messages are queued. Also controls\n     the lifetime of a notification\n\nParameters:\n    0: _titleLine : <STRING, STRUCTURED TEXT, or ARRAY> - If string, the message to display as title.\n        \n        If array:\n        - 0. _text : <STRING> - Text to display or path to .paa or .jpg\n            image (may be passed directly if only text is required)\n        - 1. _size : <NUMBER> - Scale of text\n        - 2. _color : <ARRAY> - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1])\n\n    1: _subLine : <STRING, STRUCTURED TEXT, or ARRAY> - Formatted the same as _titleLine\n    2: _lifetime : <NUMBER> - How long the notification lasts in seconds (at least 2)\n    3: _skippable : <BOOL> - If there are more notifications behind in the queue and this notification\n        comes up, it will not be shown and thrown away\n\nExamples:\n    (begin example)\n        [\n            [\"Hello\",1.1,[0.75,0,0,1]],\n            \"World\",\n            5,\n            false\n        ] call KISKA_fnc_notify;\n    (end)\n\nReturns:\n    NOTHING\n\nAuthors:\n    commy2,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_notify\";\n\n#define NOTIFY_DEFAULT_X (safezoneX + safezoneW - 13 * GUI_GRID_W)\n#define NOTIFY_DEFAULT_Y (safezoneY + 6 * GUI_GRID_H)\n#define NOTIFY_MIN_WIDTH (12 * GUI_GRID_W)\n#define NOTIFY_MIN_HEIGHT (3 * GUI_GRID_H)\n\n#define TRIPLES(var1,var2,var3) var1##_##var2##_##var3\n\n#define FADE_IN_TIME 0.2\n#define FADE_OUT_TIME 1\n\n#define BACKGROUND_OPACITY 0.25\n\n#define GET_QUEUE localNamespace getVariable \"KISKA_notificationQueue\"\n#define SET_QUEUE(var) localNamespace setVariable [\"KISKA_notificationQueue\",var]\n\n\nif (canSuspend) exitWith {\n    [\n        KISKA_fnc_notify,\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nif (!hasInterface) exitWith {};\n\nprivate _structuredText = text \"\";\nparams [\n    [\"_titleLine\",\"\",[[],\"\"]],\n    [\"_subLine\",\"\",[[],\"\",_structuredText]],\n    [\"_lifetime\",4,[123]],\n    [\"_skippable\",false,[true]]\n];\n\nif (_lifetime < 2) then {\n    _lifetime = 2;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Build composition\n---------------------------------------------------------------------------- */\nprivate _composition = [];\n// top lineBreak is for gap at top of notification\n// bottom two lineBreaks create a gap at the bottom of the notification\n[lineBreak,_titleLine,lineBreak,_subLine,lineBreak,lineBreak] apply {\n    if (_x isEqualTo lineBreak) then {\n        _composition pushBack lineBreak;\n        continue;\n    };\n\n    private _isStructuredText = _x isEqualType (text \"\");\n    if (_isStructuredText) then {\n        _composition pushBack _x;\n        continue;\n    };\n\n    // Line\n    _x params [\n        [\"_text\",\"\",[\"\",text \"\"]],\n        [\"_size\",1,[123]],\n        [\"_color\",[1,1,1,1],[[]],[3,4]]\n    ];\n\n    if ((count _color) isEqualTo 3) then {\n        _color pushBack 1;\n    };\n\n    _color = _color call BIS_fnc_colorRGBAtoHTML;\n    _size = _size * 0.55 / (getResolution select 5);\n\n    private _isImage = (toLower _text) select [(count _text) - 4] in [\".paa\", \".jpg\"];\n    if (_isImage) then {\n        _composition pushBack (parseText format [\"<img align='center' valign='middle' size='%2' color='%3' image='%1'/>\", _text, _size, _color]);\n\n    } else {\n        _text = text _text;\n        _text setAttributes [\n            \"color\", _color,\n            \"size\", str _size\n        ];\n\n        _text = composeText [_text];\n        _composition pushBack _text;\n    };\n};\n\nprivate _notification = [_composition, _lifetime, _skippable];\n\n// add the queue\nif (isNil {GET_QUEUE}) then {\n    SET_QUEUE([]);\n};\n\n(GET_QUEUE) pushBack _notification;\n\n\n/* ----------------------------------------------------------------------------\n    loop\n---------------------------------------------------------------------------- */\nif !(localNamespace getVariable [\"KISKA_notificationLoopRunning\",false]) then {\n    localNamespace setVariable [\"KISKA_notificationLoopRunning\",true];\n\n    [] spawn {\n        /* ----------------------------------------------------------------------------\n            _fn_createNotification\n        ---------------------------------------------------------------------------- */\n        private _fn_createNotification = {\n            disableSerialization;\n            params [\n                \"_composition\",\n                \"_lifetime\"\n            ];\n\n            \"KISKA_ui_notify\" cutRsc [\"RscTitleDisplayEmpty\", \"PLAIN\", 0, true];\n            private _display = uiNamespace getVariable \"RscTitleDisplayEmpty\";\n\n            private _vignette = _display displayCtrl 1202;\n            _vignette ctrlShow false;\n\n            private _notificationCtrl = _display ctrlCreate [\"RscStructuredText\", -1];\n\n            private _structuredText = composeText _composition;\n            _structuredText setAttributes [\"align\",\"center\"];\n            _structuredText = composeText [_structuredText];\n            _notificationCtrl ctrlSetStructuredText _structuredText;\n            _notificationCtrl ctrlSetBackgroundColor [0,0,0,BACKGROUND_OPACITY];\n            _notificationCtrl ctrlCommit 0.1;\n\n            // using CBA notification position if available\n            private _left = profileNamespace getVariable ['TRIPLES(IGUI,cba_ui_notify,x)', NOTIFY_DEFAULT_X];\n            private _top = profileNamespace getVariable ['TRIPLES(IGUI,cba_ui_notify,y)', NOTIFY_DEFAULT_Y];\n            private _width = profileNamespace getVariable ['TRIPLES(IGUI, cba_ui_notify, w)', NOTIFY_MIN_WIDTH];\n            private _height = profileNamespace getVariable ['TRIPLES(IGUI, cba_ui_notify, h)', NOTIFY_MIN_HEIGHT];\n\n            _width = (ctrlTextWidth _notificationCtrl) max _width;\n            _height = (ctrlTextHeight _notificationCtrl) max _height;\n\n            // ensure the box not going off screen\n            private _right = _left + _width;\n            private _bottom = _top + _height;\n\n            private _leftEdge = safezoneX;\n            private _rightEdge = safezoneW + safezoneX;\n            private _topEdge = safezoneY;\n            private _bottomEdge = safezoneH + safezoneY;\n\n            if (_right > _rightEdge) then {\n                _left = _left - (_right - _rightEdge);\n            };\n\n            if (_left < _leftEdge) then {\n                _left = _left + (_leftEdge - _left);\n            };\n\n            if (_bottom > _bottomEdge) then {\n                _top = _top - (_bottom - _bottomEdge);\n            };\n\n            if (_top < _topEdge) then {\n                _top = _top + (_topEdge - _top);\n            };\n\n\n            _notificationCtrl ctrlSetPositionW _width;\n            _notificationCtrl ctrlSetPositionX _left;\n            _notificationCtrl ctrlSetPositionY _top;\n\n            _notificationCtrl ctrlSetFade 1;\n            _notificationCtrl ctrlCommit 0;\n            // in order to get the height of the background to be properly sized,\n            // need to commit other changes before checking ctrlTextHeight\n            _notificationCtrl ctrlSetPositionH (ctrlTextHeight _notificationCtrl);\n            _notificationCtrl ctrlSetFade 0;\n            _notificationCtrl ctrlCommit (FADE_IN_TIME);\n\n            sleep _lifetime - FADE_OUT_TIME;\n\n            _notificationCtrl ctrlSetFade 1;\n            _notificationCtrl ctrlCommit (FADE_OUT_TIME);\n\n            sleep FADE_OUT_TIME;\n        };\n\n\n        /* ----------------------------------------------------------------------------\n            Queue loop\n        ---------------------------------------------------------------------------- */\n        private [\"_notificationInfo\",\"_skippable\"];\n        private _queue = GET_QUEUE;\n\n        while {(count _queue) > 0} do {\n            _notificationInfo = _queue deleteAt 0;\n            _skippable = _notificationInfo deleteAt 2;\n\n            if !(_skippable AND ((count _queue) > 0)) then {\n                _notificationInfo call _fn_createNotification;\n            };\n        };\n\n        localNamespace setVariable [\"KISKA_notificationLoopRunning\",false];\n    };\n\n};\n\n\nnil\n",
    "fileName": "fn_notify.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_notify.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_openCommandingMenuPath\n\nDescription:\n    Opens a command menu path dynamically instead of needing to define sub menus.\n\nParameters:\n    0: _menuPath <ARRAY> - An array of menus to open in their given sequence\n\n        A menu is an array of several components:\n        - 0. _menuTitle : <STRING> - the title of the commanding menu (appears above the menu).\n        - 1. _menuOptions : <[STRING,ANY][]> - an array of `[option label, value]` that will\n            appear in this given order in the commanding menu. If the value is CODE, it will \n            be called if and when selecting the given option.\n\n    1: _endExpression <STRING, CODE, or ARRAY> - The code to be executed at the end of the path.\n        It receives all menu parameters in _this. (see `KISKA_fnc_callBack`)\n    2: _exitExpression <STRING, CODE, or ARRAY> - The code to be executed in the event that\n        the menu is closed by the player. It gets all added params up to that point in _this.\n        (see `KISKA_fnc_callBack`)\n    3: _finally <STRING, CODE, or ARRAY> - Code that will be executed finally regardless\n        of whether the `_endExpression` or `_exitExpression` is triggered.\n        It receives all menu parameters in _this. (see `KISKA_fnc_callBack`)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            [\n                [\n                    \"First Menu\",\n                    [\"option 1\",\"FirstMenu_1\"],\n                    [\"option 2\",\"FirstMenu_2\"]\n                ],\n                [\n                    \"Second Menu\",\n                    [\"option 1\",\"SecondMenu_1\"],\n                    [\"option 2\",\"SecondMenu_2\"]\n                ]\n            ],\n            {\n                hint str [\"Reached end of menus with values\",_this];\n            },\n            {\n                hint str [\"Exited menu prematurely with values\",_this];\n            }\n        ] spawn KISKA_fnc_openCommandingMenuPath\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_openCommandingMenuPath\";\n\n#define MAX_KEYS 9\n\nif (!hasInterface) exitWith {\n    [\"Can only run on machines with interface\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled, exiting to scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_openCommandingMenuPath;\n};\n\nparams [\n    [\"_menuPath\",[],[[]]],\n    [\"_endExpression\",{},[\"\",{},[]]],\n    [\"_exitExpression\",{},[\"\",{},[]]],\n    [\"_finally\",{},[\"\",{},[]]]\n];\n\n// create a container for holding params from menus\nlocalNamespace setVariable [\"KISKA_commandingMenu_selectedValues\",[]];\n\nprivate _menuWasClosed = false;\nprivate _menuVariables = [];\n_menuPath apply {\n    _x params [\n        [\"_menuTitle\",\"Undefined Title\",[\"\"]],\n        [\"_menuOptions\",[],[[]]]\n    ];\n\n    private _commandingMenu = [\n        [_menuTitle,false]\n    ];\n    {\n        private \"_keyCode\";\n        if (_forEachIndex <= MAX_KEYS) then {\n            // key codes are offset by 2 (1 on the number bar is key code 2)\n            _keyCode = _forEachIndex + 2;\n        } else {\n            _keyCode = 0;\n        };\n\n        _x params [\n            [\"_optionTitle\",\"\",[\"\"]],\n            \"_optionValue\"\n        ];\n\n        private _onSelectedCallbackVariableName = [\"KISKA_commandingMenu_onOptionSelectedCallback\"] call KISKA_fnc_generateUniqueId;\n        _menuVariables pushBack _onSelectedCallbackVariableName;\n        private _onOptionSelected = [[_optionValue],{\n            params [\"_optionValue\"];\n            private _selectedValues = localNamespace getVariable 'KISKA_commandingMenu_selectedValues';\n            _selectedValues pushBack _optionValue;\n            localNamespace setVariable ['KISKA_commandingMenu_openNextMenu',true];\n        }];\n        missionNamespace setVariable [_onSelectedCallbackVariableName,_onOptionSelected];\n\n        private _expression = format [\"(missionNamespace getVariable '%1') call KISKA_fnc_callBack\",_onSelectedCallbackVariableName];\n        _commandingMenu pushBack [\n            _optionTitle,\n            [_keyCode],\n            \"\", // submenu\n            -5, // execute command\n            [[\"expression\", _expression]],\n            \"1\", // is active\n            \"1\" // is visible\n        ];\n    } forEach _menuOptions;\n\n    private _menuHasSingleOption = (count _commandingMenu) isEqualTo 2;\n    if (_menuHasSingleOption) then {\n        private _singleMenuOption = _commandingMenu select 1;\n        private _menuOptionExpression = _singleMenuOption select 4;\n        private _expressionCode = (_menuOptionExpression select 0) select 1;\n        [] call (compile _expressionCode);\n        continue;\n    };\n\n    // keeps track of whether or not to open the next menu\n    localNamespace setVariable [\"KISKA_commandingMenu_openNextMenu\",false];\n\n    private _menuVariableName = [\"KISKA_commandingMenu_subMenu\"] call KISKA_fnc_generateUniqueId;\n    // command menus must be saved to missionNamespace\n    missionNamespace setVariable [_menuVariableName,_commandingMenu];\n    _menuVariables pushBack _menuVariableName;\n    private _commandingMenuName = [\"#USER:\",_menuVariableName] joinString \"\";\n    showCommandingMenu _commandingMenuName;\n    \n    // wait for player to select and option from the current menu or for them to close the menu\n    waitUntil {\n        sleep 0.1;\n        if (localNamespace getVariable \"KISKA_commandingMenu_openNextMenu\") exitWith {true};\n        _menuWasClosed = commandingMenu isEqualTo \"\";\n        _menuWasClosed\n    };\n    if (_menuWasClosed) then { break };\n};\n\nprivate _params = localNamespace getVariable \"KISKA_commandingMenu_selectedValues\";\nprivate _expression = [_endExpression,_exitExpression] select _menuWasClosed;\n[_params, _expression] call KISKA_fnc_callBack;\n[_params, _finally] call KISKA_fnc_callBack;\n\n\n_menuVariables apply { missionNamespace setVariable [_x,nil] };\nlocalNamespace setVariable [\"KISKA_commandingMenu_selectedValues\",nil];\nlocalNamespace setVariable [\"KISKA_commandingMenu_openNextMenu\",nil];\n\n\nnil\n",
    "fileName": "fn_openCommandingMenuPath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_openCommandingMenuPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playDrivePath\n\nDescription:\n    Uses setDriveOnPath to move a vehicle. Additionally makes sure the vehicle\n     can move before starting (turn engineOn and use doStop).\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to use setDriveOnPath command on\n    1: _pathArray <ARRAY> - An array of positions in [x,y,z] format or\n        [x,y,z,speed-in-meters-per-second] for the vehicle to drive on.\n        (see setDriveOnPath documentation)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            _pathArray\n        ] call KISKA_fnc_playDrivePath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playDrivePath\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_pathArray\",[],[[]]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _driver = driver _vehicle;\nif (isNull _driver) exitWith {\n    [\"_vehicle has no driver!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n_vehicle engineOn true;\nif !(isAgent teamMember _driver) then {\n    doStop _driver;\n};\n\n// some time (more then one frame) is needed after doStop to execute setDriveOnPath\n[\n    {\n        (_this select 0) setDriveOnPath (_this select 1);\n    },\n    [_vehicle,_pathArray],\n    1\n] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_playDrivePath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_playDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_pushBackToArray\n\nDescription:\n    Pushes back a value to a global array.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The array in string format\n    1: _entryToAdd : <ANY> - The value to pushBack\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL, or DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - true if added, false if not\n\nExamples:\n    (begin example)\n        [\"myGlobalArrayVar\",someInfoHere,missionNamespace] call KISKA_fnc_pushBackToArray;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_pushBackToArray\";\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_entryToAdd\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (isNil \"_entryToAdd\") exitWith {\n    [\"_entryToAdd was undefined, nothing to pushback\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\n//[[\"Called to add \",_entryToAdd,\" to array var name: \", _arrayVariableName],false] call KISKA_fnc_log;\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\n_array pushBack _entryToAdd;\n\nif (isNil {_namespace getVariable _arrayVariableName}) then {\n    _namespace setVariable [_arrayVariableName,_array];\n};\n\n\ntrue\n",
    "fileName": "fn_pushBackToArray.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_pushBackToArray.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_pushBackToArray_interface\n\nDescription:\n    Pushes back a value to a global array. Checks if machine hasInterface before pushing.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The array in string format\n    1: _entryToAdd : <ANY> - The value to pushBack\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL, or DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - true if added, false if not\n\nExamples:\n    (begin example)\n        [\n            \"myGlobalArrayVar\",\n            someInfoHere,\n            missionNamespace\n        ] call KISKA_fnc_pushBackToArray_interface;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_pushBackToArray_interface\";\n\nif (!hasInterface) exitWith {false};\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_entryToAdd\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (isNil \"_entryToAdd\") exitWith {\n    [\"_entryToAdd was undefined, nothing to pushback\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\n//[[\"Called to add \",_entryToAdd,\" to array var name: \", _arrayVariableName],false] call KISKA_fnc_log;\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\n_array pushBack _entryToAdd;\n\nif (isNil {_namespace getVariable _arrayVariableName}) then {\n    _namespace setVariable [_arrayVariableName,_array];\n};\n\n\ntrue\n",
    "fileName": "fn_pushBackToArray_interface.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_pushBackToArray_interface.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomIndex\n\nDescription:\n    Returns a random index of an array ~2x faster than BIS_fnc_randomIndex;\n\nParameters:\n    0: _array <ARRAY> - The array to find a random index of.\n\nReturns:\n    <NUMBER> - The random index\n\nExamples:\n    (begin example)\n        private _randomIndex = [[1,2,3]] call KISKA_fnc_randomIndex;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomIndex\";\n\nparams [\n    [\"_array\",[],[[]]]\n];\n\n\nfloor (random (count _array))",
    "fileName": "fn_randomIndex.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_randomIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_reassignCurator\n\nDescription:\n    Reassigns a curator object to the local player.\n\nParameters:\n    0: _curatorObject : <OBJECT or STRING> - The curator object to reassign\n    1: _isManual : <BOOL> - Was this called from the diary entry (keeps hints from showing otherwise)\n\nReturns:\n    <BOOL> - true if added to player, false otherwise\n\nExamples:\n    (begin example)\n        // show hint messages\n        [myCuratorObject,true] call KISKA_fnc_reassignCurator;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_reassignCurator\";\n\nif (!hasInterface) exitWith {false};\n\nparams [\n    [\"_curatorObject\",objNull,[objNull,\"\"]],\n    [\"_isManual\",false,[true]]\n];\n\n// check if player is host or admin\nif !(call KISKA_fnc_isAdminOrHost) exitWith {\n    if (_isManual) then {\n        [\"Only admins can be assigned curator\"] call KISKA_fnc_notification;\n    };\n    false\n};\n\nif (_curatorObject isEqualType \"\") then {\n    _curatorObject = missionNamespace getVariable [_curatorObject,objNull];\n};\n\nif (isNull _curatorObject) exitWith {\n    [\"_curatorObject isNull!\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _unitWithCurator = getAssignedCuratorUnit _curatorObject;\nif (isNull _unitWithCurator) then {\n    [player,_curatorObject] remoteExecCall [\"assignCurator\",2];\n} else {\n    if (alive _unitWithCurator) then {\n        // no sense in alerting player if they are the curator still\n        if (!(_unitWithCurator isEqualTo player)) then {\n            [\"Another currently alive admin has the curator assigned to them already\"] call KISKA_fnc_notification;\n        } else {\n            [\"You are already the curator\"] call KISKA_fnc_notification;\n        };\n\n        false\n    } else {\n        [_unitWithCurator,_isManual,_curatorObject] spawn {\n            params [\"_unitWithCurator\",\"_isManual\",\"_curatorObject\"];\n            [_curatorObject] remoteExec [\"unAssignCurator\",2];\n\n            // wait till curator doesn't have a unit to give it the player\n            waitUntil {\n                if !(isNull (getAssignedCuratorUnit _curatorObject)) exitWith {\n                    [player,_curatorObject] remoteExecCall [\"assignCurator\",2];\n                    if (_isManual) then {\n                        hint \"You are now the curator\";\n                    };\n                    true\n                };\n\n                [_curatorObject] remoteExec [\"unAssignCurator\",2];\n\n                sleep 5;\n                false\n            };\n        };\n\n        true\n    };\n};\n",
    "fileName": "fn_reassignCurator.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_reassignCurator.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_recordDrivePath\n\nDescription:\n    Records an array of positons and speeds for use with setDriveOnPath command.\n\nParameters:\n    0: _unit <OBJECT> - The unit to record\n    1: _frequency <NUMBER> - How often to record, 0 for every frame\n    2: _recordSpeed <BOOL> - Should the speed of the _unit be recorded to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            objectParent player,\n            0.25\n        ] call KISKA_fnc_recordDrivePath\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_recordDrivePath\";\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_frequency\",0.5,[123]],\n    [\"_recordSpeed\",true,[false]]\n];\n\nif (isNull _unit) exitWith {\n    [\"_unit is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _path = [];\nprivate _id = [\n    {\n        params [\n            \"_args\",\n            \"_id\"\n        ];\n\n        _args params [\n            \"_unit\",\n            \"_path\",\n            \"_recordSpeed\"\n        ];\n        if (isNull _unit) then {\n            [\"Recording failed, _unit is null\"] call KISKA_fnc_errorNotification;\n            [_id] call CBA_fnc_removePerFrameHandler;\n\n            // remove display event\n            private _keyDownEventId = localNamespace getVariable [\"KISKA_drivePathRecordingDisplayEvent_id\", -1];\n            localNamespace setVariable [\"KISKA_drivePathRecordingDisplayEvent_id\", nil];\n            (findDisplay 46) displayRemoveEventHandler [\"KeyDown\", _keyDownEventId];\n\n        } else {\n            if (_unit getVariable [\"KISKA_fnc_recordDrivePath_\" + str _id, true]) then {\n                private _array = ASLToAGL (getPosASL _unit);\n\n                if (_recordSpeed) then {\n                    _array pushBack ((speed _unit) / 3.6);\n                };\n\n                _path pushBack _array;\n\n            } else {\n                copyToClipboard (str _path);\n                [_id] call CBA_fnc_removePerFrameHandler;\n\n            };\n        };\n\n\n    },\n    _frequency,\n    [_unit,_path,_recordSpeed]\n] call CBA_fnc_addPerFrameHandler;\n[\"Started unit recording, press escape key to stop\"] call KISKA_fnc_notification;\n\ndisableSerialization;\nprivate _display = findDisplay 46;\n// Stops Capture after pressing the ESC key\nprivate _displayId = [\n    _display,\n    \"KeyDown\",\n    {\n        _thisArgs params [\n            \"_id\",\n            \"_unit\"\n        ];\n\n        if ((_this select 1) == 1) then {\n            _unit setVariable [\"KISKA_fnc_recordDrivePath_\" + str _id, false];\n            [\"Stopped unit recording, data copied to clipboard\"] call KISKA_fnc_notification;\n\n            (_this select 0) displayRemoveEventHandler [_thisType, _thisID];\n        };\n    },\n    [_id,_unit]\n] call CBA_fnc_addBISEventHandler;\nlocalNamespace setVariable [\"KISKA_drivePathRecordingDisplayEvent_id\", _displayId];\n\n\nnil\n",
    "fileName": "fn_recordDrivePath.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_recordDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_remoteReturn_receive\n\nDescription:\n    The send back component of KISKAs remote returns.\n    This catches what was sent in KISKA_fnc_remoteReturn_send and will send the\n     variable back to the remoteExecutedOwner.\n\nParameters:\n    0: _code <STRING> - The code to execute to get a return\n    1: _args : <ARRAY> - An array of arguements for the _code\n    2: _scheduled : <BOOL> - Should _code be run in a scheduled environment\n    3: _uniqueId <STRING> - The unique variable id used to send the return back to the requester\n\nReturns:\n    NOTHING\n\nExamples:\n    // called specifically from KISKA_fnc_remoteReturn_send\n    (begin example)\n        [\n            _code,\n            _args,\n            _scheduled,\n            _uniqueId,\n            clientOwner\n        ] remoteExecCall [\"KISKA_fnc_remoteReturn_receive\",_target];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_remoteReturn_receive\";\n\nparams [\n    [\"_code\",\"\",[\"\"]],\n    [\"_args\",[],[[]]],\n    [\"_scheduled\",false,[true]],\n    \"_uniqueId\"\n];\n\nprivate _sendBackTarget = remoteExecutedOwner;\n// setVariable handling\nif (_sendBackTarget isEqualTo 0) then {\n\n    [[\"Found _sendBackTarget isEqualTo 0 for \",_uniqueId],false] call KISKA_fnc_log;\n\n    // if it's multiplayer, do not send all connected the value, just put it on server\n    if (isMultiplayer) then {\n        [\"Found to be multiplayer, setting target to 2 \",false] call KISKA_fnc_log;\n        _sendBackTarget = 2;\n    };\n} else {\n\n    [[\"Found _sendBackTarget ise \",_sendBackTarget,\" for \",_uniqueId],false] call KISKA_fnc_log;\n\n    // setVariable in single player does not work with 2 to set on the local machine\n    if (!isMultiplayer AND {_sendBackTarget isEqualTo 2}) then {\n        [[\"Not multiplayer and _sendBackTarget is 2, setting \",_uniqueId,\" to 0 target\"],false] call KISKA_fnc_log;\n        _sendBackTarget = 0;\n    };\n};\n\n\n\nprivate _compiledCode = compileFinal _code;\nif (_scheduled) then {\n\n    [_compiledCode,_args,_uniqueId,_sendBackTarget] spawn {\n        params [\"_code\",\"_args\",\"_uniqueId\",\"_sendBackTarget\"];\n\n        private \"_return\";\n        if (_args isEqualTo []) then {\n            _return = call _code;\n        } else {\n            _return = _args call _code;\n        };\n\n        missionNamespace setVariable [_uniqueId,_return,_sendBackTarget];\n    };\n} else {\n\n    private \"_return\";\n    if (_args isEqualTo []) then {\n        _return = call _compiledCode;\n    } else {\n        _return = _args call _compiledCode;\n    };\n\n    missionNamespace setVariable [_uniqueId,_return,_sendBackTarget];\n};\n",
    "fileName": "fn_remoteReturn_receive.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_remoteReturn_receive.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_remoteReturn_send\n\nDescription:\n    Gets a remote return from a scripting command on a target machine.\n    \n    Basically remoteExec but with a return.\n\n    Needs to be run in a scheduled environment as it takes time to receive\n     the return.\n\n    This should not be abused to obtain large returns over the network.\n    \n    Be smart and use for simple types (not massive arrays).\n\nParameters:\n    0: _code <STRING> - The command to execute on the target machine\n    1: _defaultValue : <ANY> - If the variable does not exist for the target, what should be returned instead\n    2: _target : <NUMBER, OBJECT, or STRING> - The target to execute the _code on\n    3: _scheduled : <BOOL> - Should _code be run in a scheduled environment (on target machine)\n    4: _awaitParams : <[NUMBER,NUMBER,BOOL]> - How the get from the target should be awaited\n\n        Parameters:\n        - 0: <NUMBER> - The sleep time between each check for the variable being received\n        - 1: <NUMBER> - The max time to wait for (this is not total game time but time slept)\n        - 2: <BOOL> - Whether or not the sleep time should be exponential (double every iteration)\n\n\nReturns:\n    <ANY> - Whatever the code returns\n\nExamples:\n    (begin example)\n        [] spawn {\n            // need to call for direct return but in scheduled environment\n            _clientIdFromServer = [\"owner (_this select 0)\",[player],2] call KISKA_fnc_remoteReturn_send;\n        };\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_remoteReturn_send\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled environment\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_code\",\"\",[\"\"]],\n    [\"_args\",[],[[]]],\n    [\"_target\",2,[123,objNull,\"\"]],\n    [\"_scheduled\",false,[true]],\n    [\"_awaitParams\",[],[[]]]\n];\n\nif ((_target isEqualType objNull) AND {isNull _target}) exitWith {\n    [\"_target is null object!\"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _targetIsNetId = false;\nprivate _targetsMultipleUsers = false;\nprivate _exitForMultiUserTarget = false;\nprivate _regularMultiplayer = isMultiplayer AND (!isMultiplayerSolo);\nif (_regularMultiplayer) then {\n    private _targetsMultipleUsers = (_target isEqualType 123) AND {_target <= 0};\n    if (_targetsMultipleUsers) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n\n    private _targetIsString = _target isEqualType \"\";\n    if (!_targetIsString) exitWith {};\n\n    private _targetIsNetId = _targetIsString AND {\n            private _split = _target splitString \":\";\n            private _splitCount = count _split;\n            (_splitCount isEqualTo 2) AND {\n                private _splitParsed = _split apply {parseNumber _x};\n                private _splitCompare = _splitParsed apply {str _x};\n                _splitCompare isEqualTo _split\n            }\n        };\n\n    if (!_targetIsNetId) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n};\n\n\nif (_exitForMultiUserTarget) exitWith {\n    [[\"_target: \",_target,\" is invalid as it will be sent to more then one machine!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_awaitParams params [\n    [\"_awaitTime\",0.05,[123]],\n    [\"_maxWaitTime\",2,[123]],\n    [\"_exponentialBackOff\",false,[true]]\n];\n\nprivate _uniqueId = [\"KISKA_RR_\" + (str clientOwner)] call KISKA_fnc_generateUniqueId;\n[_code,_args,_scheduled,_uniqueId] remoteExecCall [\"KISKA_fnc_remoteReturn_receive\",_target];\n\n\nprivate _timeWaited = 0;\nwaitUntil {\n    if (_timeWaited >= _maxWaitTime) then {\n        [\n            [\n                \"Max wait time of: \",\n                _maxWaitTime,\n                \" for variable \",\n                _uniqueId,\n                \" from target \",\n                _target,\n                \" was exceeded. Exiting with nil...\"\n            ],\n            false\n        ] call KISKA_fnc_log;\n        breakWith true;\n    };\n\n    if (!isNil _uniqueId) exitWith {\n        [[\"Got variable \",_uniqueId,\" from target \",_target],false] call KISKA_fnc_log;\n        true\n    };\n\n    sleep _awaitTime;\n    _timeWaited = _timeWaited + _awaitTime;\n    \n    if (_exponentialBackOff) then {\n        _awaitTime = _awaitTime * 2;\n    };\n    \n    [[\"Waiting for \",_uniqueId,\" from target: \",_target],false] call KISKA_fnc_log;\n    false\n};\n\nprivate _return = missionNamespace getVariable _uniqueId;\n// set to nil so that any other requesters don't get a duplicate\nmissionNamespace setVariable [_uniqueId,nil];\n\n\n_return\n",
    "fileName": "fn_remoteReturn_send.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_remoteReturn_send.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeArsenal\n\nDescription:\n    Removes both BIS and ACE arsenals from several or a single object.\n    This has a global effect.\n\nParameters:\n    0: _arsenals <ARRAY or OBJECT> - An array of objects to add arsenals to\n\nReturns:\n    <BOOL> - true if done, false if not\n\nExamples:\n    (begin example)\n        [[arsenal1, arsenal2]] call KISKA_fnc_removeArsenal;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeArsenal\";\n\nparams [\n    [\"_arsenals\",[],[[],objNull]]\n];\n\nif (_arsenals isEqualTo [] OR {(_arsenals isEqualType objNull) AND {isNull _arsenals}}) exitWith {\n    [[\"_arsenals are invalid: \",str _arsenals],true] call KISKA_fnc_log;\n    false\n};\n\nif !(_arsenals isEqualType []) then {\n    _arsenals = [_arsenals];\n};\n\nprivate _aceLoaded = [\"ace_arsenal\"] call KISKA_fnc_isPatchLoaded;\n\n_arsenals apply {\n    if (_aceLoaded) then {\n        [_x, true] call ace_arsenal_fnc_removeBox\n    };\n\n    /* [\"AmmoboxExit\",_x] call BIS_fnc_arsenal; */\n    [_x] remoteExecCall [\"KISKA_fnc_removeBISArsenalAction\", 0, true];\n};\n\n\ntrue\n",
    "fileName": "fn_removeArsenal.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_removeArsenal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeBISArsenalAction\n\nDescription:\n    Removes the BIS arsenal action from the given object.\n\nParameters:\n    0: _arsenal <OBJECT> - The arsenal to remove from\n\nReturns:\n    <BOOL> - true if arsenal was removed, false if action does not currently exist\n\nExamples:\n    (begin example)\n        _done = [arsenal] call KISKA_fnc_removeBISArsenalAction;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeBISArsenalAction\";\n\nparams [\n    [\"_object\",objNull,[objNull]]\n];\n\nif (isNull _object) exitWith {\n    [\"_object is null!\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _actionId = _object getVariable [\"bis_fnc_arsenal_action\",-1];\nif (_actionId isNotEqualTo -1) exitWith {\n    _object setVariable [\"bis_fnc_arsenal_action\",nil];\n    _object removeAction _actionId;\n    true\n};\n\n\nfalse\n",
    "fileName": "fn_removeBISArsenalAction.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_removeBISArsenalAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeEntityKilledEventHandler\n\nDescription:\n    Removes a killed KISKA entity event handler.\n\nParameters:\n    0: _entity <OBJECT> - The entity to remove event from\n    1: _eventId <NUMBER> - The Id of the event to remove\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [aUnit,{hint _this}] call KISKA_fnc_removeEntityKilledEventHandler;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeEntityKilledEventHandler\";\n\nparams [\n    [\"_entity\",objNull,[objNull]],\n    [\"_eventId\",-1,[123]]\n];\n\n\nif (isNull _entity) exitWith {\n    [\"null _entity was passed\",true] call KISKA_fnc_log;\n    -1\n};\n\n\nprivate _eventHashMap = _entity getVariable \"KISKA_entityKilledEventHashMap\";\nif (isNil \"_eventHashMap\") exitWith {};\n\n_eventHashMap deleteAt _eventId;\n\nnil\n",
    "fileName": "fn_removeEntityKilledEventHandler.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_removeEntityKilledEventHandler.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addMagRepack\n\nDescription:\n    Adds a mag repack to the player via Ctrl+R.\n    To remove see KISKA_fnc_removeMagRepack.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_addMagRepack;\n    (end)\n\nAuthor(s):\n    Quicksilver,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeMagRepack\";\n\n#define DISPLAY_CODE 46\n\nif (!hasInterface) exitWith {};\n\nif (localNamespace getVariable [\"KISKA_magRepackEventId\",-1] isEqualTo -1) exitWith {\n    [\"Mag repack was not present\"] call KISKA_fnc_log;\n    nil\n};\n\n[\n    {\n        !(isNull (findDisplay DISPLAY_CODE))\n    },\n    {\n        private _eventId = localNamespace getVariable [\"KISKA_magRepackEventId\",-1];\n        // possibility of two mag repack waitUntils runnning at once\n        if (_eventId isEqualTo -1) exitWith {\n            [\"Mag repack was already removed never added\"] call KISKA_fnc_log;\n            nil\n        };\n\n        (findDisplay DISPLAY_CODE) displayRemoveEventHandler [\"KeyDown\", _eventId];\n        localNamespace setVariable [\"KISKA_magRepackEventId\",nil];\n    },\n    0\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_removeMagRepack.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_removeMagRepack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeProximityPlayerAction\n\nDescription:\n    Stages an action added with KISKA_fnc_addProximityPlayerAction for removal.\n    This happens within the loop logic of KISKA_fnc_addProximityPlayerAction so\n     it is NOT instant.\n\nParameters:\n    0: _id : <NUMBER> - The proximity action id returned from KISKA_fnc_addProximityPlayerAction\n\nReturns:\n    <BOOL> - False if action still exists, true if it does not\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_removeProximityPlayerAction;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeProximityPlayerAction\";\n\nparams [\n    [\"_id\",-1,[123]]\n];\n\nif (_id < 0) exitWith {\n    [[_id,\" is not valid\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _varBase = \"KISKA_proximityAction_\" + (str _id);\nprivate _actionShouldBeRemovedVar = _varBase + \"_remove\";\nif !(localNamespace getVariable [_actionShouldBeRemovedVar,false]) exitWith {\n    localNamespace setVariable [_actionShouldBeRemovedVar,true];\n    true\n};\n\n\nfalse\n",
    "fileName": "fn_removeProximityPlayerAction.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_removeProximityPlayerAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_selectRandom\n\nDescription:\n    Call switchMove \"\" on a given unit. This function was created because as of release \n     2.10 there is an issue where remoteExec'ing switchMove \"\" on a unit directly within \n     some functions (KISKA_fnc_ambientAnim_stop) does not work as intended \n     (the intention being the unit returns to normal animations)\n    \n    Remoteexecuting this function, however, fixes the issue.\n\nParameters:\n    0: _unit <OBJECT> - The unit to reset animation on\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_unit] remoteExecCall [\"KISKA_fnc_resetMove\"]\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_resetMove\";\n\nparams [\n    [\"_unit\",objNull,[objNull]]\n];\n\n_unit switchMove \"\";",
    "fileName": "fn_resetMove.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_resetMove.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_selectRandom\n\nDescription:\n    Selects randomly an entry from an array be it weighted or unweighted.\n\nParameters:\n    0: _array <ARRAY> - An array either formatted as `[value, weight (number)]`, `[[array_of_values],[array_of_weights]]`, or\n        just values (`[value1,value2]`)\n    1: _valueType <ANY> - A variable that should have the same type as the value\n        entries in the array e.g. \"\" for string, [] for array\n        (only needed for possibly weighted arrays)\n\nReturns:\n    <ANY> - Random entry from the array\n\nExamples:\n    (begin example)\n        private _randomValue = [[\n            \"thing1\",\n            \"thing2\"\n        ]] call KISKA_fnc_selectRandom;\n    (end)\n    \n    (begin example)\n        private _weight1 = 0.5;\n        private _weight2 = 0.5;\n\n        private _randomWeightedValue = [\n            [\n                \"thing1\", _weight1,\n                \"thing2\", _weight2\n            ],\n            \"\"\n        ] call KISKA_fnc_selectRandom;\n    (end)\n\n    (begin example)\n        private _weight1 = 0.5;\n        private _weight2 = 0.5;\n\n        private _randomWeightedValue = [\n            [\n                [\"thing1\", \"thing2\"],\n                [_weight1, _weight2]\n            ],\n            \"\"\n        ] call KISKA_fnc_selectRandom;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_selectRandom\";\n\n#define VALUES_TO_SELECT (_array select 0)\n#define WEIGHTS (_array select 1)\n\nparams [\n    [\"_array\",[],[[]]],\n    \"_valueType\"\n];\n\nif (isNil \"_valueType\") exitWith {\n    selectRandom _array;\n};\n\nprivate _isWeightedArray_syntaxOne = (_array isEqualTypeParams [[],[]]) AND \n    ((count _array) isEqualTo 2) AND \n    { \n        (WEIGHTS isEqualTypeParams [123]) AND \n        (VALUES_TO_SELECT isEqualTypeParams [_valueType])\n    };\nif (_isWeightedArray_syntaxOne) exitWith {\n   VALUES_TO_SELECT selectRandomWeighted WEIGHTS;\n};\n\nprivate _isWeightedArray_syntaxTwo = _array isEqualTypeParams [_valueType,1];\nif (_isWeightedArray_syntaxTwo) exitWith {\n    selectRandomWeighted _array;\n};\n\n\nselectRandom _array;\n",
    "fileName": "fn_selectRandom.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_selectRandom.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_setContainerCargo\n\nDescription:\n    Takes a cargo array formatted from KISKA_fnc_getContainerCargo and adds it to another container.\n    Exact ammo counts will be preserved even inside of an item, such as magazines inside of a vest or backpack.\n\nParameters:\n    0: _containerToLoad <OBJECT> - The container to add the cargo to.\n    1: _cargo <ARRAY or OBJECT> - An array of various items, magazines, and weapons formatted from \n        KISKA_fnc_getContainerCargo or the object to copy from\n\nReturns:\n    <BOOL> - True if cargo was set\n\nExamples:\n    (begin example)\n        [container,otherContainer] call KISKA_fnc_setContainerCargo;\n    (end)\n\n    (begin example)\n        private _cargoToCopy = [otherContainer] call KISKA_fnc_getContainerCargo;\n        [container,_cargoToCopy] call KISKA_fnc_setContainerCargo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setContainerCargo\";\n\nparams [\n    [\"_containerToLoad\",objNull,[objNull]],\n    [\"_cargo\",[],[[],objNull]]\n];\n\nif (isNull _containerToLoad) exitWith {\n    [\"_containerToLoad isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_cargo isEqualType objNull) then {\n    _cargo = [_cargo] call KISKA_fnc_getContainerCargo;\n};\n\nif (_cargo isEqualTo []) exitWith {\n    [\"_cargo is empty array '[]'\",true] call KISKA_fnc_log;\n    false\n};\n\n\n[_containerToLoad] call KISKA_fnc_clearCargoGlobal;\n\n\n// items\nprivate _items = _cargo select 0;\nprivate _itemTypes = _items select 0;\nprivate _itemTypeCounts = _items select 1;\nif (_items isNotEqualTo [[],[]]) then {\n    {\n        _containerToLoad addItemCargoGlobal [_x,_itemTypeCounts select _forEachIndex];\n    } forEach _itemTypes;\n};\n\n\n// magazines\nprivate _magazines = _cargo select 1;\nif (_magazines isNotEqualTo []) then {\n    _magazines apply {\n        _containerToLoad addMagazineAmmoCargo [_x select 0,1,_x select 1];\n    };\n};\n\n\n// weapons\nprivate _weapons = _cargo select 2;\nif (_weapons isNotEqualTo []) then {\n    _weapons apply {\n        _containerToLoad addWeaponWithAttachmentsCargoGlobal _x;\n    };\n};\n\n\n// backpacks\nprivate _backpacks = _cargo select 3;\nprivate _backpackTypes = _backpacks select 0;\nprivate _backpackTypeCounts = _backpacks select 1;\nif (_backpacks isNotEqualTo [[],[]]) then {\n    {\n        _containerToLoad addBackpackCargoGlobal [_x,_backpackTypeCounts select _forEachIndex];\n    } forEach _backpackTypes;\n};\n\n\n// containers within the conatainer (vests, backpacks, etc.)\nprivate _containers = _cargo select 4;\nif (_containers isNotEqualTo []) then {\n\n    private _containersIn_containerToLoad = everyContainer _containerToLoad;\n    _containers apply {\n        private _containerInfo = _x;\n        private _containerClass = _containerInfo select 0;\n\n        // find a contianer with the class\n        private _index = _containersIn_containerToLoad findIf {(_x select 0) == _containerClass};\n        private _containerWithinContainer = (_containersIn_containerToLoad deleteAt _index) select 1;\n\n        [_containerWithinContainer,_containerInfo select 1] call KISKA_fnc_setContainerCargo;\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_setContainerCargo.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_setContainerCargo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getRelativeVectorAndPos\n\nDescription:\n    Sets the position and vector dir and up of one object to another based on\n     relative coordinates to the parent object.\n\nParameters:\n    0: _parent <OBJECT> - The object to make the coordinates relative to.\n    1: _child <OBJECT> - The object to find coordinates for.\n    2: _relativeInfo <ARRAY> - An array containing the relative coordinates to\n        change to worldspace:\n        \n            - 0. <PoitionWorld[]> - Relative world pos\n            - 1. <Vector[]> - Relative vector dir\n            - 2. <Vector[]> - Relative vector up\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            parentObject,\n            childObject,\n            [[0,0,0],[0,1,0],[0,0,1]]\n        ] call KISKA_fnc_setRelativeVectorAndPos;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setRelativeVectorAndPos\";\n\nparams [\n    [\"_parent\",objNull,[objNull]],\n    [\"_child\",objNull,[objNull]],\n    [\"_relativeInfo\",[],[[]],3]\n];\n\nif (isNull _parent) exitWith {\n    [\"Null parent object passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (isNull _child) exitWith {\n    [\"Null child object passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _relativePosWorld = _relativeInfo select 0;\nprivate _relativeVectorDir = _relativeInfo select 1;\nprivate _relativeVectorUp = _relativeInfo select 2;\n\n_child setPosWorld (_parent modelToWorldWorld _relativePosWorld);\n_child setVectorDir (_parent vectorModelToWorld _relativeVectorDir);\n_child setVectorUp (_parent vectorModelToWorld _relativeVectorUp);\n",
    "fileName": "fn_setRelativeVectorAndPos.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_setRelativeVectorAndPos.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_setWaypointExecStatement\n\nDescription:\n    Sets the (execution) statement of a given waypoint using an interface that allows\n     arg passing.\n\n    This statement will only be executed on the machine where added.\n\n    Be aware that this will create variables on the provided waypoint's group. If a waypoint\n     is deleted, the variable on the group will still remain.\n\nParameters:\n    0: _waypoint <WAYPOINT> - Default: `[]` - The waypoint you would like to the execution\n        statement of.\n    1: _statement <CODE, STRING, or ARRAY> - Default: `{}` - Code that executes once the given waypoint\n        is complete (see `KISKA_fnc_callBack` for examples).\n\n        Parameters:\n        - 0: <GROUP> - The group the waypoint belongs to\n        - 1: <OBJECT> - The group leader for the group the waypoint belongs to\n        - 2: <OBJECT[]> - The units of the group that own the waypoint\n\n    3: _existingId <STRING> - Default: `\"\"` - If updating an existing waypoint statement, provide the\n        id that was previously returned.\n\nReturns:\n    <STRING> - The id of the waypoint statment that can be used to update an existing statement\n\nExamples:\n    (begin example)\n        private _waypoint = myGroup addWaypoint [position player, 0];\n        private _id = [\n            _waypoint,\n            { hint str _this; }\n        ] call KISKA_fnc_setWaypointExecStatement\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setWaypointExecStatement\";\n\nparams [\n    [\"_waypoint\",[],[[]]],\n    [\"_statement\",{},[{},[],\"\"]],\n    [\"_existingId\",\"\",[\"\"]]\n];\n\nprivate _group = _waypoint param [0,grpNull];\nif (isNull _group) exitWith {\n    [\"Provided waypoint had null or missing group\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _id = _existingId;\nif (_id isEqualTo \"\") then {\n    _id = [\"KISKA_waypointStatement\"] call KISKA_fnc_generateUniqueId;\n};\n\n_group setVariable [_id,_statement];\n\nprivate _idStringified = [_id] call KISKA_fnc_str;\nprivate _waypointStatementString = format [\n    \"\n        private _group = group this; \n        private _callBack = _group getVariable [%1,{}];\n        if (_callBack isNotEqualTo {}) then {\n            [[_group,this,thisList],_callBack] call KISKA_fnc_callBack;\n            _group setVariable [%1,nil];\n        };\n    \",\n    _idStringified\n];\n_waypoint setWaypointStatements [\"true\",_waypointStatementString];\n\n\n_id\n",
    "fileName": "fn_setWaypointExecStatement.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_setWaypointExecStatement.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_showHide\n\nDescription:\n    On selected objects, will disable simulation and hide the object or the reverse.\n\nParameters:\n    0: _objects <ARRAY, GROUP, STRING, or OBJECT> - Units to show or hide, if string, it is a mission layer\n    1: _show <BOOL> - True to show and simulate, false to hide and disable simulation\n    2: _enableDynamicSim <BOOL> - Should the object be dynamically simulated after shown\n\nReturns:\n    <BOOL> - True if action performed, false otherwise\n\nExamples:\n    (begin example)\n        [group1, true, true] call KISKA_fnc_showHide;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_showHide\";\n\nif !(isServer) exitWith {\n    [\"Must be executed on Server\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_objects\",[],[[],grpNull,objNull,\"\"]],\n    [\"_show\",true,[true]],\n    [\"_enableDynamicSim\",false,[true]]\n];\n\nif (_objects isEqualTo []) exitWith {\n    [\"No objects to show or hide\"] call KISKA_fnc_log;\n    false\n};\n\nif (_objects isEqualType objNull) then {\n    _objects = [_objects];\n};\n\nif (_objects isEqualType grpNull) then {\n    _objects = units _objects;\n};\n\nif (_objcects isEqualType \"\") then {\n    _objects = getMissionLayerEntities _objects;\n};\n\n_objects apply {\n    if (!(isNull _x) OR {!(alive _x)}) then {\n        [_x,_show] remoteExecCall [\"allowDamage\",_x];\n        _x hideObjectGlobal !(_show);\n        _x enableSimulationGlobal _show;\n        \n        if (_x isKindOf \"Man\" AND {!((dynamicSimulationEnabled (group _x)) isEqualTo _enableDynamicSim)}) then {\n            (group _x) enableDynamicSimulation _enableDynamicSim;\n        };\n        \n        if (dynamicSimulationEnabled _x AND {!(_enableDynamicSim)}) then {\n            _x enableDynamicSimulation false;\n        } else {\n            _x enableDynamicSimulation _enableDynamicSim;\n        };\n        if (isDedicated AND {canSuspend}) then {\n            sleep 0.1;\n        };\n    };\n};\n\n\ntrue",
    "fileName": "fn_showHide.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_showHide.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_showNotification\n\nDescription:\n    A reimplementation of `BIS_fnc_showNotification`, this function works in tandem,\n    however, the arguements are changed for more flexibility.\n\nParameters:\n    0: _baseNotification <CONFIG | STRING | HASHMAP> - Config entry of the notification. \n        If a string, the config is expected to be located under a `\"CfgNotifications\"` config\n        (e.g. `configFile >> \"CfgNotifications\" >> \"MyNotification\"`) and will\n        be found with `KISKA_fnc_findConfigAny`. HashMap keys are case sensitive:\n\n            - `title` <STRING>: Text at the top of the notification popup.\n            - `iconPicture` <STRING>: The path of a picture to show on the \n                lefthand side of the notification.\n            - `iconText` <STRING>: Text to display in the lefthand side panel.\n            - `description` <STRING>: Text to show in the righthand bottom handle.\n            - `color` <COLOR(RGBA)>: Color of all the text and icons in the notification.\n                Will overwrite `colorIconPicture` and `colorIconText` if they are undefined\n                when `_baseNotification` is a config.\n            - `colorIconPicture` <COLOR(RGBA)>: Color of the icon picture.\n            - `colorIconText` <COLOR(RGBA)>: Color of the icon text.\n            - `duration` <NUMBER>: How long the notification is shown.\n            - `priority` <NUMBER>: The priority of the notification; higher will\n                put the notification higher in the queue.\n            - `sound` <STRING>: A string className of a sound defined in `CfgSounds` of \n                a sound that will play when the notification is opened.\n            - `soundClose` <STRING>: A string className of a sound defined in `CfgSounds` of \n                a sound that will play when the notification is closed.\n            - `soundRadio` <STRING>: A string className of a sound defined in `CfgSounds`.\n                Unknown when it plays.\n            - `iconSize` <NUMBER>: Ccale of the icon.\n\n    1: _args <ANY[]> - Array of args to be passed to the template. Same as `BIS_fnc_showNotification`.\n    2: _overwrites <HASHMAP> - A hashmap containing any values from the `_baseNotification`\n        to overwrite.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"Warning\"] call KISKA_fnc_showNotification;\n    (end)\n    \n    (begin example)\n        [\n            configFile >> \"MyNotifications\" >> \"MyNotification\"\n        ] call KISKA_fnc_showNotification;\n    (end)\n    \n    (begin example)\n        private _map = createHashMapFromArray [\n            [\"title\",\"hello world\"],\n            [\"description\",\"my description\"]\n        ];\n        [_map] call KISKA_fnc_showNotification;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_showNotification\";\n\n#define GET_TEXT_VALUE { if !(isText _paramConfig) exitWith {call _default}; getText _paramConfig }\n#define GET_NUMBER_VALUE { if !(isNumber _paramConfig) exitWith {call _default}; getNumber _paramConfig }\n#define GET_COLOR_VALUE { if !(isArray _paramConfig) exitWith {call _default}; private _color = getArray _paramConfig; _color call BIS_fnc_colorConfigToRGBA }\n#define GET_ARRAY_VALUE { if !(isArray _paramConfig) exitWith {call _default}; getArray _paramConfig }\n\nprivate _HASHMAP_COMPARE = createHashMap;\nparams [\n    [\"_baseNotification\",\"\",[\"\",configNull,_HASHMAP_COMPARE]],\n    [\"_args\",[],[[]]],\n    \"_overwrites\"\n];\n\nif (_baseNotification isEqualType \"\") then {\n    _baseNotification = [[\"CfgNotifications\",_baseNotification]] call KISKA_fnc_findConfigAny;\n};\n\nif ((_baseNotification isEqualType configNull) AND {isNull _baseNotification}) exitWith {\n    [\"Null notification config passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _baseNotificationIsHashmap = _baseNotification isEqualType _HASHMAP_COMPARE;\nprivate _hasOverwrites = !(isNil \"_overwrites\") AND {_overwrites isEqualType _HASHMAP_COMPARE};\nprivate [\"_invalidParamMessage\",\"_paramValue\"];\nprivate _notificationData = [\n    [\"title\",{\"\"},[\"\"],GET_TEXT_VALUE],\n    [\"iconPicture\",{\"\"},[\"\"],GET_TEXT_VALUE],\n    [\"iconText\",{\"\"},[\"\"],GET_TEXT_VALUE],\n    [\"description\",{\"\"},[\"\"],GET_TEXT_VALUE],\n    [\n        \"color\",\n        {\n            [\n                (profilenamespace getvariable ['IGUI_TEXT_RGB_R',0]),\n                (profilenamespace getvariable ['IGUI_TEXT_RGB_G',1]),\n                (profilenamespace getvariable ['IGUI_TEXT_RGB_B',1]),\n                (profilenamespace getvariable ['IGUI_TEXT_RGB_A',0.8])\n            ]\n        },\n        [[]],\n        GET_COLOR_VALUE\n    ],\n    [\n        \"colorIconPicture\",\n        {\n            if (_baseNotificationIsHashmap OR {!(isArray (_baseNotification >> \"color\"))}) exitWith {\n                [\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_R',0]),\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_G',1]),\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_B',1]),\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_A',0.8])\n                ]\n            };\n\n            getArray (_baseNotification >> \"color\") call BIS_fnc_colorConfigToRGBA\n        },\n        [[]],\n        GET_COLOR_VALUE\n    ],\n    [\n        \"colorIconText\",\n        {\n            if (_baseNotificationIsHashmap OR {!(isArray (_baseNotification >> \"color\"))}) exitWith {\n                [\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_R',0]),\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_G',1]),\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_B',1]),\n                    (profilenamespace getvariable ['IGUI_TEXT_RGB_A',0.8])\n                ]\n            };\n\n            getArray (_baseNotification >> \"color\") call BIS_fnc_colorConfigToRGBA\n        },\n        [[]],\n        GET_COLOR_VALUE\n    ],\n    [\"duration\",{3},[123],GET_NUMBER_VALUE],\n    [\"priority\",{0},[123],GET_NUMBER_VALUE],\n    [\"sound\",{\"defaultNotification\"},[\"\"],GET_TEXT_VALUE],\n    [\"soundClose\",{\"defaultNotificationClose\"},[\"\"],GET_TEXT_VALUE],\n    [\"soundRadio\",{\"\"},[\"\"],GET_TEXT_VALUE],\n    [\"iconSize\",{0},[123],GET_NUMBER_VALUE]\n] apply {\n    _x params [\"_var\", \"_default\", \"_types\", \"_getConfigValue\"];\n\n    if (_hasOverwrites AND (_var in _overwrites)) then {\n        _paramValue = _overwrites get _var;\n    } else {\n        if (_baseNotificationIsHashmap) then {\n            _paramValue = _baseNotification getOrDefaultCall [_var,_default];\n        } else {\n            private _paramConfig = _baseNotification >> _var;\n            _paramValue = call _getConfigValue;\n        };\n    };\n\n    if !(_paramValue isEqualTypeAny _types) then {\n        _invalidParamMessage = [_var,\" value \",_paramValue,\" is invalid, must be -> \",_types] joinString \"\";\n        break;\n    };\n\n    _paramValue\n};\nif !(isNil \"_invalidParamMessage\") exitWith {\n    [_invalidParamMessage,true] call KISKA_fnc_log;\n    nil\n};\n\n// preserving compatiblity with BIS function\n_notificationData insert [9,[_args]];\n\n\n//--- Add to the queue\nprivate _queue = missionnamespace getvariable [\"BIS_fnc_showNotification_queue\",[]];\nprivate _priority = _notificationData select 8;\n_queue resize (_priority max (count _queue));\nif (isnil {_queue select _priority}) then {\n    _queue set [_priority,[]];\n};\nprivate _queuePriority = _queue select _priority;\n_queuePriority set [count _queuePriority,_notificationData];\nmissionnamespace setvariable [\"BIS_fnc_showNotification_queue\",_queue];\n\n//--- Increase the counter\n[\"BIS_fnc_showNotification_counter\",+1] call bis_fnc_counter;\n\n//--- Process the queue\nprivate _notificationQueueProcess = missionnamespace getvariable \"BIS_fnc_showNotification_process\";\nprivate _startNewQueueProcess = isNil \"_notificationQueueProcess\" OR {scriptDone _notificationQueueProcess};\nif !(_startNewQueueProcess) exitWith {nil};\n\n_notificationQueueProcess = [] spawn {\n    scriptname \"BIS_fnc_showNotification: queue\";\n    private _queue = missionnamespace getvariable [\"BIS_fnc_showNotification_queue\",[]];\n    private _layers = [\n        (\"RscNotification_1\" call bis_fnc_rscLayer),\n        (\"RscNotification_2\" call bis_fnc_rscLayer)\n    ];\n    private _layerID = 0;\n    while {(count _queue) > 0} do {\n        private _queueID = count _queue - 1;\n        private _queuePriority = _queue select _queueID;\n        if (isNil \"_queuePriority\") then {\n            if (_queueID isEqualTo ((count _queue) - 1)) then {\n                _queue resize _queueID;\n            };\n\n            continue;\n        };\n\n        if ((count _queuePriority) > 0) then {\n            private _dataID = count _queuePriority - 1;\n            private _data = +(_queuePriority select _dataID);\n            if (count _data > 0 AND (alive player || ismultiplayer)) then {\n                private _duration = _data select 7;\n\n                //--- Show\n                missionnamespace setvariable [\"RscNotification_data\",_data];\n                (_layers select _layerID) cutrsc [\"RscNotification\",\"plain\"];\n                _layerID = (_layerID + 1) % 2;\n                [\"BIS_fnc_showNotification_counter\",-1] call bis_fnc_counter;\n\n                sleep _duration;\n                _queuePriority set [_dataID,[]];\n            } else {\n                _queuePriority resize _dataID;\n            };\n        };\n        if ((count _queuePriority) isEqualTo 0) then {\n            _queue resize _queueID;\n        };\n    };\n};\nmissionnamespace setvariable [\"BIS_fnc_showNotification_process\",_notificationQueueProcess];\n\n\nnil\n",
    "fileName": "fn_showNotification.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_showNotification.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_sortStringsNumerically\n\nDescription:\n    Takes an array or strings, where each string must end with an underscore and a digit\n     (`\"something_1\"`) and can handle one extra sub level digit (`\"something_1_1\"`).\n\nParameters:\n    0: _strings <STRING[]> - Default: `[]` - The strings you would like to sort\n    1: _order <BOOLEAN> - Default: `true` - ascending (`true`) or descending (`false`) \n\nReturns:\n    <STRING[]> - The sorted list of strings\n\nExamples:\n    (begin example)\n        [\n            [\"myString_2\",\"myString_3\",\"myString_1_1\",\"myString_1\"]\n        ] call KISKA_fnc_sortStringsNumerically;\n        // returns -> `[\"myString_1\",\"myString_1_1\",\"myString_2\",\"myString_3\"]`\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_sortStringsNumerically\";\n\nparams [\n    [\"_strings\",[],[[]]],\n    [\"_order\",true,[true]]\n];\n\nprivate _sortKeyMap = createHashMap;\n{\n    private _regexMatches = (_x regexFind [\"_(\\d+)_*(\\d*)\"]) param [0,[]];\n    _regexMatches params [\"\",\"_mainNumberMatch\",\"_subNumberMatch\"];\n    private _mainIndex = _mainNumberMatch select 0;\n    private _sortString = _mainIndex;\n\n    private _subIndex = _subNumberMatch select 0;\n    if (_subIndex isNotEqualTo \"\") then {\n        _sortString = [_sortString,_subIndex] joinString \".\";\n    };\n\n    _sortKeyMap set [parseNumber _sortString,_x];\n} forEach _strings;\n\nprivate _sortedKeys = keys _sortKeyMap;\n_sortedKeys sort _order;\n\n\n_sortedKeys apply { _sortKeyMap get _x }\n",
    "fileName": "fn_sortStringsNumerically.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_sortStringsNumerically.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_staticLine\n\nDescription:\n    Ejects units from vehicle and deploys chutes, will select CUP T10 chute if available.\n\n    CAUTION:\n        All units from a group THAT ARE IN THE SAME AIRCRAFT should be dropped\n        with the same function call. Not doing so can see odd behaviour from the aircraft.\n\n        This is tied to KISKA_fnc_staticLine_eject and the use of the leaveVehicle\n        command. If there are units from the same group still in the aircraft when it is\n        executed, the aircraft will ignore all commands and attempt to pickup those units\n        that were dropped.\n\nParameters:\n    0: _aircraft <OBJECT> - The aircraft to drop units from\n    1: _dropArray <ARRAY, GROUP, OBJECT> - Units to drop. If array, can be groups and/or objects (example 2)\n    2: _invincibleOnDrop <BOOL> - Should the units be invincible while dropping?\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [plane,group] spawn KISKA_fnc_staticLine;\n    (end)\n\n    (begin example)\n        [plane,[group1,unit2]] spawn KISKA_fnc_staticLine;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_staticLine\";\n\nif !(canSuspend) exitWith {\n    [\"Should be run in scheduled. Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_staticLine;\n};\n\nparams [\n    [\"_aircraft\",objNull,[objNull]],\n    [\"_dropArray\",[],[[],grpNull,objNull]],\n    [\"_invincibleOnDrop\",true,[true]]\n];\n\nif (isNull _aircraft OR !(alive _aircraft)) exitWith {\n    [\"_aircraft is null or not alive. Exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_dropArray isEqualTo []) exitWith {\n    [\"_dropArray is empty\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_dropArray isEqualTypeAny [objNull,grpNull] AND {isNull _dropArray}) exitWith {\n    [\"_dropArray isNull\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_dropArray isEqualType grpNull) then {\n    _dropArray = units _dropArray;\n};\n\nif (_dropArray isEqualType objNull) then {\n    _dropArray = [_dropArray];\n};\n\nprivate _dropArrayFiltered = [];\n_dropArray apply {\n    if (_x isEqualType grpNull) then {\n        (units _x) apply {\n            if (_x in _aircraft) then  {\n                _dropArrayFiltered pushBack _x;\n            };\n        };\n    };\n\n    if (!(_x isEqualType objNull) OR !(_x in _aircraft)) then { continue };\n\n    _dropArrayFiltered pushBack _x;\n};\n\n\nprivate _chuteType = [\"B_Parachute\",\"CUP_T10_Parachute_backpack\"] select (isClass (configfile >> \"CfgVehicles\" >> \"CUP_T10_Parachute_backpack\"));\n// execute eject\n{\n    [_aircraft,_x,_chuteType,_forEachIndex,_invincibleOnDrop] remoteExec [\"KISKA_fnc_staticLine_eject\",_x];\n} forEach _dropArrayFiltered;\n\nnil\n",
    "fileName": "fn_staticLine.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_staticLine.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_staticLine\n\nDescription:\n    Ejects the unit from their airecraft and\n    Used to reduce network messages.\n\nParameters:\n    0: _aircraft <OBJECT> - The aircraft dropping off the unit\n    1: _unit <OBJECT> - The unit to parachute\n    2: _chuteType <STRING> - Class name of the chute\n    3: _index <NUMBER> - index in drop order\n    4: _invincibleOnDrop <BOOL> - Whether or not the unit is invincible on drop\n\nReturns:\n    NOTHING\n\nExamples:\n    Executed from KISKA_fnc_staticLine\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_staticLine_eject\";\n\nparams [\"_aircraft\",\"_unit\",\"_chuteType\",\"_index\",\"_invincibleOnDrop\"];\n\nprivate _loadout = getUnitLoadout _unit;\n\nif !(isNull (unitbackpack _unit)) then {\n    removeBackpackGlobal _unit;\n};\n// decided not to use addBackpackGlobal because of waiting for locality\nwaitUntil {\n    _unit addBackpack _chuteType;\n    if (!isNull (backpackContainer _unit) OR {!alive _unit}) exitWith {true};\n    sleep 0.25;\n    false\n};\n\nif (!(alive _aircraft) OR !(alive _unit)) exitWith {};\n\nsleep (_index / 5); // delay for getting a spread of units\n\n_unit moveOut _aircraft;\n\n// keep units from trying to enter vehicle after being moved out\n// leaveVehicle causes the aircraft to shift while in-flight\n[_unit] orderGetIn false;\n\n// determine the side of the aircraft to eject the person on\nprivate _sideOfAircraft = [10,-10] select ((_index mod 2) isEqualTo 0);\n\n\n// might need to waitUntil backpackContainer is not Null to be sure\n// delay chute open to create some distance with plane\n[_unit,_aircraft,_sideOfAircraft] spawn {\n    params [\"_unit\",\"_aircraft\",\"_sideOfAircraft\"];\n\n    // place unit to the side of the aircraft\n    _unit setPosATL ((getPosATLVisual _unit) vectorAdd (_aircraft vectorModelToWorldVisual [_sideOfAircraft,0,0]));\n    // if a unit is moving too fast when they open the chute, it will sometimes cause it to not attach\n    _unit setVelocity [0,0,0];\n    sleep 1;\n    _unit action [\"OpenParachute\", _unit];\n};\n\nsleep 3;\n\nif (_invincibleOnDrop) then {\n    _unit allowDamage false;\n};\n\nwaitUntil {\n    if (((getPosATL _unit) select 2) < 0.1 OR {isTouchingGround _unit}) exitWith {true};\n    sleep 2;\n    false;\n};\n\nif (alive _unit) then {\n    if (_invincibleOnDrop) then {\n        _unit allowDamage true;\n    };\n\n    _unit setUnitLoadout _loadout;\n\n    private _group = group _unit;\n    private _unitLeader = leader _group;\n    if !(_unitLeader in _aircraft) then {\n        /*\n            orderGetIn combined with unassignVehicle does NOT keep units\n            from trying to re-embark.\n\n            The only two commands that are capable of this are leaveVehicle\n            and allowGetIn. allowGetIn is the more invasive option, so I chose\n            leaveVehicle as it would not leave a lasting affect.\n        */\n        [_group,_aircraft] remoteExec [\"leaveVehicle\",_unitLeader];\n    };\n};\n\nnil\n",
    "fileName": "fn_staticLine_eject.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_staticLine_eject.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_str\n\nDescription:\n    Given that str command produces triple quoted strings if used on a string\n     (which can be incompatible with other commands) this function simply formats\n     them as \"'string'\" instead, and all other types as normal with str.\n\nParameters:\n    0: _value <ANY> - The value to convert to a string\n\nReturns:\n    <STRING> - The value as a string\n\nExamples:\n    (begin example)\n        _asString = [_someValue] call KISKA_fnc_str;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_str\";\n\nparams [\"_value\"];\n\nif (_value isEqualType \"\") exitWith {\n    format [\"'%1'\",_value]\n};\n\n\nstr _value\n",
    "fileName": "fn_str.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_str.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_vehicleFactory\n\nDescription:\n    Add an action to given object that allows the spawn of a vehicle\n\nParameters:\n    0: _controlPanel <OBJECT> - The object to add the action to\n    1: _spawnPosition <OBJECT or ARRAY> - Where to spawn the vehicle (ASL)\n    2: _vehicleTypes <ARRAY or STRING> - The class names of vehicles to create an action for (each will get its own action if in an array)\n    3: _clearRadius <NUMBER> - How far until pad is considered clear of entities\n    4: _onCreateCode <CODE> - Code to run upon vehicle creation. Passed arg is the created vehicle\n\nReturns:\n    <BOOL> - false if not added, true otherwise\n\nExamples:\n    (begin example)\n        [player,(getPosATL player) vectorAdd [2,2,0],\"B_MRAP_01_F\"] spawn KISKA_fnc_vehicleFactory;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_vehicleFactory\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled envrionment, exiting to scheduled\"] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_vehicleFactory;\n};\n\nparams [\n    [\"_controlPanel\",objNull,[objNull]],\n    [\"_spawnPosition\",objNull,[[],objNull]],\n    [\"_vehicleTypes\",[],[[],\"\"]],\n    [\"_clearRadius\",10,[123]],\n    [\"_onCreateCode\",{},[{}]]\n];\n\nif (isNull _controlPanel) exitWith {\n    [\"_controlPanel isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_vehicleTypes isEqualTo [] OR {_vehicleTypes isEqualTo \"\"}) exitWith {\n    [\"_vehicleTypes is empty\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_vehicleTypes isEqualType \"\") then {\n    _vehicleTypes = [_vehicleTypes];\n};\n\nif (_spawnPosition isEqualType objNull) then {\n    _spawnPosition = getPosASL _spawnPosition;\n};\n\n\nprivate [\"_type\",\"_config\",\"_displayName\"];\n_vehicleTypes apply {\n\n    _type = _x;\n    _config = configFile >> \"cfgVehicles\" >> _type;\n\n    if (isClass _config) then {\n\n        // get displayName\n        _displayName = getText (_config >> \"displayname\");\n        if (_displayName isEqualTo \"\") then {\n\n            _displayName = getText (missionConfigFile >> \"cfgVehicles\" >> _type >> \"displayname\");\n            if (_displayName isEqualTo \"\") then {\n                _displayName = \"Unknown Vehicle\";\n            };\n        };\n\n        [\n            _controlPanel,\n            (\"Spawn \" + _displayName),\n            \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n            \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n            \"true\",\n            \"true\",\n            {},\n            {},\n            {\n                (_this select 3) params [\n                    \"_type\",\n                    \"_spawnPosition\",\n                    \"_clearRadius\",\n                    \"_onCreateCode\"\n                ];\n\n                if !(((ASLToAGL _spawnPosition) nearEntities [['landVehicle','air','ship'],_clearRadius]) isEqualTo []) exitWith {\n                    [\"Pad Must Be Clear Of Vehicles\"] call KISKA_fnc_notification;\n                    false\n                };\n\n                private _vehicle = createVehicle [_type,ASLToATL _spawnPosition,[],0,\"CAN_COLLIDE\"];\n\n                if !(_onCreateCode call KISKA_fnc_isEmptyCode) then {\n                    [_vehicle] call _onCreateCode;\n                };\n\n                [\"Vehicle Created\"] call KISKA_fnc_notification;\n            },\n            {},\n            [_type,_spawnPosition,_clearRadius,_onCreateCode],\n            0.5,\n            10,\n            false,\n            false,\n            false\n        ] call BIS_fnc_holdActionAdd;\n    };\n\n    // hold action conditions seem to fail if added too quickly\n    sleep 0.1;\n};\n\n\nif !(_controlPanel getVariable [\"KISKA_vehicleFactory\",false]) then {\n\n    [\n        _controlPanel,\n        \"<t color='#ba1000'>Clear Spawn</t>\",\n        \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n        \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n        \"true\",\n        \"true\",\n        {},\n        {},\n        {\n            (_this select 3) params [\"_spawnPosition\",\"_clearRadius\"];\n            private _entities = (ASLToAGL _spawnPosition) nearEntities [['landVehicle','air','ship'],_clearRadius];\n\n            _entities apply {\n                [_x] remoteExecCall [\"deleteVehicle\",2];\n            };\n\n            [\"Pad Cleared\"] call KISKA_fnc_notification;\n        },\n        {},\n        [_spawnPosition,_clearRadius],\n        0.5,\n        20,\n        false,\n        false,\n        false\n    ] call BIS_fnc_holdActionAdd;\n\n    _controlPanel setVariable [\"KISKA_vehicleFactory\",true];\n};\n\n\ntrue\n",
    "fileName": "fn_vehicleFactory.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_vehicleFactory.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_waitUntil\n\nDescription:\n    Waitunil that allows variable evaluation time instead of frame by frame.\n\nParameters:\n    0: _condition <CODE, STRING, or ARRAY> - Code that must evaluate as a `BOOL`.\n        If `(_interval <= 0) AND (_unscheduled isEqualTo true)`, this will only accept CODE\n        or `STRING` as an arguement for performance reasons and `_parameters` will be available in `_this`.\n        (See KISKA_fnc_callBack)\n    1: _onConditionMet <CODE, STRING, or ARRAY> - The code to execute upon condition being reached.\n        (See KISKA_fnc_callBack)\n    2: _interval <NUMBER> - How often to check the condition\n    3: _parameters <ARRAY> - An array of local parameters that can be accessed with _this\n    4: _unscheduled <BOOL> - Run in unscheduled environment\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _variable = 123;\n        [\n            {\n                params [\"_variable\"];\n                true\n            },\n            {\n                params [\"_variable\"];\n                hint \"wait\";\n            },\n            0.5,\n            [_variable],\n            true\n        ] call KISKA_fnc_waitUntil;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_waitUntil\";\n\nparams [\n    [\"_condition\",{},[{},\"\",[]]],\n    [\"_onConditionMet\",{},[{},\"\",[]]],\n    [\"_interval\",0.5,[123]],\n    [\"_parameters\",[]],\n    [\"_unscheduled\",true,[true]]\n];\n\n\nprivate _isPerFrame = _interval <= 0;\nif (\n    _unscheduled AND\n    _isPerFrame AND\n    (_condition isEqualType [])\n) exitWith {\n    [\n        \"Unscheduled, perframe waituntil will only support CODE or STRING as an arguement\",\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_condition isEqualType \"\") then {\n    _condition = compileFinal _condition;\n};\nif (_onConditionMet isEqualType \"\") then {\n    _onConditionMet = compileFinal _onConditionMet;\n};\n\n\n/* -----------------------------------\n    Perframe unscheduled\n----------------------------------- */\nif (_unscheduled AND _isPerframe) exitWith {\n    [\n        {\n            params [\"_parameters\",\"\",\"_condition\"];\n            _parameters call _condition\n        },\n        {\n            params [\"_parameters\",\"_onConditionMet\",\"\"];\n            [_parameters,_onConditionMet] call KISKA_fnc_callBack;\n        },\n        [_parameters,_onConditionMet,_condition]\n    ] call CBA_fnc_waitUntilAndExecute;\n};\n\n\n/* -----------------------------------\n    Unscheduled with interval\n----------------------------------- */\nif (_unscheduled) exitWith {\n    [\n        {\n            (_this select 0) params [\n                \"_condition\",\n                \"_onConditionMet\",\n                \"_interval\",\n                \"_parameters\"\n            ];\n\n            private _conditionMet = [_parameters,_condition] call KISKA_fnc_callBack;\n            if (_conditionMet) exitWith {\n                [_parameters,_onConditionMet] call KISKA_fnc_callBack;\n\n                private _id = _this select 1;\n                [_id] call CBA_fnc_removePerFrameHandler;\n            };\n        },\n        _interval,\n        _this\n    ] call CBA_fnc_addPerFrameHandler;\n\n    nil\n};\n\n\n/* -----------------------------------\n    Scheduled\n----------------------------------- */\n[_interval,_onConditionMet,_condition,_parameters] spawn {\n    params [\"_interval\",\"_onConditionMet\",\"_condition\",\"_parameters\"];\n\n    waitUntil {\n        sleep _interval;\n        private _conditionMet = [_parameters,_condition] call KISKA_fnc_callBack;\n        if (_conditionMet) exitWith {\n            [_parameters,_onConditionMet] call KISKA_fnc_callBack;\n            true\n        };\n\n        false\n    };\n\n};\n\n\nnil\n",
    "fileName": "fn_waitUntil.sqf",
    "documentationLink": "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_waitUntil.sqf"
  }
]