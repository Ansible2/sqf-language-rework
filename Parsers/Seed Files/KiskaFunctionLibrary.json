[
  {
    "text": "#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_addIcon\n\nDescription:\n    Adds and icon to the compass\n\nParameters:\n    0: _iconId <STRING> - A unique id for referencing the compass marker\n    1: _iconText <STRING> - The icon's image path or text\n    2: _iconPos <ARRAY, OBJECT, MARKER, or LOCATION> - The position of the icon\n    3: _color <ARRAY> - The RGBa of the icon\n    4: _isActive <BOOL> - Icon will use \"active\" scale of icon\n\nReturns:\n    <BOOL> - false if new iconId, true if overwriting the icon id\n\nExamples:\n    (begin example)\n        [\n            \"myMarkerID\"\n            \"images\\info_icon.paa\"\n        ] call KISKA_fnc_compass_addIcon;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_addIcon\";\n\nparams [\n    [\"_iconId\",\"\",[\"\"]],\n    [\"_iconText\",\"\",[\"\"]],\n    [\"_iconPos\",[0,0,0],[[],objNull,\"\",locationNull]],\n    [\"_color\",[1,1,1,1],[[]],4],\n    [\"_isActive\",true,[true]]\n];\n\n\nprivate _hashMap = GET_COMPASS_ICON_MAP_DEFAULT;\nprivate _overWritten = _hashMap set [_iconId,\n    [\n        _iconText,\n        _iconPos,\n        _color,\n        _isActive,\n        controlNull\n    ]\n];\n\nif (isNil {GET_COMPASS_ICON_MAP}) then {\n    localNamespace setVariable [COMPASS_ICON_MAP_VAR_STR,_hashMap];\n};\n\n\n_overWritten\n",
    "fileName": "fn_compass_addIcon.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass IDCs.hpp\"\n#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_configure\n\nDescription:\n    Initializes several display namespace variables for the compass and sets\n     up their images for the compass.\n\nParameters:\n    0: _display <DISPLAY> - The display of the compass\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_configure;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_configure\";\n\nif (!hasInterface) exitWith {};\n\ndisableSerialization;\n\nparams [\n    [\"_display\",displayNull]\n];\n\nif (isNull _display) exitWith {};\n\n\nlocalNamespace setVariable [COMPASS_DISPLAY_VAR_STR,_display];\n\nprivate _mainCompassCtrlGroup = _display displayCtrl COMPASS_GRP_IDC;\n_display setVariable [COMPASS_MAIN_CTRL_GRP_VAR_STR,_mainCompassCtrlGroup];\n\nprivate _compassImageCtrl = _mainCompassCtrlGroup controlsGroupCtrl COMPASS_IMG_IDC;\n_display setVariable [COMPASS_IMAGE_CTRL_VAR_STR,_compassImageCtrl];\n\nprivate _compassBackgroundCtrl = _mainCompassCtrlGroup controlsGroupCtrl COMPASS_BACK_IDC;\n_display setVariable [COMPASS_BACKGROUND_CTRL_VAR_STR,_compassBackgroundCtrl];\n\nprivate _compassCenterMarkersCtrl = _mainCompassCtrlGroup controlsGroupCtrl COMPASS_CENTER_IDC;\n_display setVariable [COMPASS_CENTER_MARKERS_CTRL_VAR_STR,_compassCenterMarkersCtrl];\n\n\n\n[\n    [ _mainCompassCtrlGroup, true ],\n    [ _compassImageCtrl, false, KISKA_compass_mainColor, KISKA_compass_image ],\n    [ _compassBackgroundCtrl, false, KISKA_compass_backgroundColor, \"#(rgb,8,8,3)color(1,1,1,1)\" ],\n    [ _compassCenterMarkersCtrl, false, KISKA_compass_centerColor, KISKA_compass_center_image ]\n] apply {\n    _x params [\n        \"_ctrl\",\n        \"_changePos\",\n        [ \"_color\", [1,1,1,1] ],\n        [ \"_image\", \"\" ]\n    ];\n\n\n    (ctrlPosition _ctrl) params[ \"_ctrlX\", \"_ctrlY\", \"_ctrlW\", \"_ctrlH\" ];\n    if (_ctrlW isEqualTo 0) then {\n        _ctrlW = KISKA_compass_widthScale * pixelW;\n    };\n\n\n    // ctrlSetScale cuts off the image (I don't know why for now, so using this scaling instead)\n    // ctrlSetScale also scales in such a way that is not ideal for the compass\n    _ctrlW = _ctrlW * KISKA_compass_scale;\n    _ctrlH = _ctrlH * KISKA_compass_scale;\n    if ( _changePos ) then {\n        _ctrlX = ( safeZoneX + ( safeZoneW / 2 ) - ( _ctrlW / 2 ) );\n        _ctrlY = safeZoneY + ((pixelH * pixelGrid) * KISKA_compass_y_offset)\n    };\n\n    // using ctrlSetPosition instead of individual commands because setting them with those causes the compass to be offset from center\n    _ctrl ctrlSetPosition [_ctrlX,_ctrlY,_ctrlW,_ctrlH];\n    _ctrl ctrlCommit 0;\n\n\n    if ( _image isNotEqualTo \"\" ) then {\n        _ctrl ctrlSetText _image;\n        _ctrl ctrlSetTextColor _color;\n    };\n\n};\n\n\nprivate _mainCtrlGrp_pos = ctrlPosition _mainCompassCtrlGroup;\n_display setVariable [COMPASS_MAIN_CTRL_GRP_POS_VAR_STR,_mainCtrlGrp_pos];\n\n\n// position center marker at the center of the control group\nprivate _mainCtrlGrp_posX_by2 = (_mainCtrlGrp_pos select 2) / 2;\n(ctrlPosition _compassCenterMarkersCtrl) params[ \"\", \"_ctrlY\", \"_ctrlW\", \"\" ];\n_compassCenterMarkersCtrl ctrlSetPosition[ _mainCtrlGrp_posX_by2 - ( _ctrlW / 2 ), _ctrlY  ];\n_compassCenterMarkersCtrl ctrlCommit 0;\n\n\n_display setVariable [COMPASS_CONFIGED_VAR_STR,true];\n",
    "fileName": "fn_compass_configure.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass IDCs.hpp\"\n#include \"..\\Headers\\Icon Info Indexes.hpp\"\n#include \"..\\Headers\\Compass Globals.hpp\"\n#include \"..\\Headers\\Compass Image Resolutions.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_mainLoop\n\nDescription:\n    Creates and then continues to execute a loop controlling the compass.\n\nParameters:\n    0: _display <DISPLAY> - The display the compass will be on\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [findDisplay 46] spawn KISKA_fnc_compass_mainLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_mainLoop\";\n\n#define INACTIVE_IDC -1\n#define SIMPLIFY_ANGLE(angle) (((angle) % 360) + 360) % 360;\n\nif (!hasInterface) exitWith {};\n\n// check if main menu\nif (call KISKA_fnc_isMainMenu) exitWith {};\n\ndisableSerialization;\n\nparams [\n    [\"_display\",displayNull,[displayNull]]\n];\n\n\n_display displayAddEventHandler [\"Unload\", {\n    localNamespace setVariable [COMPASS_DISPLAY_VAR_STR,displayNull];\n}];\n\nprivate [\n    \"_ctrlGrp\",\n    \"_compass\",\n    \"_cameraVectorDir\",\n    \"_cameraHeading\",\n    \"_posX\",\n    \"_grpW\",\n    \"_grpWDivided\",\n    \"_ctrlPos\",\n    \"_iconMap\",\n    \"_iconWidth\",\n    \"_iconHeight\",\n    \"_iconControl\",\n    \"_iconColor\",\n    \"_iconText\",\n    \"_iconPos\",\n    \"_iconWidthDivided\",\n    \"_camDirTo\",\n    \"_opposite\"\n];\n\n\nwaitUntil {\n    if (!KISKA_compass_show OR (isNull _display)) exitWith {true};\n\n    if !( _display getVariable [COMPASS_CONFIGED_VAR_STR,false] ) then {\n        [ _display ] call KISKA_fnc_compass_configure;\n    };\n\n    _ctrlGrp = _display getVariable COMPASS_MAIN_CTRL_GRP_VAR_STR;\n    _compass = _display getVariable COMPASS_IMAGE_CTRL_VAR_STR;\n\n    _cameraVectorDir = getCameraViewDirection player;\n    _cameraHeading = SIMPLIFY_ANGLE((_cameraVectorDir select 0) atan2 (_cameraVectorDir select 1));\n    // convert heading to actual pixel position of compass control\n    _posX = linearConversion[ 0, 360, _cameraHeading, KISKA_compass_pixelX_min, KISKA_compass_pixelX_max, true ];\n\n    _compass ctrlSetPositionX -( _posX * pixelW ); // scroll the compass\n    _compass ctrlCommit 0;\n\n\n\n    // draw icons\n    _iconMap = localNamespace getVariable [COMPASS_ICON_MAP_VAR_STR,[]];\n    if (KISKA_compass_showIcons AND {(count _iconMap) > 0}) then {\n        _ctrlPos = _display getVariable COMPASS_MAIN_CTRL_GRP_POS_VAR_STR;\n        _grpW = _ctrlPos select 2;\n        _grpWDivided = _grpW / 2;\n\n\n        _iconMap apply {\n\n            _iconPos = _y select ICON_POS;\n            call {\n                if (_iconPos isEqualType []) exitWith {\n                    _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _iconPos));\n                };\n\n                if (_iconPos isEqualType objNull AND {!( isNull _iconPos )}) exitWith {\n                    _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _iconPos));\n                };\n\n                if (_iconPos isEqualType locationNull AND {!( isNull _iconPos )}) exitWith {\n                    private _locationPos = locationPosition _iconPos;\n                    _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _locationPos));\n                };\n\n                if (_iconPos isEqualType \"\") exitWith {\n                    private _markerPos = getMarkerPos _iconPos;\n                    if ( _markerPos isNotEqualTo [0,0,0] ) then {\n                        _camDirTo = SIMPLIFY_ANGLE(_cameraHeading - (player getDir _markerPos));\n                    };\n                };\n\n                _camDirTo = nil;\n            };\n\n            _iconControl = _y select ICON_CTRL;\n            // only update if actually visible on compass range\n            if (\n                !(isNil \"_camDirTo\") AND\n                {\n                    (_camDirTo >= KISKA_compass_iconAngle_max) OR\n                    {_camDirTo <= KISKA_compass_iconAngle_min}\n                }\n            ) then {\n                private _iconActive = _y select ICON_ACTIVE;\n                _iconWidth = [KISKA_compass_iconWidth_inactive,KISKA_compass_iconWidth_active] select _iconActive;\n\n                _iconWidthDivided = _iconWidth / 2;\n                _iconText = _y select ICON_TEXT; // this is the icon's picture path\n                _iconColor = _y select ICON_COLOR;\n\n\n                if (isNull _iconControl) then {\n                    _iconControl = _display ctrlCreate [ \"ctrlActivePicture\", INACTIVE_IDC, _ctrlGrp ];\n\n                    _iconHeight = [KISKA_compass_iconHeight_inactive,KISKA_compass_iconHeight_active] select _iconActive;\n                    private _grpH = _ctrlPos select 3;\n                    _iconControl ctrlSetPosition [_grpWDivided - _iconWidthDivided, _grpH - _iconHeight, _iconWidth, _iconHeight];\n\n                    _iconControl ctrlSetText _iconText;\n                    _iconControl ctrlSetTextColor _iconColor;\n\n                    _iconControl ctrlCommit 0;\n                    _y set [ ICON_CTRL, _iconControl ];\n\n                } else {\n                    if !(ctrlShown _iconControl) then {\n                        _iconControl ctrlShow true;\n                    };\n\n                    if ( (ctrlText _iconControl) isNotEqualTo _iconText) then {\n                        _iconControl ctrlSetText _iconText;\n                    };\n\n                    if ( (ctrlTextColor _iconControl) isNotEqualTo _iconColor) then {\n                        _iconControl ctrlSetTextColor _iconColor;\n                    };\n\n                    // get the opposite angle\n                    _opposite = SIMPLIFY_ANGLE(-_camDirTo + 180);\n                    _posX = linearConversion[ KISKA_compass_shownAngle_min, KISKA_compass_shownAngle_max, _opposite, 0, _grpW, true ];\n                //    hintSilent ([_camDirTo,_opposite,KISKA_compass_shownAngle_max,KISKA_compass_shownAngle_min] joinString \"\\n\");\n                    _iconControl ctrlSetPositionX (_posX - _iconWidthDivided);\n                    _iconControl ctrlCommit 0;\n\n                };\n            } else {\n                if (ctrlShown _iconControl) then {\n                    _iconControl ctrlShow false;\n                };\n\n            };\n\n        };\n    };\n\n\n    false\n};\n",
    "fileName": "fn_compass_mainLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_parseConfig\n\nDescription:\n    Returns an array formatted for CBA settings menu lists.\n\nParameters:\n    0: _config <CONFIG> - The config to parse\n    1: _varName <STRING> - uiNamespace variable to save to and to check\n\nReturns:\n    <ARRAY> - An array formatted as [[title name strings],[image path strings],0]\n\nExamples:\n    (begin example)\n        private _array = [\n            configFile >> \"KISKA_compass\" >> \"compass\",\n            \"KISKA_compass_configs\"\n        ] call KISKA_fnc_compass_parseConfig;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_parseConfig\";\n\nparams [\"_config\",\"_varName\"];\n\nprivate _return = uiNamespace getVariable _varName;\nif (!isNil \"_return\") exitWith {\n    _return\n};\n\nif (isNull _config) exitWith {\n    [\"_config is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _nameArray = [];\nprivate _imagePathArray = [];\n(\"true\" configClasses _config) apply {\n    private _title = getText(_x >> \"title\");\n    private _imagePath = getText(_x >> \"image\");\n\n    if ((_title isNotEqualTo \"\") AND (_imagePath isNotEqualTo \"\")) then {\n        _nameArray pushBack _title;\n        _imagePathArray pushBack _imagePath;\n    };\n};\n\n_return = [_imagePathArray,_nameArray,0];\nuiNamespace setVariable [_varName,_return];\n\n\n_return\n",
    "fileName": "fn_compass_parseConfig.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_refresh\n\nDescription:\n    Resets the config global of the compass and then restarts the cutRSC for it.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - true if compass restarted\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_refresh;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_refresh\";\n\nif (!hasInterface) exitWith {\n    [\"Run on a machine without an interface, exiting...\",false] call KISKA_fnc_log;\n    false\n};\n\nprivate _display = GET_COMPASS_DISPLAY;\nif (isNull _display) exitWith {\n    [\"The display is null\",false] call KISKA_fnc_log;\n    false;\n};\n\n\nif (_display getVariable [COMPASS_CONFIGED_VAR_STR,false]) then {\n    _display setVariable [COMPASS_CONFIGED_VAR_STR,false];\n\n    (COMPASS_LAYER_NAME call BIS_fnc_rscLayer) cutText [ \"\", \"PLAIN\", -1, false ];\n    (COMPASS_LAYER_NAME call BIS_fnc_rscLayer) cutRsc [ \"KISKA_compass_rsc\", \"PLAIN\", -1, false ];\n\n    true\n\n} else {\n    [\"KISKA Compass has already been stopped\",true] call KISKA_fnc_log;\n    false\n\n};\n",
    "fileName": "fn_compass_refresh.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass Globals.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_updateColors\n\nDescription:\n    Updates the color of the ctrls for the KISKA compass.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_updateColors;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_updateColors\";\n\nprivate _display = GET_COMPASS_DISPLAY;\nif (isNull _display) exitWith {};\n\nprivate _compassImageCtrl = _display getVariable [COMPASS_IMAGE_CTRL_VAR_STR,controlNull];\nif !(isNull _compassImageCtrl) then {\n    _compassImageCtrl ctrlSetTextColor KISKA_compass_mainColor;\n};\n\nprivate _compassBackgroundCtrl = _display getVariable [COMPASS_BACKGROUND_CTRL_VAR_STR,controlNull];\nif !(isNull _compassBackgroundCtrl) then {\n    _compassBackgroundCtrl ctrlSetTextColor KISKA_compass_backgroundColor;\n};\n\nprivate _compassCenterMarkersCtrl = _display getVariable [COMPASS_CENTER_MARKERS_CTRL_VAR_STR,controlNull];\nif !(isNull _compassCenterMarkersCtrl) then {\n    _compassCenterMarkersCtrl ctrlSetTextColor KISKA_compass_centerColor;\n};\n",
    "fileName": "fn_compass_updateColors.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Compass Image Resolutions.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_compass_updateConstants\n\nDescription:\n    Updates a number of constant global variables used for the KISKA compass.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_compass_updateConstants;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_compass_updateConstants\";\n\nprivate _pixelOffset = ((COMPASS_USEABLE_WIDTH / 2) - KISKA_compass_widthScale) / 2;\nmissionNamespace setVariable [\"KISKA_compass_pixelX_min\",(MIN_COMPASS_WIDTH + _pixelOffset) * KISKA_compass_scale];\nmissionNamespace setVariable [\"KISKA_compass_pixelX_max\",(MAX_COMPASS_WIDTH + _pixelOffset) * KISKA_compass_scale];\n\nprivate _offset = linearConversion[ 630, 1260, KISKA_compass_widthScale, 0, 45, true ];\nmissionNamespace setVariable [\"KISKA_compass_shownAngle_min\",135 - _offset];\nmissionNamespace setVariable [\"KISKA_compass_shownAngle_max\",225 + _offset];\nmissionNamespace setVariable [\"KISKA_compass_iconAngle_min\",45 + _offset];\nmissionNamespace setVariable [\"KISKA_compass_iconAngle_max\",315 - _offset];\n\n\nmissionNamespace setVariable [\"KISKA_compass_iconW\",KISKA_compass_iconPixelSize * pixelW * KISKA_compass_scale];\nmissionNamespace setVariable [\"KISKA_compass_iconH\",KISKA_compass_iconPixelSize * pixelH * KISKA_compass_scale];\n\nmissionNamespace setVariable [\"KISKA_compass_iconWidth_active\",KISKA_compass_iconW * KISKA_compass_activeIconMultiplier];\nmissionNamespace setVariable [\"KISKA_compass_iconHeight_active\",KISKA_compass_iconH * KISKA_compass_activeIconMultiplier];\n\nmissionNamespace setVariable [\"KISKA_compass_iconWidth_inactive\",KISKA_compass_iconW * KISKA_compass_inactiveIconMultiplier];\nmissionNamespace setVariable [\"KISKA_compass_iconHeight_inactive\",KISKA_compass_iconH * KISKA_compass_inactiveIconMultiplier];\n",
    "fileName": "fn_compass_updateConstants.sqf"
  },
  {
    "text": "#include \"..\\Headers\\GroupChangerCommonDefines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad\n\nDescription:\n    Executes in the onload event for the KISKA's Group Changer Dislog\n\nParameters:\n    0: _display <DISPLAY> - The display of the dialog\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_display] call KISKA_fnc_GCHOnLoad;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_display\"];\n\nif (missionNamespace getVariable [\"KISKA_CBA_GCH_closeMap\",true]) then {\n    openMap false;\n};\n\n// prepare globals for controls\nlocalNamespace setVariable [\"KISKA_GCH_display\",_display];\n\n\n/* ----------------------------------------------------------------------------\n    Misc\n---------------------------------------------------------------------------- */\n// leader name indicator\nprivate _leaderNameIndicator_ctrl = _display displayCtrl GCH_LEADER_NAME_INDICATOR_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_leaderNameIndicator_ctrl\",_leaderNameIndicator_ctrl];\n\n\n// Show AI Check Box\nprivate _showAiCheckBox_ctrl = _display displayCtrl GCH_SHOW_AI_CHECKBOX_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_showAiCheckBox_ctrl\",_showAiCheckBox_ctrl];\n[_showAiCheckBox_ctrl] call KISKA_fnc_GCHOnLoad_showAiCheckbox;\n\n\n/* ----------------------------------------------------------------------------\n    Combo Boxes\n---------------------------------------------------------------------------- */\n// can be deleted\nprivate _canBeDeletedCombo_ctrl = _display displayCtrl GCH_CAN_BE_DELETED_COMBO_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_canBeDeletedCombo_ctrl\",_canBeDeletedCombo_ctrl];\n[_canBeDeletedCombo_ctrl] call KISKA_fnc_GCHOnLoad_canBeDeletedCombo;\n\n// can rally\nprivate _canRallyCombo_ctrl = _display displayCtrl GCH_CAN_RALLY_COMBO_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_canRallyCombo_ctrl\",_canRallyCombo_ctrl];\n[_canRallyCombo_ctrl] call KISKA_fnc_GCHOnLoad_canRallyCombo;\n\n// Assign Team\nprivate _assignTeamCombo_ctrl = _display displayCtrl GCH_CAN_ASSIGN_TEAM_COMBO_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_assignTeamCombo_ctrl\",_assignTeamCombo_ctrl];\n[_assignTeamCombo_ctrl] call KISKA_fnc_GCHOnLoad_assignTeamCombo;\n\n\n/* ----------------------------------------------------------------------------\n    List Boxes\n---------------------------------------------------------------------------- */\n// current group unit list\nprivate _currentGroupListBox_ctrl = _display displayCtrl GCH_CURRENT_GROUP_LISTBOX_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_currentGroupListBox_ctrl\",_currentGroupListBox_ctrl];\n\n// side groups list\nprivate _sidesGroupListBox_ctrl = _display displayCtrl GCH_SIDE_GROUPS_LISTBOX_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_sidesGroupListBox_ctrl\",_sidesGroupListBox_ctrl];\n[_sidesGroupListBox_ctrl] call KISKA_fnc_GCHOnLoad_sideGroupsList;\n\n\n/* ----------------------------------------------------------------------------\n    Buttons\n---------------------------------------------------------------------------- */\n// join group button\nprivate _joinGroupButton_ctrl = _display displayCtrl GCH_JOIN_GROUP_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_joinGroupButton_ctrl\",_joinGroupButton_ctrl];\n[_joinGroupButton_ctrl] call KISKA_fnc_GCHOnLoad_joinGroupButton;\n\n// leave group button\nprivate _leaveGroupButton_ctrl = _display displayCtrl GCH_LEAVE_GROUP_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_leaveGroupButton_ctrl\",_leaveGroupButton_ctrl];\n[_leaveGroupButton_ctrl] call KISKA_fnc_GCHOnLoad_leaveGroupButton;\n\n// close button\nprivate _closeButton_ctrl = _display displayCtrl GCH_CLOSE_BUTTON_IDC;\n//localNamespace setVariable [\"KISKA_GCH_closeButton_ctrl\",_closeButton_ctrl];\n[_closeButton_ctrl] call KISKA_fnc_GCHOnLoad_closeButton;\n\n// set leader button\nprivate _setLeaderButton_ctrl = _display displayCtrl GCH_SET_LEADER_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_setLeaderButton_ctrl\",_setLeaderButton_ctrl];\n[_setLeaderButton_ctrl] call KISKA_fnc_GCHOnLoad_setLeaderButton;\n\n// set Group ID button\nprivate _setGroupIdButton_ctrl = _display displayCtrl GCH_SET_GROUP_ID_BUTTON_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_setGroupIdButton_ctrl\",_setGroupIdButton_ctrl];\n// edit\nprivate _groupIdEdit_ctrl = _display displayCtrl GCH_SET_GROUP_ID_EDIT_IDC;\nlocalNamespace setVariable [\"KISKA_GCH_groupIdEdit_ctrl\",_groupIdEdit_ctrl];\n[_setGroupIdButton_ctrl] call KISKA_fnc_GCHOnLoad_setGroupIdButton;\n\n\n\n\n\n\n\n_display displayAddEventHandler [\"unload\",{\n    // clear localNamespace variables\n    [\n        \"KISKA_GCH_display\",\n        \"KISKA_GCH_selectedGroup\",\n        \"KISKA_GCH_currentGroupListBox_ctrl\",\n        \"KISKA_GCH_leaveGroupButton_ctrl\",\n        \"KISKA_GCH_groupUnitList\",\n        \"KISKA_GCH_leaderNameIndicator_ctrl\",\n        \"KISKA_GCH_setLeaderButton_ctrl\",\n        \"KISKA_GCH_joinGroupButton_ctrl\",\n        \"KISKA_GCH_showAiCheckBox_ctrl\",\n        \"KISKA_GCH_groupIdEdit_ctrl\",\n        \"KISKA_GCH_canBeDeletedCombo_ctrl\",\n        \"KISKA_GCH_canRallyCombo_ctrl\",\n        \"KISKA_GCH_sidesGroupListBox_ctrl\",\n        \"KISKA_GCH_sideGroupsArray\",\n        \"KISKA_GCH_setGroupIdButton_ctrl\",\n        \"KISKA_GCH_assignTeamCombo_ctrl\"\n    ] apply {\n        localNamespace setVariable [_x,nil];\n    };\n}];\n\n\n// there needs to be a variable you can assign to units/players that does not allow them to leave groups\n// or it only allows them to join certain groups\n",
    "fileName": "fn_GCHOnLoad.sqf"
  },
  {
    "text": "#include \"..\\Headers\\GCH Colors.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_assignTeamCombo\n\nDescription:\n    Adds control event handler to the combo box for turning it on and off.\n\nParameters:\n    0: _control <CONTROL> - The control for the combo box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_assignTeamCombo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_assignTeamCombo\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    private _unitList = localNamespace getVariable [\"KISKA_GCH_groupUnitList\",[]];\n    private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n    private _unitLBIndex = lbCurSel _currentGroupListBox_ctrl;\n    private _selectedUnit = _unitList select (_currentGroupListBox_ctrl lbValue _unitLBIndex);\n\n    private _selectedgroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n    private _groupLeader = leader _selectedgroup;\n\n    private _unitIsPlayer = _selectedUnit isEqualTo player;\n    if (_unitIsPlayer OR {_groupLeader isEqualTo player} OR {call KISKA_fnc_isAdminOrHost}) then {\n        if (alive _selectedUnit) then {\n            [_selectedUnit,_selectedIndex] remoteExec [\"KISKA_fnc_GCH_assignTeam\",[_groupLeader,_selectedUnit] select (_unitIsPlayer)];\n            [] spawn {\n                sleep 1;\n                [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n            };\n\n        } else {\n            [\"This unit appears to be dead\"] call KISKA_fnc_errorNotification;\n\n        };\n\n    } else {\n        [\"You must be the admin or host to change this setting\"] call KISKA_fnc_errorNotification;\n\n    };\n\n}];\n\n_control lbAdd \"MAIN\";\n\nprivate _index = _control lbAdd \"BLUE\";\n_control lbSetColor [_index, COLOR_BLUE];\n\n_index = _control lbAdd \"GREEN\";\n_control lbSetColor [_index, COLOR_GREEN];\n\n_index = _control lbAdd \"RED\";\n_control lbSetColor [_index, COLOR_RED];\n\n_index = _control lbAdd \"YELLOW\";\n_control lbSetColor [_index, COLOR_YELLOW];\n\n\n_control lbSetCurSel 0;\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_assignTeamCombo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_canBeDeletedCombo\n\nDescription:\n    Adds control event handler to the combo box for turning it on and off.\n\nParameters:\n    0: _control <CONTROL> - The control for the combo box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_canBeDeletedCombo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_canBeDeletedCombo\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    if (call KISKA_fnc_isAdminOrHost) then {\n\n        private _selectedgroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n\n        if !(isNull _selectedgroup) then {\n\n            private _canDelete = isGroupDeletedWhenEmpty _selectedgroup;\n            private _fn_setGroupAutoDelete = {\n                params [\"_allowDelete\"];\n\n                if (local _selectedgroup) then {\n                    _selectedgroup deleteGroupWhenEmpty _allowDelete;\n                } else {\n                    [_selectedgroup, _allowDelete] remoteExecCall [\"KISKA_fnc_GCH_groupDeleteQuery\",2];\n                };\n            };\n\n\n            if (_selectedIndex isEqualTo 0) then {\n                // if you can delete the group, set to false\n                if (_canDelete) then {\n                    [false] call _fn_setGroupAutoDelete;\n                };\n            } else {\n                // If you can't delete the group, set to true\n                if !(_canDelete) then {\n                    [true] call _fn_setGroupAutoDelete;\n                };\n            };\n        };\n    } else {\n        // when selecting a group, and this control is created/updated in the right pane, this error may show for certain users\n        // despite not having changed the setting, therefore, this boolean is used to see if this control was just created and this\n        // is the second time or more the control is adjusted\n        if !(_control getVariable [\"KISKA_firstTimeComboChanged\",false]) then {\n            [\"You must be the admin or host to change this setting\"] call KISKA_fnc_errorNotification;\n\n        } else {\n            _control setVariable [\"KISKA_firstTimeComboChanged\",false];\n\n        };\n    };\n}];\n\n_control lbAdd \"NO\";\n_control lbAdd \"YES\";\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_canBeDeletedCombo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_canRallyCombo\n\nDescription:\n    Adds control event handler to the combo box for turning it on and off.\n\nParameters:\n    0: _control <CONTROL> - The control for the combo box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_canRallyCombo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_canRallyCombo\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    private _selectedgroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n    if !(isNull _selectedgroup) then {\n\n        if ([_selectedgroup] call KISKA_fnc_GCH_isAllowedToEdit) then {\n            // NO\n            if (_selectedIndex isEqualTo 0) then {\n                [_selectedgroup,true] remoteExecCall [\"KISKA_fnc_disallowGroupRally\",2];\n            } else {\n            // YES\n                [_selectedgroup] remoteExecCall [\"KISKA_fnc_allowGroupRally\",2];\n            };\n        } else {\n            // when selecting a group, and this control is created/updated in the right pane, this error may show for certain users\n            // despite not having changed the setting, therefore, this boolean is used to see if this control was just created and this\n            // is the second time or more the control is adjusted\n            if !(_control getVariable [\"KISKA_firstTimeComboChanged\",false]) then {\n                [\"You do not have permission to change this setting\"] call KISKA_fnc_errorNotification;\n\n            } else {\n                _control setVariable [\"KISKA_firstTimeComboChanged\",false];\n\n            };\n        };\n    };\n\n}];\n\n_control lbAdd \"NO\";\n_control lbAdd \"YES\";\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_canRallyCombo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_closeButton\n\nDescription:\n    Adds control event handler to the close buttont that will close the dialog.\n\nParameters:\n    0: _control <CONTROL> - The control for the close button\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_closeButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_closeButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    (localNamespace getVariable \"KISKA_GCH_display\") closeDisplay 2;\n}];\n\n\nnil",
    "fileName": "fn_GCHOnLoad_closeButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_joinGroupButton\n\nDescription:\n    The function that fires on the join group button click event.\n    The Event is called from KISKA_fnc_GCHOnLoad.\n\nParameters:\n    0: _control <CONTROL> - The control of the button\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n       [buttonControl]  call KISKA_fnc_GCHOnLoad_joinGroupButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_joinGroupButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n\n    if !(isNull _selectedGroup) then {\n        if ((group player) isNotEqualTo _selectedGroup) then {\n            private _groupIsLocal = local _selectedGroup;\n            [player] joinSilent _selectedGroup;\n        };\n\n    } else {\n        [\"The group you are trying to join does not exist\"] call KISKA_fnc_errorNotification;\n\n    };\n\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_joinGroupButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnload_leaveGroupButton\n\nDescription:\n    The function that fires on the leave group button click event.\n    The Event is added in KISKA_fnc_GCHOnLoad.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [buttonControl] call KISKA_fnc_GCHOnload_leaveGroupButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_leaveGroupButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n    private _newGroup = createGroup [_playerSide, true];\n    [player] joinSilent _newGroup;\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_leaveGroupButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_setGroupIdButton\n\nDescription:\n    The function that fires on the set group id button click event.\n\n    This is called from KISKA_fnc_GCHOnLoad\n\nParameters:\n    0: _control <CONTROL> - The control of the button\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [buttonControl] call KISKA_fnc_GCHOnLoad_setGroupIdButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_setGroupIdButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n    private _editBox_ctrl = localNamespace getVariable \"KISKA_GCH_groupIdEdit_ctrl\";\n    private _newId = ctrlText _editBox_ctrl;\n\n    private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;;\n\n    if !(isNull _selectedGroup) then {\n        // case sensetive check to see if there is a change in the name\n        if !(_newId isEqualTo (groupId _selectedGroup)) then {\n\n            private _sideGroups = localNamespace getVariable \"KISKA_GCH_sideGroupsArray\";\n            // check if another group already has the id\n            private _alreadyHasName = [\n                _sideGroups,\n                {(groupId _x) isEqualTo (_thisArgs select 0)},\n                [_newId]\n            ] call KISKA_fnc_findIfBool;\n\n            if !(_alreadyHasName) then {\n                _selectedGroup setGroupIdGlobal [_newId];\n\n                // update side group list with new id\n                private _index = _sideGroups findIf {\n                    _x isEqualTo _selectedGroup\n                };\n\n                private _sideGroupsList_ctrl = localNamespace getVariable \"KISKA_GCH_sidesGroupListBox_ctrl\";\n                _sideGroupsList_ctrl lbSetText [_index,_newId];\n                [\"Group Id Updated\"] call KISKA_fnc_notification;\n            } else {\n                [\"Another group on your side already has this ID\"] call KISKA_fnc_errorNotification;\n            };\n        };\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_setGroupIdButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_setLeaderButton\n\nDescription:\n    The function that fires on the set leader button click event.\n\n    The function is called in KISKA_fnc_GCHOnLoad.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n           [buttonControl] call KISKA_fnc_GCHOnLoad_setLeaderButton;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_setLeaderButton\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"ButtonClick\",{\n\n    private _group = [] call KISKA_fnc_GCH_getSelectedGroup;\n\n    if ([_group] call KISKA_fnc_GCH_isAllowedToEdit) then {\n        private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n        private _selectedindex = lbCurSel _currentGroupListBox_ctrl;\n        private _unitArrayIndex = _currentGroupListBox_ctrl lbValue _selectedindex;\n\n        private _unitArray = localNamespace getVariable \"KISKA_GCH_groupUnitList\";\n        private _unitToSet = _unitArray select _unitArrayIndex;\n\n        if !(_unitToSet isEqualTo (leader _group)) then {\n            if (local _group) then {\n                _group selectLeader _unitToSet;\n            } else {\n                [_group,_unitToSet] remoteExecCall [\"KISKA_fnc_GCH_setLeaderRemote\",2];\n            };\n        };\n\n\n        // update leader name indicator\n        [false,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n    } else {\n        [\"You must be the leader or admin to set a leader\"] call KISKA_fnc_errorNotification;\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_setLeaderButton.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_showAiCheckbox\n\nDescription:\n    Adds control event handler to check box and sets its intial state.\n\nParameters:\n    0: _control <CONTROL> - The control for the checkbox\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_showAiCheckbox;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_showAiCheckbox\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n_control ctrlAddEventHandler [\"CheckedChanged\",{\n    params [\"_control\", \"_checked\"];\n\n    // convert from number to bool\n    _checked = [false,true] select _checked;\n    localNamespace setVariable [\"KISKA_GCH_showAI\",_checked];\n\n    [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n}];\n\n\n// set checked or not initially on open\n_control cbSetChecked (localNamespace getVariable [\"KISKA_GCH_showAI\",true]);",
    "fileName": "fn_GCHOnLoad_showAiCheckbox.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_sideGroupsList\n\nDescription:\n    Adds eventhandler to the listbox.\n\nParameters:\n    0: _control <CONTROL> - The control for the list box\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_control] call KISKA_fnc_GCHOnLoad_sideGroupsList;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCHOnLoad_sideGroupsList\";\n\nif !(hasInterface) exitWith {};\n\nparams [\"_control\"];\n\n// add event handler\n_control ctrlAddEventHandler [\"LBSelChanged\",{\n    params [\"_control\", \"_selectedIndex\"];\n\n    // get selected group\n    private _sideGroups = localNamespace getVariable \"KISKA_GCH_sideGroupsArray\";\n    private _sideGroupsIndex = _control lbValue _selectedIndex;\n    private _selectedGroup = _sideGroups select _sideGroupsIndex;\n    localNamespace setVariable [\"KISKA_GCH_selectedGroup\",_selectedGroup];\n\n    [true,true,true,true,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n}];\n\n\n[true] call KISKA_fnc_GCH_updateSideGroupsList;\n\n\nnil\n",
    "fileName": "fn_GCHOnLoad_sideGroupsList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_addDiaryEntry\n\nDescription:\n    Creates a diary entry in the map for the player to open the Group Manager\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_addDiaryEntry\";\n\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\"] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_GCH_addDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n[\n    [\n        \"Group Manager GUI\",\n        \"<execute expression='call KISKA_fnc_GCH_openDialog;'>Open Group Changer Dialog</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_GCH_addDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_addGroupEventhandlers\n\nDescription:\n    Adds group eventhandlers that help the GCH GUI function.\n\nParameters:\n    0: _group <GROUP> - The Group to add the eventhandlers to\n\nReturns:\n    <HASHMAP> - A map with all event ids contained within it\n\nExamples:\n    (begin example)\n        [group player] call KISKA_fnc_GCH_addGroupEventhandlers\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_addGroupEventhandlers\";\n\nif !(hasInterface) exitWith {[]};\n\nparams [\n    [\"_group\",grpNull,[grpNull]]\n];\n\n\nif (isNull _group) exitWith {\n    [\"Null group provided, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _eventMap = _group getVariable \"KISKA_GCH_groupEventIdMap\";\nif !(isNil \"_eventMap\") exitWith {\n    [[\"Attempted to re apply group eventhandlers to: \",_group,\" when event map is: \",_eventMap]] call KISKA_fnc_log;\n    _eventMap\n};\n\n\nprivate _unitJoinedGroup_eventId = _group addEventHandler [\"UnitJoined\", {\n    params [\"_joinedGroup\",\"_unitThatJoined\"];\n    \n    private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n    if (_joinedGroup isEqualTo _selectedGroup) then {\n        [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n    };\n\n    if (_unitThatJoined isEqualTo player) then {\n        private _joinedGroupIsExcluded = [_joinedGroup] call KISKA_fnc_GCH_isGroupExcluded;\n        if (!_joinedGroupIsExcluded) exitWith {};\n\n        private _joinedGroupAlreadyHasPlayer = [group player] call KISKA_fnc_GCH_doesGroupHaveAnotherPlayer;\n        if (_joinedGroupAlreadyHasPlayer) exitWith {};\n\n        [_joinedGroup,false,true] call KISKA_fnc_GCH_setGroupExcluded;\n    };\n}];\n\n\nprivate _unitLeftGroup_eventId = _group addEventHandler [\"UnitLeft\", {\n    params [\"_group\", \"_unitThatLeft\"];\n\n    if !(isNull _group) then {\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n        if (_group isEqualTo _selectedGroup) then {\n            [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n        };\n    };\n}];\n\nprivate _groupIdChanged_eventId = _group addEventHandler [\"GroupIdChanged\", {\n    params [\"_group\", \"_newGroupId\"];\n    \n    if !(isNull _group) then {\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n        if (_group isEqualTo _selectedGroup) then {\n            [false,false,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n        };\n\n        [false] call KISKA_fnc_GCH_updateSideGroupsList;\n    };\n}];\n\nprivate _groupLeaderChanged_eventId = _group addEventHandler [\"LeaderChanged\", {\n    params [\"_group\", \"_newLeader\"];\n\n    if !(isNull _group) then {\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n        if (_group isEqualTo _selectedGroup) then {\n            [false,true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n        };\n    };\n}];\n\nprivate _groupEmpty_eventId = _group addEventHandler [\"Empty\", {\n    // params [\"_group\"];\n}];\n\n\n_eventMap = createHashMapFromArray [\n    [\"unitjoined\",_unitJoinedGroup_eventId],\n    [\"unitleft\",_unitLeftGroup_eventId],\n    [\"idchanged\",_groupIdChanged_eventId],\n    [\"leaderchanged\",_groupLeaderChanged_eventId],\n    [\"emptygroup\",_groupEmpty_eventId]\n];\n_group setVariable [\"KISKA_GCH_groupEventIdMap\",_eventMap];\n\n\n_eventMap\n",
    "fileName": "fn_GCH_addGroupEventhandlers.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_addMissionEvents\n\nDescription:\n    Adds mission event handlers for keeping track of groups.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_addMissionEvents\";\n\nif !(hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\n\naddMissionEventHandler [\"GroupCreated\", {\n    params [\"_group\"];\n    [_group] call KISKA_fnc_GCH_addGroupEventhandlers;\n}];\n\n\naddMissionEventHandler [\"GroupDeleted\", {\n    params [\"_group\"];\n\n    private _groupChangerOpen = [] call KISKA_fnc_GCH_isOpen;\n    if (_groupChangerOpen) then {\n        private _groupIsExcluded = [_group] call KISKA_fnc_GCH_isGroupExcluded;\n        private _deletedGroupSide = side _group;\n        private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n\n        if ((_playerSide isEqualTo _deletedGroupSide) AND (!_groupIsExcluded)) then {\n            [true] call KISKA_fnc_GCH_updateSideGroupsList;\n        };\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_GCH_addMissionEvents.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCHOnLoad_assignTeamCombo\n\nDescription:\n    Reassigns a unit's team\n\nParameters:\n    0: _unit <OBJECT> - The unit to reassign\n    1: _team <NUMBER> - the team to assign\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [aUnit] remoteExec [\"KISKA_fnc_GCH_assignTeam\",LocalPlayerUnitOrLeaderOfGroup];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_assignTeam\";\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled!\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_GCH_assignTeam;\n};\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_team\",0,[123]]\n];\n\nif (isNull _unit) exitWith {\n    [\"Null object passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nswitch (_team) do {\n    case 1:{\n        _unit assignTeam \"BLUE\";\n    };\n    case 2:{\n        _unit assignTeam \"GREEN\";\n    };\n    case 3:{\n        _unit assignTeam \"RED\";\n    };\n    case 4:{\n        _unit assignTeam \"YELLOW\";\n    };\n\n    default {\n        _unit assignTeam \"MAIN\";\n    };\n};\n\n\nnil\n",
    "fileName": "fn_GCH_assignTeam.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_canPlayerChangeGroup\n\nDescription:\n    The function that fires on the leave group button click event.\n    The Event is added in KISKA_fnc_GCHOnLoad.\n\nParameters:\n    0: _groupToJoin : <group> - The group a player wants to join\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [someGroup] call KISKA_fnc_GCH_canPlayerChangeGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_canPlayerChangeGroup\";\n\n#define TRYING_TO_CREATE_NEW_GROUP 1\n#define TRYING_TO_JOIN_GROUP_WITHOUT_PERMS 2\n\nparams [\n    [\"_groupToJoin\",\"new group\",[grpNull,\"\"]]\n];\n\nprivate _allowedGroups = missionNamespace getVariable [\"KISKA_allowedGroups\",[]];\nprivate _currentPlayerGroup = group player;\n\nprivate _doExit = -1;\n\nif !(_allowedGroups isEqualTo []) then {\n\n    private _isInAllowedGroup = [\n        _allowedGroups,\n        {(group player) isEqualTo _x}\n    ] call KISKA_fnc_findIfBool;\n\n    if (_isInAllowedGroup AND {_groupToJoin isEqualTo \"new group\"}) exitWith {\n        _doExit = TRYING_TO_CREATE_NEW_GROUP;\n    };\n\n};\n\nif (_doExit isNotEqualTo -1) exitWith {\n\n    switch (_doExit) do {\n\n        case TRYING_TO_CREATE_NEW_GROUP: {\n            [\"You cannot create a new group, you must join only your allowed groups\"] call KISKA_fnc_errorNotification;\n        };\n\n        case TRYING_TO_JOIN_GROUP_WITHOUT_PERMS: {\n            private _text = parseText \"You are limited in the groups you can join, consult the Side Groups list. <t color='#00b530'>Green</t> are joinable.\";\n            [_text] call KISKA_fnc_errorNotification;\n        };\n    };\n};\n\nif (isNull _groupToJoin) exitWith {\n    [\"The group you are attempting to join no longer exists\"] call KISKA_fnc_errorNotification;\n};\n",
    "fileName": "fn_GCH_canPlayerChangeGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_doesGroupHaveAnotherPlayer\n\nDescription:\n    Checks if a group contains another player other than the local player\n\nParameters:\n    0: _group <GROUP> - The group to search in\n\nReturns:\n    <BOOL> - True if another player is in ther group\n\nExamples:\n    (begin example)\n        [group player] call KISKA_fnc_GCH_doesGroupHaveAnotherPlayer\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_doesGroupHaveAnotherPlayer\";\n\nparams [\n    [\"_group\",grpNull,[grpNull]]\n];\n\n\nif (isNull _group) exitWith {\n    [\"Null group passed\"] call KISKA_fnc_log;\n    false\n};\n\n\nprivate _anotherPlayerInGroup = [\n    units _group,\n    {\n        (_x isNotEqualTo player) AND (isPlayer _x)\n    }\n] call KISKA_fnc_findIfBool;\n\n\n_anotherPlayerInGroup\n",
    "fileName": "fn_GCH_doesGroupHaveAnotherPlayer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_dontExcludePlayerGroupDefault\n\nDescription:\n    In order to maintain a player-group-is-not-excluded by default in the \n     Group Changer, when a player joins the game, they will set their group\n     to be not excluded on all other machines and JIP\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_dontExcludePlayerGroupDefault\";\n\nif !(hasInterface) exitWith {};\n\nprivate _playerGroup = group player;\nif (isNull _playerGroup) exitWith {};\n\nprivate _isGroupExcluded = [_playerGroup,true] call KISKA_fnc_GCH_isGroupExcluded;\nprivate _exclusionWasSet = !(isNil \"_isGroupExcluded\");\nif (_exclusionWasSet) exitWith {};\n\n[_playerGroup,false,true] call KISKA_fnc_GCH_setGroupExcluded;\n\n\nnil\n",
    "fileName": "fn_GCH_dontExcludePlayerGroupDefault.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_getPlayerSide\n\nDescription:\n    Returns the side of the player's group in order to avoid if the player is\n     captive and the object is technically a part of the civ faction for instance.\n\nParameters:\n    NONE\n\nReturns:\n    <SIDE> - The side of the player's group\n\nExamples:\n    (begin example)\n        private _playerSide = call KISKA_fnc_GCH_getPlayerSide;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_getPlayerSide\";\n\nif (!hasInterface) exitWith {\n    sideLogic\n};\n\n\nside (group player)",
    "fileName": "fn_GCH_getPlayerSide.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_getSelectedGroup\n\nDescription:\n    Returns the selected group in the group changer.\n\nParameters:\n    NONE\n\nReturns:\n    <GROUP> - The currently selected group or grpNull if not found\n\nExamples:\n    (begin example)\n        private _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_getSelectedGroup\";\n\nif !(hasInterface) exitWith {grpNull};\n\nlocalNamespace getVariable [\"KISKA_GCH_selectedGroup\",grpNull]",
    "fileName": "fn_GCH_getSelectedGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_getSideGroups\n\nDescription:\n    Gets all groups of a particular side and that are not exlcuded from the GCH\n\nParameters:\n    0: _side <SIDE> - The side to get the groups of\n\nReturns:\n    <ARRAY> - List of all the groups\n\nExamples:\n    (begin example)\n        private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n        _groups = [_playerSide] call KISKA_fnc_GCH_getSideGroups;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_getSideGroups\";\n\nif !(hasInterface) exitWith {[]};\n\nparams [\n    [\"_side\",BLUFOR,[sideUnknown]]\n];\n\n\nallGroups select {\n    (side _x) isEqualTo _side AND\n    (!([_x] call KISKA_fnc_GCH_isGroupExcluded))\n};\n",
    "fileName": "fn_GCH_getSideGroups.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_groupDeleteQuery\n\nDescription:\n    Acts as a liason from a client to add a group to auto delete if necessary.\n\n    Only works where the group is local and need to use groupOwner to get that\n     which only works on the server.\n\nParameters:\n    0: _group <GROUP> - The group to change the auto-deletion on\n    1: _canDelete <BOOL> - Set the group to be deleted or not\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myGroup,false] call KISKA_fnc_GCH_groupDeleteQuery;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_groupDeleteQuery\";\n\nif (!isServer) exitWith {\n    [\"Must be run on server\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nparams [\"_group\",\"_canDelete\"];\n\n_this remoteExecCall [\"deleteGroupWhenEmpty\",groupOwner _group];\n\n\nnil\n",
    "fileName": "fn_GCH_groupDeleteQuery.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_isAllowedToEdit\n\nDescription:\n    Checks if a machine is allowed to edit a given property in the GCH dialog.\n\nParameters:\n    0: _groupLeader <OBJECT or GROUP> - The leader or group to edit the property on.\n        If provided, it will be assumed that even the group leader can edit the property\n\nReturns:\n    <BOOL> - True if yes, false if no.\n\nExamples:\n    (begin example)\n        _canEdit = [myGroup] call KISKA_fnc_GCH_isAllowedToEdit;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_isAllowedToEdit\";\n\n// hosts and admins can always edit\nif (call KISKA_fnc_isAdminOrHost) exitWith {\n    true\n};\n\nparams [\n    [\"_groupLeader\",objNull,[objNull,grpNull]]\n];\n\nif (_groupLeader isEqualType grpNull) then {\n    _groupLeader = leader _groupLeader;\n};\n\nif (isNull _groupLeader) exitWith {\n    false\n};\n\nif (local _groupLeader) then {\n    true\n} else {\n    false\n};\n",
    "fileName": "fn_GCH_isAllowedToEdit.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_isGroupExcluded\n\nDescription:\n    Checks if a group is excluded from the Group Changer menu.\n\nParameters:\n    0: _group <GROUP> - The group to check exclusion of\n    1: _canBeNil <BOOL> - Whether or not to operate under the assumption of a default \"true\" value.\n        if `true`, function can either return a BOOL or nil for the var never having been set\n\nReturns:\n    <BOOL or nil> - Returns true if the group is excluded, false if not, or nil if never defined\n\nExamples:\n    (begin example)\n        private _isExcluded = [group player] call KISKA_fnc_GCH_isGroupExcluded;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_isGroupExcluded\";\n\nif !(hasInterface) exitWith {true};\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_canBeNil\",false,[true]]\n];\n\n\nif (_canBeNil) exitWith {_group getVariable \"KISKA_GCH_exclude\"};\n_group getVariable [\"KISKA_GCH_exclude\",true];\n",
    "fileName": "fn_GCH_isGroupExcluded.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_isOpen\n\nDescription:\n    Checks if the group changer is open or not.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - Returns true if the group changer is open and false if it is not\n\nExamples:\n    (begin example)\n        private _isOpen = call KISKA_fnc_GCH_isOpen;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCH_isOpen\";\n\nif !(hasInterface) exitWith {false};\nprivate _gchDisplay = localNamespace getVariable [\"KISKA_GCH_display\",displayNull];\n\n\n!(isNull _gchDisplay)\n\n",
    "fileName": "fn_GCH_isOpen.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_openDialog\n\nDescription:\n    Opens KISKA Group Changer dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_GCH_openDialog;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_openDialog\";\n\nif (missionNamespace getVariable [\"KISKA_CBA_GCH_enabled\",true]) then {\n    createDialog \"KISKA_GCH_dialog\";\n} else {\n    [\"The Group Changer Dialog is diabled in the Server Addon Options\"] call KISKA_fnc_errorNotification;\n};\n\n\nnil\n",
    "fileName": "fn_GCH_openDialog.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_setGroupExcluded\n\nDescription:\n    Sets a group's exclusion from the Group Changer.\n\nParameters:\n    0: _group <GROUP> - The group to check exclusion of\n    1: _isExcluded <BOOL> - True to exclude group, false to include\n    2: _synchronize <BOOL> - True to remoteExec this function and provide a JIP message\n\nReturns:\n    <BOOL> - Returns true if the group is excluded or false if not\n\nExamples:\n    (begin example)\n        // exclude group\n        private _isExcluded = [group player,true] call KISKA_fnc_GCH_setGroupExcluded;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_setGroupExcluded\";\n\nif (!hasInterface) exitWith {true};\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_isExcluded\",true,[true]],\n    [\"_synchronize\",false,[true]]\n];\n\n\nif (isNull _group) exitWith {\n    [\"null group provided\"] call KISKA_fnc_log;\n    true\n};\n\nif (_synchronize) exitWith {\n    private _jipId = \"KISKA_GCH_groupExclusion:\" + (str _group);\n    [_group,_isExcluded] remoteExecCall [\"KISKA_fnc_GCH_setGroupExcluded\",0,_jipId];\n};\n\n_group setVariable [\"KISKA_GCH_exclude\",_isExcluded];\n[true] call KISKA_fnc_GCH_updateSideGroupsList;\n\n\n_isExcluded\n",
    "fileName": "fn_GCH_setGroupExcluded.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_setLeaderRemote\n\nDescription:\n    Remotely sets a leader of a group from the server. (Must be run on the server)\n\nParameters:\n    0: _group <GROUP> - The group to set the unit to leader\n    1: _unitToSet <OBJECT> - The unit to set to leader of the group\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [group player, player] call KISKA_fnc_GCH_setLeaderRemote;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_GCH_setLeaderRemote\";\n\nparams [\"_group\",\"_unitToSet\"];\n\nif (!isServer) exitWith {\n    [\"Must be run on server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n_this remoteExecCall [\"selectLeader\",groupOwner _group];\n\n\nnil",
    "fileName": "fn_GCH_setLeaderRemote.sqf"
  },
  {
    "text": "#include \"..\\Headers\\GCH Colors.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_updateCurrentGroupSection\n\nDescription:\n    Updates the individual components of the current group section of the GUI.\n\nParameters:\n    0: _updateUnitList <BOOL> - Updates the list of units\n    1: _updateLeaderIndicator <BOOL> - Updates the text that shows the leader's name\n    2: _updateGroupId <BOOL> - Updates the group's ID name\n    3: _updateCanDeleteCombo <BOOL> - Updates the state of the can delete combo list\n    4: _updateCanRallyCombo <BOOL> - Updates the state of the can delete combo list\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // update just the unit list\n        [true] call KISKA_fnc_GCH_updateCurrentGroupSection;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCH_updateCurrentGroupSection\";\n\nprivate _gchIsOpen = [] call KISKA_fnc_GCH_isOpen;\nif !(_gchIsOpen) exitWith {};\n\nparams [\n    [\"_updateUnitList\",false,[true]],\n    [\"_updateLeaderIndicator\",false,[true]],\n    [\"_updateGroupId\",false,[true]],\n    [\"_updateCanDeleteCombo\",false,[true]],\n    [\"_updateCanRallyCombo\",false,[true]]\n];\n\nprivate _selectedGroup = [] call KISKA_fnc_GCH_getSelectedGroup;\nif (isNull _selectedGroup) exitWith {\n    private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n    lbClear _currentGroupListBox_ctrl;\n\n    private _leaderNameIndicator_ctrl = localNamespace getVariable \"KISKA_GCH_leaderNameIndicator_ctrl\";\n    _leaderNameIndicator_ctrl ctrlSetText \"\";\n\n    private _groupEditId_ctrl = localNamespace getVariable \"KISKA_GCH_groupIdEdit_ctrl\";\n    _groupEditId_ctrl ctrlSetText \"\";\n\n    private _canBeDeletedCombo_ctrl = localNamespace getVariable \"KISKA_GCH_canBeDeletedCombo_ctrl\";\n    lbClear _canBeDeletedCombo_ctrl;\n\n    private _canRallyCombo_ctrl = localNamespace getVariable [\"KISKA_GCH_canRallyCombo_ctrl\",controlNull];\n    lbClear _canRallyCombo_ctrl;\n};\n\n\nif (_updateUnitList) then {\n    private _currentGroupListBox_ctrl = localNamespace getVariable \"KISKA_GCH_currentGroupListBox_ctrl\";\n    lbClear _currentGroupListBox_ctrl;\n\n    private _groupUnits = units _selectedGroup;\n    if !(localNamespace getVariable \"KISKA_GCH_showAI\") then {\n        _groupUnits = _groupUnits select {isPlayer _x};\n    };\n\n    localNamespace setVariable [\"KISKA_GCH_groupUnitList\",_groupUnits];\n\n    if !(count _groupUnits > 0) exitWith {};\n\n\n    private [\"_index\",\"_team\"];\n    private _fn_setTeamColor = {\n        // don't change white team\n        if ((_team == \"MAIN\") OR (_team == \"\")) exitWith {};\n\n        if (_team == \"BLUE\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_BLUE];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_BLUE];\n        };\n        if (_team == \"GREEN\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_GREEN];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_GREEN];\n        };\n        if (_team == \"RED\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_RED];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_RED];\n        };\n        if (_team == \"YELLOW\") exitWith {\n            _currentGroupListBox_ctrl lbSetColor [_index,COLOR_YELLOW];\n            _currentGroupListBox_ctrl lbSetSelectColor [_index,COLOR_YELLOW];\n        };\n\n    };\n\n    private \"_name\";\n    {\n        _name = name _x; // if a logic is in a group, it does not have a name\n        if (_name isNotEqualTo \"\") then {\n            _index = _currentGroupListBox_ctrl lbAdd _name;\n            // store index value in array before we sort alphabetically\n            _currentGroupListBox_ctrl lbSetValue [_index,_forEachIndex];\n\n            // color AI Green\n            if !(isPlayer _x) then {\n                _currentGroupListBox_ctrl lbSetTooltip [_index,\"AI\"];\n            };\n\n            _team = assignedTeam _x;\n            call _fn_setTeamColor;\n        };\n\n    } forEach _groupUnits;\n\n    lbSort _currentGroupListBox_ctrl;\n};\n\n\nif (_updateLeaderIndicator) then {\n    private _leader = leader _selectedGroup;\n    private \"_leaderName\";\n    if (isNull _leader) then {\n        _leaderName = \"NO LEADER\";\n    } else {\n        _leaderName = name _leader;\n    };\n    private _leaderNameIndicator_ctrl = localNamespace getVariable \"KISKA_GCH_leaderNameIndicator_ctrl\";\n    _leaderNameIndicator_ctrl ctrlSetText _leaderName;\n};\n\n\nif (_updateGroupId) then {\n    private _groupId = groupId _selectedGroup;\n    private _groupEditId_ctrl = localNamespace getVariable \"KISKA_GCH_groupIdEdit_ctrl\";\n    _groupEditId_ctrl ctrlSetText _groupId;\n};\n\n\nif (_updateCanDeleteCombo) then {\n    private _canBeDeletedCombo_ctrl = localNamespace getVariable \"KISKA_GCH_canBeDeletedCombo_ctrl\";\n    private _canDeleteWhenEmpty = isGroupDeletedWhenEmpty _selectedGroup;\n    _canBeDeletedCombo_ctrl setVariable [\"KISKA_firstTimeComboChanged\",true];\n    _canBeDeletedCombo_ctrl lbSetCurSel ([0,1] select _canDeleteWhenEmpty);\n};\n\n\nif (_updateCanRallyCombo) then {\n    private _canRallyCombo_ctrl = localNamespace getVariable [\"KISKA_GCH_canRallyCombo_ctrl\",controlNull];\n    _canRallyCombo_ctrl ctrlEnable false;\n\n    [_selectedGroup,_canRallyCombo_ctrl] spawn {\n        params [\"_selectedGroup\",\"_canRallyCombo_ctrl\"];\n\n        private _groupCanRally = [\n            \"KISKA_canRally\",\n            _selectedGroup,\n            false,\n            2\n        ] call KISKA_fnc_getVariableTarget;\n        \n        // make sure the menu is still open as it takes time to get a message from the server\n        // also make sure the same group is selected in the list\n        private _menuIsOpen = !isNull (localNamespace getVariable [\"KISKA_GCH_display\",displayNull]);\n        private _didNotSelectAnotherGroup = _selectedGroup isEqualTo ([] call KISKA_fnc_GCH_getSelectedGroup);\n        if (_menuIsOpen AND    _didNotSelectAnotherGroup) then {\n            _canRallyCombo_ctrl ctrlEnable true;\n            _canRallyCombo_ctrl setVariable [\"KISKA_firstTimeComboChanged\",true];\n            _canRallyCombo_ctrl lbSetCurSel ([0,1] select _groupCanRally);\n        };\n    };\n};\n\n\nnil\n",
    "fileName": "fn_GCH_updateCurrentGroupSection.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_GCH_updateSideGroupsList\n\nDescription:\n    Updates the side's groups list for the GCH dialog.\n\nParameters:\n    0: _queryForGroups <BOOL> - Does a search for all groups that can appear in the \n        Group Changer need to be reconducted?\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [true] call KISKA_fnc_GCH_updateSideGroupsList;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_GCH_updateSideGroupsList\";\n\n#define PLAYER_GROUP_COLOR [0,1,0,0.6] // Green\n\nif !([] call KISKA_fnc_GCH_isOpen) exitWith {};\n\nparams [\n    [\"_queryForGroups\",true,[true]]\n];\n\nprivate _listControl = localNamespace getVariable [\"KISKA_GCH_sidesGroupListBox_ctrl\",controlNull];\nif (isNull _listControl) exitWith {\n    [\"_listControl is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nlbClear _listControl;\n\nprivate _sideGroups = localNamespace getVariable [\"KISKA_GCH_sideGroupsArray\",[]];\nif (_queryForGroups OR (_sideGroups isEqualTo [])) then {\n    private _playerSide = [] call KISKA_fnc_GCH_getPlayerSide;\n    _sideGroups = [_playerSide] call KISKA_fnc_GCH_getSideGroups;\n    localNamespace setVariable [\"KISKA_GCH_sideGroupsArray\",_sideGroups];\n};\n\nprivate _selectedGroup = call KISKA_fnc_GCH_getSelectedGroup;\nprivate _groupWasPreviouslySelected = !(isNull _selectedGroup);\n\nif (_sideGroups isEqualTo []) exitWith {\n    if (_groupWasPreviouslySelected) then {\n        call KISKA_fnc_GCH_updateCurrentGroupSection;\n    };\n\n    nil\n};\n\n// add to listbox\nprivate _selectedIndex = -1;\nprivate _playerGroup = group player;\n\n{\n    private _index = _listControl lbAdd (groupId _x);\n    // saving the index as a value so that it can be referenced against the _sideGroups array\n    _listControl lbSetValue [_index,_forEachIndex];\n\n    // highlight the player group\n    if (_x isEqualTo _playerGroup) then {\n        _listControl lbSetColor [_index, PLAYER_GROUP_COLOR];\n    };\n    \n    if (_groupWasPreviouslySelected AND (_x isEqualTo _selectedGroup)) then {\n        _selectedIndex = _forEachIndex;\n    };\n} forEach _sideGroups;\n\n\n// sort list alphabetically\nlbSort _listControl;\n\nprivate _selectedGroupNotInList = _selectedIndex < 0;\nif (_selectedGroupNotInList) exitWith {\n    if (_groupWasPreviouslySelected) then {\n        call KISKA_fnc_GCH_updateCurrentGroupSection;\n    };\n\n    nil\n};\n\nprivate _listSize = lbSize _listControl;\nfor \"_listBoxIndex\" from 0 to (_listSize - 1) do {\n    private _sideGroupsIndexOfLbEntry = _listControl lbValue _listBoxIndex;\n    \n    if (_sideGroupsIndexOfLbEntry isEqualTo _selectedIndex) then {\n        _listControl lbSetCurSel _listBoxIndex;\n        break;\n    };\n};\n\n\n\nnil\n",
    "fileName": "fn_GCH_updateSideGroupsList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_addGrammarXml\n\nDescription:\n    Adds an xml grammar file to the speech recognizer.\n\nParameters:\n    0: _name <STRING> - The name of the grammar to add\n    1: _xml <STRING> - The xml in string format\n\nReturns:\n    <BOOL> - true if will be added, false if cannot be added\n\nExamples:\n    (begin example)\n        [\"name\",loadFile \"myXmlFile.xml\"] call KISKA_fnc_SR_addGrammarXml;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_addGrammarXml\";\n\nparams [\n    [\"_name\",\"\",[\"\"]],\n    [\"_xml\",\"\",[\"\"]]\n];\n\nif (_name isEqualTo \"\") exitWith {\n    [\"Grammar must have a unique name!\",true] call KISKA_fnc_log;\n};\nif (_xml isEqualTo \"\") exitWith {\n    [\"Invalid xml passed!\",true] call KISKA_fnc_log;\n};\n\nprivate _return = [\"kiska_ext_sr_addgrammarxml\",_this] call KISKA_fnc_SR_callExtension;\n\n\nif (_return == \"true\") exitWith {true};\nfalse",
    "fileName": "fn_SR_addGrammarXml.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_callExtension\n\nDescription:\n    Calls to KISKA_speechRecognition(_x64).dll extension to run a function within\n     it.\n\nParameters:\n    0: _functionToRun <STRING> - The name of the function to run\n    1: _args <ARRAY> - Any arguments to pass to the extension\n\nReturns:\n    <STRING> - Whatever the extension returns\n\nExamples:\n    (begin example)\n        private _return = [\"kiska_ext_sr_startrecording\"] call KISKA_fnc_SR_callExtension;\n    (end)\n\n    (begin example)\n        private _return = [\n            \"kiska_ext_sr_addgrammarxml\",\n            [\"my grammar\",\"...gramarxml\"]\n        ] call KISKA_fnc_SR_callExtension;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_callExtension\";\n\nparams [\n    [\"_functionToRun\",\"\",[\"\"]],\n    [\"_args\",[],[[]]]\n];\n\nif (_functionToRun isEqualTo \"\") exitWith {\n    [\"Empty function call provided\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_args isEqualTo []) exitWith {\n    \"KISKA_SpeechRecognition\" callExtension _functionToRun;\n};\n\n\n\"KISKA_SpeechRecognition\" callExtension [_functionToRun,_args];\n",
    "fileName": "fn_SR_callExtension.sqf"
  },
  {
    "text": "params [\n    \"_name\", \n    \"_function\", \n    \"_data\"\n];\n\nhint (str _this);",
    "fileName": "fn_SR_callbackHandler.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_startRecording\n\nDescription:\n    Starts KISKA Speech recognition's extension's listening to the the user's\n     microphone to complete a speech recognition event.\n\nParameters:\n    0: _timelineId <NUMBER> - The id of the timeline to stop\n\nReturns:\n    <BOOL> - true if recording started, false if recording is currently happening\n\nExamples:\n    (begin example)\n        private _started = call KISKA_fnc_SR_startRecording;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_startRecording\";\n\nprivate _return = [\"kiska_ext_sr_startrecording\"] call KISKA_fnc_SR_callExtension;\n\nif (_return == \"true\") exitWith {true};\nfalse",
    "fileName": "fn_SR_startRecording.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_SR_stopRecording\n\nDescription:\n    Manually stops KISKA's Speech Recognition extension from listening to the user's\n     microphone.\n\n    NOTE: Every complete recognition of a phrase after beginning a recording will \n     automatically stop the extension from listening. The purpose of this function \n     is to manually tell the extension you want to stop recording during the act of \n     saying a phrase\n\nParameters:\n\nReturns:\n    <BOOL> - true if a recording was stopped, false if recording was not happening \n     when called\n\nExamples:\n    (begin example)\n        private _stopped = call KISKA_fnc_SR_stopRecording;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_SR_stopRecording\";\n\nprivate _return = [\"kiska_ext_sr_stoprecording\"] call KISKA_fnc_SR_callExtension;\n\nif (_return == \"true\") exitWith {true};\nfalse",
    "fileName": "fn_SR_stopRecording.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_addDiaryEntry\n\nDescription:\n    Creates a diary entry in the map for the player to open the support Manager\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_addDiaryEntry\";\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\"] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n[\n    [\n        \"Support Manager GUI\",\n        \"<execute expression='call KISKA_fnc_supportManager_openDialog;'>Open Support Manager</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_supportManager_addDiaryEntry.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_addToPool\n\nDescription:\n    Adds an entry into the local support manager pool.\n\nParameters:\n    0: _entryToAdd <STRING or ARRAY> - The support class or [support class,uses left]\n    1: _bypassChecks <BOOL> - Decides whether or not to perform checks on _entryToAdd for errors\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"someClass\"] call KISKA_fnc_supportManager_addToPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_addToPool\";\n\nif !(hasInterface) exitWith {};\n\nparams [\n    [\"_entryToAdd\",\"\",[\"\",[]]],\n    [\"_bypassChecks\",false]\n];\n\nprivate _exit = false;\nif !(_bypassChecks) then {\n    if (_entryToAdd isEqualTo \"\" OR {_entryToAdd isEqualTo []}) exitWith {\n        [\"_entryToAdd is empty!\",true] call KISKA_fnc_log;\n        _exit = true;\n    };\n\n    // verify class is defined\n    private \"_class\";\n    if (_entryToAdd isEqualType []) then {\n        _class = _entryToAdd select 0;\n    } else {\n        _class = _entryToAdd;\n    };\n\n    private _config = [[\"CfgCommunicationMenu\",_class]] call KISKA_fnc_findConfigAny;\n    if (isNull _config) exitWith {\n        [[_class,\" is not defined in any CfgCommunicationMenu!\"],true] call KISKA_fnc_log;\n        _exit = true;\n    };\n};\n\nif (_exit) exitWith {};\n\n\nprivate _supportArray = GET_SM_POOL;\n_supportArray pushBack _entryToAdd;\nif (isNil SM_POOL_VAR_STR) then {\n    missionNamespace setVariable [SM_POOL_VAR_STR,_supportArray];\n};\n\ncall KISKA_fnc_supportManager_updateCurrentList;\ncall KISKA_fnc_supportManager_updatePoolList;\n\n\nnil\n",
    "fileName": "fn_supportManager_addToPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_addToPool_global\n\nDescription:\n    Adds an entry into the global support manager pool.\n\n    THIS FUNCTION HAS A GLOBAL EFFECT\n\nParameters:\n    0: _entryToAdd <STRING or ARRAY> - The support class or [support class,uses left]\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"someClass\"] call KISKA_fnc_supportManager_addToPool_global;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_addToPool_global\";\n\nparams [\n    [\"_entryToAdd\",\"\",[\"\",[]]]\n];\n\nif (_entryToAdd isEqualTo \"\" OR {_entryToAdd isEqualTo []}) exitWith {\n    [\"_entryToAdd is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\n// verify class is defined\nprivate \"_class\";\nif (_entryToAdd isEqualType []) then {\n    _class = _entryToAdd select 0;\n} else {\n    _class = _entryToAdd;\n};\n\nprivate _config = [[\"CfgCommunicationMenu\",_class]] call KISKA_fnc_findConfigAny;\nif (isNull _config) exitWith {\n    [[_class,\" is not defined in any CfgCommunicationMenu!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n[_entryToAdd,true] remoteExec [\"KISKA_fnc_supportManager_addToPool\",0,true];\n\n\nnil\n",
    "fileName": "fn_supportManager_addToPool_global.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_onLoad\n\nDescription:\n    Sets up uiNamespace globals for and intializes the Support Manager GUI.\n\nParameters:\n    0: _display <DISPLAY> - The loaded display\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // called from config\n        [_this select 0] call KISKA_fnc_supportManager_onLoad;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_onLoad\";\ndisableSerialization;\n\n// check if player wants map to close when openning the manager\nif (missionNamespace getVariable [\"KISKA_CBA_supportManager_closeMap\",true]) then {\n    openMap false;\n};\n\nparams [\"_display\"];\n\n\nlocalNamespace setVariable [SM_DISPLAY_VAR_STR,_display];\n\n// initialize pool list entries\n_display setVariable [SM_POOL_LIST_CTRL_VAR_STR,_display displayCtrl SM_POOL_LISTBOX_IDC];\ncall KISKA_fnc_supportManager_updatePoolList;\n\n\n// intialize current supports list\n_display setVariable [SM_CURRENT_LIST_CTRL_VAR_STR,_display displayCtrl SM_CURRENT_LISTBOX_IDC];\ncall KISKA_fnc_supportManager_updateCurrentList;\n\n\n// give buttons click events\n(_display displayCtrl SM_TAKE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    call KISKA_fnc_supportManager_take_buttonClickEvent;\n}];\n(_display displayCtrl SM_STORE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    call KISKA_fnc_supportManager_store_buttonClickEvent;\n}];\n(_display displayCtrl SM_CLOSE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    GET_SM_DISPLAY closeDisplay 2;\n}];\n\n\nnil\n",
    "fileName": "fn_supportManager_onLoad.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_openDialog\n\nDescription:\n    Opens KISKA Support Manager dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_supportManager_openDialog;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ncreateDialog \"KISKA_supportManager_Dialog\";\n",
    "fileName": "fn_supportManager_openDialog.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_removeFromPool\n\nDescription:\n    Removes the provided index from the pool.\n\nParameters:\n    0: _index <NUMBER> - The selected index\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_supportManager_removeFromPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_removeFromPool\";\n\nif (!hasInterface) exitWith {};\n\nparams [\"_index\"];\n\nprivate _array = GET_SM_POOL;\nif (_array isNotEqualTo []) then {\n    _array deleteAt _index;\n};\n\ncall KISKA_fnc_supportManager_updateCurrentList;\ncall KISKA_fnc_supportManager_updatePoolList;\n\nnil\n",
    "fileName": "fn_supportManager_removeFromPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_removeFromPool_global\n\nDescription:\n    Removes the provided index from the support pool with GLOBAl EFFECT.\n\nParameters:\n    0: _index <NUMBER> - The selected index\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_supportManager_removeFromPool_global;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_removeFromPool_global\";\n\nparams [\"_index\"];\n\n[_index] remoteExec [\"KISKA_fnc_supportManager_removeFromPool\",0,true];\n\n\nnil\n",
    "fileName": "fn_supportManager_removeFromPool_global.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_store_buttonClickEvent\n\nDescription:\n    Activates when the take button is pressed and gives player the support.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_supportManager_store_buttonClickEvent;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_store_buttonClickEvent\";\n\ndisableSerialization;\n\nprivate _listControl = GET_SM_CURRENT_LIST_CTRL;\nprivate _selectedIndex = lbCurSel _listControl;\n\nif (_selectedIndex isEqualTo -1) exitWith {\n    [\"You must select an item to store\",4] call KISKA_fnc_errorNotification;\n};\n\nprivate _commMenuItems = player getVariable [\"BIS_fnc_addCommMenuItem_menu\",[]];\nprivate _selectedItemSupportId = _listControl lbValue _selectedIndex;\nprivate _indexToRemove = _commMenuItems findIf {\n    (_x select 0) isEqualTo _selectedItemSupportId\n};\n\n\nif (_indexToRemove isEqualTo -1) exitWith {\n    [\n        [\n            \"Could not find support to remove with id: \",\n            _selectedItemSupportId,\n            \" -- BIS_fnc_addCommMenuItem_menu is: \",\n            _commMenuItems\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\nprivate _kiskaSupportInfo = KISKA_playersSupportMap deleteAt _selectedItemSupportId;\n// if support number-of-uses is default amount\nif ((_kiskaSupportInfo select 1) isEqualTo -1) then {\n    // then change to the shorthand syntax for use with KISKA_fnc_supportManager_addToPool_global\n    // so that it has the default amount of uses\n    _kiskaSupportInfo = _kiskaSupportInfo select 0;\n};\n\n[_kiskaSupportInfo] call KISKA_fnc_supportManager_addToPool_global;\n[player,_selectedItemSupportId] call BIS_fnc_removeCommMenuItem;\n\n\nnil\n",
    "fileName": "fn_supportManager_store_buttonClickEvent.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_take_buttonClickEvent\n\nDescription:\n    Activates when the take button is pressed and gives player the support.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_supportManager_take_buttonClickEvent;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_take_buttonClickEvent\";\n\n#define DEFAULT_CANT_TAKE_MESSAGE \"You do not have permission for this support\"\n\n// support menu only supports a max of ten at a time\nprivate _maxAllowedSupports = missionNamespace getVariable [\"KISKA_CBA_supportManager_maxSupports\",10];\nprivate _hasMaxSupports = count (player getVariable [\"BIS_fnc_addCommMenuItem_menu\",[]]) isEqualTo _maxAllowedSupports;\nif (_hasMaxSupports) then { \n    [\"You already have the max supports possible\"] call KISKA_fnc_errorNotification;\n\n} else {\n    private _selectedIndex = lbCurSel (GET_SM_POOL_LIST_CTRL);\n    if (_selectedIndex isNotEqualTo -1) exitWith {};\n\n    private \"_supportClass\";\n    private _useCount = -1;\n    private _support = SM_POOL_GVAR select _selectedIndex;\n\n    if (_support isEqualType []) then {\n        // adding number of allowed uses\n        _supportClass = _support select 0;\n        _useCount = _support select 1;\n\n    } else {\n        _supportClass = _support;\n\n    };\n\n    // searching any config as some might want to add supports in an addon vs missionConfigFile\n    private _config = [[\"CfgCommunicationMenu\",_supportClass]] call KISKA_fnc_findConfigAny;\n    private _condition = getText(_config >> \"managerCondition\");\n\n    // add to player and update list\n    if ((_condition isEqualTo \"\") OR { [_supportClass] call (compile _condition) }) then {\n        [player,_supportClass,\"\",_useCount] call KISKA_fnc_addCommMenuItem;\n        [_selectedIndex] call KISKA_fnc_supportManager_removeFromPool_global;\n\n    } else {\n        private _conditionMessage = getText(_config >> \"conditionMessage\");\n        if (_conditionMessage isEqualTo \"\") then {\n            _conditionMessage = DEFAULT_CANT_TAKE_MESSAGE;\n        };\n\n        [_conditionMessage] call KISKA_fnc_errorNotification;\n\n    };\n};\n\n\nnil\n",
    "fileName": "fn_supportManager_take_buttonClickEvent.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_updateCurrentList\n\nDescription:\n    Acts as an event that will update the current supports list of a player in\n     the GUI.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_supportManager_updateCurrentList;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_updateCurrentList\";\n\nif !(hasInterface) exitWith {};\n\ndisableSerialization;\n\nprivate _listControl = GET_SM_CURRENT_LIST_CTRL;\nif (isNull _listControl) exitWith {};\n\n\nlbClear _listControl;\nif (!(isNil \"KISKA_playersSupportMap\") AND {count KISKA_playersSupportMap > 0}) then {\n\n    private [\"_config\",\"_text\",\"_class\",\"_toolTip\",\"_path\",\"_icon\",\"_usesLeft\"];\n    private _usedIconColor = missionNamespace getVariable [\"KISKA_CBA_supportManager_usedIconColor\",[0.75,0,0,1]];\n    KISKA_playersSupportMap apply {\n\n        _class = _y select 0;\n        _config = [[\"cfgCommunicationMenu\",_class]] call KISKA_fnc_findConfigAny;\n        _toolTip = getText(_config >> \"tooltip\");\n        _text = getText(_config >> \"text\");\n        _icon = getText(_config >> \"icon\");\n\n        _path = _listControl lbAdd _text;\n        // save comm menu id as value\n        _listControl lbSetValue [_path, _x];\n        _listControl lbSetTooltip [_path,_toolTip];\n        _listControl lbSetPicture [_path,_icon];\n\n        // if support number of uses is default amount\n        _usesLeft = _y select 1;\n        if (_usesLeft isNotEqualTo -1) then {\n            _listControl lbSetPictureColor [_path,_usedIconColor];\n            _listControl lbSetPictureColorSelected [_path,_usedIconColor];\n        };\n\n    };\n\n    lbSortByValue _listControl;\n};\n\n\nnil\n",
    "fileName": "fn_supportManager_updateCurrentList.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportManager_updatePoolList\n\nDescription:\n    Acts as an event that will update the available supports pool list in\n     the Support Manager GUI.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_supportManager_updatePoolList;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportManager_updatePoolList\";\n\nif !(hasInterface) exitWith {};\n\ndisableSerialization;\n\nprivate _poolControl = GET_SM_POOL_LIST_CTRL;\nif (isNull _poolControl) exitWith {};\n\nif (isNil SM_POOL_VAR_STR) then {\n    missionNamespace setVariable [SM_POOL_VAR_STR,[]];\n};\nif (SM_POOL_GVAR isEqualTo []) exitWith {\n    lbClear _poolControl;\n    _poolControl setVariable [SM_DISPLAYED_POOL_VAR_STR,[]];\n};\n\n\n\nprivate _configHash = createHashMap;\nprivate [\"_displayText\",\"_comparedIndex\",\"_config\",\"_comMenuClass\",\"_path\",\"_toolTip\",\"_icon\"];\n/* ----------------------------------------------------------------------------\n    _fn_setText\n---------------------------------------------------------------------------- */\nprivate _fn_setText = {\n    if (_comMenuClass in _configHash) then {\n        _config = _configHash get _comMenuClass;\n    } else {\n        _config = [[\"CfgCommunicationMenu\",_comMenuClass]] call KISKA_fnc_findConfigAny;\n        _configHash set [_comMenuClass,_config];\n    };\n\n    _icon = getText(_config >> \"icon\");\n    _displayText = getText(_config >> \"text\");\n    _toolTip = getText(_config >> \"tooltip\");\n};\n\n/* ----------------------------------------------------------------------------\n    _fn_adjustCurrentEntry\n---------------------------------------------------------------------------- */\nprivate _usedIconColor = missionNamespace getVariable [\"KISKA_CBA_supportManager_usedIconColor\",[0.75,0,0,1]];\nprivate _fn_adjustCurrentEntry = {\n    // entries that are arrays will be [\"classname\",NumberOfUsesLeft]\n    // some supports have multiple uses in them, this keeps track of that if someone stores a\n    // multi-use one after having already used it.\n    if (_comMenuClass isEqualType []) then {\n        _poolControl lbSetValue [_path,(_comMenuClass select 1)];\n        // if support was used\n        _poolControl lbSetPictureColor [_path,_usedIconColor];\n        _poolControl lbSetPictureColorSelected [_path,_usedIconColor];\n        _comMenuClass = (_comMenuClass select 0);\n    } else {\n        // set to default value of zero if entry was not already there\n        if ((_poolControl lbValue _path) isNotEqualTo 0) then {\n            _poolControl lbSetValue [_path,0];\n        };\n    };\n\n    _poolControl lbSetData [_path,_comMenuClass];\n    call _fn_setText;\n    _poolControl lbSetTooltip [_path,_toolTip];\n    _poolControl lbSetText [_path,_displayText];\n    _poolControl lbSetPicture [_path,_icon];\n\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Change Entries\n---------------------------------------------------------------------------- */\nprivate _supportPool_displayed = GET_SM_DISPLAYED_POOL;\n// subtracting 1 from this to get indexes\nprivate _countOfDisplayed = (count _supportPool_displayed) - 1;\n{\n    _comMenuClass = _x;\n    // instead of clearing the list, we will change entries up until there are more entries in the array then currently in the list\n    if (_countOfDisplayed >= _forEachIndex) then {\n        // check if entry at index is different and therefore needs to be changed\n        _comparedIndex = _supportPool_displayed select _forEachIndex;\n        if (_comMenuClass isNotEqualTo _comparedIndex) then {\n            _path = _forEachIndex;\n            call _fn_adjustCurrentEntry;\n        };\n    } else {\n        _path = _poolControl lbAdd \"\";\n        call _fn_adjustCurrentEntry;\n    };\n\n} forEach SM_POOL_GVAR;\n\n// delete overflow indexes that are no longer accurate\nprivate _countOfCurrent = (count SM_POOL_GVAR) - 1;\nif (_countOfDisplayed > _countOfCurrent) then {\n    private _indexToDelete = _countOfCurrent + 1;\n    for \"_i\" from _countOfCurrent to _countOfDisplayed do {\n        // deleting the same index because the tree will move down with each deletetion\n        _poolControl lbDelete _indexToDelete;\n    };\n};\n\n_poolControl setVariable [SM_DISPLAYED_POOL_VAR_STR,+SM_POOL_GVAR];\n",
    "fileName": "fn_supportManager_updatePoolList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_addDiaryEntry\n\nDescription:\n    Creates a diary entry in the map for the player to open the trait Manager.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_addDiaryEntry\";\n\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\"] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_traitManager_addDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n[\n    [\n        \"Trait Manager GUI\",\n        \"<execute expression='call KISKA_fnc_traitManager_openDialog;'>Open Trait Manager GUI</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_traitManager_addDiaryEntry.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_addToPool\n\nDescription:\n    Adds an entry into the local trait manager pool.\n\nParameters:\n    0: _entryToAdd <STRING> - The trait to add\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"medic\"] call KISKA_fnc_traitManager_addToPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_addToPool\";\n\nif !(hasInterface) exitWith {};\n\nparams [\n    [\"_entryToAdd\",\"\",[\"\"]]\n];\n\nif (_entryToAdd isEqualTo \"\") exitWith {\n    [\"_entryToAdd is empty string!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _traitPoolArray = GET_TM_POOL;\n_traitPoolArray pushBack _entryToAdd;\nif (isNil TM_POOL_VAR_STR) then {\n    missionNamespace setVariable [TM_POOL_VAR_STR,_traitPoolArray];\n};\n\ncall KISKA_fnc_traitManager_updateCurrentList;\ncall KISKA_fnc_traitManager_updatePoolList;\n\n\nnil\n",
    "fileName": "fn_traitManager_addToPool.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_addToPool_global\n\nDescription:\n    Adds an entry into the global trait manager pool.\n\nParameters:\n    0: _entryToAdd <STRING> - The trait to add\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"medic\"] call KISKA_fnc_traitManager_addToPool_global;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_traitManager_addToPool_global\";\n\nparams [\n    [\"_entryToAdd\",\"\",[\"\"]]\n];\n\n_entryToAdd = toUpperANSI _entryToAdd;\n\nif (_entryToAdd isEqualTo \"\" OR {_entryToAdd in NUMBER_TRAITS}) exitWith {\n    [[_entryToAdd,\" can't be added\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n[_entryToAdd] remoteExec [\"KISKA_fnc_traitManager_addToPool\",0,true];\n\n\nnil\n",
    "fileName": "fn_traitManager_addToPool_global.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_onLoad\n\nDescription:\n    Sets up uiNamespace globals for and intializes the Trait Manager GUI.\n\nParameters:\n    0: _display <DISPLAY> - The loaded display\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // called from config\n        [_this select 0] call KISKA_fnc_traitManager_onLoad;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_onLoad\";\ndisableSerialization;\n\n// check if player wants map to close when openning the manager\nif (missionNamespace getVariable [\"KISKA_CBA_traitManager_closeMap\",true]) then {\n    openMap false;\n};\n\nparams [\"_display\"];\n\n\nlocalNamespace setVariable [TM_DISPLAY_VAR_STR,_display];\n\n// initialize pool list entries\n_display setVariable [TM_POOL_LIST_CTRL_VAR_STR,_display displayCtrl TM_POOL_LISTBOX_IDC];\ncall KISKA_fnc_traitManager_updatePoolList;\n\n\n// intialize current traits list\n_display setVariable [TM_CURRENT_LIST_CTRL_VAR_STR,_display displayCtrl TM_CURRENT_LISTBOX_IDC];\ncall KISKA_fnc_traitManager_updateCurrentList;\n\n\n// give buttons click events\n(_display displayCtrl TM_TAKE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    call KISKA_fnc_traitManager_take_buttonClickEvent;\n}];\n(_display displayCtrl TM_STORE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    call KISKA_fnc_traitManager_store_buttonClickEvent;\n}];\n(_display displayCtrl TM_CLOSE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    GET_TM_DISPLAY closeDisplay 2;\n}];\n\n\nnil\n",
    "fileName": "fn_traitManager_onLoad.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_onLoad_traitPool\n\nDescription:\n    Begins the loop that syncs across the network and populates the pool list.\n\nParameters:\n    0: _display <DISPLAY> - The loaded display of the trait manager\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // called from config\n        [_display] spawn KISKA_fnc_traitManager_onLoad_traitPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_traitManager_onLoad_traitPool\";\n\n#define REFRESH_SPEED (missionNamespace getVariable [\"KISKA_CBA_traitManager_updateFreq\",0.5])\n\nif (!canSuspend) exitWith {\n    _this spawn KISKA_fnc_traitManager_onLoad_traitPool;\n};\n\nparams [\"_display\"];\n\nprivate _poolControl = uiNamespace getVariable \"KISKA_TM_poolListBox_ctrl\";\n\n// init to empty array if undefined to allow comparisons\nif (isNil TM_POOL_VAR_STR) then {\n    missionNamespace setVariable [TM_POOL_VAR_STR,[]];\n};\n\nprivate _fn_updateTraitPoolList = {\n\n    if (POOL_GVAR isEqualTo []) exitWith {\n        lbClear _poolControl;\n    };\n\n    // subtracting 1 from these to get indexes\n    private _countOfDisplayed = (count _traitPool_displayed) - 1;\n    private _countOfCurrent = (count TM_POOL_GVAR) - 1;\n\n    private \"_trait\";\n    {\n        _trait = toUpperANSI _x;\n        // instead of clearing the list, we will change entries up until there are more entries in the array then currently in the list\n        if (_countOfDisplayed >= _forEachIndex) then {\n            // check if entry at index is different and therefore needs to be changed\n            _comparedIndex = _traitPool_displayed select _forEachIndex;\n            if (_trait != _comparedIndex) then {\n                _poolControl lbSetText [_forEachIndex, _trait];\n            };\n        } else {\n            _poolControl lbAdd _trait;\n        };\n    } forEach TM_POOL_GVAR;\n\n    // delete overflow indexes that are no longer accurate\n    private _countOfCurrent = (count TM_POOL_GVAR) - 1;\n    if (_countOfDisplayed > _countOfCurrent) then {\n        private _indexToDelete = _countOfCurrent + 1;\n        for \"_i\" from _countOfCurrent to _countOfDisplayed do {\n            // deleting the same index because the tree will move down with each deletetion\n            _poolControl lbDelete _indexToDelete;\n        };\n    };\n};\n\nprivate _traitPool_displayed = [];\nwhile {sleep REFRESH_SPEED; !(isNull _display)} do {\n\n    // support pool check\n    if (_traitPool_displayed isNotEqualTo TM_POOL_GVAR) then {\n        call _fn_updateTraitPoolList;\n        _traitPool_displayed = +TM_POOL_GVAR;\n    };\n};\n\n\nnil\n",
    "fileName": "fn_traitManager_onLoad_traitPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_openDialog\n\nDescription:\n    Opens KISKA Trait Manager dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_traitManager_openDialog;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\ncreateDialog \"KISKA_traitManager_Dialog\";\n",
    "fileName": "fn_traitManager_openDialog.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_removeFromPool\n\nDescription:\n    Removes the provided index from the pool.\n\nParameters:\n    0: _index <NUMBER> - The selected index\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_traitManager_removeFromPool;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_removeFromPool\";\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_index\",-1,[123]]\n];\n\nprivate _array = GET_TM_POOL;\nif (_array isNotEqualTo []) then {\n    _array deleteAt _index;\n};\n\ncall KISKA_fnc_traitManager_updateCurrentList;\ncall KISKA_fnc_traitManager_updatePoolList;\n\nnil\n",
    "fileName": "fn_traitManager_removeFromPool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_removeFromPool_global\n\nDescription:\n    Removes the provided index from the trait pool with GLOBAl EFFECT.\n\nParameters:\n    0: _index <NUMBER> - The selected index\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_traitManager_removeFromPool_global;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_removeFromPool_global\";\n\nparams [\"_index\"];\n\n[_index] remoteExec [\"KISKA_fnc_traitManager_removeFromPool\",0,true];\n\n\nnil\n",
    "fileName": "fn_traitManager_removeFromPool_global.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_store_buttonClickEvent\n\nDescription:\n    Activates when the take button is pressed and gives player the support.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_traitManager_store_buttonClickEvent;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_traitManager_store_buttonClickEvent\";\n\nprivate _currentListbox_ctrl = GET_TM_CURRENT_LIST_CTRL;\nprivate _selectedIndex = lbCurSel _currentListbox_ctrl;\n\nif (_selectedIndex isNotEqualTo -1) then {\n    private _trait = _currentListbox_ctrl lbText _selectedIndex;\n    private _isCustomTrait = !(_trait in RESERVED_TRAITS);\n    player setUnitTrait [_trait,false,_isCustomTrait];\n\n    [_trait] call KISKA_fnc_traitManager_addToPool_global;\n};\n",
    "fileName": "fn_traitManager_store_buttonClickEvent.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_take_buttonClickEvent\n\nDescription:\n    Activates when the take button is pressed and gives player the trait\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_traitManager_take_buttonClickEvent;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_traitManager_take_buttonClickEvent\";\n\n#define DEFAULT_ERROR_MESSAGE \"You do not have permission for this trait\"\n\nprivate _selectedIndex = lbCurSel (GET_TM_POOL_LIST_CTRL);\nif (_selectedIndex isNotEqualTo -1) then {\n\n    private _trait = toUpperANSI (TM_POOL_GVAR select _selectedIndex);\n    if !(player getUnitTrait _trait) then {\n        // check condition to take\n        private _config = [[\"KISKA_cfgTraits\",_trait]] call KISKA_fnc_findConfigAny;\n        private _condition = \"\";\n        if !(isNull _config) then {\n           _condition = getText(_config >> \"managerCondition\");\n        };\n\n        // add to player and update list\n        if (_condition isEqualTo \"\" OR {[_trait] call (compile _condition)}) then {\n            private _isCustomTrait = !(_trait in RESERVED_TRAITS);\n            player setUnitTrait [_trait,true,_isCustomTrait];\n\n            [_selectedIndex] call KISKA_fnc_traitManager_removeFromPool_global;\n\n        } else {\n            private _message = getText(_config >> \"errorMessage\");\n            if (_message isEqualTo \"\") then {\n                _message = DEFAULT_ERROR_MESSAGE;\n            };\n\n            [_message] call KISKA_fnc_errorNotification;\n\n        };\n        \n    } else {\n        [\"You already have this trait\"] call KISKA_fnc_errorNotification;\n\n    };\n};\n\n\nnil\n",
    "fileName": "fn_traitManager_take_buttonClickEvent.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traitManager_updateCurrentList\n\nDescription:\n    Acts as an event that will update the current trait list of a player in\n     the GUI.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_traitManager_updateCurrentList;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\ndisableSerialization;\nscriptName \"KISKA_fnc_traitManager_updateCurrentList\";\n\n// check if menu is open\nprivate _listControl = GET_TM_CURRENT_LIST_CTRL;\nif (isNull _listControl) exitWith {};\n\nlbClear _listControl;\n\nprivate [\"_trait\",\"_traitValue\"];\n(getAllUnitTraits player) apply {\n    _trait = toUpperANSI (_x select 0);\n    _traitValue = _x select 1;\n\n    // don't add Coefficient traits to the list\n    if !(_traitValue isEqualType 123) then {\n        // default traits are the only bools and if they are true the player has them\\\n        // custom values are strings\n        private _isDefaultTrait = _traitValue isEqualType (true);\n        if (!_isDefaultTrait OR {_isDefaultTrait AND _traitValue}) then {\n            _listControl lbAdd _trait;\n        };\n    };\n};\n\n\nnil\n",
    "fileName": "fn_traitManager_updateCurrentList.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Trait Manager Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_traittManager_updatePoolList\n\nDescription:\n    Acts as an event that will update the available traits pool list in\n     the Trait Manager GUI.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_traitManager_updatePoolList;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_traitManager_updatePoolList\";\n\nif !(hasInterface) exitWith {};\n\ndisableSerialization;\n\n// check if menu is open\nprivate _poolControl = GET_TM_POOL_LIST_CTRL;\nif (isNull _poolControl) exitWith {\n    [\"_poolControl is null!\"] call KISKA_fnc_log;\n    nil\n};\n\n// init to empty array if undefined to allow comparisons\nif (isNil TM_POOL_VAR_STR) then {\n    missionNamespace setVariable [TM_POOL_VAR_STR,[]];\n};\nif (TM_POOL_GVAR isEqualTo []) exitWith {\n    lbClear _poolControl;\n    _poolControl setVariable [TM_DISPLAYED_POOL_VAR_STR,[]];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Change Entries\n---------------------------------------------------------------------------- */\nprivate _traitPool_displayed = GET_TM_DISPLAYED_POOL;\n\n// subtracting 1 from this to get indexes\nprivate _countOfDisplayed = (count _traitPool_displayed) - 1;\nprivate [\"_trait\",\"_comparedIndex\"];\n{\n    _trait = toUpperANSI _x;\n    // instead of clearing the list, we will change entries up until there are more entries in the array then currently in the list\n    if (_countOfDisplayed >= _forEachIndex) then {\n        // check if entry at index is different and therefore needs to be changed\n        _comparedIndex = _traitPool_displayed select _forEachIndex;\n        if (_trait != _comparedIndex) then {\n            _poolControl lbSetText [_forEachIndex, _trait];\n        };\n\n    } else {\n        _poolControl lbAdd _trait;\n    };\n\n} forEach TM_POOL_GVAR;\n\n\n// delete overflow indexes that are no longer accurate\nprivate _countOfCurrent = (count TM_POOL_GVAR) - 1;\nif (_countOfDisplayed > _countOfCurrent) then {\n    private _indexToDelete = _countOfCurrent + 1;\n    for \"_i\" from _countOfCurrent to _countOfDisplayed do {\n        // deleting the same index because the tree will move down with each deletetion\n        _poolControl lbDelete _indexToDelete;\n    };\n};\n// creating a copy of TM_POOL_GVAR so that when changes are made to it, the displayed array will not have those changes and therefore we can compare\n_poolControl setVariable [TM_DISPLAYED_POOL_VAR_STR,+TM_POOL_GVAR];\n",
    "fileName": "fn_traitManager_updatePoolList.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_addOpenGuiDiaryEntry\n\nDescription:\n    Creates a diary entry to open the VDL dialog.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_addOpenGuiDiaryEntry\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_VDL_addOpenGuiDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n[\n    [\n        \"View Distance Limiter\",\n        \"<execute expression='call KISKA_fnc_VDL_openDialog;'>View Distance Limiter</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_VDL_addOpenGuiDiaryEntry.sqf"
  },
  {
    "text": "#include \"..\\Headers\\View Distance Limiter Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_controlsGroup_onLoad\n\nDescription:\n    Acts as the onload event for the KISKA View Distance Limiter Dialog\n\nParameters:\n    0: _controlsGroup <CONTROL> - The controls group for the particular setting\n    1: _varName <STRING> - The name of the profileNamespace variable in which this\n        setting will be saved when changed\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [controlsGroup,\"someName\"] call KISKA_fnc_VDL_controlsGroup_onLoad;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_controlsGroup_onLoad\";\n\nif (!hasInterface) exitWith {};\n\ndisableSerialization;\n\nparams [\"_controlsGroup\",\"_varName\"];\n\n\n_controlsGroup setVariable [CTRL_GRP_VAR_STR,_varName];\n\n/* ----------------------------------------------------------------------------\n    Slider\n---------------------------------------------------------------------------- */\nprivate _slider_ctrl = _controlsGroup controlsGroupCtrl SLIDER_IDC;\n_controlsGroup setVariable [CTRL_GRP_SLIDER_CTRL_VAR_STR,_slider_ctrl];\n_slider_ctrl ctrlAddEventHandler [\"SliderPosChanged\",{\n    params [\"_slider_ctrl\", \"_newValue\"];\n\n    private _settingControlGroup = ctrlParentControlsGroup _slider_ctrl;\n    private _editBox_ctrl = _settingControlGroup getVariable CTRL_GRP_EDIT_CTRL_VAR_STR;\n\n    private _strValue = str _newValue;\n    _editBox_ctrl ctrlSetText _strValue;\n    _slider_ctrl ctrlSetTooltip _strValue;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Set Button\n---------------------------------------------------------------------------- */\nprivate _setButton_ctrl = _controlsGroup controlsGroupCtrl BUTTON_IDC;\n//_controlsGroup setVariable [CTRL_GRP_BUTTON_CTRL_VAR_STR,_setButton_ctrl];\n_setButton_ctrl ctrlAddEventHandler [\"ButtonClick\",{\n    params [\"_setButton_ctrl\"];\n\n    private _settingControlGroup = ctrlParentControlsGroup _setButton_ctrl;\n    private _slider_ctrl = _settingControlGroup getVariable [CTRL_GRP_SLIDER_CTRL_VAR_STR,controlNull];\n\n    private _varName = _settingControlGroup getVariable CTRL_GRP_VAR_STR;\n    private _value = sliderPosition _slider_ctrl;\n\n    profileNamespace setVariable [_varName,_value];\n    missionNamespace setVariable [_varName,_value];\n\n    saveProfileNamespace;\n    [\"Saved changes\"] call KISKA_fnc_notification;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Edit Box\n---------------------------------------------------------------------------- */\nprivate _editBox_ctrl = _controlsGroup controlsGroupCtrl EDIT_IDC;\n_controlsGroup setVariable [CTRL_GRP_EDIT_CTRL_VAR_STR,_editBox_ctrl];\n_editBox_ctrl ctrlAddEventHandler [\"KeyUp\",{\n    params [\"_editBox_ctrl\"];\n\n    private _text = ctrlText _editBox_ctrl;\n    private _number = _text call BIS_fnc_parseNumberSafe;\n    // if we don't check that an actual number is present, we can't start with a blank edit box if say doing negative numbers\n    if (str _number == _text) then {\n        private _settingControlGroup = ctrlParentControlsGroup _editBox_ctrl;\n        private _slider_ctrl = _settingControlGroup getVariable CTRL_GRP_SLIDER_CTRL_VAR_STR;\n\n        private _sliderRange = sliderRange _slider_ctrl;\n        private _sliderMin = _sliderRange select 0;\n        private _sliderMax = _sliderRange select 1;\n        // check to see if entered number fits inside slider range\n        if ((_number >= _sliderMin) AND {_number <= _sliderMax}) then {\n            _slider_ctrl ctrlSetTooltip (str _number);\n            _slider_ctrl sliderSetPosition _number;\n        };\n    };\n}];\n\n\n\nprivate _defaultValue = getNumber(configFile >> \"KISKA_viewDistanceLimiter_dialog\" >> \"controls\" >> ctrlClassName _controlsGroup >> \"controls\" >> \"settingSlider\" >> \"sliderPosition\");\nprivate _profileValue = profileNamespace getVariable [_varName,_defaultValue];\nprivate _currentValue = missionNamespace getVariable [_varName,_profileValue];\n\n_editBox_ctrl ctrlSetText (str _currentValue);\n_slider_ctrl sliderSetPosition _currentValue;\n\n\nnil\n",
    "fileName": "fn_VDL_controlsGroup_onLoad.sqf"
  },
  {
    "text": "#include \"..\\Headers\\View Distance Limiter Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_onLoad\n\nDescription:\n    Acts as the onload event for the KISKA View Distance Limiter Dialog\n\nParameters:\n    0: _display <DISPLAY> - The display of the dialog\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [display] call KISKA_fnc_VDL_onLoad;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_onLoad\";\n\nif (!hasInterface) exitWith {};\n\ndisableSerialization;\n\nparams [\"_display\"];\n\n\n/* ----------------------------------------------------------------------------\n    unload event\n---------------------------------------------------------------------------- */\nlocalNamespace setVariable [VDL_DISPLAY_VAR_STR,_display];\n_display displayAddEventHandler [\"Unload\", {\n    //params [\"_display\"];\n    localNamespace setVariable [VDL_DISPLAY_VAR_STR,nil];\n}];\n\n\n/* ----------------------------------------------------------------------------\n    System On Check box\n---------------------------------------------------------------------------- */\nprivate _systemOnCheckox = _display displayCtrl VDL_SYSTEM_ON_CHECKBOX_IDC;\nif (GET_VDL_GLOBAL_IS_RUNNING) then {\n    _systemOnCheckox cbSetChecked true;\n};\n\n_systemOnCheckox ctrlAddEventHandler [\"CheckedChanged\",{\n    params [\"_control\", \"_checked\"];\n    _checked = [false,true] select _checked;\n\n    missionNamespace setVariable [VDL_GLOBAL_RUN_STR,_checked];\n    if (_checked AND !(GET_VDL_GLOBAL_IS_RUNNING)) then {\n        #define GET_SLIDER_POS_FOR_CTRLGRP(idc) sliderPosition (((ctrlParent _control) displayCtrl idc) controlsGroupCtrl SLIDER_IDC)\n        [\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_TARGET_FPS_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_CHECK_FREQ_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_MIN_OBJECT_DIST_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_MAX_OBJECT_DIST_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_INCRIMENT_CTRL_GRP_IDC ),\n            GET_SLIDER_POS_FOR_CTRLGRP( VDL_TERRAIN_DIST_CTRL_GRP_IDC )\n        ] spawn KISKA_fnc_viewDistanceLimiter;\n    };\n\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Tie View Distance Check box\n---------------------------------------------------------------------------- */\nprivate _tieViewDist_checkBox = _display displayCtrl VDL_TIED_DISTANCE_CHECKBOX_IDC;\nif (GET_VDL_GLOBAL_TIED_VIEW_DIST_VAR) then {\n    _tieViewDist_checkBox cbSetChecked true;\n};\n\n_tieViewDist_checkBox ctrlAddEventHandler [\"CheckedChanged\",{\n    params [\"\", \"_checked\"];\n    _checked = [false,true] select _checked;\n    missionNamespace setVariable [VDL_GLOBAL_TIED_VIEW_DIST_VAR_STR,_checked];\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Close button\n---------------------------------------------------------------------------- */\n(_display displayCtrl VDL_CLOSE_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    (GET_VDL_DISPLAY) closeDisplay 2;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Set all button\n---------------------------------------------------------------------------- */\n(_display displayCtrl VDL_SET_ALL_BUTTON_IDC) ctrlAddEventHandler [\"ButtonClick\",{\n    params [\"_setButton_ctrl\"];\n\n    private _display = localNamespace getVariable [VDL_DISPLAY_VAR_STR,displayNull];\n    (_display getVariable VDL_CONTROL_GRPS_VAR_STR) apply {\n        private _slider_ctrl = _x getVariable [CTRL_GRP_SLIDER_CTRL_VAR_STR,controlNull];\n\n        private _varName = _x getVariable [CTRL_GRP_VAR_STR,\"\"];\n        private _value = sliderPosition _slider_ctrl;\n        profileNamespace setVariable [_varName,_value];\n        missionNamespace setVariable [_varName,_value];\n    };\n\n    saveProfileNamespace;\n    [\"Saved All changes\"] call KISKA_fnc_notification;\n}];\n\n\n/* ----------------------------------------------------------------------------\n    Control groups\n---------------------------------------------------------------------------- */\nprivate _controlGroups = [];\n[\n    [VDL_TARGET_FPS_CTRL_GRP_IDC, VDL_FPS_VAR_STR],\n    [VDL_MIN_OBJECT_DIST_CTRL_GRP_IDC, VDL_MIN_DIST_VAR_STR],\n    [VDL_MAX_OBJECT_DIST_CTRL_GRP_IDC, VDL_MAX_DIST_VAR_STR],\n    [VDL_TERRAIN_DIST_CTRL_GRP_IDC, VDL_VIEW_DIST_VAR_STR],\n    [VDL_CHECK_FREQ_CTRL_GRP_IDC, VDL_FREQUENCY_VAR_STR],\n    [VDL_INCRIMENT_CTRL_GRP_IDC, VDL_INCREMENT_VAR_STR]\n] apply {\n    private _control = _display displayCtrl (_x select 0);\n    [_control,_x select 1] call KISKA_fnc_VDL_controlsGroup_onLoad;\n    _controlGroups pushBack _control;\n};\n\n_display setVariable [VDL_CONTROL_GRPS_VAR_STR,_controlGroups];\n\n\nnil\n",
    "fileName": "fn_VDL_onLoad.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_VDL_openDialog\n\nDescription:\n    Opens the GUI for the VDL system.\n\nParameters:\n    NONE\n\nReturns:\n    BOOL\n\nExamples:\n    (begin example)\n        call KISKA_fnc_VDL_openDialog;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_VDL_openDialog\";\n\nif (!hasInterface) exitWith {false};\n\nif !(missionNamespace getVariable [\"KISKA_CBA_VDL_available\",true]) exitWith {\n    [\"The View Distance Limiter Dialog is not available\"] call KISKA_fnc_notification;\n    false\n};\n\nif (missionNamespace getVariable [\"KISKA_CBA_VDL_closeMap\",true]) then {\n    openMap false;\n};\n\n\ncreateDialog \"KISKA_viewDistanceLimiter_dialog\";\n",
    "fileName": "fn_VDL_openDialog.sqf"
  },
  {
    "text": "#include \"..\\Headers\\View Distance Limiter Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_viewDistanceLimiter\n\nDescription:\n    Starts a looping function for limiting a player's viewDistance.\n    Loop can be stopped by setting mission variable \"KISKA_VDL_run\" to false.\n    All other values have global vars that can be edited while it is in use.\n\n    See each param for associated global var.\n\nParameters:\n    0: _targetFPS <NUMBER> - The desired FPS (lower) limit (KISKA_VDL_fps)\n    1: _checkFreq <NUMBER> - The frequency of checks for FPS (KISKA_VDL_freq)\n    2: _minObjectDistance <NUMBER> - The minimum the objectViewDistance, can be set by (KISKA_VDL_minDist)\n    3: _maxObjectDistance <NUMBER> - The max the objectViewDistance, can be set by (KISKA_VDL_maxDist)\n    4: _increment <NUMBER> - The amount the viewDistance can incriment up or down each cycle (KISKA_VDL_inc)\n    5: _viewDistance <NUMBER> - This is the static overall viewDistance, can be set by (KISKA_VDL_viewDist)\n                                 This is static because it doesn't affect FPS too much.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        Every 3 seconds, check\n        [45,3,500,1700,25,3000] spawn KISKA_fnc_viewDistanceLimiter;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_viewDistanceLimiter\";\n\nif (!hasInterface) exitWith {};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in a scheduled environment. Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_viewDistanceLimiter\n};\n\nparams [\n    [\"_targetFPS\",missionNamespace getVariable [VDL_FPS_VAR_STR,60],[123]],\n    [\"_checkFreq\",missionNamespace getVariable [VDL_FREQUENCY_VAR_STR,0.5],[123]],\n    [\"_minObjectDistance\",missionNamespace getVariable [VDL_MIN_DIST_VAR_STR,500],[123]],\n    [\"_maxObjectDistance\",missionNamespace getVariable [VDL_MAX_DIST_VAR_STR,1200],[123]],\n    [\"_increment\",missionNamespace getVariable [VDL_INCREMENT_VAR_STR,25],[123]],\n    [\"_viewDistance\",missionNamespace getVariable [VDL_VIEW_DIST_VAR_STR,3000],[123]]\n];\n\n\nmissionNamespace setVariable [VDL_GLOBAL_RUN_STR,true];\nmissionNamespace setVariable [VDL_FPS_VAR_STR,_targetFPS];\nmissionNamespace setVariable [VDL_FREQUENCY_VAR_STR,_checkFreq];\nif (_minObjectDistance > _maxObjectDistance) then {\n    _minObjectDistance = _maxObjectDistance;\n};\nmissionNamespace setVariable [VDL_MIN_DIST_VAR_STR,_minObjectDistance];\nmissionNamespace setVariable [VDL_MAX_DIST_VAR_STR,_maxObjectDistance];\nmissionNamespace setVariable [VDL_INCREMENT_VAR_STR,_increment];\nif (_viewDistance < _maxObjectDistance) then {\n    _viewDistance = _maxObjectDistance;\n};\nmissionNamespace setVariable [VDL_VIEW_DIST_VAR_STR,_viewDistance];\n\n\nprivate \"_objectViewDistance\";\nprivate _fn_moveUp = {\n    if (_objectViewDistance < (GET_VDL_MAX_DIST_VAR)) exitWith {\n        setObjectViewDistance (_objectViewDistance + (GET_VDL_INCREMENT_VAR));\n    };\n    if (_objectViewDistance > (GET_VDL_MAX_DIST_VAR)) exitWith {\n        setObjectViewDistance (GET_VDL_MAX_DIST_VAR);\n    };\n};\nprivate _fn_moveDown = {\n    if (_objectViewDistance > (GET_VDL_MIN_DIST_VAR)) exitWith {\n        setObjectViewDistance (_objectViewDistance - (GET_VDL_INCREMENT_VAR));\n    };\n    if (_objectViewDistance < (GET_VDL_MIN_DIST_VAR)) exitWith {\n        setObjectViewDistance (GET_VDL_MIN_DIST_VAR);\n    };\n};\n\n\nmissionNamespace setVariable [VDL_GLOBAL_IS_RUNNING_STR,true];\nwhile {sleep (GET_VDL_FREQUENCY_VAR); GET_VDL_GLOBAL_IS_RUNNING} do {\n    _objectViewDistance = getObjectViewDistance select 0;\n    if (!(GET_VDL_GLOBAL_TIED_VIEW_DIST_VAR) AND ((GET_VDL_VIEW_DIST_VAR) isNotEqualTo viewDistance)) then {\n        setViewDistance (GET_VDL_VIEW_DIST_VAR);\n    };\n\n    // is fps at target?\n    if (diag_fps < (GET_VDL_FPS_VAR)) then {\n        // not at target fps\n        call _fn_moveDown;\n    } else {\n        // at target fps\n        call _fn_moveUp;\n    };\n\n    if (GET_VDL_GLOBAL_TIED_VIEW_DIST_VAR) then {\n        [{\n            setViewDistance (getObjectViewDistance select 0);\n        }] call CBA_fnc_execNextFrame;\n    };\n};\n\n\nmissionNamespace setVariable [VDL_GLOBAL_IS_RUNNING_STR,false];\n",
    "fileName": "fn_viewDistanceLimiter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_deployFastRope\n\nDescription:\n    An edit of the ACE function to allow for custom drop of units.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to fastrope from\n    1: _unitsToDeploy <ARRAY> - An array of units to drop from the _vehicle.\n        This function has a destructive effect on this array (deletes entries)\n    2: _ropeOrigins <ARRAY> - An array of either relative (to the vehicle) attachment\n        points for the ropes or a memory point to attachTo\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            (fullCrew [_vehicle,\"cargo\"]) apply {\n                _x select 0\n            }\n        ] call KISKA_fnc_ACE_deployFastRope;\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_deployFastRope\";\n\n#if __has_include(\"\\z\\ace\\addons\\fastroping\\script_component.hpp\")\n    #include \"\\z\\ace\\addons\\fastroping\\script_component.hpp\"\n    #define DEFAULT_ROPE_DEPLOY_TIME 4\n\n\nif !([\"ace_fastroping\"] call KISKA_fnc_isPatchLoaded) exitWith {\n    [\"ace_fastroping is required for this function\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\", objNull, [objNull]],\n    [\"_unitsToDeploy\",[],[[]]],\n    [\"_ropeOrigins\",[],[[]]]\n];\n\n/* ----------------------------------------------------------------------------\n    Verify Params\n---------------------------------------------------------------------------- */\nif (isNull _vehicle || {!(_vehicle isKindOf \"Helicopter\")}) exitWith {\n    [\"_vehicle is invalid or null\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_unitsToDeploy isEqualTo []) exitWith {\n    [\"_unitsToDeploy is empty!\", true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _config = configOf _vehicle;\nprivate _configEnabled = getNumber (_config >> QGVAR(enabled));\nif (_configEnabled isEqualTo 0 AND (_ropeOrigins isEqualTo [])) exitWith {\n    [\n        [\n            \"Fastrope not configured for vehicle: \",\n            getText(_config >> \"DisplayName\"),\n            \" or no rope origins were passed\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (\n    (_configEnabled isEqualTo 2) AND\n    (isNull (_vehicle getVariable [QGVAR(FRIES), objNull]))\n) exitWith {\n    [[getText(_config >> \"DisplayName\"),\" requires a FRIES for fastroping but has not been equipped with one\"],true] call KISKA_fnc_log;\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    Deploy Ropes\n---------------------------------------------------------------------------- */\nprivate _onPrepareFunctionName = getText (_config >> QGVAR(onPrepare));\nif (_onPrepareFunctionName isEqualTo \"\") then {\n    _onPrepareFunctionName = \"ace_fastroping_onPrepare\";\n};\nprivate _onPrepareFunction = missionNamespace getVariable _onPrepareFunctionName;\n// overwrite if needed\n_onPrepareFunction = _vehicle getVariable [\"KISKA_ACE_onPrepareFastrope\", _onPrepareFunction];\nprivate _deployTime = [[_vehicle],_onPrepareFunction] call KISKA_fnc_callBack;\nif (isNil \"_deployTime\" OR {!(_deployTime isEqualType 123)}) then {\n    _deployTime = DEFAULT_ROPE_DEPLOY_TIME;\n};\n\n[_vehicle,_ropeOrigins] call KISKA_fnc_ACE_deployRopes;\n\n(driver _vehicle) disableAI \"MOVE\";\n\n\n/* ----------------------------------------------------------------------------\n    Drop function\n---------------------------------------------------------------------------- */\nDFUNC(deployAIRecursive) = {\n    params [\"_vehicle\", \"_unitsToDeploy\"];\n\n    private _unit = _unitsToDeploy deleteAt 0;\n    if (alive _unit AND (_unit in _vehicle)) then {\n        unassignVehicle _unit;\n        [_unit] allowGetIn false;\n        [_unit, _vehicle] call FUNC(fastRope);\n\n    } else {\n        [[\"Found unit that was either not alive or not in vehicle: \", _vehicle],false] call KISKA_fnc_log;\n\n    };\n\n    if (_unitsToDeploy isNotEqualTo []) then {\n        [\n            {\n                [\n                    {\n                        params [\"_vehicle\"];\n                        private _deployedRopes = _vehicle getVariable [QGVAR(deployedRopes), []];\n                        ({!(_x select 5)} count _deployedRopes) > 0\n                    },\n                    FUNC(deployAIRecursive),\n                    _this\n                ] call CBA_fnc_waitUntilAndExecute;\n            },\n            [_vehicle, _unitsToDeploy],\n            1\n        ] call CBA_fnc_waitAndExecute;\n\n    } else {\n        [\n            {\n                private _deployedRopes = _this getVariable [QGVAR(deployedRopes), []];\n                ({_x select 5} count (_deployedRopes)) isEqualTo 0\n            },\n            {\n                [_this] call FUNC(cutRopes);\n                (driver _this) enableAI \"MOVE\";\n            },\n            _vehicle\n        ] call CBA_fnc_waitUntilAndExecute;\n\n    };\n};\n\n[\n    FUNC(deployAIRecursive),\n    [_vehicle, _unitsToDeploy],\n    _deployTime\n] call CBA_fnc_waitAndExecute;\n\n\n#else\n[\"ACE #include for \\z\\ace\\addons\\fastroping\\functions\\script_component.hpp not found!\",true] call KISKA_fnc_log;\nnil\n\n#endif\n",
    "fileName": "fn_ACE_deployFastRope.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_deployRopes\n\nDescription:\n    An edit of ace_fastroping_fnc_deployRopes to allow for custom drop of units.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to fastrope from\n    1: _ropeOrigins <ARRAY> - An array of either relative (to the vehicle) attachment\n        points for the ropes or a memory point to attachTo\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [heli] call KISKA_fnc_ACE_deployRopes;\n    (end)\n\nAuthor(s):\n    BaerMitUmlaut,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_deployRopes\";\n\n#if __has_include(\"\\z\\ace\\addons\\fastroping\\script_component.hpp\")\n    #include \"\\z\\ace\\addons\\fastroping\\script_component.hpp\"\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_ropeOrigins\",[],[[]]]\n];\n\n\nprivate _config = configOf _vehicle;\nprivate _deployedRopes = _vehicle getVariable [QGVAR(deployedRopes), []];\nprivate _hookAttachment = _vehicle getVariable [QGVAR(FRIES), _vehicle];\nprivate _ropeLength = DEFAULT_ROPE_LENGTH;\n\n_ropeOrigins apply {\n    private _ropeOrigin = _x;\n    private _hook = QGVAR(helper) createVehicle [0, 0, 0];\n    _hook allowDamage false;\n    if (_ropeOrigin isEqualType []) then {\n        _hook attachTo [_hookAttachment, _ropeOrigin];\n    } else {\n        _hook attachTo [_hookAttachment, [0, 0, 0], _ropeOrigin];\n    };\n\n    private _origin = getPosATL _hook;\n    private _dummy = createVehicle [QGVAR(helper), _origin vectorAdd [0, 0, -1], [], 0, \"CAN_COLLIDE\"];\n    _dummy allowDamage false;\n    _dummy disableCollisionWith _vehicle;\n\n    private _ropeTop = ropeCreate [_dummy, [0, 0, 0], _hook, [0, 0, 0], 0.5];\n    private _ropeBottom = ropeCreate [_dummy, [0, 0, 0], 1];\n    ropeUnwind [_ropeBottom, 30, _ropelength, false];\n\n    _ropeTop addEventHandler [\"RopeBreak\", {[_this, \"top\"] call FUNC(onRopeBreak)}];\n    _ropeBottom addEventHandler [\"RopeBreak\", {[_this, \"bottom\"] call FUNC(onRopeBreak)}];\n\n    //deployedRopes format: attachment point, top part of the rope, bottom part of the rope, attachTo helper object, occupied, broken\n    _deployedRopes pushBack [_ropeOrigin, _ropeTop, _ropeBottom, _dummy, _hook, false, false];\n\n    false\n};\n\n_vehicle setVariable [QGVAR(deployedRopes), _deployedRopes, true];\n_vehicle setVariable [QGVAR(deploymentStage), 3, true];\n_vehicle setVariable [QGVAR(ropeLength), _ropeLength, true];\n\n#else\n[\"ACE #include for \\z\\ace\\addons\\fastroping\\functions\\script_component.hpp not found!\",true] call KISKA_fnc_log;\nnil\n\n#endif\n",
    "fileName": "fn_ACE_deployRopes.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_fastRope\n\nDescription:\n    Sends a vehicle to a given point and fastropes the given units from the helicopter.\n\n    Pilots should ideally be placed in \"CARELESS\" behaviour when around enemies.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to fastrope from\n    1: _dropPosition <ARRAY or OBJECT> - The positionASL to drop the units off at; Z coordinate\n        matters\n    2: _unitsToDeploy <CODE, STRING, ARRAY, OBJECT[], GROUP, or OBJECT> - An array of units to drop from the _vehicle,\n        Or code that will run once the helicopter has reached the drop point that must return an array of object\n        (see KISKA_fnc_callBack for examples)\n\n        Parameters:\n        - 0: _vehicle - The drop vehicle\n\n    3: _afterDropCode <CODE, STRING or ARRAY> - Code to execute after the drop is complete, see KISKA_fnc_callBack\n        \n        Parameters:\n        - 0: _vehicle - The drop vehicle\n\n    4: _hoverHeight <NUMBER> - The height the helicopter should hover above the drop position\n        while units are fastroping. Max is 28, min is 5\n    5: _ropeOrigins <ARRAY> - An array of: either relative (to the vehicle) attachment\n        points for the ropes and/or memory points to attachTo\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        //  basic example\n        [\n            _vehicle,\n            _position,\n            (fullCrew [_vehicle,\"cargo\"]) apply {\n                _x select 0\n            },\n            {hint \"fastrope done\"},\n            28,\n            [[0,0,0]]\n        ] call KISKA_fnc_ACE_fastRope;\n    (end)\n\n    (begin example)\n        // using code instead to defer the list of units to drop\n        // until the helicopter is over the drop point\n        [\n            _vehicle,\n            _position,\n            {\n                params [\"_vehicle\"];\n\n                (fullCrew [_vehicle,\"cargo\"]) apply {\n                    _x select 0\n                }\n            },\n            {hint \"fastrope done\"},\n            28,\n            [[0,0,0]]\n        ] call KISKA_fnc_ACE_fastRope;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_fastRope\";\n\n#define MIN_HOVER_HEIGHT 5\n#define MAX_HOVER_HEIGHT 28\n#define HOVER_INTERVAL 0.05\n\nif !([\"ace_fastroping\"] call KISKA_fnc_isPatchLoaded) exitWith {\n    [\"ace_fastroping is required for this function\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_dropPosition\",[],[[],objNull]],\n    [\"_unitsToDeploy\",[],[[],grpNull,objNull,{},\"\"]],\n    [\"_afterDropCode\",{},[\"\",{},[]]],\n    [\"_hoverHeight\",20,[123]],\n    [\"_ropeOrigins\",[],[[]]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    Verify Params\n---------------------------------------------------------------------------- */\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_ropeOrigins isEqualTo []) then {\n    private _config = configOf _vehicle;\n    _ropeOrigins = getArray (_config >> \"ace_fastroping_ropeOrigins\");\n};\n\n[_vehicle] call ace_fastroping_fnc_equipFRIES;\n// some vehicles may fail ace_fastroping_fnc_canPrepareFRIES if not called with ace_fastroping_fnc_equipFRIES first\nprivate _canEquipFRIES = [_vehicle] call ace_fastroping_fnc_canPrepareFRIES;\nif (\n    !(_canEquipFRIES) AND\n    (_ropeOrigins isEqualTo [])\n) exitWith {\n    [\n        [typeOf _vehicle,\" is not configured for ACE FRIES system, can't fastrope, or no _ropeOrigins were passed\"],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (_dropPosition isEqualType objNull) then {\n    _dropPosition = getPosASL _dropPosition;\n};\n\n_hoverHeight = _hoverHeight max MIN_HOVER_HEIGHT;\n_hoverHeight = _hoverHeight min MAX_HOVER_HEIGHT;\n\n\n/* ----------------------------------------------------------------------------\n    Verify _unitsToDeploy\n---------------------------------------------------------------------------- */\nif (_unitsToDeploy isEqualTo []) exitWith {\n    [\"_unitsToDeploy is empty\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_unitsToDeploy isEqualTypeAny [objNull,grpNull] AND {isNull _unitsToDeploy}) exitWith {\n    [\"_unitsToDeploy isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_unitsToDeploy isEqualType grpNull) then {\n    _unitsToDeploy = units _unitsToDeploy;\n};\n\nif (_unitsToDeploy isEqualType objNull) then {\n    _unitsToDeploy = [_unitsToDeploy];\n};\n\nprivate _unitsToDeployFiltered = [];\nprivate _unitsToDeployIsCode = \n    (_unitsToDeploy isEqualTypeParams [[],{}]) OR \n    (_unitsToDeploy isEqualTypeParams [[],\"\"]) OR\n    _unitsToDeploy isEqualType \"\" OR \n    _unitsToDeploy isEqualType {};\n\nif (_unitsToDeploy isEqualType [] AND !_unitsToDeployIsCode) then {\n    _unitsToDeploy apply {\n        if (_x isEqualType grpNull) then {\n            _unitsToDeployFiltered append (units _x);\n        };\n\n        if (_x isEqualType objNull) then {\n            _unitsToDeployFiltered pushBackUnique _x;\n        };\n    };\n};\n\nif (_unitsToDeployFiltered isEqualTo []) then {\n    _unitsToDeployFiltered = _unitsToDeploy;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Prepare FRIES\n---------------------------------------------------------------------------- */\n_vehicle setVariable [\"ACE_Rappelling\",true];\nprivate _hoverPosition_ASL = _dropPosition vectorAdd [0,0,_hoverHeight];\n\n[\n    _vehicle,\n    _hoverPosition_ASL,\n    {\n        params [\"_vehicle\"];\n        isNil {_vehicle getVariable \"ACE_Rappelling\"}\n    }\n] call KISKA_fnc_hover;\n\n/* ----------------------------------------------------------------------------\n    Monitor drop for completion\n---------------------------------------------------------------------------- */\n[\n    {\n        params [\"_vehicle\",\"_hoverPosition_ASL\"];\n\n        if (!alive _vehicle) exitWith {true};\n        if (!alive (currentPilot _vehicle)) exitWith {true};\n        private _currentVehiclePosition_ASL = getPosASLVisual _vehicle;\n\n        (speed _vehicle < (2.5 * 3.6))\n        AND\n        {\n            (_hoverPosition_ASL distance2d _currentVehiclePosition_ASL) < 25\n        }\n        AND\n        {\n            (_hoverPosition_ASL vectorDiff _currentVehiclePosition_ASL) select 2 < 25\n        }\n    },\n    {\n        params [\n            \"_vehicle\",\n            \"\",\n            \"_unitsToDeploy\",\n            \"_afterDropCode\",\n            \"_ropeOrigins\",\n            \"_unitsToDeployIsCode\"\n        ];\n\n        if (!(alive _vehicle) OR !(alive (currentPilot _vehicle))) exitWith {};\n            \n        if (_unitsToDeployIsCode) then {\n            _unitsToDeploy = [\n                [_vehicle],\n                _unitsToDeploy\n            ] call KISKA_fnc_callBack;\n        };\n\n        [_vehicle, _unitsToDeploy, _ropeOrigins] call KISKA_fnc_ACE_deployFastRope;\n\n        [_vehicle,_afterDropCode] spawn {\n            params [\"_vehicle\",\"_afterDropCode\"];\n\n            waitUntil {\n                sleep 1;\n                ((_vehicle getVariable [\"ace_fastroping_deployedRopes\", []]) isNotEqualTo [])\n            };\n\n            waitUntil {\n                sleep 1;\n                ((_vehicle getVariable [\"ace_fastroping_deployedRopes\", []]) isEqualTo [])\n            };\n\n            _vehicle setVariable [\"ACE_Rappelling\",nil];\n            \n            [\n                [_vehicle],\n                _afterDropCode\n            ] call KISKA_fnc_callBack;\n        };\n    },\n    0.5,\n    [_vehicle,_hoverPosition_ASL,_unitsToDeployFiltered,_afterDropCode,_ropeOrigins,_unitsToDeployIsCode]\n] call KISKA_fnc_waitUntil;\n",
    "fileName": "fn_ACE_fastRope.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_setOnPrepareFastrope\n\nDescription:\n    Sets the onprepare function of a specific vehicle when it conducts fastroping\n     with KISKA_fnc_fastRope (not any other implementation of ACE fastroping).\n    \n    By default, ACE uses a config value (on the vehicle's class) of a string that \n     is the name of the function to call. This function will overwrite that config \n     function or add support for vehicles that do not have an onPrepare function defined.\n\n    The onPrepare function is what happens just prior to the helicopter dropping\n     its ropes. You may want to do something like openning the vehicles doors before\n     the units fastrope, for example.\n    \n    Your new onPrepare function can return a number that will then be used as the\n     time it takes for the ropes to be lowered down from the helicopter \n     (the default is 4 seconds).\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to fastrope from\n    1: _onPrepare <CODE, ARRAY, or STRING> - A function that returns a number\n        being the time it takes for the ropes to deploy from the given vehicle\n        (SEE KISKA_fnc_callBack for array syntax).\n        \n        Args:\n            - 0. <OBJECT> - The helicopter conducting a fastrope\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            {4} // takes 4 seconds to lower ropes\n        ] call KISKA_fnc_ACE_setOnPrepareFastrope;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_setOnPrepareFastrope\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_onPrepareFunction\",{},[\"\",{},[]]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\n_vehicle setVariable [\"KISKA_ACE_onPrepareFastrope\",_onPrepareFunction];\n",
    "fileName": "fn_ACE_setOnPrepareFastrope.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_addSupportMenuAction\n\nDescription:\n    Adds the ACE action to a player object that allows them to self interact\n     and pull up the support menu.\n\nParameters:\n    0: _player <OBJECT> - The player object\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_addSupportMenuAction\";\n\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif !([\"ace_main\"] call KISKA_fnc_isPatchLoaded) exitWith {\n    [\"ACE is not loaded, action will not be added\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_ACE_addSupportMenuAction;\n};\n\nwaitUntil {\n    sleep 0.1;\n    !(isNull player)\n};\n\nprivate _action = [\n    \"Open Comm Menu\",\n    \"Open Comm Menu\",\n    \"\\a3\\Ui_f\\data\\GUI\\Cfg\\CommunicationMenu\\call_ca.paa\",\n    {showCommandingMenu \"#User:BIS_fnc_addCommMenuItem_menu\"},\n    {alive player}\n] call ace_interact_menu_fnc_createAction;\n\n[player,1,[\"ACE_SelfActions\"],_action] call ace_interact_menu_fnc_addActionToObject;\n",
    "fileName": "fn_ACE_addSupportMenuAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACE_unconsciousIsCaptive\n\nDescription:\n    Adds a CBA event that hooks into when a player becomes unconcious, making them\n     turn captive in order to keep the AI from shooting downed players.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACE_unconsciousIsCaptive\";\n\nif (!hasInterface) exitWith {};\n\nif (!canSuspend) exitWith {\n    [] spawn KISKA_fnc_ACE_unconsciousIsCaptive;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\n\nif !([\"ace_medical\"] call KISKA_fnc_isPatchLoaded) exitWith {\n    [\"ACE medical is not loaded, will not add event...\",false] call KISKA_fnc_log;\n    nil\n};\n\n\nif (localNamespace getVariable [\"KISKA_ACE_addedUnconsciousPlayerEvent\",false]) exitWith {};\n\n\n[\n    \"ace_unconscious\",\n    {\n        params [\"_unit\",\"_unconscious\"];\n        if (_unit isEqualTo player) then {\n\n            if (_unconscious) then {\n                [\"Player ace_unconscious event fired.\"] call KISKA_fnc_log;\n                private _makeCaptive = localNamespace getVariable [\"KISKA_CBA_ACE_unconciousPlayerIsCaptive\",true];\n                private _wasCaptiveBefore = captive _unit;\n                private _wasMadeCaptive =  false;\n\n                if (!_wasCaptiveBefore AND {_makeCaptive}) then {\n                    [\"Player was not captive beforehand, will be made captive\"] call KISKA_fnc_log;\n                    _wasMadeCaptive = true;\n                    _unit setCaptive true;\n                };\n\n                localNamespace setVariable [\"KISKA_ACE_wasMadeCaptive\",_wasMadeCaptive];\n\n            } else { // if waking up\n                [\"Player is waking from unconscious state\"] call KISKA_fnc_log;\n\n                if (captive _unit) then {\n                    [\"Player is a captive\"] call KISKA_fnc_log;\n\n                    if (localNamespace getVariable [\"KISKA_ACE_wasMadeCaptive\",false]) then {\n                        [\"Player was previosuly made captive, captive will be turned off...\"] call KISKA_fnc_log;\n                        _unit setCaptive false;\n                    };\n\n                };\n\n                localNamespace setVariable [\"KISKA_ACE_wasMadeCaptive\",false];\n\n            };\n\n        };\n    }\n] call CBA_fnc_addEventhandler;\n\n\nwaitUntil {\n    sleep 1;\n    !isNull player;\n};\n\n\nplayer addEventHandler [\"Respawn\",{\n    params [\"_unit\"];\n    \n    if (captive _unit) then {\n        [\n            \"Player is a captive\",\n            missionNamespace getVariable [\"KISKA_CBA_logWithError\",false],\n            true,\n            false,\n            \"KISKA_unconsciousACEEvent_respawnHandler\"\n        ] call KISKA_fnc_log;\n\n        if (localNamespace getVariable [\"KISKA_ACE_wasMadeCaptive\",false]) then {\n            [\n                \"Player was previosuly made captive, captive will be turned off...\",\n                missionNamespace getVariable [\"KISKA_CBA_logWithError\",false],\n                true,\n                false,\n                \"KISKA_unconsciousACEEvent_respawnHandler\"\n            ] call KISKA_fnc_log;\n\n            _unit setCaptive false;\n        };\n\n    };\n\n    localNamespace setVariable [\"KISKA_ACE_wasMadeCaptive\",false];\n}];\n\n\nlocalNamespace setVariable [\"KISKA_ACE_addedUnconsciousPlayerEvent\",true];\n\n\nnil\n",
    "fileName": "fn_ACE_unconsciousIsCaptive.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ACEX_setHCTransfer\n\nDescription:\n    Simply sets the blacklist variable of a given unit from being transferred by the\n     ACEX headless client module. Variable is set on the server.\n\nParameters:\n    0: _unit <GROUP or OBJECT> - The unit to blacklist\n    1: _setting <BOOL> - The blacklist value to set (true to blacklist, false to allow transfer)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // disable transfer\n        [someGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n    (end)\n\n    (begin example)\n        // enable transfer\n        [someGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ACEX_setHCTransfer\";\n\nif (!isMultiplayer) exitWith {\n    [\"No need to run in singleplayer...\"] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_unit\",objNull,[grpNull,objNull]],\n    [\"_setting\",false,[true]]\n];\n\nif (isNull _unit) exitWith {\n    [\"A null unit was passed, will not blacklist\",true] call KISKA_fnc_log;\n    nil\n};\n\n_unit setVariable [\"acex_headless_blacklist\",_setting,2];\n\n\nnil\n",
    "fileName": "fn_ACEX_setHCTransfer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_AAAZone\n\nDescription:\n    Sets up a zone that when entered by an enemy aircraft, the provided vehicle will engage.\n\n    Otherwise, vehicle will stay the same.\n\nParameters:\n    0: _vehicle : <OBJECT> - The AAA piece\n    1: _radius : <NUMBER> - How far out the turret is alerted to\n    2: _checkTime : <NUMBER> - How often does the AAA scan the area for targets\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myVehicle] spawn KISKA_fnc_AAAZone;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_AAAZone\";\n\n\nif (!canSuspend) exitWith {\n    [\"ReExecuting in scheduled environment\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_AAAZone;\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_radius\",1000,[123]],\n    [\"_checkTime\",5,[123]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null object\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (!local _vehicle) exitWith {\n    [[_vehicle,\" is not local to machine, executing on owner\"],false] call KISKA_fnc_log;\n    _this remoteExec [\"KISKA_fnc_AAAZone\",_vehicle];\n    nil\n};\n\nprivate _gunner = gunner _vehicle;\nif (isNull _gunner) exitWith {\n    [[_vehicle,\" does not have a gunner\"],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _gunnerGroup = group _gunner;\nif (isNull _gunnerGroup) exitWith {\n    [\"_gunnerGroup is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n// disable HC transfer\n[_gunnerGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\nprivate _fn_controlShots = {\n    params [\"_doShoot\"];\n\n    if (_doShoot) then {\n        [_gunner,\"WEAPONAIM\"] remoteExecCall [\"enableAI\",_gunner];\n        [_gunnerGroup,\"RED\"] remoteExecCall [\"setCombatMode\",_gunnerGroup];\n\n    } else {\n        [_gunner,\"WEAPONAIM\"] remoteExecCall [\"disableAI\",_gunner];\n        [_gunnerGroup,\"BLUE\"] remoteExecCall [\"setCombatMode\",_gunnerGroup];\n\n    };\n};\n\n// disable unit\n[false] call _fn_controlShots;\n\n\nprivate _AAAside = side _vehicle;\nprivate _doFire = false;\nprivate \"_entitiesInRadius\";\n\n_vehicle setVariable [\"KISKA_doAAA\",true];\nwhile {sleep _checkTime; _vehicle getVariable [\"KISKA_doAAA\",true]} do {\n    _entitiesInRadius = _vehicle nearEntities [\"air\",_radius];\n\n    // if any air units are found\n    if (_entitiesInRadius isNotEqualTo []) then {\n        //[\"Found entities in radius\",false] call KISKA_fnc_log;\n\n        // find an enemy unit to fire at\n        private _index = _entitiesInRadius findIf {\n            //[[\"Side of\",_x,\"is\",side _x,\": side of AAA is\",_AAASide]] call KISKA_fnc_log;\n            [side _x,_AAAside] call BIS_fnc_sideIsEnemy;\n        };\n\n        // if an enemy aircraft is found AND _vehicle is not already engaging\n        if (_index isNotEqualTo -1 AND {!_doFire}) then {\n            //[[\"Found a unit to engage and not already doing so, weapon aim on for\",_gunner],false] call KISKA_fnc_log;\n\n            _doFire = true;\n            [true] call _fn_controlShots;\n        } else {\n            // only disable if no targets are found and already engaging\n            //[[\"Did not meet fire standards. Do fire? \",_doFire,\" Index? \",_index],false] call KISKA_fnc_log;\n\n            if (_index isEqualTo -1 AND {_doFire}) then {\n                //[\"No enemy targets to engage anymore. Disabling weapon aim and _doFire to false\",false] call KISKA_fnc_log;\n\n                _doFire = false;\n                [false] call _fn_controlShots;\n            };\n        };\n    } else {\n        //[\"No entities in area found\",false] call KISKA_fnc_log;\n\n        if (_doFire) then {\n            //[\"Setting _doFire to false\",false] call KISKA_fnc_log;\n\n            _doFire = false;\n        };\n    };\n\n    // if vehicle is dead or gunner is absent\n    if !(alive _gunner) then {\n        //[[\"_gunner \",_gunner,\" is no longer alive, exiting\"]] call KISKA_fnc_log;\n\n        if (alive _vehicle) then {\n            //[[\"_vehicle \",_vehicle,\" is still alive, setting KISKA_doAAA to nil\"]] call KISKA_fnc_log;\n\n            _vehicle setVariable [\"KISKA_doAAA\",nil];\n        };\n\n        break;\n    };\n\n    if !(alive _vehicle) then {\n        //[[\"_vehicle \",_vehicle,\" is no longer alive, exiting\"]] call KISKA_fnc_log;\n        break;\n    };\n};\n\nif (alive _gunner) then {\n    [true] call _fn_controlShots;\n    // allow HC transfer\n    [_gunnerGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n};\n\n\nnil\n",
    "fileName": "fn_AAAZone.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_arty\n\nDescription:\n    Fires a number of rounds from artillery piece at target with random disperstion values\n\nParameters:\n    0: _gun : <OBJECT> - The artillery piece\n    1: _target : <OBJECT or ARRAY> - Self Expllanitory\n    2: _rounds : <NUMBER> - Number of rounds to fire\n    3: _randomDistance : <NUMBER> - max distance error margin (0 will be directly on target for all rounds)\n    4: _randomDirection : <NUMBER> - 360 direction within rounds can land\n    5: _fireTime : <ARRAY> - Array of random time between shots for bell curve\n\nReturns:\n    Nothing\n\nExamples:\n    (begin example)\n        [vehicle, target, 2, 100, 360, [9,10,11]] spawn KISKA_fnc_arty;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_arty\";\n\nif (!canSuspend) exitWith {\n    [\"ReExecuting in scheduled environment\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_arty;\n};\n\nparams [\n    [\"_gun\",objNull,[objNull]],\n    [\"_target\",objNull,[objNull,[]]],\n    [\"_rounds\",1,[1]],\n    [\"_randomDistance\",0,[1]],\n    [\"_randomDirection\",360,[1]],\n    [\"_fireTime\",[10,11,12],[[],1]]\n];\n\nif (!(alive _gun) OR !(alive (gunner _gun))) exitWith {\n    [[_gun,\" or its gunner are not alive, exiting...\"]] call KISKA_fnc_log;\n    nil\n};\n\nif (_rounds < 1) exitWith {\n    [[_gun,\" was told to fire less than 1 round, exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _ammo = (getArtilleryAmmo [_gun]) select 0;\nif (isNil \"_ammo\") exitWith {\n    [[_gun,\" was told to fire but has no ammo, exiting...\"]] call KISKA_fnc_log;\n    nil\n};\n\nprivate [\"_fireDirection\",\"_fireDistance\",\"_targetToAimAt\"];\nfor \"_i\" from 1 to _rounds do {\n    if (!(alive _gun) OR !(alive (gunner _gun))) then {\n        [[_gun,\" or its gunner are not alive, exiting...\"]] call KISKA_fnc_log;\n        break;\n    };\n\n    _fireDirection = round random _randomDirection;\n    _fireDistance = round random _randomDistance;\n    _targetToAimAt = _target getPos [_fireDistance, _fireDirection];\n\n    _gun doArtilleryFire [_targetToAimAt,_ammo,1];\n\n    _rounds = _rounds - 1;\n\n    if (_i isNotEqualTo _rounds) then {\n        sleep (round random _fireTime);\n    };\n};\n\n\nnil\n",
    "fileName": "fn_arty.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_attack\n\nDescription:\n    Modified version of CBA_fnc_taskAttack.\n    Now allows setting of different behaviour and combatMode.\n\nParameters:\n    0: _group <GROUP or OBJECT> - Unit(s) to attack\n    1: _position <OBJECT, LOCATION, GROUP, or ARRAY> - The position to attack\n    2: _radius <NUMBER> - Radius for waypoint placement\n    3: _behaviour <STRING> - What behaviour will the attacker(s) have\n    4: _combatMode <STRING> - What combatMode will the attacker(s) have\n    5: _override <BOOL> - Clear units current waypoints\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [group1,attackPosition,100,\"COMBAT\",\"RED\"] call KISKA_fnc_attack;\n    (end)\n\nAuthor:\n    Rommel,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_attack\";\n\nparams [\n    [\"_group\",grpNull,[objNull,grpNull]],\n    [\"_position\",objNull,[[],objNull,locationNull,grpNull]],\n    [\"_radius\",-1,[123]],\n    [\"_behaviour\",\"AWARE\",[\"\"]],\n    [\"_combatMode\",\"RED\",[\"\"]],\n    [\"_override\",false,[true]]\n];\n\n_group = _group call CBA_fnc_getGroup;\n\n// Don't create waypoints on each machine\nif !(local _group) exitWith {\n    [[\"Found that \",_group,\" was not local, exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n// Allow TaskAttack to override other set waypoints\nif (_override) then {\n    [_group,-1,true] call KISKA_fnc_clearWaypoints;\n};\n\n[_group, _position, _radius, \"SAD\", _behaviour, _combatMode] call CBA_fnc_addWaypoint;\n\n\nnil\n",
    "fileName": "fn_attack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_clearWaypoints\n\nDescription:\n    Clears a group's waypoints and conditionally halts their previous movement.\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group to clear the waypoints of.\n    1: _numberToRemove <NUMBER> - The number of waypoints to remove (-1 will remove all)\n    2: _stopUnits <BOOL> - Should the units stop in place after clear?\n\nReturns:\n    NOTHING\n\nExample:\n    (begin example)\n        [group player,-1,false] call KISKA_fnc_clearWaypoints\n    (end)\n\nAuthor(s):\n    SilentSpike,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nparams [\n    [\"_group\", grpNull, [grpNull, objNull]],\n    [\"_numberToRemove\",-1,[123]],\n    [\"_stopUnits\", false, [true]]\n];\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\nprivate _numberOfCurrentWaypoints = count (waypoints _group);\nif (_numberOfCurrentWaypoints isEqualTo 0) exitWith {};\n\nif (_numberToRemove isEqualTo -1) then {\n    _numberToRemove = _numberOfCurrentWaypoints;\n};\n\nfor \"_i\" from (_numberToRemove - 1) to 0 step -1 do {\n    deleteWaypoint [_group, _i];\n};\n\nprivate _removedAllWaypoints = _numberToRemove isEqualTo _numberOfCurrentWaypoints;\nif (!_stopUnits OR !_removedAllWaypoints) exitWith {};\n\n\n\nif ((units _group) isNotEqualTo []) then {\n    // Create a self-deleting waypoint at the leader position to halt all planned movement (based on old waypoints)\n    private _wp = _group addWaypoint [getPosASL (leader _group), -1];\n    _wp setWaypointStatements [\"true\", \"deleteWaypoint [group this, currentWaypoint (group this)]\"];\n};\n\n\nnil",
    "fileName": "fn_clearWaypoints.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_defend\n\nDescription:\n    A function for a group to defend a parsed location. Should be ran locally.\n\n    Units will mount nearby static machine guns and garrison in nearby buildings.\n    10% chance to patrol the radius unless specified differently (100% when no available building positions).\n    0% chance to hold defensive positions in combat unless specified differently.\n\nModifications:\n    Accounted for doMove command's inability to use z-axis\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group to do the defending\n    1: _position <OBJECT, LOCATION, GROUP, or ARRAY> - centre of area to defend <ARRAY, OBJECT, LOCATION, GROUP> (Default: _group)\n    2: _radius <NUMBER> - radius of area to defend <NUMBER> (Default: 50)\n    3: _threshold <NUMBER> - minimum building positions required to be considered for garrison <NUMBER> (Default: 3)\n    4: _patrol <NUMBER or BOOL> - chance for each unit to patrol instead of garrison, true for default, false for 0% <NUMBER, BOOLEAN> (Default: 0.1)\n    5: _hold <NUMBER or BOOL> - chance for each unit to hold their garrison in combat, true for 100%, false for 0% <NUMBER, BOOLEAN> (Default: 0)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [this] call KISKA_fnc_defend\n    (end)\n\nAuthor:\n    Rommel,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_defend\";\n\n\nparams [\n    [\"_group\",grpNull,[grpNull,objNull]],\n    [\"_position\",[],[[],objNull,grpNull,locationNull],3],\n    [\"_radius\", 50, [0]],\n    [\"_threshold\", 3, [0]],\n    [\"_patrol\", 0.1, [true, 0]],\n    [\"_hold\", 0, [true, 0]]\n];\n\n// Input validation stuff here\n_group = _group call CBA_fnc_getGroup;\n// Don't create waypoints on each machine\nif !(local _group) exitWith {\n    [[\"Found that \",_group,\" was not local, exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_position = [_position, _group] select (_position isEqualTo []);\n_position = _position call CBA_fnc_getPos;\n\nif (_patrol isEqualType true) then {\n    _patrol = [0, 0.1] select _patrol;\n};\n\nif (_hold isEqualType true) then {\n    _hold = [0,1] select _hold;\n};\n\n// Start of the actual function\n[_group] call KISKA_fnc_clearWaypoints;\n\nprivate _statics = _position nearObjects [\"StaticWeapon\", _radius];\nprivate _buildings = _position nearObjects [\"Building\", _radius];\n\n// Filter out occupied statics\n_statics = _statics select {locked _x != 2 && {(_x emptyPositions \"Gunner\") > 0}};\n\n// Filter out buildings below the size threshold (and store positions for later use)\n_buildings = _buildings select {\n    private _positions = _x buildingPos -1;\n\n    if (isNil {_x getVariable \"CBA_taskDefend_positions\"}) then {\n        _x setVariable [\"CBA_taskDefend_positions\", _positions];\n    };\n\n    count (_positions) >= _threshold\n};\n\n// If patrolling is enabled then the leader must be free to lead it\nprivate _units = units _group;\nif (_patrol > 0 && {count _units > 1}) then {\n    _units deleteAt (_units find (leader _group));\n};\n\n\n_units apply {\n    // 31% chance to occupy nearest free static weapon\n    if ((random 1 < 0.31) && { !(_statics isEqualto []) }) then {\n        _x assignAsGunner (_statics deleteAt 0);\n        [_x] orderGetIn true;\n    } else {\n        // Respect chance to patrol, or force if no building positions left\n        if !((_buildings isEqualto []) || { (random 1 < _patrol) }) then {\n            private _randomBuildingIndex = [_buildings] call KISKA_fnc_randomIndex;\n            private _building = _buildings select _randomBuildingIndex;\n\n            private _buildingDefendPositions = _building getVariable [\"CBA_taskDefend_positions\", []];\n            if (_buildingDefendPositions isNotEqualTo []) then {\n                private _pos = [_buildingDefendPositions] call KISKA_fnc_deleteRandomIndex;\n\n                // If building positions are all taken remove from possible buildings\n                if (_buildingDefendPositions isEqualTo []) then {\n                    _buildings deleteAt _randomBuildingIndex;\n                    _building setVariable [\"CBA_taskDefend_positions\", nil];\n                } else {\n                    _building setVariable [\"CBA_taskDefend_positions\", _buildingDefendPositions];\n                };\n\n                // Wait until AI is in position then force them to stay\n                [_x, _pos, _hold] spawn {\n                    params [\"_unit\", \"_pos\", \"_hold\"];\n                    if (surfaceIsWater _pos) exitwith {};\n\n                    _unit doMove _pos;\n                    waituntil {unitReady _unit};\n                    // doMove does not accout for height of a position, so we force it the AI there\n                    if !((getPosATL _unit) isEqualTo _pos) then {\n                        _unit setPosATL _pos;\n                    };\n\n                    if (random 1 < _hold) then {\n                        _unit disableAI \"PATH\";\n                    } else {\n                        doStop _unit;\n                    };\n                /*\n                    [\n                        {unitReady (_this select 0)},\n                        {\n                            params [\n                                [\"_unit\",objNull,[objNull]],\n                                [\"_pos\",[0,0,0],[[]]],\n                                [\"_hold\", 0, [true, 0]]\n                            ];\n\n                            if !((getPosATL _unit) isEqualTo _pos) then {\n                                _unit setPosATL _pos;\n                            };\n\n                            if (random 1 < _hold) then {\n                                _unit disableAI \"PATH\";\n                            } else {\n                                doStop _unit;\n                            };\n                        },\n                        [_unit,_pos,_hold]\n                    ] call CBA_fnc_waitUntilAndExecute;\n                */\n\n                    // This command causes AI to repeatedly attempt to crouch when engaged\n                    // If ever fixed by BI then consider uncommenting\n                    // _unit setUnitPos \"UP\";\n                };\n            };\n        };\n    };\n};\n\n// Unassigned (or combat reacted) units will patrol\n[_group, _position, _radius, 5, \"sad\", \"safe\", \"red\", \"limited\"] call CBA_fnc_taskPatrol;\n\n\nnil\n",
    "fileName": "fn_defend.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_driveTo\n\nDescription:\n    Units will drive to point and get out of vehicle.\n\nParameters:\n    0: _crew : <GROUP, OBJECT[], or OBJECT> - The units to move into the vehicle and drive\n    1: _vehicle : <OBJECT> - The vehicle to put units into\n    2: _dismountPoint : <OBJECT or ARRAY> - The position to move to, can be object or position array\n    3: _completionRadius : <NUMBER> - The radius at which the waypoint is complete and the units can disembark from the _dismountPoint, -1 for exact placement\n    4: _speed : <STRING> - The for the driver group to move at\n    5: _codeOnComplete : <CODE, STRING, or ARRAY> - Code to run upon completion of disembark. See KISKA_fnc_callBack\n        \n        Parameters:\n        - 0: <OBJECT> - The vehicle, crew (ARRAY), and crew groups (ARRAY)\n        - 1: <OBJECT[]> - The crew of the vehicle\n        - 2: <GROUP[]> - All the groups that are in the vehicle crew\n\nReturns:\n    <BOOL> - false if encountered error, true if success\n\nExamples:\n    (begin example)\n        [_group1, _vehicle, myDismountPoint] call KISKA_fnc_driveTo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_driveTo\";\n\nparams [\n    [\"_crew\",[],[[],grpNull,objNull]],\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_dismountPoint\",objNull,[[],objNull]],\n    [\"_completionRadius\",10,[123]],\n    [\"_speed\",\"NORMAL\",[\"\"]],\n    [\"_codeOnComplete\",{},[{},\"\",[]]]\n];\n\nif ((_crew isEqualTypeAny [grpNull,objNull] AND {isNull _crew}) OR {_crew isEqualTo []}) exitWith {\n    [[\"_crew for \",_vehicle,\" is undefined\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",true] call KISKA_fnc_log;\n    false\n};\n\n\nif (_crew isEqualType grpNull) then {\n    _crew = units _crew;\n};\nif (_crew isEqualType objNull) then {\n    _crew = [_crew];\n};\n\n\nprivate _vehicleCrew = crew _vehicle;\nprivate _crewGroups = [];\n{\n    if !(_x in _vehicleCrew) then {\n        _x moveInAny _vehicle;\n    };\n    _crewGroups pushBackUnique (group _x);\n} forEach _crew;\n\nprivate _driverGroup = group (driver _vehicle);\n_driverGroup setSpeedMode _speed;\n\n\n// disable HC transfer while driving\n[_driverGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n/* [_driverGroup] call KISKA_fnc_clearWaypoints; */\n/* [_driverGroup,_dismountPoint,-1,\"MOVE\",\"UNCHANGED\",\"NO CHANGE\",_speed,\"NO CHANGE\",\"\",[0,0,0],_completionRadius] call CBA_fnc_addWaypoint; */\n\n// position loop\n[_vehicle,_crew,_codeOnComplete,_completionRadius,_dismountPoint,_driverGroup,_crewGroups] spawn {\n    params [\n        \"_vehicle\",\n        \"_crew\",\n        \"_codeOnComplete\",\n        \"_completionRadius\",\n        \"_dismountPoint\",\n        \"_driverGroup\",\n        \"_crewGroups\"\n    ];\n\n\n    // Need to wait for driver to be ready to move\n    private _driver = driver _vehicle;\n    waitUntil {\n        if (!alive _driver OR {!(_driver in _vehicle)}) exitWith {true};\n        sleep 0.1;\n        unitReady _driver;\n    };\n\n    private \"_dismountPointPos\";\n    if (_dismountPoint isEqualType objNull) then {\n        _dismountPointPos = getPosATL _dismountPoint;\n    } else {\n        _dismountPointPos = _dismountPoint;\n    };\n\n    _driverGroup move _dismountPointPos;\n\n    waitUntil {\n        if (\n            _vehicle distance _dismountPoint <= _completionRadius OR\n             !(alive _vehicle) OR\n             (isNull (driver _vehicle) OR\n              {!(_driver in _vehicle)})\n        ) exitWith {true};\n\n        sleep 1;\n        false\n    };\n\n    if (alive _vehicle) then {\n        [[\"_vehicle \",_vehicle,\" has reached its destination\"],false] call KISKA_fnc_log;\n\n        _crew apply {\n            [_x,_vehicle] remoteExecCall [\"leaveVehicle\",_x];\n        };\n    };\n\n    // enable HC transfer\n    [_driverGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n\n    [\n        [_vehicle,_crew,_crewGroups],\n        _codeOnComplete\n    ] call KISKA_fnc_callBack;\n\n};\n\n\ntrue\n",
    "fileName": "fn_driveTo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_dropOff\n\nDescription:\n    Tells a vehicle to move to a position and then drop off the specified units.\n\nParameters:\n    0: _vehicle : <OBJECT> - The vehicle that will drop of units\n    1: _dropOffPosition : <OBJECT or ARRAY> - The position to drop units off, can be object or position array\n    2: _unitsToDropOff : <GROUP, ARRAY, or OBJECT> - The units to drop off\n    3: _completionRadius : <NUMBER> - The radius at which the waypoint is complete and the units can disembark from the _dropOffPosition, -1 for exact placement\n    4: _speed : <STRING> - The for the driver group to move at\n    5: _codeOnComplete : <CODE, STRING, or ARRAY> - Code to run upon completion of disembark. See KISKA_fnc_callBack\n        \n        Params:\n        \n            - 0. <OBJECT> - The vehicle that will drop of units\n            - 1. <ARRAY> - The units dropped off at this location\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            myVehicle,\n            myPosition,\n            player\n        ] call KISKA_fnc_dropOff;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_dropOff\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_dropOffPosition\",objNull,[[],objNull]],\n    [\"_unitsToDropOff\",[],[[],grpNull,objNull]],\n    [\"_completionRadius\",10,[123]],\n    [\"_speed\",\"NORMAL\",[\"\"]],\n    [\"_codeOnComplete\",{},[{},\"\",[]]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _driver = driver _vehicle;\nif !(alive _driver) exitWith {\n    [\"_driver is null or dead, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _positionIsObject = _dropOffPosition isEqualType objNull;\nif (_positionIsObject AND (isNull _dropOffPosition)) exitWith {\n    [\"_dropOffPosition is null, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_positionIsObject) then {\n    _dropOffPosition = getPosATL _dropOffPosition;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Verify _unitsToDropOff parameter\n---------------------------------------------------------------------------- */\nif (_unitsToDropOff isEqualTo []) exitWith {\n    [\"_unitsToDropOff is empty, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_unitsToDropOff isEqualTypeAny [objNull,grpNull] AND {isNull _unitsToDropOff}) exitWith {\n    [\"_unitsToDropOff isNull, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_unitsToDropOff isEqualType grpNull) then {\n    _unitsToDropOff = units _unitsToDropOff;\n};\n\nif (_unitsToDropOff isEqualType objNull) then {\n    _unitsToDropOff = [_unitsToDropOff];\n};\n\nprivate _unitsToDropOffFiltered = [];\n\nif (_unitsToDropOff isEqualType []) then {\n    _unitsToDropOff apply {\n        if (_x isEqualType grpNull) then {\n            _unitsToDropOffFiltered append (units _x);\n        };\n\n        if (_x isEqualType objNull) then {\n            _unitsToDropOffFiltered pushBack _x;\n        };\n    };\n};\n\n\n/* ----------------------------------------------------------------------------\n    Main Function\n---------------------------------------------------------------------------- */\nprivate _driverGroup = group _driver;\n_driverGroup setSpeedMode _speed;\n// disable HC transfer while driving\n[_driverGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n[\n    _vehicle,\n    _unitsToDropOffFiltered,\n    _codeOnComplete,\n    _completionRadius,\n    _dropOffPosition,\n    _driver,\n    _driverGroup\n] spawn {\n    params [\n        \"_vehicle\",\n        \"_unitsToDropOffFiltered\",\n        \"_codeOnComplete\",\n        \"_completionRadius\",\n        \"_dropOffPosition\",\n        \"_driver\",\n        \"_driverGroup\"\n    ];\n\n\n    // Need to wait for driver to be ready to move\n    private _driver = driver _vehicle;\n    waitUntil {\n        if !(alive _driver) exitWith {true};\n        sleep 0.1;\n        unitReady _driver;\n    };\n\n    if (_driver in _vehicle) then {\n        _driverGroup move _dropOffPosition;\n    };\n\n    waitUntil {\n        if (\n            _vehicle distance _dropOffPosition <= _completionRadius OR\n            !(alive _vehicle) OR\n            (isNull (driver _vehicle) OR\n            {!(_driver in _vehicle)})\n        ) exitWith {true};\n\n        sleep 1;\n        false\n    };\n\n    if (alive _vehicle) then {\n        [[\"_vehicle \",_vehicle,\" has reached its destination\"],false] call KISKA_fnc_log;\n\n        _unitsToDropOffFiltered apply {\n            [_x,_vehicle] remoteExec [\"leaveVehicle\",_x];\n            [_x,_vehicle] remoteExec [\"moveOut\",_x];\n            sleep 0.5;\n        };\n\n        waitUntil {\n            if (\n                !alive _vehicle OR\n                {(_unitsToDropOffFiltered findIf {_x in _vehicle}) < 0}\n            ) exitWith {true};\n\n            sleep 1;\n            false\n        };\n    };\n\n    // enable HC transfer\n    [_driverGroup,false] call KISKA_fnc_ACEX_setHCTransfer;\n\n    [\n        [_vehicle,_unitsToDropOffFiltered],\n        _codeOnComplete\n    ] call KISKA_fnc_callBack;\n};\n\nnil\n",
    "fileName": "fn_dropOff.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_engageHeliTurretsLoop\n\nDescription:\n    Sets up a helicopter's turrets to be able to properly engage enemies without\n     without the pilot going crazy.\n\n    Starts a loop that will reveal targets within a given radius to gunners to engage.\n\n    You can use variables in the _heli's namepsace to adjust params dynamically:\n        \"KISKA_heliTurrets_endLoop\" - ends the function\n        \"KISKA_heliTurrets_sleepTime\" - adjusts the _sleepTime param\n        \"KISKA_heliTurrets_revealAccuracy\" - adjusts the _revealAccuracy param\n        \"KISKA_heliTurrets_detectionRadius\" - adjusts the _detectionRadius param\n        \"KISKA_heliTurrets_running\" - checks if the system is running\n\nParameters:\n    0: _heli : <OBJECT> - The helicopter to set up\n    1: _sleepTime : <NUMBER> - Time in between each \"refresh\" of the targets gunners are revealed\n    2: _revealAccuracy : <NUMBER> - The accuracy of the reveals of targets for gunners\n    3: _detectionRadius : <NUMBER> - The radius within to search for targets for the gunners\n    4: _skill : <NUMBER> - The skill of the vehicle crew\n    5: _makeInvulnerable : <BOOL> - Makes vehicle crew invulnerable or not\n    6: _turretsWithWeapons : <ARRAY> - If you've already found which turrets to regard as \"gunner\" turrets, pass their turret paths\n        or the function will get them.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            5,\n            4,\n            250,\n            1,\n            true\n        ] spawn KISKA_fnc_engageHeliTurretsLoop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_engageHeliTurretsLoop\";\n\n#define MIN_SLEEP_TIME 0.01\n#define EXIT_VAR_STR \"KISKA_heliTurrets_endLoop\"\n#define SLEEP_TIME_VAR_STR \"KISKA_heliTurrets_sleepTime\"\n#define REVEAL_ACC_VAR_STR \"KISKA_heliTurrets_revealAccuracy\"\n#define IS_RUNNING_VAR_STR \"KISKA_heliTurrets_running\"\n#define DETECT_RADIUS_VAR_STR \"KISKA_heliTurrets_detectionRadius\"\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled! Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_engageHeliTurretsLoop;\n};\n\n\nparams [\n    [\"_heli\",objNull,[objNull]],\n    [\"_sleepTime\",5,[123]],\n    [\"_revealAccuracy\",4,[123]],\n    [\"_detectionRadius\",250,[123]],\n    [\"_skill\",1,[123]],\n    [\"_makeInvulnerable\",false,[true]],\n    [\"_turretsWithWeapons\",[],[[]]]\n];\n\n\nif (isNull _heli) exitWith {\n    [\"A null object was passed\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    verify vehicle is compatible\n---------------------------------------------------------------------------- */\nprivate _aircraftType = typeOf _heli;\nif (_turretsWithWeapons isEqualTo []) then {\n    _turretsWithWeapons = [_aircraftType] call KISKA_fnc_classTurretsWithGuns;\n};\nif (_turretsWithWeapons isEqualTo []) exitWith {\n    [[_aircraftType,\" does not have properly configured turrets!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Prepare AI\n---------------------------------------------------------------------------- */\nprivate _turretUnits = [];\nprivate _turretSeperated = false;\nprivate _vehicleCrew = crew _heli;\nprivate _side = side (_vehicleCrew select 0);\n\n_vehicleCrew apply {\n    if (_makeInvulnerable) then {\n       _x allowDamage false;\n    };\n    _x setSkill _skill;\n\n    _x disableAI \"SUPPRESSION\";\n    _x disableAI \"RADIOPROTOCOL\";\n\n    // give turrets their own groups so that they can engage targets at will\n    if ((_heli unitTurret _x) in _turretsWithWeapons) then {\n    /*\n        About seperating one turret...\n        My testing has revealed that in order to have both turrets on a helicopter (if it has two)\n         engaging targets simultaneously, one needs to be in a seperate group from the pilot, and one\n         needs to be grouped with the pilot.\n    */\n        if !(_turretSeperated) then {\n            _turretSeperated = true;\n            private _group = createGroup _side;\n            [_x] joinSilent _group;\n            _group setCombatBehaviour \"COMBAT\";\n            _group setCombatMode \"RED\";\n        };\n        _turretUnits pushBack _x;\n    } else { // disable targeting for the other crew\n        _x disableAI \"AUTOCOMBAT\";\n        _x disableAI \"TARGET\";\n        //_x disableAI \"AUTOTARGET\";\n        _x disableAI \"FSM\";\n    };\n};\n\n// keep the pilots from freaking out under fire\nprivate _pilotsGroup = group (currentPilot _heli);\n_pilotsGroup setBehaviour \"CARELESS\"; // Only careless group will follow speed limit\n// the pilot group's combat mode MUST be a fire-at-will version as it adjusts it for the entire vehicle\n_pilotsGroup setCombatMode \"RED\";\n\n\n\n/* ----------------------------------------------------------------------------\n    Loop\n---------------------------------------------------------------------------- */\nprivate _fn_getTargets = {\n    (_heli nearEntities [[\"MAN\",\"CAR\",\"TANK\"],(_heli getVariable [DETECT_RADIUS_VAR_STR, _detectionRadius])]) select {\n        !(isAgent teamMember _x) AND\n        {[side _x, _side] call BIS_fnc_sideIsEnemy}\n    };\n};\n\n\nif (_sleepTime < MIN_SLEEP_TIME) then {\n    _sleepTime = MIN_SLEEP_TIME;\n};\n\n\n_heli setVariable [EXIT_VAR_STR,false];\n_heli setVariable [IS_RUNNING_VAR_STR,true];\n_heli setVariable [DETECT_RADIUS_VAR_STR, _detectionRadius];\n_heli setVariable [SLEEP_TIME_VAR_STR, _sleepTime];\n_heli setVariable [REVEAL_ACC_VAR_STR, _revealAccuracy];\n\n\nprivate _targetsInArea = [];\n// using waituntil to avoid running more then once a frame\nwaitUntil {\n    if (!(alive _heli) OR (_heli getVariable [EXIT_VAR_STR,false])) exitWith {true};\n\n    _targetsInArea = call _fn_getTargets;\n    if (_targetsInArea isNotEqualTo []) then {\n\n        _targetsInArea apply {\n            _currentTarget = _x;\n\n            _turretUnits apply {\n                if !(isNull _x) then {\n                    _x reveal [_currentTarget,(_heli getVariable [REVEAL_ACC_VAR_STR, _revealAccuracy])];\n                };\n            };\n\n        };\n\n    };\n\n    sleep (_heli getVariable [SLEEP_TIME_VAR_STR, _sleepTime]);\n\n    false\n};\n\n_heli setVariable [IS_RUNNING_VAR_STR,false];\n_heli setVariable [EXIT_VAR_STR,false];\n",
    "fileName": "fn_engageHeliTurretsLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_heliLand\n\nDescription:\n    Makes a helicopter land at a given position.\n\nParameters:\n    0: _aircraft <OBJECT> - The helicopter\n    1: _landingPosition <ARRAY or OBJECT> - Where to land. If object, position ATL is used.\n    2: _landMode <STRING> - Options are `\"LAND\"`, `\"GET IN\"`, and `\"GET OUT\"`\n    3: _createHelipad <BOOL> - If true, and invisible helipad will be created. Helipads strongly encourage where a unit will land.\n    4: _afterLandCode <CODE, STRING, or ARRAY> - Code to spawn after the helicopter has landed. See KISKA_fnc_callBack\n        \n        Parameters:\n        - 0: <OBJECT> - The helicopter\n\nReturns:\n    <BOOL> - True if helicopter can attempt, false if problem\n\nExamples:\n    (begin example)\n        [myHeli,position player] call KISKA_fnc_heliLand;\n    (end)\n\nAuthor:\n    Karel Moricky,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_heliLand\";\n\n#define HELIPAD_BASE \"Helipad_base_F\"\n#define INVISIBLE_PAD_TYPE \"Land_HelipadEmpty_F\"\n#define LAND_EVENT \"KISKA_landedEvent\"\n#define HIGH_LANDED_THRESHOLD 3\n\nparams [\n    [\"_aircraft\",objNull,[objNull]],\n    [\"_landingPosition\",[],[[],objNull]],\n    [\"_landMode\",\"LAND\",[\"\"]],\n    [\"_createHelipad\",true,[true]],\n    [\"_afterLandCode\",{},[{},\"\",[]]]\n];\n\nif (isNull _aircraft) exitWith {\n    [\"_aircraft is a null object\",true] call KISKA_fnc_log;\n    false\n};\n\nif (!(_aircraft isKindOf \"Helicopter\") AND {!(_aircraft isKindOf \"VTOL_Base_F\")}) exitWith {\n    [[_aircraft,\" is not a helicopter or VTOL, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\n// disable aceX hc transfer\n[group (currentPilot _aircraft),true] call KISKA_fnc_ACEX_setHCTransfer;\n\n// move command only supports positions, not objects\nif (_landingPosition isEqualType objNull) then {\n    // if LZ is already a pad, don't create another one\n    if (_createHelipad AND {_landingPosition isKindOf HELIPAD_BASE}) then {\n        _createHelipad = false;\n    };\n    _landingPosition = getPosATL _landingPosition;\n};\n\n// helipads are where AI will primarly look to land\nif (_createHelipad) then {\n    INVISIBLE_PAD_TYPE createVehicle _landingPosition;\n};\n\nprivate _keepEngineOn = false;\nprivate _landedHeight = 0.1;\n_landMode = toUpperANSI _landMode;\nif (_landMode isNotEqualTo \"LAND\") then {\n    switch (_landMode) do {\n        case \"GET IN\";\n        case \"GET OUT\": {\n            _keepEngineOn = true;\n            _landedHeight = HIGH_LANDED_THRESHOLD;\n        };\n\n        default {\n            [[\"Unknown land type: \", _landMode,\" used for aircraft: \",_aircraft,\" . Changing to mode 'LAND'\"],true] call KISKA_fnc_log;\n            _landMode = \"LAND\";\n        };\n    };\n};\n\n\n[_aircraft,_landingPosition,_landMode,_afterLandCode,_keepEngineOn,_landedHeight] spawn {\n    params [\"_aircraft\",\"_landingPosition\",\"_landMode\",\"_afterLandCode\",\"_keepEngineOn\",\"_landedHeight\"];\n\n    _aircraft move _landingPosition;\n    _aircraft setVariable [\"KISKA_isLanding\",true];\n\n    private _landed = false;\n    private _wasToldToLand = false;\n    private \"_unitAlt\";\n    waitUntil {\n        sleep 1;\n        if (!alive _aircraft) exitWith {true};\n        // to interrupt a landing aircraft\n        if (_aircraft getVariable [\"KISKA_cancelLanding\",false]) exitWith {true};\n\n        if !(_wasToldToLand) then {\n            // tell unit to land at position when ready\n            if (unitReady _aircraft) then {\n                _aircraft land _landMode;\n                _wasToldToLand = true;\n            };\n\n        } else {\n            _unitAlt = (getPosATL _aircraft) select 2;\n            if (isTouchingGround _aircraft OR (_unitAlt <= _landedHeight)) then {\n                _landed = true;\n                // reinforce land\n                // sometimes, the helicopter will \"land\" but immediately take off again\n                // this is why the thing is told to land again\n                sleep 2;\n                _aircraft land _landMode;\n\n                if (_keepEngineOn) then {\n                    _aircraft engineon true;\n                };\n            };\n\n        };\n\n        _landed\n    };\n\n    // variable to track if other code can run\n    _aircraft setVariable [\"KISKA_cancelLanding\",false];\n    _aircraft setVariable [\"KISKA_isLanding\",false];\n\n    [[_aircraft],_afterLandCode] call KISKA_fnc_callBack;\n    [_aircraft,LAND_EVENT,[_aircraft]] call BIS_fnc_callScriptedEventHandler;\n};\n\n\ntrue\n",
    "fileName": "fn_heliLand.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_heliPatrol\n\nDescription:\n    Has a helicopter patrol looking for enemy men.\n    If \"spotted\", the helicopter will land in a safe area and drop off infantry if onboard.\n    It will then move to engage the units if it has weapons or just stalk them if not.\n    The infantry will continually stalk the unit until dead.\n\nParameters:\n    0: _helicopter <OBJECT> - The patrolling helicopter\n    1: _patrolPoints <ARRAY> - An Array of patrol points (OBJECTs or positions)\n    2: _spotDistance3D <NUMBER> - How far away can the helicopter spot a player\n    3: _patrolHeight <NUMBER> - What's the flying height of the helicopter\n    4: _patrolSpeed <STRING> - setWaypointSpeed, takes \"UNCHANGED\", \"LIMITED\", \"NORMAL\", and \"FULL\"\n    5: _randomPatrol <BOOL> - Should patrol points be randomized or followed in array order\n\n\nReturns:\n    <BOOL> - True if helicopter will patrol, false if problem encountered\n\nExamples:\n    (begin example)\n        [heli,[logic1,logic2,logic3],500,200,false] call KISKA_fnc_heliPatrol;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_heliPatrol\";\n\nparams [\n    [\"_helicopter\",objNull,[objNull]],\n    [\"_patrolPoints\",[],[[]]],\n    [\"_spotDistance3D\",800,[123]],\n    [\"_patrolHeight\",100,[123]],\n    [\"_patrolSpeed\",\"NORMAL\",[\"\"]],\n    [\"_randomPatrol\",true,[true]]\n];\n\nif (isNull _helicopter) exitWith {\n    [\"_helicopter is a null object\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_patrolHeight > _spotDistance3D) exitWith {\n    [[_patrolHeight,\" is higher then \",_spotDistance3D,\". The helicopter can't spot anything\"],true] call KISKA_fnc_log;\n    false\n};\n\nif !(_patrolPoints isEqualTypeAny [objNull,[]]) exitWith {\n    [[_patrolPoints,\" need to be either positions or objects, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _pilot = currentPilot _helicopter;\n\nif (isNull _pilot) exitWith {\n    [[\"No pilot found in \",_helicopter],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _helicopterGroup = group _pilot;\n[_helicopterGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n_helicopter flyInHeight _patrolHeight;\n\n[_helicopterGroup,_patrolPoints,count _patrolPoints,_randomPatrol,\"SAFE\",_patrolSpeed,\"WHITE\"] call KISKA_fnc_patrolSpecific;\n\n\n\n[_helicopter,_spotDistance3D,_helicopterGroup] spawn {\n    params [\"_helicopter\",\"_spotDistance3D\",\"_helicopterGroup\"];\n\n    // search for targets\n    private [\"_targets\",\"_foundTargetIndex\"];\n    private _helicopterSide = side _helicopterGroup;\n    waitUntil {\n        _targets = _helicopter nearEntities [\"MAN\",_spotDistance3D];\n        _foundTargetIndex = _targets findIf {\n                ([side _x,_helicopterSide] call BIS_fnc_sideIsEnemy) AND\n                {(_x distance _helicopter) <= _spotDistance3D} AND\n                {side _x != Civilian}\n            };\n        if (_foundTargetIndex isNotEqualTo -1) exitWith {true};\n        sleep 4;\n        false\n    };\n    // Move to land\n    private _foundTarget = _targets select _foundTargetIndex;\n    private _foundTargetPosition = getPosATL _foundTarget;\n\n    private _landingZone = [_foundTarget,300,500,5,0,0,0,[],[_foundTargetPosition,_foundTargetPosition]] call BIS_fnc_findSafePos;\n    _landingZone pushBack 0;\n\n    [_helicopterGroup] call KISKA_fnc_clearWaypoints;\n    [_helicopterGroup,_landingZone,0,\"TR UNLOAD\",\"AWARE\",\"WHITE\",\"NORMAL\"] call CBA_fnc_addwaypoint;\n\n\n    // waituntil the helicopter is about to land\n    waitUntil {\n        sleep 2;\n        ((getPosATLVisual _helicopter select 2) < 2)\n    };\n    // tell all groups that in the aircraft that aren't crew to stalk the target group\n    private _targetGroup = group _foundTarget;\n    private _groups = [];\n    (crew _helicopter) apply {\n        private _group = group _x;\n        if (!(_group in _groups) AND {_group isNotEqualTo _helicopterGroup}) then {\n            _groups pushBack _group\n        };\n    };\n    _groups apply {\n        [_x,_targetGroup] spawn BIS_fnc_stalk;\n        _x setCombatMode \"YELLOW\";\n    };\n\n\n    // Wait for all passengers to be out\n    private _helicopterGroupCount = count (units _helicopterGroup);\n    waitUntil {\n        if (count (crew _helicopter) <= _helicopterGroupCount) exitWith {true};\n        sleep 1;\n        false\n    };\n\n    // tell the helicopter to engage the target\n    [_helicopterGroup,_targetGroup] spawn BIS_fnc_stalk;\n    _helicopterGroup setCombatMode \"RED\";\n};\n\n\ntrue\n",
    "fileName": "fn_heliPatrol.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hover\n\nDescription:\n    Sends a vehicle to a given point to hover.\n\n    Pilots should ideally be placed in \"CARELESS\" behaviour when around enemies.\n\nParameters:\n    0: _vehicle <OBJECT> - The helicopter/vtol to hover\n    1: _hoverPosition <PositionASL[] or OBJECT> - The positionASL to drop the units off at; Z coordinate\n        matters\n    2: _shouldHoverStop <CODE> - Code that should return a boolean to determine if the vehicle should stop its hover.\n        This condition is checked every 0.05s.\n        \n        Parameters:\n        - 0: _vehicle - The drop vehicle\n        - 1: _pilot - The currentPilot of _vehicle\n\n    3: _onHoverEnd <CODE, STRING, or ARRAY> - Code that executes after the hover completes, see KISKA_fnc_callBack\n        This condition is checked every 0.05s.\n        \n        Parameters:\n        - 0: _vehicle - The drop vehicle\n        - 1: _pilot - The currentPilot of _vehicle\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n\t\t\tmyHeli,\n\t\t\tmyHoverPositionASL,\n\t\t\t{\n\t\t\t\tlocalNamespace getVariable [\"stopMyHover\",false]\n\t\t\t},\n\t\t\t{\n\t\t\t\thint \"after hover\";\n\t\t\t}\n        ] call KISKA_fnc_hover;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hover\";\n\n#define HOVER_INTERVAL 0.05\n#define START_VELOCITY_CONTROL_DISTANCE 400\n#define DEFAULT_VELOCITY_MAGNITUDE 50\n#define MAX_DECELERATION_SPEED 10\n#define ACCELERATION_INCREMENT 0.25\n#define DISTANCE_TO_DISABLE_PILOT_AI 25\n#define DISTANCE_TO_STOP_VELOCITY_ADJUSTMENT 2.5\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_hoverPosition\",[],[objNull,[]],3],\n    [\"_shouldHoverStop\",{false},[{}]],\n    [\"_onHoverEnd\",{},[\"\",{},[]]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _hoverPositionIsObject = _hoverPosition isEqualType objNull;\nif (_hoverPositionIsObject AND { isNull _hoverPosition }) exitWith {\n    [\"null _hoverPosition passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_hoverPositionIsObject) then {\n    _hoverPosition = getPosASL _hoverPosition;\n};\n\n\nprivate _vehicleGroup = group (commander _vehicle);\n_vehicleGroup allowFleeing 0;\nprivate _pilot = driver _vehicle;\n_pilot setSkill 1;\n_pilot move (ASLToATL _hoverPosition);\n\n\n// guides helicopter to drop position\n[\n    {\n        params [\"_args\", \"_id\"];\n        _args params [\n            \"_vehicle\",\n            \"_hoverPosition\",\n            \"_shouldHoverStop\",\n\t\t\t\"_onHoverEnd\"\n        ];\n        \n        private _pilot = currentPilot _vehicle;\n        if (\n            !(alive _vehicle) OR\n            !(alive _pilot) OR\n            { \n\t\t\t\t[_vehicle,_pilot] call _shouldHoverStop \n\t\t\t}\n        ) exitWith {\n            if (_pilot getVariable [\"KISKA_hover_hoverAiDisabled\",true]) then {\n                _pilot setVariable [\"KISKA_hover_hoverAiDisabled\",nil];\n                [_pilot,\"PATH\"] remoteExecCall [\"enableAI\",_pilot];\n            };\n\n\t\t\tif (_onHoverEnd isNotEqualTo {}) then {\n\t\t\t\t[[_vehicle,_pilot],_onHoverEnd] call KISKA_fnc_callBack;\n\t\t\t};\n\n            [_id] call CBA_fnc_removePerFrameHandler;\n        };\n        \n        private _currentVehiclePosition_ASL = getPosASLVisual _vehicle;\n        private _distanceToHoverPosition = _currentVehiclePosition_ASL vectorDistance _hoverPosition;\n\n        if (_distanceToHoverPosition > START_VELOCITY_CONTROL_DISTANCE) exitWith {};\n\n        if (isNil {_vehicle getVariable \"KISKA_hoverTransformStart_speed\"}) then {\n            _vehicle setVariable [\"KISKA_hoverTransformStart_speed\",(speed _vehicle) / 3.6];\n        };\n\n        private _speed = _vehicle getVariable \"KISKA_hoverTransformStart_speed\";\n        private _velocityMagnitude = DEFAULT_VELOCITY_MAGNITUDE;\n\n        private _withinAccelerationArea = _distanceToHoverPosition > 100;\n        if (_withinAccelerationArea) then {\n            if (_speed < _velocityMagnitude) then {\n                _speed = _speed + ACCELERATION_INCREMENT;\n                _vehicle setVariable [\"KISKA_hoverTransformStart_speed\",_speed];\n            };\n\n        } else {\n            _speed = (_speed - 1) max MAX_DECELERATION_SPEED;\n            _vehicle setVariable [\"KISKA_hoverTransformStart_speed\",_speed];\n\n        };\n\n\n        if (\n            (_distanceToHoverPosition <= DISTANCE_TO_DISABLE_PILOT_AI) AND\n            (_pilot checkAIFeature \"PATH\")\n        ) then {\n            [_pilot,\"PATH\"] remoteExecCall [\"disableAI\",_pilot];\n            _pilot setVariable [\"KISKA_hover_hoverAiDisabled\",true];\n        };\n\n        _velocityMagnitude = _speed;\n        if ((_currentVehiclePosition_ASL distance2d _hoverPosition) >= DISTANCE_TO_STOP_VELOCITY_ADJUSTMENT) then {\n            if ( _distanceToHoverPosition <= 15 ) then {\n                _velocityMagnitude = (_distanceToHoverPosition / 10) * 5;\n\n            };\n\n            private _currentVelocity = velocity _vehicle;\n            _currentVelocity = (_currentVehiclePosition_ASL vectorFromTo _hoverPosition) vectorMultiply _velocityMagnitude;\n            _vehicle setVelocity _currentVelocity;\n\n        };\n\n    },\n    HOVER_INTERVAL,\n    [\n        _vehicle,\n        _hoverPosition,\n        _shouldHoverStop,\n        _onHoverEnd\n    ]\n] call CBA_fnc_addPerFrameHandler;\n\n\nnil\n",
    "fileName": "fn_hover.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_initDynamicSimConfig\n\nDescription:\n    Initializes the dynamic simulation system with the given values based on\n     mission config values.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        POST-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_initDynamicSimConfig\";\n\nprivate _dynamicSimConfig = missionConfigFile >> \"KISKA_dynamicSimulation\";\nif (isNull _dynamicSimConfig) exitWith {\n    [\"_dynamicSimConfig at missionConfigFile >> 'KISKA_dynamicSimulation', is null\",false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _enableSystem = [_dynamicSimConfig >> \"enableDynamicSimulation\"] call BIS_fnc_getCfgDataBool;\nenableDynamicSimulationSystem _enableSystem;\n\n\nprivate _coefConfig = _dynamicSimConfig >> \"Coef\";\nprivate _coefProperties = [\"IsMoving\"];\n_coefProperties apply {\n    private _propertyConfig = _coefConfig >> _x;\n    if !(isNumber _propertyConfig) then {\n        [[_x,\" was not defined (as number) in the missionConfigFile >> KISKA_dynamicSimulation >> Coef class\"],false] call KISKA_fnc_log;\n        continue;\n    };\n\n    _x setDynamicSimulationDistanceCoef (getNumber _propertyConfig);\n};\n\n\nprivate _activationDistanceConfig = _dynamicSimConfig >> \"ActivationDistance\";\nprivate _distanceProperties = [\"Group\",\"Vehicle\",\"EmptyVehicle\",\"Prop\"];\n_distanceProperties apply {\n    private _propertyConfig = _activationDistanceConfig >> _x;\n    if !(isNumber _propertyConfig) then {\n        [[_x,\" was not defined (as number) in the missionConfigFile >> KISKA_dynamicSimulation >> ActivationDistance class\"],false] call KISKA_fnc_log;\n        continue;\n    };\n\n    _x setDynamicSimulationDistance (getNumber _propertyConfig);\n};\n\n\nnil",
    "fileName": "fn_initDynamicSimConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_lookHere\n\nDescription:\n    Takes objects and sets their direction towards the nearest object or position within a set\n\nParameters:\n    0: _objectsToRotate <OBJECT or ARRAY> - The objects to setDir on \n    1: _positionsToLookAt <OBJECT or ARRAY> - The positions or objects to search for nearest\n    2: _setDirection <BOOL> - Also set objects direction relative to the look position\n\nReturns:\n    BOOL\n\nExamples:\n    (begin example)\n        [player,[[0,0,0]]] call KISKA_fnc_lookHere;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_lookHere\";\n\nparams [\n    [\"_objectsToRotate\",[],[objNull,[]]],\n    [\"_positionsToLookAt\",[],[objNull,[]]],\n    [\"_setDirection\",true,[true]]\n];\n\nif (_objectsToRotate isEqualTo [] OR {_objectsToRotate isEqualType objNull AND {isNull _objectsToRotate}}) exitWith {\n    [\"_objectsToRotate is undefined\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_objectsToRotate isEqualtype objNull) then {\n    _objectsToRotate = [_objectsToRotate];\n};\n\n_objectsToRotate apply {\n    private _nearestPosition = [_positionsToLookAt,_x] call BIS_fnc_nearestPosition;\n    \n    if (_setDirection) then {\n        _x setDir (_x getRelDir _nearestPosition);\n    };\n    \n    _x doWatch _nearestPosition;\n};\n\n\ntrue",
    "fileName": "fn_lookHere.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_patrolSpecific\n\nDescription:\n    Creates a cycle of waypoints for a patrol using a predetermined set of possible points\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group or unit to give waypoints to\n    1: _postions <ARRAY> - An array of possible positions to patrol between, can be either positions or objects\n    2: _numWaypoints <NUMBER> - The number of waypoints, use -1 to patrol all given positions\n\n    (Optional)\n    3: _random <BOOL> - Should waypoints be randomized from _positions array\n    4: _behaviour <STRING> - setWaypointBehaviour, takes \"UNCHANGED\", \"SAFE\", \"COMBAT\", \"AWARE\", \"CARELESS\", and \"STEALTH\"\n    5: _speed <STRING> - setWaypointSpeed, takes \"UNCHANGED\", \"LIMITED\", \"NORMAL\", and \"FULL\"\n    6: _combatMode <STRING> - setWaypointCombatMode, takes \"NO CHANGE\", \"BLUE\", \"GREEN\", \"WHITE\", \"YELLOW\", and \"RED\"\n    7: _formation <STRING> - setWaypointFormation, takes \"NO CHANGE\", \"COLUMN\", \"STAG COLUMN\", \"WEDGE\", \"ECH LEFT\", \"ECH RIGHT\", \"VEE\", \"LINE\", \"FILE\", and \"DIAMOND\"\n\nReturns:\n    <BOOL> - True if units will patrol, false if problem encountered\n\nExamples:\n    (begin example)\n        [_group,_positionsArray,5] call KISKA_fnc_patrolSpecific;\n    (end)\n\nAuthor:\n    Ansible2,\n    Spectre\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_patrolSpecific\";\n\nparams [\n    [\"_group\",grpNull,[grpNull,objNull]],\n    [\"_positions\",[],[[]]],\n    [\"_numWaypoints\",-1,[1]],\n    [\"_random\",true,[true]],\n    [\"_behaviour\",\"SAFE\",[\"\"]],\n    [\"_speed\",\"LIMITED\",[\"\"]],\n    [\"_combatMode\",\"RED\",[\"\"]],\n    [\"_formation\",\"STAG COLUMN\",[\"\"]]\n];\n\nif !(local _group) exitWith {\n    [[\"Found that \",_group,\" was not local, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (isNull _group) exitwith {\n    [[\"Found that \",_group,\" was null, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (_numWaypoints < 0) then {\n    _numWaypoints = count _positions;\n};\nif (_numWaypoints < 2) exitwith {\n    [[_numWaypoints,\" is not above 2, needs to be atleast 2, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (_positions isEqualTo []) exitwith {\n    [[_positions,\". No positions passed, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif ((count _positions) < 1) exitwith {\n    [[_positions,\". Need more positions to be passed. Exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\n\n[_group] call KISKA_fnc_clearWaypoints;\n\nprivate \"_cyclePosition\";\n\nfor \"_i\" from 1 to _numWaypoints do {\n    private \"_selectedPosition\";\n    private \"_waypoint\";\n\n    if (_random) then {\n        _selectedPosition = [_positions] call KISKA_fnc_deleteRandomIndex;\n        _waypoint = _group addWaypoint [_selectedPosition,0];\n    } else {\n        _selectedPosition = _positions select (_i - 1);\n        _waypoint = _group addWaypoint [_selectedPosition,0];\n    };\n\n    if (_i isEqualTo 1) then {\n        _cycleposition = _selectedPosition;\n    };\n\n    _waypoint setWaypointType \"MOVE\";\n    [_waypoint,_behaviour] remoteExec [\"setWaypointBehaviour\",2];\n    [_waypoint,_formation] remoteExec [\"setWaypointFormation\",2];\n    [_waypoint,_speed] remoteExec [\"setWaypointSpeed\",2];\n    _waypoint setWaypointCombatMode _combatMode;\n};\n\n\n_cycleWaypoint = _group addWaypoint [_cyclePosition,0];\n_cycleWaypoint setWaypointType \"CYCLE\";\n\n\ntrue\n",
    "fileName": "fn_patrolSpecific.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_setCrew\n\nDescription:\n    Moves units into a vehicle as crew and then as passengers.\n\nParameters:\n    0: _crew : <GROUP, ARRAY, or OBJECT> - The units to move into the vehicle\n    1: _vehicle : <OBJECT> - The vehicle to put units into\n    2: _deleteCrewIfNull : <BOOL> - If the vehicle turns out to be null, the provided crew will be deleted\n\nReturns:\n    <BOOL> - True if crew was set, false if problem encountered\n\nExamples:\n    (begin example)\n        [_group1,_vehicle] call KISKA_fnc_setCrew;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setCrew\";\n\nparams [\n    [\"_crew\",grpNull,[[],grpNull,objNull]],\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_deleteCrewIfNull\",true,[true]]\n];\n\nif (_crew isEqualType grpNull) then {\n    _crew = units _crew\n};\n\nif (_crew isEqualType objNull) then {\n    _crew = [_crew]\n};\n\nif (_crew isEqualTo []) exitWith {\n    [[\"Found that vehicle crew is empty, exiting...\"],true] call KISKA_fnc_log;\n    false\n};\n\nif !(alive _vehicle) exitWith {\n    [[\"Found that \",_vehicle,\" is either null or dead already, exiting...\"]] call KISKA_fnc_log;\n\n    if (_deleteCrewIfNull) then {\n        [[\"Deleting crew of null vehicle: \",_crew]] call KISKA_fnc_log;\n        _crew apply {\n            deleteVehicle _x;\n        };\n    };\n\n    false\n};\n\n\n// crew moved in too fast after init seems to be unreliable\n// they may not end up in the vehicle\n// if this happens, delay the calling of this function slightly\n_crew apply {\n    if (alive _x) then {\n        private _movedIn = _x moveInAny _vehicle;\n\n        if !(_movedIn) then {\n            [[\"Deleted excess unit: \",_x]] call KISKA_fnc_log;\n            deleteVehicle _x\n        };\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_setCrew.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_slingLoad\n\nDescription:\n    Tells AI helicopter to pick up a given object and drop it off at a given location.\n\nParameters:\n    0: _heli : <OBJECT> - Helicopter with pilot to perform slingload\n    1: _liftObject : <OBJECT> - The object to sling load\n    2: _dropOffPoint : <ARRAY, OBJECT, LOCATION, or GROUP> - Where to drop the _liftObject off at\n    3: _afterDropCode : <ARRAY, CODE, or STRING> - Code to execute after the drop off waypoint is complete.\n        This is saved to the pilot's namespace in \"KISKA_postSlingLoadCode\" which is deleted after\n        it is called. (See KISKA_fnc_callBack)\n            \n        Parmeters:\n        - 0. <OBJECT> - The pilot of the helicopter\n        - 1. <OBJECT> - The helicopter\n                \n    4: _flightPath : <(PositionASL | OBJECT | LOCATION | GROUP)[]> - An array of sequential positions\n        the aircraft must travel prior to droping off the _liftObject\n\nReturns:\n    <ARRAY> -\n        0: <OBJECT> - The pilot\n        1: <GROUP> - Pilot's group\n        2: <ARRAY> - Generated waypoints\n\nExamples:\n    (begin example)\n        [\n            heli,\n            someObject,\n            dropOff,\n            [\n                [heli],\n                {\n                    hint str [_this,_thisArgs]\n                }\n            ]\n        ] call KISKA_fnc_slingLoad;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_slingLoad\";\n\n// TODO: this may need to be a gradient\n#define LIMIT_SPEED_DISTANCE 200\n#define DISTANCE_STEP_SIZE 50\n#define SPEED_STEP_SIZE 5\n\nparams [\n    [\"_heli\",objNull,[objNull]],\n    [\"_liftObject\",objNull,[objNull]],\n    [\"_dropOffPoint\",objNull,[[],objNull,grpNull,locationNull]],\n    [\"_afterDropCode\",{},[[],{},\"\"]],\n    [\"_flightPath\",[],[[]]]\n];\n\n/* ----------------------------------------------------------------------------\n    Verify Params\n---------------------------------------------------------------------------- */\nif !(alive _heli) exitWith {\n    [\"_heli is not alive! Exiting...\", true] call KISKA_fnc_log;\n    []\n};\n\nprivate _pilot = currentPilot _heli;\nif !(alive _pilot) exitWith {\n    [[_heli,\"'s pilot is not alive! Exiting...\"], true] call KISKA_fnc_log;\n    []\n};\n\nif !(alive _liftObject) exitWith {\n    [\"_liftObject is dead, will not lift...\"] call KISKA_fnc_log;\n    []\n};\n\nif !(_heli canSlingLoad _liftObject) exitWith {\n    [[_heli,\" can't lift \",_liftObject], true] call KISKA_fnc_log;\n    []\n};\n\nprivate _dropOffPointIsInvalid = (\n    (_dropOffPoint isEqualTypeAny [grpNull,locationNull,objNull] AND\n    {isNull _dropOffPoint}) OR\n    (_dropOffPoint isEqualTo [])\n);\n\nif (_dropOffPointIsInvalid) exitWith {\n    [\"Invalid _dropOffPoint provided\",true] call KISKA_fnc_log;\n    []\n};\n\n\n/* ----------------------------------------------------------------------------\n    Add waypoints\n---------------------------------------------------------------------------- */\nprivate _group = group _pilot;\n[_group] call KISKA_fnc_clearWaypoints;\n\n\n/* -------------------------------------\n    Handle Speed\n------------------------------------- */\nprivate _distanceToCargo2d = _heli distance2D _liftObject;\nif (_distanceToCargo2d <= LIMIT_SPEED_DISTANCE) then {\n\n    if !([\"KISKA_limitSpeed\"] call KISKA_fnc_managedRun_isDefined) then {\n        [\n            \"KISKA_limitSpeed\",\n            {\n                params [\n                    [\"_vehicle\",objNull,[objNull]],\n                    [\"_speed\",-1,[123]]\n                ];\n                _vehicle limitSpeed _speed;\n            }\n        ] call KISKA_fnc_managedRun_updateCode;\n    };\n\n    private _speedLimit = ((_distanceToCargo2d / DISTANCE_STEP_SIZE) * SPEED_STEP_SIZE) min SPEED_STEP_SIZE;\n    private _limitSpeedId = [\n        \"KISKA_limitSpeed\",\n        [_heli,_speedLimit],\n        _heli\n    ] call KISKA_fnc_managedRun_execute;\n\n    _pilot setVariable [\"KISKA_slingLoad_limitSpeedId\",_limitSpeedId];\n};\n\n/* -------------------------------------\n    Hook cargo\n------------------------------------- */\n_pilot setVariable [\"KISKA_slingLoad_onHook\",{\n    params [\"_pilot\"];\n\n    private _heli = objectParent _pilot;\n    private _limitSpeedId = _pilot getVariable [\"KISKA_slingLoad_limitSpeedId\",-1];\n    if (_limitSpeedId >= 0) then {\n        [\n            \"KISKA_limitSpeed\",\n            // BOHEMIA BUG: wiki states that -1 will remove a speed limit, however, at least for helicopters, that does not seem to be the case\n            [_heli,999999],\n            _heli,\n            _limitSpeedId\n        ] call KISKA_fnc_managedRun_execute;\n    };\n\n    _pilot setVariable [\"KISKA_slingLoad_limitSpeedId\",nil];\n}];\n\n[\n    _group,\n    _liftObject,\n    -1,\n    \"HOOK\",\n    \"SAFE\",\n    \"BLUE\",\n    \"UNCHANGED\",\n    \"NO CHANGE\",\n    \"[this] call (this getVariable ['KISKA_slingLoad_onHook',{}]); this setVariable ['KISKA_slingLoad_onHook',nil];\"\n] call CBA_fnc_addWaypoint;\n\n\n/* -------------------------------------\n    Drop off\n------------------------------------- */\nif (_flightPath isNotEqualTo []) then {\n    _flightPath apply {\n        [\n            _group,\n            _x,\n            -1,\n            \"MOVE\"\n        ] call CBA_fnc_addWaypoint;\n    };\n};\n\n_pilot setVariable [\"KISKA_postSlingLoadCode\",_afterDropCode];\n_pilot setVariable [\"KISKA_slingLoad_onUnhook\",{\n    params [\"_pilot\"];\n\n    private _heli = objectParent _pilot;\n    private _afterDropCode = _pilot getVariable ['KISKA_postSlingLoadCode',{}]; \n    [[_pilot,_heli],_afterDropCode] call KISKA_fnc_callBack; \n\n    _pilot setVariable ['KISKA_postSlingLoadCode',nil];\n}];\n\n[\n    _group,\n    _dropOffPoint,\n    -1,\n    \"UNHOOK\",\n    \"UNCHANGED\",\n    \"NO CHANGE\",\n    \"UNCHANGED\",\n    \"NO CHANGE\",\n    \"[this] call (this getVariable ['KISKA_slingLoad_onUnhook',{}]); this setVariable ['KISKA_slingLoad_onUnhook',nil];\"\n] call CBA_fnc_addWaypoint;\n\n\n[_pilot, _group, waypoints _group];\n",
    "fileName": "fn_slingLoad.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spawn\n\nDescription:\n    Randomly spawns units on an array of positions.\n\n    PositionATL is expected and arrays can have 4 indexes with a direction for the\n     unit to face being the 4th. If no direction is specified, a random one is chosen.\n     Using an object instead of a position will result in the unit facing the same way\n     that the object is.\n\n    This is destructive on the _spawnPositions array so be sure to copy (+_spawnPositions)\n     if you need to reuse the array.\n\nParameters:\n    0: _numberOfUnits <NUMBER> - Number of units to spawn, if -1, all provided positions\n        will be filled\n    1: _numberOfUnitsPerGroup <NUMBER> - Number of units per group\n    2: _unitTypes <ARRAY> - Unit types to select randomly from (can be weighted or unweighted array)\n    3: _spawnPositions <ARRAY> - List of positions at which units will randomly spawn, the array can be positions and/or objects.\n        If given an empty array, all units will spawn at [0,0,0]\n\n    4: _canUnitsMove <BOOL> - Can units walk (optional)\n    5: _enableDynamic <BOOL> - Should the units be dynamically simmed (Optional)\n    6: _side <SIDE> - Side of units (optional)\n    7: _allowedStances <STRING[] or (STRING,NUMBER)[]> - A weighted or unweighted array of setUnitPos compatible \n     values that the units will be randomly set to (`[\"up\",0.7,\"middle\",0.3]` by default) (optional)\n\nReturns:\n    <OBJECT[]> - All units spawned by the function\n\nExamples:\n    (begin example)\n        _spawnedUnits = [2, 2, _arrayOfTypes, [[0,0,0],spawnObject]] call KISKA_fnc_spawn;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spawn\";\n\nparams [\n    [\"_numberOfUnits\",1,[1]],\n    [\"_numberOfUnitsPerGroup\",1,[1]],\n    [\"_unitTypes\",[\"O_Soldier_F\"],[[]]],\n    [\"_spawnPositions\",[],[[]]],\n\n    [\"_canUnitsMove\",false,[true]],\n    [\"_enableDynamic\",true,[true]],\n    [\"_side\",OPFOR,[sideUnknown]],\n    [\"_allowedStances\",[\"up\",0.7,\"middle\",0.3],[[]]]\n];\n\n// Verify Params\n// Is there at least on position to spawn on\nif (count _spawnPositions < 1) then {\n    for \"_i\" from 1 to _numberOfUnits do {\n        _spawnPositions pushBack [0,0,0];\n    };\n};\n\n\nif (_numberOfUnits isEqualTo -1) then {\n    _numberOfUnits = count _spawnPositions;\n};\n\nif (_numberOfUnitsPerGroup isEqualTo -1) then {\n    _numberOfUnitsPerGroup = _numberOfUnits;\n};\n\n// Check atleast one unit to spawn\nif (_numberOfUnits < 1) exitWith {\n    [[\"_numberOfUnits is \",_numberOfUnits,\" needs to be atleast 1. Exiting...\"],true] call KISKA_fnc_log;\n    []\n};\n\nif (_allowedStances isEqualTo []) exitWith {\n    [[\"_allowedStances is empty!\"],true] call KISKA_fnc_log;\n    []\n};\n\n// Re adjust number of units if there are not enough spawn points\nif (count _spawnPositions < _numberOfUnits) then {\n    [[\"Count of _spawnPositions is \",_spawnPositions,\" and _numberOfUnits is \",_numberOfUnits,\" ReAdjusting _numberOfUnits to _spawnPositions\"]] call KISKA_fnc_log;\n\n    _numberOfUnits = count _spawnPositions;\n};\n\n\n// filter out bad unit types\nprivate _unitTypesFiltered = [];\nprivate _weightedArray = _unitTypes isEqualTypeParams [\"\",1];\n{\n    if (_x isEqualType \"\") then {\n        if (isClass (configFile >> \"cfgVehicles\" >> _x) OR {isClass (missionConfigFile >> \"cfgVehicles\" >> _x)}) then {\n            _unitTypesFiltered pushBack _x;\n\n            if (_weightedArray) then {\n                _unitTypesFiltered pushBack (_unitTypes select (_forEachIndex + 1));\n            };\n        } else {\n            [[\"Found invalid class \",_x]] call KISKA_fnc_log;\n        };\n    };\n} forEach _unitTypes;\n\n// exit if no valid types\nif (_unitTypesFiltered isEqualTo []) exitWith {\n    [[\"Did not find any valid unit types in \",_unitTypes],true] call KISKA_fnc_log;\n    []\n};\n\n\n\n// create units\nprivate _spawnedUnits = [];\n\nprivate _numberOfGroups = ceil (_numberOfUnits/_numberOfUnitsPerGroup);\n\nprivate [\n    \"_group\",\n    \"_unit\",\n    \"_selectedSpawnPosition\",\n    \"_selectedUnitType\",\n    \"_faceDirection\",\n    \"_watchPosition\"\n];\n\nfor \"_i1\" from 1 to _numberOfGroups do {\n    // create group\n    _group = createGroup [_side,true];\n    _group setCombatMode \"RED\";\n    if (_enableDynamic) then {\n        _group enableDynamicSimulation true;\n    };\n\n    // create units for group\n    for \"_i2\" from 1 to _numberOfUnitsPerGroup do {\n        // check if number of units requested have been created\n        if ((count _spawnedUnits) isEqualTo _numberOfUnits) then {break};\n\n        _selectedSpawnPosition = [_spawnPositions] call KISKA_fnc_deleteRandomIndex;\n\n        // get unit type\n        _selectedUnitType = [_unitTypesFiltered,\"\"] call KISKA_fnc_selectRandom;\n\n        // if spawn position includes a rotation param, set it\n        if (_selectedSpawnPosition isEqualType objNull) then {\n            _faceDirection = getDir _selectedSpawnPosition;\n\n        } else {\n            if (count _selectedSpawnPosition isEqualTo 4) then {\n                _faceDirection = _selectedSpawnPosition deleteAt 3;\n\n            } else {\n                _faceDirection = floor (random 360);\n\n            };\n\n        };\n        _watchPosition = _selectedSpawnPosition getPos [50,_faceDirection];\n\n        // create unit and make sure it was made\n        _unit = _group createUnit [_selectedUnitType,_selectedSpawnPosition,[],0,\"Can_Collide\"];\n        // units with different default sides then what was selected will not be set to the selected side without this command\n        [_unit] joinSilent _group;\n\n        doStop _unit;\n\n        _unit setDir _faceDirection;\n        _unit doWatch _watchPosition;\n\n        _unit setUnitPos ([_allowedStances,\"\"] call KISKA_fnc_selectRandom);\n        if !(_canUnitsMove) then {\n            _unit disableAI \"path\";\n        };\n\n        // make sure units don't trigger dynamic sim\n        if (_enableDynamic) then {\n            _unit triggerDynamicSimulation false;\n        };\n\n        // put unit in master array\n        if (!isNull _unit) then {\n            _spawnedUnits pushBack _unit;\n        };\n    };\n};\n\n// add to zeus\nallCurators apply {\n    [_x,[_spawnedUnits,false]] remoteExec [\"addCuratorEditableObjects\",2];\n};\n\n[[\"Spawned \",(count _spawnedUnits)],false] call KISKA_fnc_log;\n\n\n_spawnedUnits\n",
    "fileName": "fn_spawn.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spawnGroup\n\nDescription:\n    Spawns a group, adds to curator, and sets to aware. Based on selected unit types\n\nParameters:\n    0: _numberOfUnits <NUMBER> - Number of units to spawn\n    1: _unitTypes <ARRAY> - Unit types to select randomly from (can be weighted array)\n    2: _side <SIDE> - ...\n    3: _position <ARRAY, OBJECT, GROUP> - Position to spawn on\n    4: _enableDynamicSimulation <BOOL> - ... (optional)\n\nReturns:\n    <GROUP> - The group created by the function\n\nExamples:\n    (begin example)\n        _spawnedGroup = [4, _listOfUnitTypes, OPFOR, [0,0,0], true] call KISKA_fnc_spawnGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spawnGroup\";\n\nparams [\n    [\"_numberOfUnits\",1,[1]],\n    [\"_unitTypes\",[\"O_Soldier_F\"],[[]]],\n    [\"_side\",OPFOR,[sideUnknown]],\n    [\"_position\",[0,0,0],[objNull,grpNull,[]]],\n    [\"_enableDynamicSimulation\",true,[true]]\n];\n\n// Verify params\nif (_numberOfUnits < 1) exitWith {\n    [[\"_numberOfUnits is \",_numberOfUnits,\" needs to be atleast 1. Exiting...\"],true] call KISKA_fnc_log;\n    grpNull\n};\n\n// filter out bad unit types\nprivate _unitTypesFiltered = [];\nprivate _weightedArray = _unitTypes isEqualTypeParams [\"\",1];\n{\n    if (_x isEqualType \"\") then {\n        if (isClass (configFile >> \"cfgVehicles\" >> _x) OR {isClass (missionConfigFile >> \"cfgVehicles\" >> _x)}) then {\n            _unitTypesFiltered pushBack _x;\n\n            if (_weightedArray) then {\n                _unitTypesFiltered pushBack (_unitTypes select (_forEachIndex + 1));\n            };\n        } else {\n            [[\"Found invalid class \",_x]] call KISKA_fnc_log;\n        };\n    };\n} forEach _unitTypes;\n\nif (_unitTypesFiltered isEqualTo []) exitWith {\n    [[\"Did not find any valid unit types in \",_unitTypes],true] call KISKA_fnc_log;\n    grpNull\n};\n\n\n// create units\nprivate _group = createGroup [_side,true];\n\nfor \"_i\" from 1 to _numberOfUnits do {\n    private _selectedUnitType = [_unitTypesFiltered,\"\"] call KISKA_fnc_selectRandom;\n    private _unit = _group createUnit [_selectedUnitType,_position,[],5,\"NONE\"];\n\n    [_unit] joinSilent _group;\n    _unit triggerDynamicSimulation false;\n\n    if (_i isEqualTo 1) then {_unit setUnitRank \"LIEUTENANT\"; continue;};\n    if (_i isEqualTo 2) then {_unit setUnitRank \"SERGEANT\"};\n};\n\n_group setCombatBehaviour \"AWARE\";\n_group setCombatMode \"RED\";\n\nprivate _spawnedUnits = units _group;\nallCurators apply {\n    [_x,[_spawnedUnits,false]] remoteExec [\"addCuratorEditableObjects\",2];\n};\n\nif (_enableDynamicSimulation) then {\n    _group enableDynamicSimulation true;\n};\n\n\n_group\n",
    "fileName": "fn_spawnGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spawnVehicle\n\nDescription:\n    A slightly altered/optimized version of BIS_fnc_spawnVehicle.\n    Has support for CUP aircraft to spawn at velocity.\n\nParameters:\n    0: _spawnPosition <ARRAY or OBJECT> - 3D array in the format of PositionATL\n        (PositionAGL if boat or amphibious). Objects can be used, however, this\n    1: _spawnDirection <NUMBER> - The direction the vehicle is facing when created (relative to north)\n        if _spawnPosition is an object and _spawnDirection == -1, _spawnDirection will be set to the\n        direction of the _spawnPosition object\n    2: _vehicleClass <STRING> - The typeOf vehicle to spawn\n    3: _group <SIDE or GROUP> - Either the side to create a group on or an\n        already existing group to add the units to\n    4: _forcePosition <BOOL> - Force vehicle to spawn at exact coordinates\n        Does nothing when _spawnPosition is an object\n    5: _crewInstructions <(STRING | OBJECT)[]> - An array of classnames of unit types and/or man objects\n        for the crew. Units are moved into the vehicle using moveInAny in the order provided\n    6: _deleteOverflow <BOOL> - Delete any units from _crewInstructions that prexisted if they don't fit in the vehicle\n\nReturns:\n    <[OBJECT,OBJECT[],GROUP]> -\n    - 0: <OBJECT> - The created vehicle\n    - 1: <OBJECT[]> - The vehicle crew (if soldier type, it will be the same as created vehicle)\n    - 2: <GROUP> -  The group the crew is a part of\n\nExamples:\n    (begin example)\n        [player,0,\"someclass\"] call KISKA_fnc_spawnVehicle;\n    (end)\n\nAuthor(s):\n    Joris-Jan van 't Land,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spawnVehicle\";\n\nparams [\n    [\"_spawnPosition\",[0,0,0],[[],objNull]],\n    [\"_spawnDirection\",0,[123]],\n    [\"_vehicleClass\",\"\",[\"\"]],\n    [\"_group\",BLUFOR,[sideUnknown,grpNull]],\n    [\"_forcePosition\",true,[true]],\n    [\"_crewInstructions\",[], [[]] ],\n    [\"_deleteOverflow\",true,[true]]\n];\n\nprivate _positionIsObject = _spawnPosition isEqualType objNull;\nif (_positionIsObject AND {isNull _spawnPosition}) exitWith {\n    [\"_spawnPosition is null object!\",true] call KISKA_fnc_log;\n    []\n};\n\n\nif (_vehicleClass isEqualTo \"\") exitWith {\n    [\"_vehicleClass is empty string, exiting...\",true] call KISKA_fnc_log;\n    []\n};\n\nif (_group isEqualType grpNull AND {isNull _group}) exitWith {\n    [[\"Tried to spawn class: \",_vehicleClass,\" but the _group is type GROUP and the group is null, exiting...\"],true] call KISKA_fnc_log;\n    []\n};\n\nif (_positionIsObject AND (_spawnDirection isEqualTo -1)) then {\n    _spawnDirection = getDir _spawnPosition;\n};\n\nprivate _spawnPositionATL = _spawnPosition;\nif (_positionIsObject) then {\n    _spawnPositionATL = getPosATL _spawnPosition;\n};\n\n// make a group if side is provided\nprivate _createdNewGroup = false;\nif (_group isEqualType sideEnemy) then {\n    _group = createGroup _group;\n    _createdNewGroup = true;\n};\n\n\n// determine vehicle type and then adjust creation params for it\n// e.g. spawn some vehicles in the air\nprivate _simulationType = getText(configFile >> \"CfgVehicles\" >> _vehicleClass >> \"simulation\");\nprivate \"_createdVehicle\";\nswitch (toLowerANSI _simulationType) do {\n    case \"soldier\": {\n        _createdVehicle = _group createunit [_vehicleClass,_spawnPosition,[],0,\"NONE\"];\n        // units have a tendency to still not be a part of an existing group with createUnit\n        if !(_createdNewGroup) then {\n            [_createdVehicle] joinSilent _group\n        };\n\n    };\n    case \"airplanex\";\n    case \"airplane\"; // CUP planes do not use airplaneX\n    case \"helicopterrtd\";\n    case \"helicopter\";\n    case \"helicopterx\": {\n        if (!_forcePosition) then {\n            _spawnPositionATL set [2,(_spawnPositionATL select 2) max 50];\n            _createdVehicle = createVehicle [_vehicleClass,_spawnPositionATL,[],0,\"FLY\"];\n\n            _forcePosition = true;\n        } else {\n            _createdVehicle = createVehicle [_vehicleClass,_spawnPositionATL,[],0,\"NONE\"];\n\n        };\n\n    };\n    default {\n        _createdVehicle = createvehicle [_vehicleClass,_spawnPosition,[],0,\"NONE\"];\n    };\n};\n\nif (_forcePosition) then {\n    _createdVehicle setPosATL _spawnPositionATL;\n};\n\n_createdVehicle setDir _spawnDirection;\n\n\n\nprivate _crew = [];\n// soldiers do not need anymore handling\nif (_simulationType != \"soldier\") then {\n    // Set plane velocity straight ahead so they don't crash\n    if (_simulationType == \"airplanex\" OR {_simulationType == \"airplane\"}) then {\n        _createdVehicle setVelocityModelSpace [0,100,0];\n        //_createdVehicle setVelocity [100 * (sin _spawnDirection), 100 * (cos _spawnDirection), 0];\n    };\n\n    // Spawn the crew and add the vehicle to the group\n    if (_crewInstructions isEqualTo []) then {\n        createvehiclecrew _createdVehicle;\n        _crew = crew _createdVehicle;\n\n    } else {\n        private _movedIn = false;\n        private \"_unit\";\n        _crewInstructions apply {\n            if (_x isEqualType objNull) then {\n                _unit = _x;\n            } else {\n                _unit = _group createunit [_x,[0,0,0],[],0,\"NONE\"];\n            };\n\n            _movedIn = _unit moveInAny _createdVehicle;\n            if (!_movedIn) then {\n                [\n                    [\n                        \"Unit \",\n                        _unit,\n                        \" could not be moved into the vehicle \",\n                        _createdVehicle,\n                        \" as there was no room in the vehicle\"\n                    ],\n                    true\n                ] call KISKA_fnc_log;\n                \n                if (_deleteOverflow) then {\n                    deleteVehicle _unit;\n                };\n\n            } else {\n                _crew pushBack _unit;\n            };\n        };\n\n    };\n\n    _crew joinsilent _group;\n    _group addVehicle _createdVehicle;\n\n    // If this is a new group, select a leader\n    if (_createdNewGroup) then {\n        _group selectLeader (commander _createdVehicle);\n    };\n\n} else {\n    _crew pushBack _createdVehicle;\n\n};\n\n\n[_createdVehicle, _crew, _group]\n",
    "fileName": "fn_spawnVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stalk\n\nDescription:\n    Rewrite of BIS_fnc_stalk for optimizations and features.\n    One provided group will continually be provided waypoints to another group's\n     positions providing a \"stalking\" affect.\n\nParameters:\n    0: _stalkerGroup <GROUP or OBJECT> - The group to do the stalking\n    1: _stalked <GROUP or OBJECT> - The group or unit to be stalked, if group is used, \n        the leader will be stalked until every unit in the group is dead\n    2: _refreshInterval <NUMBER> - How often the _stalkerGroup will have their waypoint\n        updated with the position of the _stalkedGroup, and how often to check the _conditionToEndStalking\n    3: _postStalking <STRING, ARRAY, or CODE> - Code that after stalking is complete\n        will be executed. (See KISKA_fnc_callBack _callBackFunction parameter)\n    4: _conditionToEndStalking <STRING, ARRAY, or CODE> - Code that (if returns true)\n        can end the stalking. (See KISKA_fnc_callBack _callBackFunction parameter).\n        The stalking will automatically end if all units in one or both groups end\n        up dead.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            someGroup,\n            group player,\n            15,\n            {hint str _this},\n            {false}\n        ] spawn KISKA_fnc_stalk\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stalk\";\n\n\nif !(canSuspend) exitWith {\n    [\"Must be run in scheduled environment. Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_stalk;\n};\n\n\nparams [\n    [\"_stalkerGroup\",grpNull,[objNull,grpNull]],\n    [\"_stalked\",grpNull,[objNull,grpNull]],\n    [\"_refreshInterval\",25,[123]],\n    [\"_postStalking\",{},[[],{},\"\"]],\n    [\"_conditionToEndStalking\",{false},[[],{},\"\"]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    Parameter verification\n---------------------------------------------------------------------------- */\nif (isNull _stalkerGroup) exitWith {\n    [\"_stalkerGroup is null! Exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _stalkingGroup = false;\nif (_stalked isEqualType grpNull) then {\n    _stalked = leader _stalked;\n    _stalkingGroup = true;\n};\nif (isNull _stalked) exitWith {\n    [[_stalkerGroup,\" was asked to stalk a null entity! Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_refreshInterval < 5) then {\n    [\"_refreshInterval was less than 5, adjusting to 5\",false] call KISKA_fnc_log;\n    _refreshInterval = 5;\n};\n\nif (_stalkerGroup isEqualType objNull) then {\n    _stalkerGroup = group _stalkerGroup;\n};\n\nprivate _entityCurrentlyStalking = _stalkerGroup getVariable [\"KISKA_stalkingThis\",objNull];\nif !(isNull _entityCurrentlyStalking) exitWith {\n    [\n        [\n            _stalkerGroup,\n            \" is already stalking the entity \",\n            _entityCurrentlyStalking,\n            \" and cannot stalk multiple ones\"\n        ]\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Main loop\n---------------------------------------------------------------------------- */\n_stalkerGroup setVariable [\"KISKA_stalkingThis\",_stalked];\n\nprivate _stalkedGroup = group _stalked;\nprivate _stalkedIsAlive = alive _stalked;\nwhile {\n    ([_stalkerGroup] call KISKA_fnc_isGroupAlive) AND \n    {\n        if (_stalkingGroup) exitWith {\n            [_stalkedGroup] call KISKA_fnc_isGroupAlive\n        };\n\n        _stalkedIsAlive\n    }\n} do {\n    [_stalkerGroup] call KISKA_fnc_clearWaypoints;\n\n    // waypoints don't work great for buildings, move command in close will have them\n    // got up stairs and get on top of enemies\n    private _stalkerGroupLeader = leader _stalkerGroup;\n    private _distance2DBetweenGroups = _stalkerGroupLeader distance2D _stalked;\n    if (_distance2DBetweenGroups > 50) then {\n        [_stalkerGroup, _stalked, 25, \"MOVE\", \"AWARE\", \"YELLOW\", \"FULL\"] call CBA_fnc_addWaypoint;\n    } else {\n        // if not slept before and remoteExecCalled (not just remoteExec'd) unit will just stand still\n        sleep 0.5;\n        [_stalkerGroupLeader, (getPosATL _stalked)] remoteExecCall [\"move\", _stalkerGroupLeader];\n    };\n\n    private _conditionMet = [\n        [_stalkerGroup,_stalked],\n        _conditionToEndStalking\n    ] call KISKA_fnc_callBack;\n    if (_conditionMet) then {break};\n\n\n    sleep _refreshInterval;\n\n    _stalkedIsAlive = alive _stalked;\n    if (_stalkingGroup AND (!_stalkedIsAlive)) then {\n        _stalked = leader _stalkedGroup;\n        _stalkerGroup setVariable [\"KISKA_stalkingThis\",_stalked];\n    };\n};\n\n/* ----------------------------------------------------------------------------\n    Post\n---------------------------------------------------------------------------- */\nif !(isNull _stalkerGroup) then {\n    _stalkerGroup setVariable [\"KISKA_stalkingThis\",nil];\n    (units _stalkerGroup) apply {\n        [_x,objNull] remoteExec [\"commandTarget\",_x];\n    };\n    [_stalkerGroup] call KISKA_fnc_clearWaypoints;\n};\n\n\n[\n    [_stalkerGroup,_stalked,_stalkedGroup],\n    _postStalking\n] call KISKA_fnc_callBack;\n\n\nnil\n",
    "fileName": "fn_stalk.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_vlsFireAt\n\nDescription:\n    Orders VLS to fire at a target. Projectile will follow terrain.\n\nParameters:\n    0: _launcher <OBJECT> - The VLS launcher to have the missile originate from\n    1: _target <OBJECT or ARRAY> - Target to hit missile with, can also be a position (AGL)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [VLS_1,target_1] call KISKA_fnc_vlsFireAt;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_vlsFireAt\";\n\n#define VLS_WEAPON \"weapon_vls_01\"\n#define VLS_CLASS \"B_Ship_MRLS_01_F\"\n#define DUMMY_TARGET_CLASS \"Sign_Arrow_Large_Blue_F\"\n\nparams [\n    [\"_launcher\",objNull,[objNull]],\n    [\"_target\",objNull,[objNull,[]]]\n];\n\n// verify Params\nif (isNull _launcher) exitWith {\n    [[\"Found that _launcher \",_launcher,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\nif !(_launcher isKindOf VLS_CLASS) exitWith {\n    [[typeOf _launcher,\" is not a kind of of B_Ship_MRLS_01_F. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\nif !(local _launcher) exitWith {\n    [[\"Launcher: \",_launcher,\" is not local to the this machine!\"],true] call KISKA_fnc_log;\n    nil\n};\nif ((_target isEqualType objNull) AND {isNull _target}) exitWith {\n    [[\"Found that _target \",_target,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n// _target is position, create a logic to fire at\nif (_target isEqualType []) then {\n    private _targetPosition = _target;\n    _target = DUMMY_TARGET_CLASS createVehicle [0,0,0];\n\n    [_target] remoteExecCall [\"hideObjectGlobal\",2];\n    _target setPosASL (AGLToASL _targetPosition);\n\n    [\n        _launcher,\n        \"fired\",\n        {\n            params [\"_launcher\", \"\", \"\", \"\", \"\", \"\", \"_projectile\"];\n            _thisArgs params [\"_target\"];\n\n            [\n                [[_projectile],{\n                    _thisArgs params [\"_projectile\"];\n                    !(alive _projectile)\n                }],\n                [[_target],{\n                    _thisArgs params [\"_target\"];\n                    deleteVehicle _target;\n                }],\n                5\n            ] call KISKA_fnc_waitUntil;\n\n            _launcher removeEventHandler [\"fired\", _thisID];\n        },\n        [_target]\n    ] call CBA_fnc_addBISEventHandler;\n};\n\n// check if vehicle can recieve remote targets\nif !(vehicleReceiveRemoteTargets _launcher) then {\n    _launcher setVehicleReceiveRemoteTargets true;\n    // return to state\n    [\n        {(_this select 0) setVehicleReceiveRemoteTargets false},\n        [_launcher],\n        3\n    ] call CBA_fnc_waitAndExecute;\n};\n\nprivate _side = side _launcher;\n_side reportRemoteTarget [_target, 2];\n_target confirmSensorTarget [_side, true];\n_launcher fireAtTarget [_target, VLS_WEAPON];\n",
    "fileName": "fn_vlsFireAt.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim\n\nDescription:\n    Provides an updated version of BIS_fnc_ambientAnim in a tighter package that\n     allows for more customization.\n\nParameters:\n    0: _units <OBJECT[] or OBJECT> - An array of units or a single unit to animate\n    1: _animationParams <HASHMAP, STRING[], (STRING,NUMBER)[], or STRING> - This can be three things:\n        \n        - If a string, a single animation set that is located in the `_animationMap`\n        - If an array, you can have weighted or unweighted array of strings that are random animation sets to select from\n        - lastly, you can have a HASHMAP setup for snap to animations:\n         \n            - `_animSet` <STRING[], (STRING,NUMBER)[], or STRING> - A single snapto animation set or weighted/unweighted array to randomly select from.\n            - `_snapToRange` <NUMBER> - This is how far will be searched around the unit to find an object to \"snap\" onto. Cannot be more then 10m.\n            - `_backupAnims` <STRING[], (STRING,NUMBER)[], or STRING> - Same as `_snapToAnimationSet` but for animations to use in the even that \n            ALL of the `_snapToAnimationSet` animations fail to be used due to valid objects not being within range.\n            - `_fallbackFunction` <CODE, ARRAY, or STRING> - (See `KISKA_fnc_callBack`) In the event that\n            a unit is not able to find an object to snap to AND1 no _backupAnims are present, this function will be called with the\n            following params. If you still want the unit to be animated in this case, pass `{}`, `\"\"`, or `[]`\n                \n                - 0: _unit <OBJECT> - The unit\n                - 1: _animationParams <STRING[], (STRING,NUMBER)[], or STRING>\n                - 2: _exitOnCombat <BOOL>\n                - 3: _equipmentLevel <STRING[], (STRING,NUMBER)[], or STRING>\n                - 4: _animationMap <HASHMAP or CONFIG>\n\n    2: _exitOnCombat <BOOL> - True for unit to return to the state it was in prior to\n        KISKA_fnc_ambientAnim being called when they are enter combat behaviour.\n    3: _equipmentLevel <ARRAY or STRING> - A quick means of temporarily adjusting a unit's equipment to match a scene. Options:\n        \n        - \"\": no changes\n        - \"NONE\": no goggles, headgear, vest, weapon, nvgs, backpack\n        - \"LIGHT\": no goggles, headgear, vest, backpack\n        - \"MEDIUM\": no goggles, headgear\n        - \"FULL\": no goggles\n\n    4: _animationMap <HASHMAP or CONFIG> - See KISKA_fnc_ambientAnim_createMapFromConfig\n        This is a hashmap that will searched for information for a specific _animSet\n        A config can be passed and will be parsed/cached.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // exits on combat\n        [\n            someUnit,\n            \"SIT_GROUND_ARMED\",\n            true\n        ] call KISKA_fnc_ambientAnim;\n    (end)\n\n    (begin example)\n        // use animation set SIT_CHAIR_ARMED_2 and snap\n        // to objects within 10 meters of unit's position\n        // if no objects that are snappable for SIT_CHAIR_ARMED_2\n        // are found, unit will use SIT_GROUND_ARMED animation set\n        [\n            someUnit,\n            createHashMapFromArray [\n                [\"_animSet\", \"SIT_CHAIR_ARMED_2\"],\n                [\"_snapToRange\", 10],\n                [\"_backupAnims\",\"SIT_GROUND_ARMED\"]\n            ]\n        ] call KISKA_fnc_ambientAnim;\n    (end)\n\n    (begin example)\n        // STAND_UNARMED_3 is 10x more likely to be used than STAND_ARMED_1\n        [\n            someUnit,\n            [\n                \"STAND_ARMED_1\",1,\n                \"STAND_UNARMED_3\",10\n            ]\n        ] call KISKA_fnc_ambientAnim;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim\";\n// TODO: handle remote units being passed\n// TODO: Add supplemental animation sets by using polpox animation viewer\n// TODO: Add LEAN_ON_TABLE animation set\n#define HASHMAP_TYPE createHashMap\n#define DEFAULT_ANIMATION_MAP (configFile >> \"KISKA_AmbientAnimations\" >> \"DefaultAnimationMap\")\n\nparams [\n    [\"_units\",objNull,[[],objNull]],\n    [\"_animationParams\",\"\",[\"\",[],HASHMAP_TYPE]],\n    [\"_exitOnCombat\",false,[true]],\n    [\"_equipmentLevel\",\"\",[\"\",[]]],\n    [\"_animationMap\",DEFAULT_ANIMATION_MAP,[createHashMap,configNull]]\n];\n\n\nprivate [\"_fallbackFunction\",\"_snapToRange\",\"_animSet\",\"_backupAnims\"];\nprivate _fallbackFunctionIsPresent = false;\nprivate _isSnapAnimations = _animationParams isEqualType HASHMAP_TYPE;\nprivate _parsedSnapToMapErrors = [];\n\nif !(_isSnapAnimations) then {\n    _animSet = _animationParams;\n\n} else {\n    _animSet = _animationParams getOrDefault [\"_animSet\",\"\"];\n    if !(_animSet isEqualTypeAny [\"\",[]]) then {\n        _parsedSnapToMapErrors pushBack ((str _animSet) + \" is not a valid type for _animSet (STRING or ARRAY)\");\n    };\n\n    _snapToRange = _animationParams getOrDefault [\"_snapToRange\",5];\n    if !(_snapToRange isEqualType 123) then {\n        _parsedSnapToMapErrors pushBack ((str _snapToRange) + \" is not a valid type for _snapToRange (NUMBER)\");\n    };\n\n    _backupAnims = _animationParams getOrDefault [\"_backupAnims\",\"\"];\n    if !(_backupAnims isEqualTypeAny [\"\",[]]) then {\n        _parsedSnapToMapErrors pushBack ((str _backupAnims) + \" is not a valid type for _backupAnims (STRING or ARRAY)\");\n    };\n\n    _fallbackFunction = _animationParams getOrDefault [\"_fallbackFunction\",{}];\n    if !(_fallbackFunction isEqualTypeAny [\"\",{},[]]) then {\n        _parsedSnapToMapErrors pushBack ((str _fallbackFunction) + \" is not a valid type for _fallbackFunction (STRING, CODE, or ARRAY)\");\n    };\n\n\n\n    if (_parsedSnapToMapErrors isNotEqualTo []) exitWith {};\n    \n    if (_snapToRange > 10) then { _snapToRange = 10 };\n    _fallbackFunctionIsPresent = _fallbackFunction isNotEqualTo {} AND\n        _fallbackFunction isNotEqualTo [] AND\n        _fallbackFunction isNotEqualTo \"\";\n};\n\n\n/* ----------------------------------------------------------------------------\n\n    Verify params\n\n---------------------------------------------------------------------------- */\nif (_parsedSnapToMapErrors isNotEqualTo []) exitWith {\n    [[\"Errors with snap animation map:\",_parsedSnapToMapErrors]] call KISKA_fnc_log;\n    nil\n};\n\nif (_units isEqualTo []) exitWith {\n    [\"Empty _units array passed!\", true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _isObject = _units isEqualType objNull;\nif (_isObject AND {isNull _units}) exitWith {\n    [\"Null unit passed\", true] call KISKA_fnc_log;\n    nil\n};\n\nif (_isObject) then {\n    _units = [_units];\n};\n\nprivate _animationMapIsConfig = _animationMap isEqualType configNull;\nif (_animationMapIsConfig AND {isNull _animationMap}) exitWith {\n    [\"_animationMap is null config!\", true] call KISKA_fnc_log;\n    nil\n};\n\nif (_animationMapIsConfig) then {\n    _animationMap = [_animationMap] call KISKA_fnc_ambientAnim_createMapFromConfig;\n};\n\n\nprivate _setsToVerify = _animSet;\nprivate _isWeightedAnimSet = _animSet isEqualTypeParams [\"\",123];\nif !(_animSet isEqualType []) then {\n    _setsToVerify = [_animSet];\n    if (_isSnapAnimations) then {\n        _animSet = _setsToVerify;\n    };\n};\n\nprivate _invalidSets = [];\n{\n    if (_isWeightedAnimSet) then {\n        private _isWeightIndex = (_forEachIndex mod 2) isNotEqualTo 0;\n        if ((_x isEqualType 123) AND _isWeightIndex) then {continue};\n    };\n\n    private _animationSetInfo = _animationMap getOrDefault [_x,[]] ;\n    if (_animationSetInfo isEqualTo []) then {\n        _invalidSets pushBack _x;\n        continue;\n    };\n\n    if (!_isSnapAnimations) then {continue};\n\n    if (_animationSetInfo getOrDefault [\"snapToObjectsMap\",[]] isEqualTo []) then {\n        _invalidSets pushBack (_x + \":snapToObjectsMap_empty\");\n    };\n} forEach _setsToVerify;\n\n\nif (count _invalidSets > 0) exitWith {\n    [[\"Invalid animation set(s) passed: \",_invalidSets],true] call KISKA_fnc_log;\n    nil\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\n    Helper functions\n\n---------------------------------------------------------------------------- */\n\n/* -------------------------------------\n    _fn_getSetupInfoWithoutSnap\n------------------------------------- */\nprivate _fn_getSetupInfoWithoutSnap = {\n    params [\"_animSetToSelectFrom\"];\n\n    private _animSetSelection = _animSetToSelectFrom;\n    if (_animSetToSelectFrom isEqualType []) then {\n        _animSetSelection = [_animSetToSelectFrom,\"\"] call KISKA_fnc_selectRandom;\n    };\n\n    private _animationSetInfo = _animationMap get _animSetSelection;\n    if (isNil \"_animationSetInfo\") exitWith {\n        [\n            [\"Could not find animation set for: \",_animSetSelection,\" inside map: \",_animationMap],\n            true\n        ] call KISKA_fnc_log;\n\n        []\n    };\n\n    \n    [false, _animationSetInfo]\n};\n\n\n/* -------------------------------------\n    _fn_findObjectToSnapTo\n------------------------------------- */\nprivate _fn_findObjectToSnapTo = {\n    params [\"_snapToObjectsMap\",\"_objectsToCheck\"];\n    \n    private _snapToObjectTypes = keys _snapToObjectsMap;\n    private _snapToObjectInfo = [];\n    _objectsToCheck apply {\n        private _objectType = toLowerANSI (typeOf _x);\n        private _snapToObjectMapKey = _objectType;\n        private _objectInUse = !(isNull (_x getVariable [\"KISKA_ambientAnim_objectUsedBy\",objNull]));\n        if (_objectInUse) then { continue };\n        \n        private \"_objectToSnapTo\";\n        if (_objectType in _snapToObjectTypes) then { \n            _objectToSnapTo = _x;\n\n        } else {\n            private _parentTypeIndex = _snapToObjectTypes findIf {\n                _objectType isKindOf _x;\n            };\n            private _objectNotSupportedForAnimationSet = _parentTypeIndex isEqualTo -1;\n            if (_objectNotSupportedForAnimationSet) then { continue };\n            \n            _objectType = _snapToObjectTypes select _parentTypeIndex;\n            _objectToSnapTo = _x;\n\n        };\n\n\n        private _vehicleConfigSnapAllowance = configFile >> \"CfgVehicles\" >> _objectType >> \"KISKA_AmbientAnimations\" >> \"snapAllowance\";\n        private _configedSnapAllowance = getNumber(_vehicleConfigSnapAllowance);\n        private _allowanceNotConfigedInMainConfig = _configedSnapAllowance isEqualTo 0;\n\n        if (_allowanceNotConfigedInMainConfig) then {\n            private _objectKiskaAnimationConfig = [\n                [\"KISKA_AmbientAnimations\",\"ObjectSpecifics\",_objectType]\n            ] call KISKA_fnc_findConfigAny;\n            if (isNull _objectKiskaAnimationConfig) exitWith {};\n\n            _configedSnapAllowance = getNumber(_objectKiskaAnimationConfig >> \"snapAllowance\");\n        };\n\n        private _hasSnapAllowance = _configedSnapAllowance > 1;\n        private _snapAllowanceInfo = [];\n\n        if (_hasSnapAllowance) then {\n            private _usedSnapIds = _x getVariable [\"KISKA_ambientAnim_usedSnapIds\",[]];\n            if ((count _usedSnapIds) >= _configedSnapAllowance) then { continue };\n\n            private _objectSnapPointsHashMap = _snapToObjectsMap get _snapToObjectMapKey;\n            {\n                if (_x in _usedSnapIds) then { continue };\n\n                if (_x isEqualType []) then { \n                    private _someIdsAlreadyBeingUsed = (_x arrayIntersect _usedSnapIds) isNotEqualTo [];\n                    if (_someIdsAlreadyBeingUsed) then { continue };\n                };\n\n                _snapAllowanceInfo pushBack _x;\n                _snapAllowanceInfo pushBack _y;\n            } forEach _objectSnapPointsHashMap;\n        };\n        \n        _snapToObjectInfo pushBack _objectType;\n        _snapToObjectInfo pushBack _objectToSnapTo;\n        if (_snapAllowanceInfo isNotEqualTo []) then {\n            _snapToObjectInfo pushBack _snapAllowanceInfo;\n        };\n\n        break;\n    };\n\n\n    _snapToObjectInfo\n};\n\n\n/* -------------------------------------\n    _fn_handleNoSnap\n------------------------------------- */\nprivate _fn_handleNoSnap = {\n    params [\"_unit\",\"_backupAnims\"];\n\n    private _backupAnimsIsDefined = (_backupAnims isNotEqualTo []) AND (_backupAnims isNotEqualTo \"\");\n    if (_backupAnimsIsDefined) exitWith {\n        [_backupAnims] call _fn_getSetupInfoWithoutSnap\n    };\n\n    // empty _setupInfo return\n    if (!_fallbackFunctionIsPresent) exitWith { [] };\n    [\n        [\n            _unit, \n            _animationParams,\n            _exitOnCombat,\n            _equipmentLevel,\n            _animationMap\n        ],\n        _fallbackFunction\n    ] call KISKA_fnc_callBack;\n\n    // empty _setupInfo\n    []\n};\n\n\n/* -------------------------------------\n    _fn_getSetupInfoWithSnap\n------------------------------------- */\n// accept that only one set can be be tried from the primary\n// Try extremely hard to dynamically exclude sets from the array (the array can be weighted)\n// shuffle the entire array each time and loop through every set (this would also be hard with weighted arrays)\n// delete one random entry at a time and eventually make the array anew\nprivate _fn_getSetupInfoWithSnap = {\n    params [\"_unit\",\"_animSetToSelectFrom\",\"_backupAnims\"];\n\n    // using nearObjects to support snapping to simple objects\n    private _nearObjects = _unit nearObjects _snapToRange;\n    if (_nearObjects isEqualTo []) exitWith {\n        [[\"There are no near objects to snap to for unit: \",_unit]] call KISKA_fnc_log;\n        [_unit, _backupAnims] call _fn_handleNoSnap\n    };  \n\n\n    private [\"_animSetSelection\",\"_snapToObjectsMap\",\"_animationSetInfoFromSetup\",\"_objectToSnapTo\"];\n    private _snapIdsToUse = -1;\n    private _snapObjectFound = false;\n    private _snapToObjectInfo = [];\n    private _checkedAnimSets = [];\n    private _step = [1,2] select _isWeightedAnimSet;\n    for \"_i\" from 1 to (count _animSetToSelectFrom) step _step do { \n        if (_isWeightedAnimSet) then {\n            _animSetSelection = [_animSetToSelectFrom,\"\"] call KISKA_fnc_selectRandom;\n            private _indexOfSelectedAnim = _animSetToSelectFrom find _animSetSelection;\n            _animSetToSelectFrom deleteAt _indexOfSelectedAnim;\n            _checkedAnimSets pushBack _animSetSelection;\n            \n            // previous deleteAt will shift the weight into the anim's former index\n            private _animWeight = _animSetToSelectFrom deleteAt _indexOfSelectedAnim;\n            _checkedAnimSets pushBack _animWeight;\n\n        } else {\n            _animSetSelection = [_animSetToSelectFrom] call KISKA_fnc_deleteRandomIndex;\n            _checkedAnimSets pushBack _animSetSelection;\n\n        };\n\n        _animationSetInfoFromSetup = _animationMap get _animSetSelection;\n        _snapToObjectsMap = _animationSetInfoFromSetup get \"snapToObjectsMap\";        \n        // loop\n        _snapToObjectInfo = [_snapToObjectsMap, _nearObjects] call _fn_findObjectToSnapTo;\n\n        _snapObjectFound = _snapToObjectInfo isNotEqualTo [];\n        if (_snapObjectFound) then { break };\n    };\n    // _animSetToSelectFrom array may be used by other units, so \"restore\" it\n    _animSetToSelectFrom append _checkedAnimSets;\n\n\n    if (!_snapObjectFound) exitWith {\n        [[\"No objects met snapping criteria for unit: \",_unit]] call KISKA_fnc_log;\n        [_unit, _backupAnims] call _fn_handleNoSnap\n    };\n\n\n    _snapToObjectInfo params [\"_objectType\",\"\",\"_snapAllowanceInfo\"];\n    _objectToSnapTo = _snapToObjectInfo param [1];\n\n    [_unit,_objectToSnapTo] remoteExecCall [\"disableCollisionWith\",_unit];\n    [_objectToSnapTo,_unit] remoteExecCall [\"disableCollisionWith\",_objectToSnapTo];\n\n    if (isNil \"_snapAllowanceInfo\") then {\n        _objectToSnapTo setVariable [\"KISKA_ambientAnim_objectUsedBy\",_unit];\n        private _relativeObjectInfo = _snapToObjectsMap get _objectType;\n        [_objectToSnapTo,_unit,_relativeObjectInfo] call KISKA_fnc_setRelativeVectorAndPos;\n\n    } else {\n        private _usedSnapIds = _objectToSnapTo getVariable \"KISKA_ambientAnim_usedSnapIds\";\n        if (isNil \"_usedSnapIds\") then {\n            _usedSnapIds = [];\n            _objectToSnapTo setVariable [\"KISKA_ambientAnim_usedSnapIds\",_usedSnapIds];\n        };\n\n\n        _snapIdsToUse = _snapAllowanceInfo param [0];\n        if (_snapIdsToUse isEqualType 123) then {\n            _usedSnapIds pushBack _snapIdsToUse;\n        } else {\n            _usedSnapIds append _snapIdsToUse;\n        };\n\n        private _relativeObjectInfo = _snapAllowanceInfo param [1];\n        [_objectToSnapTo,_unit,_relativeObjectInfo] call KISKA_fnc_setRelativeVectorAndPos;\n    };\n\n\n    [true, _animationSetInfoFromSetup, _objectToSnapTo, _snapIdsToUse]\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\n    Apply Animations\n\n---------------------------------------------------------------------------- */\nprivate _randomEquipmentLevel = _equipmentLevel isEqualType [];\n_units apply {\n    private _unit = _x;\n    if !(alive _unit) then {\n        continue;\n    };\n\n    private _unitIsAnimated = !(isNil {_unit getVariable \"KISKA_ambientAnimMap\"});\n    if (_unitIsAnimated) then {\n        [_unit] call KISKA_fnc_ambientAnim_stop;\n    };\n\n    private _unitInfoMap = createHashmap;\n    detach _unit;\n    \n\n    private \"_setupInfo\";\n    if (_isSnapAnimations) then {\n        _setupInfo = [_unit,_animSet,_backupAnims] call _fn_getSetupInfoWithSnap;\n    } else {\n        _setupInfo = [_animSet] call _fn_getSetupInfoWithoutSnap;\n    };\n\n\n    if (_setupInfo isEqualTo []) then { continue };\n\n\n    _setupInfo params [\n        \"_isSnapAnim\",\n        \"_animationSetInfo\"\n    ];\n\n    _unitInfoMap set [\"_animationSetInfo\",_animationSetInfo];\n    if (_isSnapAnim) then {\n        private _objectToSnapTo = _setupInfo param [2,objNull];\n        _unitInfoMap set [\"_snapToObject\",_objectToSnapTo];\n\n        private _snapIdsToUse = _setupInfo param [3,-1];\n        if (_snapIdsToUse isNotEqualTo -1) then {\n            _unitInfoMap set [\"_usedSnapIds\",_snapIdsToUse];\n        };\n    };\n\n\n    /* --------------------------------------\n        Handle AttachTo Logic\n        // some animations (STAND_ARMED_1)\n        // will wind up stuttering if not attached to a logic.\n        // this also happens with BIS_fnc_ambientAnim.\n        // unknown why.\n\n        // This does also benefit some seated animations if required.\n    -------------------------------------- */\n    // TODO: error here, \"_animationSetInfo\" is not hashmap, but array???\n    if (_animationSetInfo getOrDefault [\"attachToLogic\",false]) then {\n        private _logicGroup = [_x] call KISKA_fnc_ambientAnim_getNearestAttachLogicGroup;\n        if (isNull _logicGroup) then {\n            _logicGroup = createGroup sideLogic;\n            _logicGroup deleteGroupWhenEmpty true;\n            _logicGroup addEventHandler [\"Deleted\",{\n                params [\"_group\"];\n                \n                private _mapId = _group getVariable [\"KISKA_ambientAnimGroup_ID\",-1];\n                if (_mapId >= 0) then {\n                    private _logicGroupsMap = call KISKA_fnc_ambientAnim_getAttachLogicGroupsMap;\n                    _logicGroupsMap deleteAt _mapId;\n                };\n            }];\n\n            [_logicGroup] call KISKA_fnc_ambientAnim_addAttachLogicGroup;\n        };\n\n        private _helper = _logicGroup createUnit [\"Logic\", [0,0,0], [], 0, \"NONE\"];\n        _helper setPosWorld (getPosWorld _unit);\n        _helper setVectorDir (vectorDir _unit);\n        _helper setVectorUp (vectorUp _unit);\n\n        _unitInfoMap set [\"_attachToLogic\",_helper];\n        _unit attachTo [_helper,[0,0,0]];\n    };\n\n\n    /* --------------------------------------\n        Handle Equipment\n    -------------------------------------- */\n    private _loadoutBeforeAnimation = getUnitLoadout _unit;\n    private _loadoutAdjusted = false;\n\n    private _removeAllWeapons = _animationSetInfo getOrDefault [\"removeAllWeapons\",false];\n    if (_removeAllWeapons) then {\n        removeAllWeapons _unit;\n        _loadoutAdjusted = true;\n        \n    } else {\n        private _removeSecondaryWeapon = _animationSetInfo getOrDefault [\"removeSecondaryWeapon\",false];\n        if (_removeSecondaryWeapon) then {\n            _unit removeWeaponGlobal (secondaryWeapon _unit);\n            _loadoutAdjusted = true;\n        };\n\n        private _removeHandgun = _animationSetInfo getOrDefault [\"removeHandgun\",false];\n        if (_removeHandgun) then {\n            _unit removeWeaponGlobal (handgunWeapon _unit);\n            _loadoutAdjusted = true;\n        };\n\n        private _removePrimaryWeapon = _animationSetInfo getOrDefault [\"removePrimaryWeapon\",false];\n        if (_removePrimaryWeapon) then {\n            _unit removeWeaponGlobal (primaryWeapon _unit);\n            _loadoutAdjusted = true;\n        };\n    };\n\n\n    private _removeBackpack = _animationSetInfo getOrDefault [\"removeBackpack\",false];\n    if (_removeBackpack) then {\n        removeBackpack _unit;\n        _loadoutAdjusted = true;\n    };\n\n    private _removeNightVision = _animationSetInfo getOrDefault [\"removeNightVison\",false];\n    if (_removeNightVision) then {\n        removeAllAssignedItems _unit;\n        _loadoutAdjusted = true;\n    };\n\n    private \"_equipmentLevelSelection\";\n    if (_randomEquipmentLevel) then {\n        _equipmentLevelSelection = [_equipmentLevel,\"\"] call KISKA_fnc_selectRandom;\n    } else {\n        _equipmentLevelSelection = _equipmentLevel;\n    };\n\n    switch (_equipmentLevelSelection) do\n    {\n        case \"NONE\":\n        {\n            removeGoggles _unit;\n            removeHeadgear _unit;\n            removeVest _unit;\n            removeAllWeapons _unit;\n            removeBackpack _unit;\n            removeAllAssignedItems _unit;\n            _loadoutAdjusted = true;\n        };\n        case \"LIGHT\":\n        {\n            removeGoggles _unit;\n            removeHeadgear _unit;\n            removeVest _unit;\n            removeBackpack _unit;\n            _loadoutAdjusted = true;\n        };\n        case \"MEDIUM\":\n        {\n            removeGoggles _unit;\n            removeHeadgear _unit;\n            _loadoutAdjusted = true;\n        };\n        case \"FULL\":\n        {\n            removeGoggles _unit;\n            _loadoutAdjusted = true;\n        };\n        default\n        {\n        };\n    };\n\n    if (_loadoutAdjusted) then {\n        _unitInfoMap set [\"_loadoutBeforeAnimation\",_loadoutBeforeAnimation];\n    };\n\n    [\"ANIM\",\"AUTOTARGET\",\"FSM\",\"MOVE\",\"TARGET\"] apply {\n        [_unit,_x] remoteExecCall [\"disableAI\",_unit];\n    };\n\n\n    private _baseJipId = \"KISKA_AmAnim_\" + (str _unit);\n    _unitInfoMap set [\"KISKA_ambientAnim_JIPId_switchMove\",(_baseJipId + \"_sm\")];\n    _unitInfoMap set [\"KISKA_ambientAnim_JIPId_playMoveNow\",(_baseJipId + \"_pmn\")];\n\n    /* --------------------------------------\n        Initial Animate\n    -------------------------------------- */\n    _unit setVariable [\"KISKA_ambientAnimMap\",_unitInfoMap];\n    [_unit] call KISKA_fnc_ambientAnim_play;\n\n\n    /* --------------------------------------\n        Add Eventhandlers\n    -------------------------------------- */\n    private _animDoneEventHandlerId = _unit addEventHandler [\"AnimDone\",\n        {\n            params [\"_unit\",\"_anim\"];\n\n            if (alive _unit) then {\n                _this call KISKA_fnc_ambientAnim_play;\n            };\n        }\n    ];\n    _unitInfoMap set [\"_animDoneEventHandlerId\",_animDoneEventHandlerId];\n\n\n    private _unitKilledEventHandlerId = _unit addEventHandler [\"KILLED\",\n        {\n            params [\"_unit\"];\n            [_unit,false] call KISKA_fnc_ambientAnim_stop;\n        }\n    ];\n    _unitInfoMap set [\"_unitKilledEventHandlerId\",_unitKilledEventHandlerId];\n\n\n    private _unitDeletedEventHandlerId = _unit addEventHandler [\"Deleted\",\n        {\n            params [\"_unit\"];\n            [_unit,true] call KISKA_fnc_ambientAnim_stop;\n        }\n    ];\n    _unitInfoMap set [\"_unitDeletedEventHandlerId\",_unitDeletedEventHandlerId];\n\n\n    if (_exitOnCombat) then {\n        private _behaviourEventId = [\n            _unit,\n            (configFile >> \"KISKA_eventHandlers\" >> \"Behaviour\"),\n            {\n                params [\"_unit\",\"_behaviour\",\"_eventHandlerConfig\"];\n\n                if (_behaviour == \"COMBAT\") then {\n                    [\n                        _unit,\n                        _eventHandlerConfig,\n                        _thisScriptedEventhandler\n                    ] call KISKA_fnc_eventHandler_remove;\n\n                    [_unit] call KISKA_fnc_ambientAnim_stop;\n                };\n            }\n        ] call KISKA_fnc_eventHandler_addFromConfig;\n\n        _unitInfoMap set [\"_behaviourEventId\",_behaviourEventId];\n    };\n\n\n};\n\n\nnil",
    "fileName": "fn_ambientAnim.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_addAttachLogicGroup\n\nDescription:\n    Adds a group to the global attachTo logics map used to store them for reference.\n\nParameters:\n    0: _logicGroup <GROUP> - The group to add\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [createGroup sideLogic] call KISKA_fnc_ambientAnim_getAttachToLogicGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_addAttachLogicGroup\";\n\nparams [\n    [\"_logicGroup\",grpNull,[grpNull]]\n];\n\nprivate _logicSide = side _logicGroup;\nif (_logicSide isNotEqualTo sideLogic) exitWith {\n    [\n        [\n            \"Group: \",\n            _logicGroup,\n            \" is not a valid side of sideLogic, it is side: \",\n            _logicSide\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\nprivate _logicGroupsMap = call KISKA_fnc_ambientAnim_getAttachLogicGroupsMap;\n\nprivate _id = [\"KISKA_ambientAnimGroup_ID\"] call KISKA_fnc_idCounter;\n_logicGroup setVariable [\"KISKA_ambientAnimGroup_ID\",_id];\n_logicGroupsMap set [_id,_logicGroup];\n\n\nnil\n",
    "fileName": "fn_ambientAnim_addAttachLogicGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_createMapFromConfig\n\nDescription:\n    Parses a given config into a hashmap that can be used by KISKA_fnc_ambientAnim.\n    This config will then be the hashmap KISKA_ambientAnim_configAnimationSetMap\n     with the config as the key.\n\n    See configFile >> \"KISKA_AmbientAnimations\" for an example of a configed map.\n    \n    (begin config example)\n        class ambientAnimsConfig\n        {\n            class someAnimSet\n            {\n                animations[] = {\"myAnimation\"}; // the only required property of an anim set\n            };\n        };\n    (end)\n\nParameters:\n    0: _config <CONFIG> - A config to parse into a hashmap\n\nReturns:\n    <HASHMAP> - A map of the animation sets and their properties.\n\nExamples:\n    (begin example)\n        private _map = [\n            configFile >> \"KISKA_AmbientAnimations\"\n        ] call KISKA_fnc_ambientAnim_createMapFromConfig;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_createMapFromConfig\";\n\nparams [\n    [\"_config\",configNull,[configNull]]\n];\n\n\nif (isNull _config) exitWith {\n    [\"Null config passed!\",true] call KISKA_fnc_log;\n    []\n};\n\nif (isNil \"KISKA_ambientAnim_configAnimationSetMap\") then {\n    missionNamespace setVariable [\"KISKA_ambientAnim_configAnimationSetMap\",createHashMap];\n};\n\nprivate _animationMap = KISKA_ambientAnim_configAnimationSetMap getOrDefault [_config,[]];\nif (_animationMap isNotEqualTo []) exitWith {_animationMap};\n\n\nprivate _fn_getRelativeInfo = {\n    params [\"_snapToObjectClass\"];\n\n    private _relativeInfoArray = getArray(_snapToObjectClass >> \"relativeInfo\");\n    if (_relativeInfoArray isNotEqualTo []) exitWith { _relativeInfoArray };\n\n    [\n        getArray(_snapToObjectClass >> \"relativePos\"),\n        getArray(_snapToObjectClass >> \"relativeDir\"),\n        getArray(_snapToObjectClass >> \"relativeUp\")\n    ]\n};\n\nprivate _fn_parseSnapToObjectClass = {\n    params [\"_snapToObjectsConfig\"];\n    \n    private _snapToObjectClasses = configProperties [_snapToObjectsConfig,\"isClass _x\"];\n    \n    private _snapToObjects = [];\n    _snapToObjectClasses apply {\n        private _snapToObjectClass = _x;\n        private _type = toLowerANSI (getText(_snapToObjectClass >> \"type\"));\n        if (_type isEqualTo \"\") then {\n            [[\"No type found parsing relative object info for \",_snapToObjectClass],true] call KISKA_fnc_log;\n            continue;\n        };\n\n        private _snapPointClassConfigs = configProperties [_snapToObjectClass >> \"snapPoints\",\"isClass _x\"];\n        private _isNotMultiSnap = _snapPointClassConfigs isEqualTo [];\n        if (_isNotMultiSnap) then {\n            private _relativeInfo = [_snapToObjectClass] call _fn_getRelativeInfo;\n            _snapToObjects pushBack [\n                _type,\n                _relativeInfo\n            ];\n            \n            continue;\n        };\n\n\n        private _objectSnapPointsHashMap = createHashMap;\n        _snapPointClassConfigs apply {\n            private \"_snapId\";\n            \n            if (isArray(_x >> \"snapId\")) then {\n                _snapId = getArray(_x >> \"snapId\");\n\n            } else {\n                _snapId = getNumber(_x >> \"snapId\");\n                if (_snapId isEqualTo 0) then {\n                    [[\"Found invalid or nonexistent snap id in config: \",_x],true] call KISKA_fnc_log;\n                    continue;\n                };\n\n            };\n\n\n            private _relativeInfoArray = [_x] call _fn_getRelativeInfo;\n            _objectSnapPointsHashMap set [_snapId,_relativeInfoArray];\n        };\n\n        _snapToObjects pushBack [_type, _objectSnapPointsHashMap]\n\n    };\n\n    \n    _snapToObjects\n};\n\n\n_animationMap = createHashMap;\nprivate _classes = configProperties [_config, \"isClass _x\", true];\n_classes apply {\n    // map for specific animation set class\n    private _animationSetInfo = createHashMap;\n    private _animations = getArray(_x >> \"animations\");\n    if (_animations isEqualTo []) then {\n        [[\"Class: \", _x,\" did not have any animations defined and will not be parsed!\",true]] call KISKA_fnc_log;\n        continue;\n    };\n    _animationSetInfo set [\"animations\", _animations];\n\n    private _snapToObjectsConfig = _x >> \"snapToObjects\";\n\n    private _parsedSnapToObjects = [];\n    if !(isNull _snapToObjectsConfig) then {\n        if (isArray _snapToObjectsConfig) then {\n            _parsedSnapToObjects = getArray(_x >> \"snapToObjects\");\n\n        } else {\n            if (isClass _snapToObjectsConfig) then {\n                _parsedSnapToObjects = [_snapToObjectsConfig] call _fn_parseSnapToObjectClass;\n            };\n\n        };\n\n        if (_parsedSnapToObjects isNotEqualTo []) then {\n            private _snapToObjectsMap = createHashMapFromArray _parsedSnapToObjects;\n            _animationSetInfo set [\"snapToObjectsMap\", _snapToObjectsMap];\n        };\n    };\n\n    private _configClass = _x;\n    [\n        [\"removeAllWeapons\",\"removeAllWeapons\"],\n        [\"removeSecondaryWeapon\",\"removeSecondaryWeapon\"],\n        [\"removeHandgun\",\"removeHandgun\"],\n        [\"removePrimaryWeapon\",\"removePrimaryWeapon\"],\n        [\"attachToLogic\",\"attachToLogic\"],\n        [\"removeBackpack\",\"removeBackpack\"],\n        [\"removeNightVision\",\"removeNightVision\"],\n        [\"canInterpolate\",\"canInterpolate\"]\n    ] apply {\n        _x params [\"_hashMapKey\",\"_configPropertyName\"];\n        private _configValue = [_configClass >> _configPropertyName] call BIS_fnc_getCfgDataBool;\n        _animationSetInfo set [_hashMapKey,_configValue];\n    };\n\n    _animationMap set [configName _configClass, _animationSetInfo];\n};\nKISKA_ambientAnim_configAnimationSetMap set [_config, _animationMap];\n\n\n_animationMap\n",
    "fileName": "fn_ambientAnim_createMapFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_getAttachLogicGroupsMap\n\nDescription:\n    Returns the hashmap that contains all logic groups used for ambient animations.\n\n    Users can then reference all the groups with the `values` command.\n\n    A hashmap was used in order to provide a quicker means of removing entries when\n     a group is deleted as opposed to having to used the `find` command with an array.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - A hashmap containing all the logic group\n\nExamples:\n    (begin example)\n        private _map = call KISKA_fnc_ambientAnim_getAttachLogicGroupsMap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_getAttachLogicGroupsMap\";\n\nprivate _map = localNamespace getVariable \"KISKA_ambientAnim_attachLogicGroupsMap\";\nif (isNil \"_map\") then {\n    _map = createHashMap;\n    localNamespace setVariable [\"KISKA_ambientAnim_attachLogicGroupsMap\",_map];\n};\n\n\n_map\n",
    "fileName": "fn_ambientAnim_getAttachLogicGroupsMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_addAttachLogicGroup\n\nDescription:\n    Finds the nearest attach logic group used for ambient animations.\n\nParameters:\n    0: _position <OBJECT or Position-2D> - The position to check\n\nReturns:\n    <GROUP> - the nearest logic group used for ambient animations\n\nExamples:\n    (begin example)\n        private _group = [player] call KISKA_fnc_ambientAnim_getNearestAttachLogicGroup;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_getNearestAttachLogicGroup\";\n\n#define RADIUS_TO_CHECK 100\n\nparams [\n    [\"_position\",[],[objNull,[]],[2,3]]\n];\n\nif ((_position isEqualType objNull) AND {isNull _position}) exitWith {\n    [\"empty array provided\",true] call KISKA_fnc_log;\n    grpNull\n};\n\nif (_position isEqualTo []) exitWith {\n    [\"empty array provided\",true] call KISKA_fnc_log;\n    grpNull\n};    \n\n\nprivate _nearestDistance = -1;\nprivate _nearest = grpNull;\n// radius is 3d for nearEntities\n(_position nearEntities [\"Logic\",RADIUS_TO_CHECK]) apply {\n    private _id = _x getVariable \"KISKA_ambientAnimGroup_ID\";\n    if (isNil \"_id\") then {continue};\n\n    private _distance = _position distance2D _x;\n    private _aNearestWasFound = !(isNull _nearest);\n    if (_aNearestWasFound AND (_distance > _nearestDistance)) then {\n        continue\n    };\n\n    _nearestDistance = _distance;\n    _nearest = _x;\n};\n\n\n_nearest\n",
    "fileName": "fn_ambientAnim_getNearestAttachLogicGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim\n\nDescription:\n    Returns whether or not a unit is currently using Kiska's ambient animation\n     system.\n\nParameters:\n    0: _unit <OBJECT> - A unit to check if they are using KISKA ambient anim system\n\nReturns:\n    <BOOL> - Whether or not the unit is using KISKA's ambient animation system\n\nExamples:\n    (begin example)\n        private _isAnimated = [someUnit] call KISKA_fnc_ambientAnim_isAnimated;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_isAnimated\";\n\nparams [\n    [\"_unit\",objNull,[objNull]]\n];\n\nif !(alive _unit) exitWith {\n    false\n};\n\nprivate _isAnimated = !(isNil {_unit getVariable \"KISKA_ambientAnimMap\"});\n\n\n_isAnimated\n",
    "fileName": "fn_ambientAnim_isAnimated.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_play\n\nDescription:\n    Starts animations for KISKA_fnc_ambientAnim.\n\n    This should not be directly called and is instead handled in events defined\n     in KISKA_fnc_ambientAnim.\n\nParameters:\n    0: _unit <OBJECT> - The unit to animate\n    1: _previousAnim <STRING> - The previous animation the unit played\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        (SHOULD NOT BE DIRECTLY CALLED)\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_play\";\n\nif (canSuspend) exitWith {\n    [\n        KISKA_fnc_ambientAnim_play,\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_previousAnim\",\"\",[\"\"]]\n];\n\nif !(alive _unit) exitWith {\n    [_unit] call KISKA_fnc_ambientAnim_stop;\n};\n\nprivate _ambientAnimInfoMap = _unit getVariable \"KISKA_ambientAnimMap\";\nif (isNil \"_ambientAnimInfoMap\") exitWith {\n    [\"Error: _ambientAnimInfoMap not found\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _animationSetInfo = _ambientAnimInfoMap get \"_animationSetInfo\";\nprivate _nearUnits = _unit nearEntities [\"man\", 5];\n_nearUnits deleteAt (_nearUnits find _unit);\n\nprivate _takenAnimations = _nearUnits apply {toLowerANSI (animationState _x)};\n_takenAnimations pushBack (toLowerANSI _previousAnim);\nprivate _setAnimations = _animationSetInfo getOrDefault [\"animations\",[]];\nprivate _animationsToUse = _setAnimations - _takenAnimations;\nif (_animationsToUse isEqualTo []) then {\n    _animationsToUse = _setAnimations;\n};\nprivate _animation = [_animationsToUse,\"\"] call KISKA_fnc_selectRandom;\n\nif (_animationSetInfo getOrDefault [\"canInterpolate\",false]) then {\n    private _jipId = _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_playMoveNow\";\n    [_unit,_animation] remoteExec [\"playMoveNow\",0,_jipId];\n\n} else {\n    // best practice to make sure an animation actually plays is to use both switchMove and playMoveNow\n    private _jipId = _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_switchMove\";\n    [_unit,_animation] remoteExec [\"switchMove\",0,_jipId];\n    \n    _jipId = _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_playMoveNow\";\n    [_unit,_animation] remoteExec [\"playMoveNow\",0,_jipId];\n\n};\n/* [[\"Play called for \", _unit,\" _previousAnim: \", _previousAnim, \" Current Anim: \",_animation]] call KISKA_fnc_log; */\n\nnil\n",
    "fileName": "fn_ambientAnim_play.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_setStoredLoadout\n\nDescription:\n    When a unit has it's loadout adjusted for an ambient animation, the loadout\n     they previously had is stored and restored after their ambient animation stops.\n\nParameters:\n    0: _unit <OBJECT> - The unit to animate\n    1: _loadout <ARRAY> - The loadout to store\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            someUnit,\n            getUnitLoadout someUnit\n        ] call KISKA_fnc_ambientAnim_setStoredLoadout;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_setStoredLoadout\";\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_loadout\",[],[[]]]\n];\n\nif (isNull _unit) exitWith {\n    [\"null unit passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _ambientAnimInfoMap = _unit getVariable \"KISKA_ambientAnimMap\";\nif (isNil \"_ambientAnimInfoMap\") exitWith {\n    [[_unit,\" does not have a KISKA_ambientAnimMap within their namespace\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_ambientAnimInfoMap set [\"_loadoutBeforeAnimation\",_loadout];\n\n\nnil\n",
    "fileName": "fn_ambientAnim_setStoredLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientAnim_stop\n\nDescription:\n    Stops a unit's use of KISKA_fnc_ambientAnim and returns them to the state they\n     were in before it ran.\n\nParameters:\n    0: _unit <OBJECT> - The unit who is running KISKA ambient anims\n    1: _triggeredByDeletion <BOOL> - If this stop was initiated by the delete Eventhandler\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [someUnit] call KISKA_fnc_ambientAnim_stop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientAnim_stop\";\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_triggeredByDeletion\",false,[true]]\n];\n\nif (isNull _unit) exitWith {\n    [\"_unit is null\",false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _ambientAnimInfoMap = _unit getVariable \"KISKA_ambientAnimMap\";\nif (isNil \"_ambientAnimInfoMap\") exitWith {\n    if (!_triggeredByDeletion) then {\n        [[_unit,\" does not have a KISKA_ambientAnimMap currently in their namespace!\"],true] call KISKA_fnc_log;\n    };\n\n    nil\n};\n\n// remove JIP messages\nremoteExec [\"\", _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_switchMove\"];\nremoteExec [\"\", _ambientAnimInfoMap get \"KISKA_ambientAnim_JIPId_playMoveNow\"];\n\n\ndetach _unit;\nprivate _attachToLogic = _ambientAnimInfoMap getOrDefault [\"_attachToLogic\",objNull];\nif !(isNull _attachToLogic) then {\n    deleteVehicle _attachToLogic;\n};\n\nprivate _behaviourEventId = _ambientAnimInfoMap getOrDefault [\"_behaviourEventId\",-1];\nif (_behaviourEventId >= 0) then {\n    [\n        _unit,\n        (configFile >> \"KISKA_eventHandlers\" >> \"Behaviour\"),\n        _behaviourEventId\n    ] call KISKA_fnc_eventHandler_remove;\n};\n\nprivate _snapToObject = _ambientAnimInfoMap getOrDefault [\"_snapToObject\",objNull];\nprivate _snapObjectIsNotNull = !(isNull _snapToObject);\nif (_snapObjectIsNotNull) then {\n    _snapToObject setVariable [\"KISKA_ambientAnim_objectUsedBy\",nil];\n    private _snapIdsUsedByUnit = _ambientAnimInfoMap getOrDefault [\"_usedSnapIds\",-1];\n    if (_snapIdsUsedByUnit isEqualTo -1) exitWith {};\n    \n    \n    private _objectUsedSnapIdList = _snapToObject getVariable [\"KISKA_ambientAnim_usedSnapIds\",[]];\n    if (_snapIdsUsedByUnit isEqualType 123) exitWith {\n        _objectUsedSnapIdList deleteAt (_objectUsedSnapIdList find _snapIdsUsedByUnit);\n    };\n\n    if (_snapIdsUsedByUnit isEqualType []) exitWith {\n        _snapIdsUsedByUnit apply {\n            _objectUsedSnapIdList deleteAt (_objectUsedSnapIdList find _snapIdsUsedByUnit);\n        };\n    };\n};\n\n\nif (_triggeredByDeletion) exitWith {};\nprivate _unitDeletedEventHandlerId = _ambientAnimInfoMap get \"_unitDeletedEventHandlerId\";\n_unit removeEventHandler [\"Deleted\", _unitDeletedEventHandlerId];\n\n\nif !(alive _unit) exitWith {};\n\n\n[\"ANIM\",\"AUTOTARGET\",\"FSM\",\"MOVE\",\"TARGET\"] apply {\n    [_unit,_x] remoteExecCall [\"enableAI\",_unit];\n};\n\nprivate _animDoneEventHandlerId = _ambientAnimInfoMap get \"_animDoneEventHandlerId\";\n_unit removeEventHandler [\"AnimDone\", _animDoneEventHandlerId];\n\nprivate _unitKilledEventHandlerId = _ambientAnimInfoMap get \"_unitKilledEventHandlerId\";\n_unit removeEventHandler [\"KILLED\", _unitKilledEventHandlerId];\n\n\n_unit setVariable [\"KISKA_ambientAnimMap\",nil];\n\n\nprivate _unitLoadoutBeforeAnimation = _ambientAnimInfoMap getOrDefault [\"_loadoutBeforeAnimation\",[]];\nif (_unitLoadoutBeforeAnimation isNotEqualTo []) then {\n    _unit setUnitLoadout _unitLoadoutBeforeAnimation;\n};\n\n\nif (_snapObjectIsNotNull) then {\n    [_unit, _snapToObject] remoteExecCall [\"enableCollisionWith\", _unit];\n    [_snapToObject,_unit] remoteExecCall [\"enableCollisionWith\", _snapToObject];\n};\n\n\n[_unit,\"\"] remoteExecCall [\"KISKA_fnc_resetMove\"];\n\n\nnil\n",
    "fileName": "fn_ambientAnim_stop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig\n\nDescription:\n    Spawns a configed KISKA base.\n\nParameters:\n    0: _baseConfig <STRING or CONFIG> - The config path of the base config or if\n        in missionConfigFile >> \"KISKA_bases\" config, its class\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        private _baseMap = [\"SomeBaseConfig\"] call KISKA_fnc_bases_createFromConfig;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig\";\n\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\n\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_turrets;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_infantry;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_agents;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_patrols;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_landVehicles;\n[_baseConfig] call KISKA_fnc_bases_createFromConfig_simples;\n\n\n// return base map\n[_baseConfig] call KISKA_fnc_bases_getHashmap\n",
    "fileName": "fn_bases_createFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_agents\n\nDescription:\n    Spawns a configed KISKA bases' agents.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_agents;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_agents\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_agentsList = _baseMap get \"agent list\";\n\nprivate _agentsConfig = _baseConfig >> \"agents\";\nprivate _agentClasses = configProperties [_agentsConfig,\"isClass _x\"];\n\n\n/* ----------------------------------------------------------------------------\n\n    Create Agents\n\n---------------------------------------------------------------------------- */\n_agentClasses apply {\n    private _classConfig = _x;\n    private _spawnPositions = (_classConfig >> \"positions\" ) call BIS_fnc_getCfgData;\n    if (_spawnPositions isEqualType \"\") then {\n        _spawnPositions = [_spawnPositions] call KISKA_fnc_getMissionLayerObjects;\n    };\n\n    if (_spawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n\n    private _unitClasses = [[_x,_baseConfig,_agentsConfig]] call KISKA_fnc_bases_getInfantryClasses;\n    \n    private _numberOfAgents = (_classConfig >> \"numberOfAgents\") call BIS_fnc_getCfgData;\n    if (_numberOfAgents isEqualType \"\") then {\n        _numberOfAgents = [[_spawnPositions],_numberOfAgents,false] call KISKA_fnc_callBack;\n    };\n\n    private _numberOfSpawns = count _spawnPositions;\n    if (_numberOfSpawns < _numberOfAgents OR (_numberOfAgents isEqualTo -1)) then {\n        _numberOfAgents = _numberOfSpawns;\n    };\n\n    _spawnPositions = [_spawnPositions] call CBA_fnc_shuffle;\n    private _agents = [];\n\n    private _placement = \"CAN_COLLIDE\";\n    private _placementConfigValue = getText(_x >> \"placement\");\n    if (_placementConfigValue isNotEqualTo \"\") then {\n        _placement = _placementConfigValue;\n    };\n\n    private _enableDynamicSim = [_classConfig >> \"dynamicSim\"] call BIS_fnc_getCfgDataBool;\n\n    for \"_i\" from 0 to (_numberOfAgents - 1) do {\n        private _spawnPosition = _spawnPositions select _i;\n        private _direction = 0;\n        if (_spawnPosition isEqualType objNull) then {\n            _direction = getDir _spawnPosition;\n        };\n        if (_spawnPosition isEqualType [] AND {count _spawnPosition > 3}) then {\n            _direction = _spawnPosition deleteAt 3;\n        };\n\n        private _agent = createAgent [\n            selectRandom _unitClasses,\n            _spawnPosition,\n            [],\n            0,\n            _placement\n        ];\n\n        _agent enableDynamicSimulation _enableDynamicSim;\n        _agent setDir _direction;\n        _agents pushBack _agent;\n    };\n\n    [_classConfig,_agents] call KISKA_fnc_bases_initAmbientAnimFromClass;\n\n\n    private _onAgentsCreated = getText(_classConfig >> \"onAgentsCreated\");\n    if (_onAgentsCreated isNotEqualTo \"\") then {\n        _onAgentsCreated = compile _onAgentsCreated;\n        [\n            _onAgentsCreated,\n            [_agents]\n        ] call CBA_fnc_directCall;\n    };\n\n    _base_agentsList append _agents;\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_agents.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_infantry\n\nDescription:\n    Spawns a configed KISKA bases' infantry.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_infantry;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_infantry\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\nprivate _base_infantryUnits = _baseMap get \"infantry units\";\nprivate _base_infantryGroups = _baseMap get \"infantry groups\";\n\nprivate _infantryConfig = _baseConfig >> \"infantry\";\nprivate _infantryClasses = configProperties [_infantryConfig,\"isClass _x\"];\n\n\n\n/* ----------------------------------------------------------------------------\n\n    Create Infantry\n\n---------------------------------------------------------------------------- */\n_infantryClasses apply {\n    private _classConfig = _x;\n    private _spawnPositions = (_classConfig >> \"positions\") call BIS_fnc_getCfgData;\n    if (_spawnPositions isEqualType \"\") then {\n        _spawnPositions = [_spawnPositions] call KISKA_fnc_getMissionLayerObjects;\n    };\n\n    if (_spawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n\n    private _unitClasses = [[_x,_baseConfig,_infantryConfig]] call KISKA_fnc_bases_getInfantryClasses;\n    if (_unitClasses isEqualTo []) then { \n        [\n            [\n                \"Unable to find any infantry classes for config: \",\n                _classConfig,\n                \" Check KISKA Base configuration for it.\"\n            ],\n            true\n        ] call KISKA_fnc_log;\n        continue \n    };\n\n\n    private _side = [[_x,_baseConfig,_infantryConfig]] call KISKA_fnc_bases_getSide;\n\n    private _numberOfUnits = (_classConfig >> \"numberOfUnits\") call BIS_fnc_getCfgData;\n    if (_numberOfUnits isEqualType \"\") then {\n        _numberOfUnits = [[_spawnPositions],_numberOfUnits,false] call KISKA_fnc_callBack;\n    };\n\n    private _unitsPerGroup = (_classConfig >> \"unitsPerGroup\") call BIS_fnc_getCfgData;\n    if (_unitsPerGroup isEqualType \"\") then {\n        _unitsPerGroup = [[_numberOfUnits,_spawnPositions],_unitsPerGroup,false] call KISKA_fnc_callBack;\n    };\n\n    if (_unitsPerGroup < 1) then {\n        _unitsPerGroup = _numberOfUnits;\n    };\n\n    private _allowedStances = getArray(_classConfig >> \"stances\");\n    if (_allowedStances isEqualTo []) then {\n        _allowedStances = [\"up\",0.7,\"middle\",0.3];\n    };\n\n    private _units = [\n        _numberOfUnits,\n        _unitsPerGroup,\n        _unitClasses,\n        _spawnPositions,\n        [_classConfig >> \"canPath\"] call BIS_fnc_getCfgDataBool,\n        [_classConfig >> \"dynamicSim\"] call BIS_fnc_getCfgDataBool,\n        _side,\n        _allowedStances\n    ] call KISKA_fnc_spawn;\n\n    if (_units isEqualTo []) then {\n        [\n            [\n                \"Unable to create any units for config: \",\n                _classConfig,\n                \" Check KISKA Base configuration for it.\"\n            ],\n            true\n        ] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    [_classConfig,_units] call KISKA_fnc_bases_initAmbientAnimFromClass;\n\n    private _onUnitsCreated = getText(_classConfig >> \"onUnitsCreated\");\n    if (_onUnitsCreated isNotEqualTo \"\") then {\n        _onUnitsCreated = compile _onUnitsCreated;\n        [\n            _onUnitsCreated,\n            [_units]\n        ] call CBA_fnc_directCall;\n    };\n\n    _base_unitList append _units;\n    _base_infantryUnits append _units;\n\n    private _groups = [];\n    _units apply {\n        private _group = group _x;\n        _groups pushBackUnique _group;\n    };\n\n    _base_groupList append _groups;\n    _base_infantryGroups append _groups;\n    _groups apply {\n        _x setVariable [\"KISKA_bases_config\",_classConfig];\n    };\n\n\n    if (isNull (_x >> \"reinforce\")) then { continue; };\n    [_groups,_x] call KISKA_fnc_bases_initReinforceFromClass;\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_infantry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_landVehicles\n\nDescription:\n    Spawns a configed KISKA bases' land vehicles.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_landVehicles;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_landVehicles\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\nprivate _base_landVehicles = _baseMap get \"land vehicles\";\nprivate _base_landVehicleGroups = _baseMap get \"land vehicle groups\";\n\n\n\n/* ----------------------------------------------------------------------------\n\n    Create Vehicles\n\n---------------------------------------------------------------------------- */\nprivate _landVehiclesConfig = _baseConfig >> \"landVehicles\";\nprivate _landVehicleConfigClasses = configProperties [_landVehiclesConfig,\"isClass _x\"];\n_landVehicleConfigClasses apply {\n    private _side = [[_x,_baseConfig,_landVehiclesConfig]] call KISKA_fnc_bases_getSide;\n\n    private _spawnPosition = (_x >> \"position\") call BIS_fnc_getCfgData;\n    private _spawnDirection = -1;\n    if (_spawnPosition isEqualType \"\") then {\n        _spawnPosition = missionNamespace getVariable [_spawnPosition,objNull];\n    };\n\n    if (_spawnPosition isEqualType []) then {\n        _spawnDirection = 0;\n        if (count _spawnPosition > 3) then {\n            _spawnDirection = _spawnPosition deleteAt 3;\n        };\n    };\n\n    private _vehicleClass = (_x >> \"vehicleClass\") call BIS_fnc_getCfgData;\n    if (_vehicleClass isEqualType []) then {\n        _vehicleClass = selectRandom _vehicleClass;\n    };\n\n    private _vehicleInfo = [\n        _spawnPosition,\n        _spawnDirection,\n        _vehicleClass,\n        _side,\n        true,\n        getArray(_x >> \"crew\"),\n        true\n    ] call KISKA_fnc_spawnVehicle;\n    _vehicleInfo params [\"_vehicle\",\"_units\",\"_group\"];\n\n    _base_unitList append _units;\n    _base_groupList pushBack _group;\n    _base_landVehicles pushBack _vehicle;\n    _base_landVehicleGroups pushBack _group;\n\n\n    if ([_x >> \"dynamicSim\"] call BIS_fnc_getCfgDataBool) then {\n        [_vehicle, true] remoteExec [\"enableDynamicSimulation\", 2];\n        [_group, true] remoteExec [\"enableDynamicSimulation\", 2];\n    };\n\n    if !([_x >> \"canPath\"] call BIS_fnc_getCfgDataBool) then {\n        (driver _vehicle) disableAI \"PATH\";\n    };\n\n    private _onVehicleCreated = getText(_x >> \"onVehicleCreated\");\n    if (_onVehicleCreated isNotEqualTo \"\") then {\n        [\n            compile _onVehicleCreated,\n            _vehicleInfo\n        ] call CBA_fnc_directCall;\n    };\n\n\n    if (isNull (_x >> \"reinforce\")) then {continue;};\n    [_x, _group] call KISKA_fnc_bases_initReinforceFromClass;\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_landVehicles.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_patrols\n\nDescription:\n    Spawns a configed KISKA bases' patrols.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_patrols;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_patrols\";\n\n#define DEFAULT_PATROL_BEHAVIOUR \"SAFE\"\n#define DEFAULT_PATROL_SPEED \"LIMITED\"\n#define DEFAULT_PATROL_COMBATMODE \"RED\"\n#define DEFAULT_PATROL_FORMATION \"STAG COLUMN\"\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\nprivate _base_patrolUnits = _baseMap get \"patrol units\";\nprivate _base_patrolGroups = _baseMap get \"patrol groups\";\n\nprivate _patrolsConfig = _baseConfig >> \"patrols\";\nprivate _patrolClasses = configProperties [_patrolsConfig,\"isClass _x\"];\n\n/* ----------------------------------------------------------------------------\n\n    Create Patrols\n\n---------------------------------------------------------------------------- */\n_patrolClasses apply {\n    private _spawnPosition = (_x >> \"spawnPosition\") call BIS_fnc_getCfgData;\n    if (_spawnPosition isEqualType \"\") then {\n        _spawnPosition = missionNamespace getVariable [_spawnPosition,objNull];\n    };\n\n    private _unitClasses = [[_x,_baseConfig,_patrolsConfig]] call KISKA_fnc_bases_getInfantryClasses;\n    private _side = [[_x,_baseConfig,_patrolsConfig]] call KISKA_fnc_bases_getSide;\n\n    private _numberOfUnits = (_x >> \"numberOfUnits\") call BIS_fnc_getCfgData;\n    if (_numberOfUnits isEqualType \"\") then {\n        _numberOfUnits = [[],_numberOfUnits,false] call KISKA_fnc_callBack;\n    };\n\n    private _group = [\n        _numberOfUnits,\n        _unitClasses,\n        _side,\n        _spawnPosition,\n        [_x >> \"dynamicSim\"] call BIS_fnc_getCfgDataBool\n    ] call KISKA_fnc_spawnGroup;\n\n\n    // patrol point details\n    private _behaviour = getText(_x >> \"behaviour\");\n    if (_behaviour isEqualTo \"\") then {\n        _behaviour = DEFAULT_PATROL_BEHAVIOUR;\n    };\n    private _speed = getText(_x >> \"speed\");\n    if (_speed isEqualTo \"\") then {\n        _speed = DEFAULT_PATROL_SPEED;\n    };\n    private _combatMode = getText(_x >> \"combatMode\");\n    if (_combatMode isEqualTo \"\") then {\n        _combatMode = DEFAULT_PATROL_COMBATMODE;\n    };\n    private _formation = getText(_x >> \"formation\");\n    if (_formation isEqualTo \"\") then {\n        _formation = DEFAULT_PATROL_FORMATION;\n    };\n\n\n\n    private _specificPatrolClass = _x >> \"SpecificPatrol\";\n    if (isClass _specificPatrolClass) then {\n        private _patrolPoints = (_specificPatrolClass >> \"patrolPoints\") call BIS_fnc_getCfgData;\n        if (_patrolPoints isEqualType \"\") then {\n            _patrolPoints = [_patrolPoints] call KISKA_fnc_getMissionLayerObjects;\n        };\n\n        if (_patrolPoints isEqualTo []) then {\n            [[\"Retrieved empty patrol points array for config class: \", _x >> \"SpecificPatrol\"],true] call KISKA_fnc_log;\n            continue;\n        };\n\n        [\n            _group,\n            _patrolPoints,\n            getNumber(_specificPatrolClass >> \"numberOfPoints\"),\n            [_specificPatrolClass >> \"random\"] call BIS_fnc_getCfgDataBool,\n            _behaviour,\n            _speed,\n            _combatMode,\n            _formation\n        ] call KISKA_fnc_patrolSpecific;\n\n    } else {\n        private _randomPatrolClass = _x >> \"RandomPatrol\";\n\n        // get params\n        private _patrolCenter = [_randomPatrolClass >> \"center\"] call BIS_fnc_getCfgDataArray;\n        if (_patrolCenter isEqualTo []) then {\n            _patrolCenter = _spawnPosition;\n        };\n        private _waypointType = getText(_randomPatrolClass >> \"waypointType\");\n        if (_waypointType isEqualTo \"\") then {\n            _waypointType = \"MOVE\";\n        };\n        private _radius = getNumber(_randomPatrolClass >> \"radius\");\n        if (_radius isEqualTo 0) then {\n            _radius = 500;\n        };\n\n\n        [\n            _group,\n            _patrolCenter,\n            _radius,\n            getNumber(_randomPatrolClass >> \"numberOfPoints\"),\n            _waypointType,\n            _behaviour,\n            _combatMode,\n            _speed,\n            _formation\n        ] call CBA_fnc_taskPatrol;\n    };\n\n    private _onGroupCreated = getText(_x >> \"onGroupCreated\");\n    if (_onGroupCreated isNotEqualTo \"\") then {\n        [\n            compile _onGroupCreated,\n            [_group]\n        ] call CBA_fnc_directCall;\n    };\n\n    _base_groupList pushBack _group;\n    _base_patrolGroups pushBack _group;\n\n    private _units = units _group;\n    _base_unitList append _units;\n    _base_patrolUnits append _units;\n\n    if (isNull (_x >> \"reinforce\")) then { continue; };\n    [_group,_x] call KISKA_fnc_bases_initReinforceFromClass;\n};\n\n\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_patrols.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_simples\n\nDescription:\n    Spawns a configed KISKA bases' simple objects.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_simples;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_simples\";\n\n#define DEFAULT_SIMPLE_OFFSET [0, 0, 0.1]\n\n#define SIMPLE_DATA_INDEX_TYPE 0\n#define SIMPLE_DATA_INDEX_OFFSET 1\n#define SIMPLE_DATA_INDEX_VECTORUP 2\n#define SIMPLE_DATA_INDEX_VECTORDIR 3\n#define SIMPLE_DATA_INDEX_ANIMATIONS 4\n#define SIMPLE_DATA_INDEX_SELECTIONS 5\n#define SIMPLE_DATA_INDEX_CREATED_EVENT 6\n#define SIMPLE_DATA_INDEX_FOLLOW_TERRAIN 7\n#define SIMPLE_DATA_INDEX_SUPERSIMPLE 8\n\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _simplesConfig = _baseConfig >> \"Simples\";\nprivate _simplesConfigClasses = configProperties [_simplesConfig,\"isClass _x\"];\n\n/* ----------------------------------------------------------------------------\n\n    Helper functions\n\n---------------------------------------------------------------------------- */\nprivate _configDataHashMap = createHashMap;\nprivate _fn_getSimpleClassData = {\n    params [\"_config\"];\n\n    private \"_dataArray\";\n    if (_config in _configDataHashMap) then {\n        _dataArray = _configDataHashMap get _config;\n\n    } else {\n        _dataArray = [];\n        \n        private \"_type\";\n        private _getTypeFunction = getText(_config >> \"getTypeFunction\");\n        if (_getTypeFunction isNotEqualTo \"\") then {\n            _type = [[_config],_getTypeFunction] call KISKA_fnc_callBack;\n        } else {\n            _type = (_config >> \"type\") call BIS_fnc_getCfgData;\n        };\n        _dataArray pushBack _type;\n\n\n        private _offsetConfig = _config >> \"offset\";\n        if (isArray _offsetConfig) then {\n            _dataArray pushBack (getArray _offsetConfig);\n        } else {\n            _dataArray pushBack [0,0,0.1];\n        };\n\n        _dataArray pushBack (getArray(_config >> \"vectorUp\"));\n        _dataArray pushBack (getArray(_config >> \"vectorDir\"));\n        _dataArray pushBack (getArray(_config >> \"animations\"));\n        _dataArray pushBack (getArray(_config >> \"selections\"));\n        _dataArray pushBack (compile (getText(_config >> \"onObjectCreated\")));\n\n        private _followTerrainConfig = _config >> \"followTerrain\";\n        if (isNumber _followTerrainConfig) then {\n            _dataArray pushBack ([_followTerrainConfig] call BIS_fnc_getCfgDataBool);\n\n        } else {\n            _dataArray pushBack true;\n\n        };\n\n        private _superSimpleConfig = _config >> \"superSimple\";\n        if (isNumber _superSimpleConfig) then {\n            _dataArray pushBack ([_superSimpleConfig] call BIS_fnc_getCfgDataBool);\n\n        } else {\n            _dataArray pushBack true;\n\n        };\n\n        _configDataHashMap set [_config,_dataArray];\n    };\n\n\n    _dataArray\n};\n\nprivate _fn_getTypeConfigs = {\n    params [\"_parentConfig\"];\n    \n    private _unfilteredTypeConfigs = configProperties [_parentConfig,\"isClass _x\"];\n    private _filteredTypeConfigs = [];\n\n    _unfilteredTypeConfigs apply {\n        private _filterCondition = getText(_x >> \"filterCondition\");\n        \n        private _conditionIsNotDefined = _filterCondition isEqualTo \"\";\n        if (\n            _conditionIsNotDefined OR\n            { [_x] call (compile _filterCondition) }\n        ) then {\n            _filteredTypeConfigs pushBack _x;\n        };\n    };\n\n\n    _filteredTypeConfigs\n};\n\n/* ----------------------------------------------------------------------------\n\n    Create objects\n\n---------------------------------------------------------------------------- */\nprivate [\n    \"_objectDirection\",\n    \"_offset\",\n    \"_vectorUp\",\n    \"_vectorDir\",\n    \"_animations\",\n    \"_selections\",\n    \"_onObjectCreated\"\n];\n_simplesConfigClasses apply {\n    private _topConfig = _x;\n    private _typeConfigs = [_topConfig] call _fn_getTypeConfigs;\n    if (_typeConfigs isEqualTo []) then {\n        [\n            [\n                \"Skipped simple bases class: \",_topConfig,\n                \" because no simple classes were found after filtering\"\n            ]\n        ] call KISKA_fnc_log;\n\n        continue;\n    };\n\n\n    private _positions = (_topConfig >> \"positions\") call BIS_fnc_getCfgData;\n    if (_positions isEqualType \"\") then {\n        private _layerObjects = [_positions] call KISKA_fnc_getMissionLayerObjects;\n        _positions = _layerObjects apply {\n            private _position = getPosASL _x; // TODO: This may need to be positions world?\n            _position pushBack (getDir _x);\n\n            _position\n        };\n    };\n\n    if (_positions isEqualTo []) then {\n        [\n            [\n                \"Skipped simple bases class: \",_topConfig,\n                \" because no positions were found\"\n            ]\n        ] call KISKA_fnc_log;\n\n        continue;\n    };\n\n\n    _positions apply {\n        if (count _x > 3) then {\n            _objectDirection = _x deleteAt 3;\n        } else {\n            _objectDirection = 0;\n        };\n\n        private _objectClass = selectRandom _typeConfigs;\n        private _objectData = [_objectClass] call _fn_getSimpleClassData;\n        private _objectType = _objectData select SIMPLE_DATA_INDEX_TYPE;\n        if (_objectType isEqualType []) then {\n            _objectType = [_objectType,\"\"] call KISKA_fnc_selectRandom;\n        };\n\n        private _object = [\n            _objectType,\n            _x,\n            _objectDirection,\n            _objectData select SIMPLE_DATA_INDEX_FOLLOW_TERRAIN,\n            _objectData select SIMPLE_DATA_INDEX_SUPERSIMPLE\n        ] call BIS_fnc_createSimpleObject;\n\n\n        _offset = _objectData select SIMPLE_DATA_INDEX_OFFSET;\n        if (_offset isNotEqualTo []) then {\n            _object setPosASL (_x vectorAdd _offset);\n        };\n\n        _vectorDir = _objectData select SIMPLE_DATA_INDEX_VECTORDIR;\n        if (_vectorDir isNotEqualTo []) then {\n            _object setVectorDir _vectorDir;\n        };\n\n        _vectorUp = _objectData select SIMPLE_DATA_INDEX_VECTORUP;\n        if (_vectorUp isNotEqualTo []) then {\n            _object setVectorUp _vectorUp;\n        };\n\n        (_objectData select SIMPLE_DATA_INDEX_ANIMATIONS) apply {\n            _object animate [_x select 0, _x select 1, true];\n        };\n        (_objectData select SIMPLE_DATA_INDEX_SELECTIONS) apply {\n            _object hideSelection [_x select 0, (_x select 1) > 0];\n        };\n\n        _onObjectCreated = _objectData select SIMPLE_DATA_INDEX_CREATED_EVENT;\n        if (_onObjectCreated isNotEqualTo {}) then {\n            [\n                _onObjectCreated,\n                [_object]\n            ] call CBA_fnc_directCall;\n        };\n    };\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_simples.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_createFromConfig_turrets\n\nDescription:\n    Spawns a configed KISKA bases' turrets.\n\nParameters:\n    0: _baseConfig <CONFIG> - The config path of the base config\n\nReturns:\n    <HASHMAP> - see KISKA_fnc_bases_getHashmap\n\nExamples:\n    (begin example)\n        [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_createFromConfig_turrets;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_createFromConfig_turrets\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseMap = [_baseConfig] call KISKA_fnc_bases_getHashmap;\nprivate _base_turretGunners = _baseMap get \"turret gunners\";\nprivate _base_unitList = _baseMap get \"unit list\";\nprivate _base_groupList = _baseMap get \"group list\";\n\nprivate _turretsConfig = _baseConfig >> \"turrets\";\nprivate _turretClasses = configProperties [_turretsConfig,\"isClass _x\"];\n\n/* ----------------------------------------------------------------------------\n\n    Create Turrets\n\n---------------------------------------------------------------------------- */\n_turretClasses apply {\n    private _turretConfig = _x;\n\n\n    private _turretSpawnPositions = (_turretConfig >> \"turretSpawnPositions\") call BIS_fnc_getCfgData;\n    if (_turretSpawnPositions isEqualType \"\") then {\n        _turretSpawnPositions = [_turretSpawnPositions] call KISKA_fnc_getMissionLayerObjects;\n    };\n    if (_turretSpawnPositions isEqualTo []) then {\n        [[\"Could not find spawn positions for KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n\n    private _turretTypes = (_turretConfig >> \"turretTypes\") call BIS_fnc_getCfgData;\n    if (_turretTypes isEqualType \"\") then {\n        _turretTypes = [[],_turretTypes,false] call KISKA_fnc_callBack;\n    };\n    if (_turretTypes isEqualTo []) then {\n        [[\"Could not find types for turrets in KISKA bases class: \",_x],true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _numberOfTurrets = (_classConfig >> \"numberOfTurrets\") call BIS_fnc_getCfgData;\n    private _totalNumberOfSpawns = count _turretSpawnPositions;\n    if (_numberOfTurrets isEqualType \"\") then {\n        _numberOfTurrets = [[_totalNumberOfSpawns],_numberOfTurrets,false] call KISKA_fnc_callBack;\n    };\n    if (_numberOfTurrets < 0) then {\n        _numberOfTurrets = _totalNumberOfSpawns\n    };\n\n\n    private _turrets = [];\n    for \"_i\" from 1 to _numberOfTurrets do {\n        private _spawnPosition = [_turretSpawnPositions] call KISKA_fnc_deleteRandomIndex;\n        private _class = [_turretTypes,\"\"] call KISKA_fnc_selectRandom;\n        private _turret = createVehicle [_class, _spawnPosition, [], 0, \"NONE\"];\n        _turrets pushBack _turret;\n    };\n\n    if (_turrets isEqualTo []) then {\n        [[\"Created no turrets for KISKA base class: \",_turretConfig], true] call KISKA_fnc_log;\n        continue;\n    };\n\n\n    private _unitClasses = [\n        [_turretConfig,_baseConfig,_turretsConfig]\n    ] call KISKA_fnc_bases_getInfantryClasses;\n\n    private _side = [\n        [_turretConfig,_baseConfig,_turretsConfig]\n    ] call KISKA_fnc_bases_getSide;\n\n    private _enableDynamicSim = [_turretConfig >> \"dynamicSim\"] call BIS_fnc_getCfgDataBool;\n    private _excludeFromHeadlessTransfer = [_turretConfig >> \"excludeHCTransfer\"] call BIS_fnc_getCfgDataBool;\n\n    private _onUnitCreated = compile getText(_turretConfig >> \"onUnitCreated\");\n    private _onUnitMovedInGunner = compile getText(_turretConfig >> \"onUnitMovedInGunner\");\n\n    private _reinforceClass = _turretConfig >> \"reinforce\";\n    _turrets apply {\n        private _group = createGroup _side;\n        private _unitClass = [_unitClasses,\"\"] call KISKA_fnc_selectRandom;\n        private _unit = _group createUnit [_unitClass,[0,0,0],[],0,\"NONE\"];\n        [_group,_excludeFromHeadlessTransfer] call KISKA_fnc_ACEX_setHCTransfer;\n\n\n        if (_onUnitCreated isNotEqualto {}) then {\n            [\n                _onUnitCreated,\n                [_unit]\n            ] call CBA_fnc_directCall;\n        };\n\n\n        if (_enableDynamicSim) then {\n            [_group, true] remoteExec [\"enableDynamicSimulation\", 2];\n        };\n        _unit moveInGunner _x;\n\n\n        if (_onUnitMovedInGunner isNotEqualto {}) then {\n            [\n                _onUnitMovedInGunner,\n                [_unit,_x]\n            ] call CBA_fnc_directCall;\n        };\n\n        _base_turretGunners pushBack _unit;\n        _base_unitList pushBack _unit;\n        _base_groupList pushBack _group;\n\n        if (isNull _reinforceClass) then { continue; };\n        [_group,_turretConfig] call KISKA_fnc_bases_initReinforceFromClass;\n    };\n\n};\n\n\n_baseMap\n",
    "fileName": "fn_bases_createFromConfig_turrets.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_getHashmap\n\nDescription:\n    Returns a KISKA bases' hashmap spawn data or initializes if it did not exist.\n\nParameters:\n    0: _baseConfig <CONFIG or STRING> - The config path of the base config\n\nReturns:\n    <HASHMAP> - a hashmap containing data about the base:\n\n    - `unit list`: <OBJECT[]> - All spawned units (includes turret units)\n    - `group list`: <GROUP[]> - All spawned groups (does NOT include turret units)\n    - `turret gunners`: <OBJECT[]> - All turret units\n    - `infantry units`: <OBJECT[]> - All infantry spawned units\n    - `infantry groups`: <GROUP[]> - All infantry spawned groups\n    - `patrol units`: <OBJECT[]> - All patrol spawned units\n    - `patrol groups`: <GROUP[]> - All patrol spawned groups\n    - `land vehicles`: <OBJECT[]> - All land spawned vehicles\n    - `land vehicle groups`: <GROUP[]> - All land vehicle crew groups\n    - `agent list`: <OBJECT[]> - All spawned agents\n\nExamples:\n    (begin example)\n        private _mapOfDataForSpecificBase = [\n            \"SomeBaseConfig\"\n        ] call KISKA_fnc_bases_getHashmap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_getHashmap\";\n\nparams [\n    [\"_baseConfig\",configNull,[\"\",configNull]]\n];\n\n\nif (_baseConfig isEqualType \"\") then {\n    _baseConfig = missionConfigFile >> \"KISKA_Bases\" >> _baseConfig;\n};\nif (isNull _baseConfig) exitWith {\n    [\"A null _baseConfig was passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _baseName = configName _baseConfig;\nif (isNil \"KISKA_bases_map\") then {\n    missionNamespace setVariable [\"KISKA_bases_map\",createHashMap];\n};\n\nprivate _baseData = KISKA_bases_map getOrDefault [_baseName, -1];\nif (_baseData isNotEqualTo -1) exitWith {_baseData};\n\n\n_baseData = createHashMapFromArray [\n    [\"unit list\",[]],\n    [\"group list\",[]],\n    [\"turret gunners\",[]],\n    [\"infantry units\",[]],\n    [\"infantry groups\",[]],\n    [\"patrol units\",[]],\n    [\"patrol groups\",[]],\n    [\"land vehicles\",[]],\n    [\"land vehicle groups\",[]],\n    [\"agent list\",[]]\n];\nKISKA_bases_map set [_baseName,_baseData];\n\n\n_baseData\n",
    "fileName": "fn_bases_getHashmap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_getInfantryClasses\n\nDescription:\n    Selects the most specific config's infantryClasses property and returns its\n     value.\n\nParameters:\n    0: _configClasses <ARRAY> - An array of CONFIGs to select the \"infantryClasses\"\n        property from. If a string, value is found, it will be treated as a function\n        that should return an array of classnames.\n\nReturns:\n    <STRING[]> - An array of STRING class names\n\nExamples:\n    (begin example)\n        [\n            [\n                missionConfigFile >> \"KISKA_Bases\" >> \"myBase\",\n                missionConfigFile >> \"KISKA_Bases\" >> \"myBase\" >> \"Infantry\",\n                missionConfigFile >> \"KISKA_Bases\" >> \"myBase\" >> \"Infantry\" >> \"myInfantryClass\"\n            ]\n        ] call KISKA_fnc_bases_getInfantryClasses;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_getInfantryClasses\";\n\nparams [\n    [\"_configClasses\",[],[[]]]\n];\n\nprivate _infantryClasses = [\n    \"infantryClasses\",\n    _configClasses,\n    [[],\"\"],\n    [123]\n] call KISKA_fnc_getMostSpecificCfgValue;\n\nif (isNil \"_infantryClasses\") exitWith {\n    [[\"No infantryClasses were found at the following configs: \",str _configClasses],true] call KISKA_fnc_log;\n    []\n};\n\nif (_infantryClasses isEqualType \"\") then {\n    _infantryClasses = [[],_infantryClasses] call KISKA_fnc_callBack;\n};\n\n\n_infantryClasses\n",
    "fileName": "fn_bases_getInfantryClasses.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_getSide\n\nDescription:\n    Selects the most specific config's infantryClasses property and returns its\n     value.\n\nParameters:\n    0: _configClasses <ARRAY> - An array of CONFIGs to select the \"side\" property from\n        That will be converted from a number in the side\n\nReturns:\n    <SIDE> - The returned side for the given configs\n\nExamples:\n    (begin example)\n        [\n            [\n                missionConfigFile >> \"KISKA_Bases\" >> \"myBase\"\n                missionConfigFile >> \"KISKA_Bases\" >> \"myBase\" >> \"Infantry\",\n                missionConfigFile >> \"KISKA_Bases\" >> \"myBase\" >> \"Infantry\" >> \"myInfantryClass\"\n            ]\n        ] call KISKA_fnc_bases_getSide;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_getSide\";\n\nparams [\n    [\"_configClasses\",[],[[]]]\n];\n\n\nprivate _sideId = [\n    \"side\",\n    _configClasses,\n    [],\n    [[],\"\"]\n] call KISKA_fnc_getMostSpecificCfgValue;\n\nif (isNil \"_sideId\") exitWith {\n    [[\"No side found the following configs: \", str _configClasses],true] call KISKA_fnc_log;\n    sideUnknown\n};\nprivate _side = _sideId call BIS_fnc_sideType;\n\n\n_side\n",
    "fileName": "fn_bases_getSide.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_initAmbientAnimFromClass\n\nDescription:\n    Parses and initializes a KISKA base entry's ambient animation class.\n\n    This is meant to be called from KISKA bases createFromConfig functions.\n\nParameters:\n    0: _configToInit <CONFIG> - The config path to the entry's that has an ambientAnim class\n    1: _units <OBJECT[] or OBJECT> - The units that are under the config to init\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            missionConfigFile >> \"SomeBaseConfig\" >> \"infantry >> \"someInfantryConfigClass\",\n            someUnit\n        ] call KISKA_fnc_bases_initAmbientAnimFromClass;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_initAmbientAnimFromClass\";\n\nparams [\n    [\"_configToInit\",configNull,[configNull]],\n    [\"_units\",objNull,[[],objNull]]\n];\n\nif (isNull _configToInit) exitWith {\n    [\"Passed a null _configToInit\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _ambientAnimConfig = _configToInit >> \"ambientAnim\";\nif (isNull _ambientAnimConfig) exitWith {\n    [[\"Config: \",_configToInit,\" does not have an 'ambientAnim' class in it\"],false] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _exitOnCombat = [_ambientAnimConfig >> \"exitOnCombat\"] call BIS_fnc_getCfgDataBool;\nprivate _equipmentLevel = (_ambientAnimConfig >> \"equipmentLevel\") call BIS_fnc_getCfgData;\nif (isNil \"_equipmentLevel\") then {\n    _equipmentLevel = \"\";\n};\n\n\nprivate _animationParams = \"\";\nprivate _animationSetConfig = _ambientAnimConfig >> \"animationSet\";\nif (isClass _animationSetConfig) then {\n    private _snapToAnimationSets = (_animationSetConfig >> \"snapToAnimations\") call BIS_fnc_getCfgData;\n    if (isNil \"_snapToAnimationSets\") then { _snapToAnimationSets = \"\" };\n\n    private _backupAnimationSets = (_animationSetConfig >> \"backupAnimations\") call BIS_fnc_getCfgData;\n    if (isNil \"_backupAnimationSets\") then { _backupAnimationSets = \"\" };\n\n    private _snapToRange = getNumber(_animationSetConfig >> \"snapToRange\");\n    private _snapRangeIsUndefined = _snapToRange isEqualTo 0;\n    if (_snapRangeIsUndefined) then {\n        _snapToRange = 5;\n    };\n    private _fallbackFunction = getText(_animationSetConfig >> \"fallbackFunction\");\n    \n    _animationParams = createHashMapFromArray [\n        [\"_animSet\",_snapToAnimationSets],\n        [\"_snapToRange\",_snapToRange],\n        [\"_backupAnims\",_backupAnimationSets],\n        [\"_fallbackFunction\",_fallbackFunction]\n    ];\n\n} else {\n    _animationParams = _animationSetConfig call BIS_fnc_getCfgData;\n};\n\n\n\nprivate _args = [\n    _units,\n    _animationParams,\n    _exitOnCombat,\n    _equipmentLevel\n];\n\nprivate _getAnimationMapFunction = getText(_ambientAnimConfig >> \"getAnimationMapFunction\");\nif (_getAnimationMapFunction isNotEqualTo \"\") then {\n    private _animationMap = [[],_getAnimationMapFunction] call KISKA_fnc_callBack;\n    _args pushBack _animationMap;\n};\n\n_args call KISKA_fnc_ambientAnim;\n\n\nnil\n",
    "fileName": "fn_bases_initAmbientAnimFromClass.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_initReinforceFromClass\n\nDescription:\n    Parses a reinforce class that is used in a unit's KIKSA bases class, and\n    initializes the group(s) reactivity to it.\n\nParameters:\n    0: _group <GROUP, GROUP[]> - The config path of the base config\n    1: _config <CONFIG> - The config path of the base config\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _group,\n            SomeBaseConfig >> \"infantry\" >> \"someUnitClass\"\n        ] call KISKA_fnc_bases_initReinforceFromClass;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_initReinforceFromClass\";\n\nparams [\n    [\"_group\",grpNull,[grpNull,[]]],\n    [\"_config\",configNull,[configNull]]\n];\n\nprivate _groupIsArray = _group isEqualType [];\nif ((!_groupIsArray) AND {isNull _group}) exitWith {\n    [\"_group is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_groupIsArray AND {_group isEqualTo []}) exitWith {\n    [\"_group is an empty array!\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (isNull _config) exitWith {\n    [\"_config is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _reinforceClass = _x >> \"reinforce\";\nif (isNull _reinforceClass) exitWith {\n    [\n        [\"config \",_config,\" does not have a 'reinforce' class within it!\"],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _reinforceId = configName _x;\nprivate _idPropertyConfig = _reinforceClass >> \"id\";\nif (isText _idPropertyConfig) then {\n    _reinforceId = _idPropertyConfig call BIS_fnc_getCfgData;\n};\n\nprivate _canCallIds = getArray(_reinforceClass >> \"canCall\");\nprivate _reinforcePriority = getNumber(_reinforceClass >> \"priority\");\nprivate _onEnemyDetected = getText(_reinforceClass >> \"onEnemyDetected\");\n\nif (_groupIsArray) exitWith {\n    _group apply {\n        [\n            _x,\n            _reinforceId,\n            _canCallIds,\n            _reinforcePriority,\n            _onEnemyDetected\n        ] call KISKA_fnc_bases_setupReactivity;\n    };\n\n    nil\n};\n\n\n[\n    _group,\n    _reinforceId,\n    _canCallIds,\n    _reinforcePriority,\n    _onEnemyDetected\n] call KISKA_fnc_bases_setupReactivity;\n\n\nnil\n",
    "fileName": "fn_bases_initReinforceFromClass.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_setupReactivity\n\nDescription:\n    Adds values and eventhandlers to the given group's namespace to be able to \n     interact with KISKA bases reaction system\n\nParameters:\n    0: _group <GROUP> - The group to add setup reactions for\n    1: _reinforceId <NUMBER or STRING> - A globally unqiue identifier for this group (or a collection of groups)\n    2: _canCallIds <STRING[]> - An array of _reinforceIds denoting groups that will respond to\n        distress calls from this group\n    3: _priority <NUMBER> - a number signifying how important this group's call will be\n        (if a group is responding to another call, they will break away from it for this call if higher)\n    4: _onEnemyDetected <CODE or STRING> - Code that will be executed when the group enters combat.\n        Must return a boolean that denotes whether to execute default functionality that happens\n        with the event (see KISKA_fnc_bases_triggerReaction).\n        \n        Parameters:\n        - 0: <GROUP> - The group the event is triggering for\n        - 1: <OBJECT> - The enemy unit that was detected\n        - 2: <ARRAY> - An array of GROUPs that can respond to the call (based on _canCallIds)\n        - 3: <NUMBER> - The same _priority\n\nReturns:\n    <NUMBER> - The event id of the EnemyDetected group eventhandler\n\nExamples:\n    (begin example)\n        [\n            aGroup,\n            123,\n            [\"anotherGroupsId\"],\n            1,\n            {\n                hint str _this;\n                false // continue with default reaction behaviour\n            }\n        ] call KISKA_fnc_bases_setupReactivity;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_setupReactivity\";\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_reinforceId\",\"\",[123,\"\"]],\n    [\"_canCallIds\",[],[[]]],\n    [\"_priority\",1,[123]],\n    [\"_onEnemyDetected\",{},[\"\",{}]]\n];\n\nif (isNull _group) exitWith {\n    [\"Null group passed\",true] call KISKA_fnc_log;\n    -1\n};\n\n\n_group setVariable [\"KISKA_bases_canCallReinforceIds\", _canCallIds];\n_group setVariable [\"KISKA_bases_reinforcePriority\", _priority];\n_group setVariable [\"KISKA_bases_reinforceId\", _reinforceId];\n\nif (_onEnemyDetected isEqualType \"\") then {\n    _onEnemyDetected = compile _onEnemyDetected;\n};\n_group setVariable [\"KISKA_bases_reinforceOnEnemyDetected\",_onEnemyDetected];\n\n\n\nif (isNil \"KISKA_bases_reinforceGroupsMap\") then {\n    missionNamespace setVariable [\"KISKA_bases_reinforceGroupsMap\",createHashMap];\n};\n\nprivate _entryWithId = KISKA_bases_reinforceGroupsMap getOrDefault [_reinforceId,[]];\nprivate _idTaken = _entryWithId isNotEqualTo [];\nif (_idTaken) then {\n    _entryWithId pushBackUnique _group;\n} else {\n    KISKA_bases_reinforceGroupsMap set [_reinforceId,[_group]];\n};\n\n\n_group addEventHandler [\"EnemyDetected\",KISKA_fnc_bases_triggerReaction];\n",
    "fileName": "fn_bases_setupReactivity.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_bases_triggerReaction\n\nDescription:\n    Acts as the default event for the reactive bases when a group calls for reinforcements.\n\nParameters:\n    0: _group <GROUP> - The group the event is triggering for\n    1: _detectedTarget <OBJECT> - The enemy unit that was detected\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            someGroup,\n            anEnemyUnit\n        ] call KISKA_fnc_bases_triggerReaction\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_bases_triggerReaction\";\n\nparams [\n    [\"_group\",grpNull,[grpNull]],\n    [\"_detectedTarget\",objNull,[objNull]]\n];\n\nif ((isNull _group) OR (isNull _detectedTarget)) exitWith {};\n\nprivate _reinforceGroupIds = _group getVariable [\"KISKA_bases_canCallReinforceIds\",[]];\nprivate _groupsToRespond = [];\n_reinforceGroupIds apply {\n    private _groups = KISKA_bases_reinforceGroupsMap get _x;\n    _groupsToRespond append _groups;\n};\n\n\nprivate _priority = _group getVariable [\"KISKA_bases_reinforcePriority\",-1];\nprivate _onEnemyDetected = _group getVariable [\"KISKA_bases_reinforceOnEnemyDetected\",{}];\nprivate _preventDefault = false;\n\nif (_onEnemyDetected isNotEqualTo {}) then {\n    _preventDefault = [\n        _group,\n        _detectedTarget,\n        _groupsToRespond,\n        _priority\n    ] call _onEnemyDetected;\n};\n\n\nif (_preventDefault) exitWith {};\n\n// don't try to fight air vehicles\nprivate _targetVehicleALT = (getPosATL _detectedTarget) select 2;\nif (_targetVehicleALT >= 5) exitWith {\n    [\n        [\n            _group,\n            \" detected a target that could not be reached: \",\n            _detectedTarget,\n            \" which is of type: \",\n            typeOf _detectedTarget \n        ],\n        false\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    Default response behviour\n---------------------------------------------------------------------------- */\nprivate _fnc_findReplacementTarget = {\n    params [\"_group\"];\n\n    private _simDistance = dynamicSimulationDistance \"Group\";\n    private _targets = [];\n    private \"_leaderOfCallingGroup\";\n    waitUntil {\n        sleep 2;\n        // in case leader changes\n        _leaderOfCallingGroup = leader _group;\n        if !(alive _leaderOfCallingGroup) exitWith {true};\n        _targets = _leaderOfCallingGroup targets [true, _simDistance];\n        if (_targets isEqualTo []) then {continueWith false};\n\n        private _foundEnemyIndex = _targets findIf { !(captive _x) };\n        _foundEnemyIndex isNotEqualTo -1;\n    };\n\n    // in case _closestEnemy dies while processing\n    private _closestEnemy = objNull;\n    private _distanceOfClosest = -1;\n    _targets apply {\n        if (captive _x) then {continue};\n\n        private _distance = _x distance _leaderOfCallingGroup;\n        if (!(alive _closestEnemy) OR (_distance < _distanceOfClosest)) then {\n            _distanceOfClosest = _distance;\n            _closestEnemy = _x;\n        };\n    };\n\n\n    _closestEnemy\n};\n\n\n\n[\n    _group,\n    _detectedTarget,\n    _groupsToRespond,\n    _priority,\n    _fnc_findReplacementTarget\n] spawn {\n    scriptName \"KISKA_fnc_bases_triggerReaction\";\n\n    params [\"_group\",\"_detectedTarget\",\"_groupsToRespond\",\"_priority\",\"_fnc_findReplacementTarget\"];\n\n    sleep 3;\n\n    private _groupIsAlive = [_group] call KISKA_fnc_isGroupAlive;\n    if !(_groupIsAlive) exitWith {};\n\n    if (\n        !(alive _detectedTarget) AND\n        {\n            _detectedTarget = [_group] call _fnc_findReplacementTarget;\n            isNull _detectedTarget\n        }\n    ) exitWith {\n        [\"Original detected target is not alive and could not find replacement\"] call KISKA_fnc_log;\n        nil\n    };\n\n    private _groupRespondingToId = _group getVariable [\"KISKA_bases_respondingToId\",\"\"];\n    private _groupIsAlsoResponding = _groupRespondingToId isNotEqualTo \"\";\n    private _groupReinforceId = _group getVariable [\"KISKA_bases_reinforceId\",\"\"];\n    private _leaderOfCallingGroup = leader _group;\n\n    _groupsToRespond apply {\n        private _currentMissionPriority = _x getVariable [\"KISKA_bases_responseMissionPriority\",-1];\n        private _currentlyStalked = _x getVariable [\"KISKA_bases_stalkingThis\",objNull];\n\n        if (\n            (_currentMissionPriority > _priority) OR \n            (!(isNull _currentlyStalked) AND (_detectedTarget isEqualTo _currentlyStalked))\n        ) then {\n            continue;\n        };\n\n        // check that the group being called doesn't already have\n        // the group calling responding to them\n        // e.g. group1 calls for group2, group2 then calls for group1\n        // group2 shouldn't acknowledge this because group1 already called\n        private _reinforceId = _x getVariable [\"KISKA_bases_reinforceId\",\"\"];\n        private _willBeCircularResponse = _reinforceId isEqualTo _groupRespondingToId;\n        if (_groupIsAlsoResponding AND _willBeCircularResponse) then {\n            continue;\n        };\n\n        private _leaderOfRespondingGroup = leader _x;\n        if ((isNull _x) OR (isNull _leaderOfRespondingGroup)) then {\n            continue;\n        };\n\n        _x setVariable [\"KISKA_bases_stalkingThis\",_detectedTarget];\n\n        private _currentBehaviour = combatBehaviour _x;\n        private _distanceBetweenGroups = _leaderOfRespondingGroup distance _leaderOfCallingGroup;\n        if (\n            (_distanceBetweenGroups > 20) AND\n            (_currentBehaviour != \"combat\")\n        ) then {\n            [_x,\"aware\"] remoteExec [\"setBehaviourStrong\",_leaderOfRespondingGroup];\n        };\n\n        private _groupUnits = units _x;\n        // reset infantry positions\n        _groupUnits apply {\n            private _isAnimated = [_x] call KISKA_fnc_ambientAnim_isAnimated;\n            if (_isAnimated) then {\n                [_x] call KISKA_fnc_ambientAnim_stop;\n            };\n\n            [_x,\"AUTO\"] remoteExec [\"setUnitPos\",_x];\n        };\n        // in case unit was told to stop with doStop\n        [_groupUnits, _leaderOfRespondingGroup] remoteExec [\"doFollow\", _leaderOfRespondingGroup];\n\n        // some time is needed after reseting units with doFollow or they will lock up\n        sleep 1;\n        \n        [_x, _detectedTarget, 15, {\n            params [\"_stalkerGroup\",\"_stalkedUnit\",\"_groupToStalk\"];\n            \n            private _groupIsAlive = [_stalkerGroup] call KISKA_fnc_isGroupAlive;\n            if (!_groupIsAlive) exitWith {};\n\n            private _canStalkGroup = [_groupToStalk] call KISKA_fnc_isGroupAlive;\n            if (!_canStalkGroup) exitWith {\n                _stalkerGroup setVariable [\"KISKA_bases_responseMissionPriority\", nil];\n                _stalkerGroup setVariable [\"KISKA_bases_respondingToId\", nil];\n                _stalkerGroup setVariable [\"KISKA_bases_stalkingThis\", nil];\n            };\n \n            [\n                _stalkerGroup,\n                _groupToStalk,\n                20,\n                {\n                    params [\"_stalkerGroup\"];\n                    \n                    _stalkerGroup setVariable [\"KISKA_bases_responseMissionPriority\", nil];\n                    _stalkerGroup setVariable [\"KISKA_bases_respondingToId\", nil];\n                    _stalkerGroup setVariable [\"KISKA_bases_stalkingThis\", nil];\n                }\n            ] spawn KISKA_fnc_stalk;\n            \n        }] spawn KISKA_fnc_stalk;\n\n        _x setVariable [\"KISKA_bases_responseMissionPriority\",_priority];\n        _x setVariable [\"KISKA_bases_respondingToId\", _groupReinforceId];\n    };\n};\n\n\n\n\nnil\n",
    "fileName": "fn_bases_triggerReaction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ciwsAlarm\n\nDescription:\n    Sounds an alarm for the CIWS\n\nParameters:\n    0: _turret : <OBJECT> - The CIWS turret\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [turret1] spawn KISKA_fnc_ciwsAlarm;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ciwsAlarm\";\n\n#define WAIT_FOR_AIRRAIDSTART 6.4\n#define WAIT_TO_LOOP_SOUND 10.8\n#define ALARM_DISTANCE 1000\n#define ALARM_VOLUME 3\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled; running in scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_ciwsAlarm;\n};\n\nparams [\n    [\"_turret\",objNull,[objNull]]\n];\n\nif (isNull _turret) exitWith {\n    [[_turret,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_turret getVariable [\"KISKA_CIWS_alarmSounding\",false]) exitWith {\n    [[_turret,\" already has its alarm sounding\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n// set turret to engaging targets\n_turret setVariable [\"KISKA_CIWS_allClear\",false];\n_turret setVariable [\"KISKA_CIWS_alarmSounding\",true];\n\n// start the alarms\n[\"KISKA_airRaidStart\",_turret,ALARM_DISTANCE,ALARM_VOLUME] call KISKA_fnc_playSound3d;\n\n// start Sirens\n[_turret] spawn KISKA_fnc_ciwsSiren;\n\n// To make the sounds appear to be synched, wait a bit to start the loop audio\nsleep WAIT_FOR_AIRRAIDSTART;\n\n// start the air raid loop\nwaitUntil {\n    // check if loop should end and play audio if it should\n    if (_turret getVariable \"KISKA_CIWS_allClear\") exitWith {\n        [\"KISKA_airRaidEnd\",_turret,1000,3] call KISKA_fnc_playSound3d;\n        _turret setVariable [\"KISKA_CIWS_alarmSounding\",false];\n        true\n    };\n\n    // play looped audio again\n    [\"KISKA_airRaidLoop\",_turret,1000,3] call KISKA_fnc_playSound3d;\n    // sound should wait to loop back to end audio or loop sound\n    sleep WAIT_TO_LOOP_SOUND;\n    false\n};\n\n\nnil\n",
    "fileName": "fn_ciwsAlarm.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ciwsInit\n\nDescription:\n    Fires a number of rounds from AAA piece at target with random disperstion values.\n\n    To stop, set the variable \"KISKA_runCIWS\" to false.\n\nParameters:\n    0: _turret : <OBJECT> - The CIWS turret\n    1: _searchDistance : <NUMBER> - How far out will the CIWS be notified of a target\n    2: _engageAboveAltitude : <NUMBER> - What altittiude (AGL) does the target need to be above to be engaged\n    3: _searchInterval : <NUMBER> - Time between checks for targets in area\n    4: _doNotFireBelowAngle : <NUMBER> - Below what angle should the turret NOT fire (keep it from firing at ground accidently)\n    5: _pitchTolerance : <NUMBER> - if the turret's pitch is within this margin of degrees to the target, it can engage\n    6: _rotationTolerance : <NUMBER> - if the turret's rotation is within this margin of degrees to the target, it can engage\n    7: _soundAlarm : <BOOL> - Play air raid siren and sound alarm when incoming detected\n    8: _engageTypes : <ARRAY> - This array decides what types of objects or entities should be engaged by the CIWS\n                                 these are formatted as an array or string inside, using an array allows the\n                                 decision to define a type as supported by nearEntities (which is much faster then the default nearObjects)\n                                 simply by setting it as [\"myEntityType\",true]\n\nReturns:\n    Nothing\n\nExamples:\n    (begin example)\n        [turret,3000,100] spawn KISKA_fnc_ciwsInit;\n    (end)\n\nAuthor:\n    DayZMedic,\n    modified/optimized by Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ciwsInit\";\n\n\n#define DEFAULT_ENGAGE_TYPES [[\"RocketBase\",false],[\"MissileBase\",false],[\"ShellBase\",false],[\"R_230mm_HE\",false]]\n#define NUMBER_OF_MAGS 3\n#define EXPLOSION_DELAY_CONST 0.0005\n#define TURRET_WEAPON \"Gatling_30mm_Plane_CAS_01_F\"\n#define TURRET_MAGAZINE \"1000Rnd_Gatling_30mm_Plane_CAS_01_F\"\n\n\nif !(local (_this select 0)) exitWith {\n    [\"Must be run where the unit is local, remoting to local\",true] call KISKA_fnc_log;\n    _this remoteExec [\"KISKA_fnc_ciwsInit\",(_this select 0)];\n};\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled; running in scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_ciwsInit;\n};\n\nparams [\n    [\"_turret\",objNull,[objNull]],\n    [\"_searchDistance\",3000,[123]],\n    [\"_engageAboveAltitude\",50,[123]],\n    [\"_searchInterval\",2,[123]],\n    [\"_doNotFireBelowAngle\",5,[123]],\n    [\"_pitchTolerance\",3,[123]],\n    [\"_rotationTolerance\",10,[123]],\n    [\"_soundAlarm\",true,[false]],\n    [\"_engageTypes\",DEFAULT_ENGAGE_TYPES,[]]\n];\n\nif (isNull _turret) exitWith {\n    [[_turret,\" is a null object. Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\nif !(_turret isKindOf \"AAA_System_01_base_F\") exitWith {\n    [[typeOf _turret,\" is not the proper type (AAA_System_01_base_F). Exiting...\"],true] call KISKA_fnc_log;\n    nil\n};\n\n// disable HC transfer\n[group _turret,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n\n// give the turret the cool red tracer gatling for more authenticity\n_turret addWeaponTurret [TURRET_WEAPON, [0]];\nfor \"_i\" from 1 to NUMBER_OF_MAGS do {\n    _turret addMagazineTurret [TURRET_MAGAZINE,[0],1000];\n};\n_turret selectWeaponTurret [TURRET_WEAPON,[0]];\n\nprivate _engagedTargetsHash = missionNamespace getVariable [\"KISKA_CIWS_engagedTargetsHash\",createHashMap];\nif (isNil \"KISKA_CIWS_engagedTargetsHash\") then {\n    missionNamespace setVariable [\"KISKA_CIWS_engagedTargetsHash\",_engagedTargetsHash];\n};\n\n\n_turret setVariable [\"KISKA_runCIWS\",true];\n\n// make sure turret only fires when we tell it to\n// possibly add this as a param in the future\n//_turret setCombatMode \"BLUE\";\n\n[[_turret,\" set KISKA_runCIWS to true\"],false] call KISKA_fnc_log;\n\nprivate [\n    \"_targetDistance\",\n    \"_turretPitchAngle\",\n    \"_angleToTarget\",\n    \"_currentPitchTolerance\",\n    \"_turretVector\",\n    \"_turretDir\",\n    \"_relativeDir\",\n    \"_currentRotTolerance\",\n    \"_targetAlt\",\n    \"_firedShots\",\n    \"_turretPitchAngle\",\n    \"_targetPos\",\n    \"_targetBoom\",\n    \"_targetIndex\",\n    \"_targetNetId\"\n];\n\nprivate _incoming = [];\nprivate _fn_updateIncomingList = {\n    // nearestObjects and nearEntities do not work here\n    [[_turret,\" is searching for incoming within \",_searchDistance],false] call KISKA_fnc_log;\n\n    _incoming = [];\n\n    _engageTypes apply {\n        _x params [\n            \"_type\",\n            [\"_isEntity\",false]\n        ];\n\n        if (_isEntity) then {\n            _incoming append (_turret nearEntities [_type,_searchDistance]);\n        } else {\n            _incoming append (_turret nearObjects [_type,_searchDistance]);\n        };\n\n    };\n\n    [[_turret,\" found \",_incoming],false] call KISKA_fnc_log;\n\n    _incoming\n};\n\nprivate _target = objNull;\n\nprivate _fn_isNullTarget = {\n    isNull _target\n};\n\n// used a wait and exec to create a new thread so that this could be evaluated independently\n// the goal is to reduce alarm sound overlap by keeping it going if the rounds are close together\nprivate _fn_checkIfStopAlarm = {\n    [\n        {\n            params [\"_turret\",\"_searchDistance\",\"_engageTypes\"];\n            private _incoming = [];\n\n            _engageTypes apply {\n                _x params [\n                    \"_type\",\n                    [\"_isEntity\",false]\n                ];\n\n                if (_isEntity) then {\n                    _incoming append (_turret nearEntities [_type,_searchDistance]);\n                } else {\n                    _incoming append (_turret nearObjects [_type,_searchDistance]);\n                };\n            };\n\n            if (_incoming isEqualTo []) then {\n                _turret setVariable [\"KISKA_CIWS_allClear\",true];\n            };\n        },\n        [_turret,_searchDistance,_engageTypes],\n        5\n    ] call CBA_fnc_waitAndExecute;\n};\n\n// turrets don't like to watch objects consistently, so we'll use their position instead for doWatch\nprivate _fn_updateTargetPos = {\n    _targetPos = getPosASLVisual _target;\n};\n\nprivate _fn_waitToFireOnTarget = {\n    _turret enableAI \"WEAPONAIM\";\n\n    waitUntil {\n        if (call _fn_isNullTarget) exitWith {\n            [[_turret,\" stopped waiting on null target #1\"],false] call KISKA_fnc_log;\n            true\n        };\n        // keep turret rotating to target\n        [[_turret,\" trying to get an angle on \",_target],false] call KISKA_fnc_log;\n\n// why?\n/*\n        if (call _fn_isNullTarget) exitWith {\n            [[_turret,\" stopped waiting on null target #1\"],false] call KISKA_fnc_log;\n            true\n        };\n*/\n        call _fn_updateTargetPos;\n        _turret lookAt _targetPos;\n\n        //// turret pitch\n        // get turrets pitch angle (0.6 offset is baked into source anim)\n        _turretPitchAngle = abs ((deg (_turret animationSourcePhase \"maingun\")) + 0.6);\n        // get the angle needed to target\n        _angleToTarget = abs (acos ((_turret distance2D _target) / (_turret distance _target)));\n        // get the difference between turrets current pitch and the targets actual angle\n        _currentPitchTolerance = (selectMax [_turretPitchAngle,_angleToTarget]) - (selectMin [_turretPitchAngle,_angleToTarget]);\n        [[\"_turret: \",_turret,\" _turretPitchAngle: \",_turretPitchAngle,\" _angleToTarget: \",_angleToTarget,\" _currentPitchTolerance: \",_currentPitchTolerance],false] call KISKA_fnc_log;\n\n        //// turret rotation\n        // get turrets rotational angle\n        _turretVector = _turret weaponDirection (currentWeapon _turret);\n        _turretDir = (_turretVector select 0) atan2 (_turretVector select 1);\n        _turretDir = [_turretDir] call CBA_fnc_simplifyAngle;\n        // get relative rotational angle to the target\n        _relativeDir = _turret getDir _target;\n        // get the degree between where the target is at relative to the turret position and its actual gun\n        _currentRotTolerance = (_turretDir max _relativeDir) - (_turretDir min _relativeDir);\n        [[\"_turret: \",_turret,\" _turretVector: \",_turretVector,\" _turretDir: \",_turretDir,\" _relativeDir: \",_relativeDir,\" _currentRotTolerance: \",_currentRotTolerance],false] call KISKA_fnc_log;\n\n        // get target alt\n        call _fn_updateTargetPos;\n        _targetAlt = (ASLToAGL _targetPos) select 2;\n\n        if (call _fn_isNullTarget) exitWith {\n            [[_turret,\" stopped waiting on null target #2\"],false] call KISKA_fnc_log;\n            true\n        };\n\n        if (\n            (_currentPitchTolerance <= _pitchTolerance AND\n            {_currentRotTolerance <= _rotationTolerance} AND\n            {_targetALt >= _engageAboveAltitude})/* OR\n\n            {(_turret distance _target) >= (_searchDistance * 0.75)}*/\n        )\n        exitWith {\n            [[_turret,\" got an angle on \",_target],false] call KISKA_fnc_log;\n            true\n        };\n\n        sleep 0.25;\n        [[_turret,\" sleep 0.25\"],false] call KISKA_fnc_log;\n\n        false\n    };\n};\n\nprivate _fn_whileTargetsIncoming = {\n    [[_turret,\" found targets\"],false] call KISKA_fnc_log;\n\n    // while there are still targets in the air; this was orginally a simple for loop, but the alarm sound requires the extra complication of\n    /// searching for incoming projectiles constantly after the first is detected\n    while {\n        [[_turret,\" sleep 0.5, _fn_whileTargetsIncoming\"],false] call KISKA_fnc_log;\n        sleep 0.5;\n        call _fn_updateIncomingList;\n        // if projectiles are still incoming\n        if !(_incoming isEqualTo []) then {true} else {false}\n    } do {\n        // check if sound alarm requested and that the alarm is not already sounding\n        if (_soundAlarm AND {!(_turret getVariable [\"KISKA_CIWS_alarmSounding\",false])}) then {\n            // sound alarm\n            [_turret] spawn KISKA_fnc_ciwsAlarm;\n        };\n\n        [[_turret,\" searching through targets\"],false] call KISKA_fnc_log;\n        _targetIndex = _incoming findIf {\n            // check if another turret is already engaging the target\n            !((_x call BIS_fnc_netId) in KISKA_CIWS_engagedTargetsHash) AND\n            {(_x distance _turret) > 25}\n        };\n\n        if (_targetIndex != -1) then {\n            _target = _incoming select _targetIndex;\n            _targetNetId = _target call BIS_fnc_netId;\n            _targetDistance = _target distance _turret;\n\n            [[_turret,\" found target \",_target,\" at \",_targetDistance,\". Its netId is: \",_targetNetId],false] call KISKA_fnc_log;\n\n            call _fn_waitToFireOnTarget;\n\n            call _fn_fireAtTarget\n\n        } else {\n            [[_turret,\" target, \",_target,\" did not meet params\"],false] call KISKA_fnc_log;\n            //sleep 0.5;\n        };\n    };\n\n};\n\nprivate _fn_fireAtTarget = {\n    if (!(isNull _target) AND {(_turret distance _target) <= _searchDistance}) then {\n        [[_turret,\" got params met on \",_target],false] call KISKA_fnc_log;\n\n        // track if unit actually got off shots\n        _firedShots = false;\n        private _numberOfShots = random [50,100,150];\n        [[\"_numberOfShots is:\",_numberOfShots]] call KISKA_fnc_log;\n\n        private _shotMin = _numberOfShots / 3;\n        [[\"_shotMin is: \",_shotMin],false] call KISKA_fnc_log;\n\n        private _explodeAtShot = round (random [_shotMin,_shotMin * 2,_numberOfShots]);\n        [[\"_explodeAtShot is: \",_explodeAtShot],false] call KISKA_fnc_log;\n\n        private _didExplode = false;\n        private \"_engagedBy\";\n\n        for \"_i\" from 1 to _numberOfShots do {\n\n            if (isNull _target) then {\n                [[_turret,\" target became null\"],false] call KISKA_fnc_log;\n                break;\n            };\n\n            _engagedBy = KISKA_CIWS_engagedTargetsHash getOrDefault [_targetNetId, objNull];\n            [[_target,\" is currently engaged by \",_engagedBy,\". NetId is: \",_targetNetId],false] call KISKA_fnc_log;\n\n            // check if target was engaged by another turret\n            if (!(isNull _engagedBy) AND {_engagedBy isNotEqualTo _turret}) then {\n                [[_turret,\" will not engage \",_target,\"; It's already being engaged by \",_engagedBy],false] call KISKA_fnc_log;\n                break;\n            };\n\n            // keep watching target\n            _turret lookAt _target;\n            _turretPitchAngle = (deg (_turret animationSourcePhase \"maingun\")) + 0.6;\n\n            // only fire above specified angle\n            if (_turretPitchAngle >= _doNotFireBelowAngle) then {\n                // ensure target is not engaged by other turrets\n                if (isNull _engagedBy) then {\n                    [[_turret,\" is set to engage \",_target,\". NetId is: \",_targetNetId],false] call KISKA_fnc_log;\n                    KISKA_CIWS_engagedTargetsHash set [_targetNetId,_turret];\n                };\n\n                // turret shoots 1 round\n                _turret fireAtTarget [_target,currentWeapon _turret];\n\n                // create explosion\n                if (!_didExplode AND {_i >= _explodeAtShot}) then {\n                    [\"Reached explosion, updating target pos\",false] call KISKA_fnc_log;\n                    call _fn_updateTargetPos;\n\n                    // delay explosion because bullets take time to reach their target\n                    if (!isNull _target) then {\n                        [[\"Creating an explosion for target \",_target,\" for turret \",_turret]] call KISKA_fnc_log;\n\n                        [_turret,_targetPos] spawn {\n                            params [\"_turret\",\"_targetPos\"];\n\n                            // bullet travels about 1m every 0.0005s\n                            private _sleep = (EXPLOSION_DELAY_CONST * (_turret distance _targetPos));\n                            sleep _sleep;\n                            createVehicle [\"HelicopterExploBig\",ASLToAGL _targetPos,[],0,\"FLY\"];\n                        };\n\n                        // stop target so it doesn't hit something\n                        _target setVelocity [0,0,0];\n                    };\n\n                    _didExplode = true;\n                };\n\n                // update if unit fired\n                if (!_firedShots) then {\n                    _firedShots = true;\n                };\n\n                [[_turret,\" fired at \",_target,\" shot number \",_i],false] call KISKA_fnc_log;\n            };\n\n            sleep 0.01;\n        };\n\n        // reset lookAt\n        _turret lookAt objNull;\n        // sometimes the turret locks up in its aiming animations (becomes slow to aim)\n        // this is used as a sort of reset\n        _turret disableAI \"WEAPONAIM\";\n\n        if (\n            !(isNull _target) AND\n            {_firedShots} AND\n            {KISKA_CIWS_engagedTargetsHash getOrDefault [_targetNetId, objNull] isEqualTo _turret}\n        ) then {\n            triggerAmmo _target;\n\n            // remove from target hash\n            [[\"Removed turret \",_turret,\" from target hash for target \",_target,\" with a netId of: \",_targetNetId],false] call KISKA_fnc_log;\n            KISKA_CIWS_engagedTargetsHash deleteAt _targetNetId;\n\n            if (alive _target) then {\n                deleteVehicle _target;\n            };\n\n            [[_turret,\" destroyed target \",_target],false] call KISKA_fnc_log;\n        };\n\n    } else {\n        // reset lookAt\n        _turret lookAt objNull;\n        _turret disableAI \"WEAPONAIM\";\n\n        [[_turret,\" target \",_target,\" did not meet params\"],false] call KISKA_fnc_log;\n    };\n};\n\n\n_turret disableAI \"AutoTarget\";\n_turret disableAI \"Target\";\n\nwhile {alive _turret AND {_turret getVariable [\"KISKA_runCIWS\",true]}} do {\n    // get incoming projectiles\n    call _fn_updateIncomingList;\n\n    // if projectiles are present then proceed, else sleep\n    if !(_incoming isEqualTo []) then {\n        call _fn_whileTargetsIncoming;\n\n        // turn off alarm if used\n        if (_soundAlarm) then {\n            call _fn_checkIfStopAlarm\n        };\n\n    } else {\n        [[_turret,\" sleep 0.5, the target did not meet params\"],false] call KISKA_fnc_log;\n        sleep _searchInterval;\n    };\n};\n\nif (alive _turret) then {\n    _turret enableAI \"AutoTarget\";\n    _turret enableAI \"Target\";\n    // enable HC transfer\n    [group _turret,false] call KISKA_fnc_ACEX_setHCTransfer;\n};\n\n\nnil\n",
    "fileName": "fn_ciwsInit.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ciwsSiren\n\nDescription:\n    Sounds a siren for the CIWS\n\nParameters:\n    0: _turret : <OBJECT> - The CIWS turret\n\nReturns:\n    Nothing\n\nExamples:\n    (begin example)\n        [turret1] spawn KISKA_fnc_ciwsSiren;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\n#define SIREN_DISTANCE 1000\n#define SIREN_VOLUME 2\n\nscriptName \"KISKA_fnc_ciwsSiren\";\n\nparams [\"_turret\"];\n\nif (_turret getVariable [\"KISKA_CIWS_sirenSounding\",false]) exitWith {\n    [[_turret,\" already has its siren sounding\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_turret setVariable [\"KISKA_CIWS_sirenSounding\",true];\n\nwaitUntil {\n    [\"KISKA_Siren\",_turret,SIREN_DISTANCE,SIREN_VOLUME] call KISKA_fnc_playSound3d;\n    sleep 8;\n    if (_turret getVariable \"KISKA_CIWS_allClear\") exitWith {true};\n\n    false\n};\n\n_turret setVariable [\"KISKA_CIWS_sirenSounding\",false];",
    "fileName": "fn_ciwsSiren.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_addVehicle\n\nDescription:\n    Adds a given vehicle to a convoy. The index returned will be a key to the\n     _convoyHashMap that can be used to get the vehicle for that index in the convoy.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to add to\n    1: _vehicle <OBJECT> - The vehicle to add\n    2: _insertIndex <NUMBER> - The index to insert the vehicle into the convoy at. \n        Negative value means the back.\n        (0 is lead vehicle, 1 is vehicle directly behind leader, etc.)\n\n    3: _convoySeperation <NUMBER> - How far the vehicle should keep from the \n        vehicle in front (min of 10)\n\nReturns:\n    <NUMBER> - The index the vehicle was inserted into the convoy at\n\nExamples:\n    (begin example)\n        private _convoyMap = [] call KISKA_fnc_convoy_create;\n        private _spotInConvoy = [\n            _convoyMap,\n            vic\n        ] call KISKA_fnc_convoy_addVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_addVehicle\";\n\n#define MAX_ARRAY_LENGTH 1E7\n#define MIN_COMPLETION_BOX_WIDTH 5\n#define MIN_COMPLETION_BOX_LENGTH 5\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nparams [\n    [\"_convoyHashMap\",nil,[createHashMap]],\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_insertIndex\",-1,[123]],\n    [\"_convoySeperation\",-1,[123]]\n];\n\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [\"nil _convoyHashMap passed\",true] call KISKA_fnc_log;\n    -1\n};\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",true] call KISKA_fnc_log;\n    -1\n};\n\nprivate _driver = driver _vehicle;\nif !(alive _driver) exitWith {\n    [[\"_vehicle \",_vehicle,\" does not have an alive driver\"],false] call KISKA_fnc_log;\n    -1\n};\n\nprivate _convoyStatemachine = _convoyHashMap get \"_stateMachine\";\nif (isNil \"_convoyStatemachine\") exitWith {\n    [[\"_stateMachine is not defined in map: \",_convoyHashMap],true] call KISKA_fnc_log;\n    -1\n};\n\nprivate _convoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n// there can be times where there is a slight amount of speed in a (mostly) stationary vehicle\nif ((speed _convoyLead) > 0.5) exitWith {\n    [[\"_convoyLead \",_convoyLead,\" is moving, must be stopped to add vehicles to the convoy\"]] call KISKA_fnc_log;\n    -1\n};\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\nif (_vehicle in _convoyVehicles) exitWith {\n    [[\"_vehicle \",_vehicle,\" is already in _convoyHashMap \",_convoyHashMap],true] call KISKA_fnc_log;\n    [_vehicle] call KISKA_fnc_convoy_getVehicleIndex\n};\n\n\n\nprivate _convoyCount = count _convoyVehicles;\nprivate _indexToCopyFrom = -1;\nprivate \"_convoyIndex\";\nif (_insertIndex < 0) then {\n    _convoyIndex = _convoyVehicles pushBack _vehicle;\n    _convoyHashMap set [_convoyIndex,_vehicle];\n\n    if (_convoyIndex isEqualTo 1) exitWith {};\n\n    _indexToCopyFrom = _convoyIndex - 1;\n\n} else {\n    private _vehiclesToChangeIndex = _convoyVehicles select [_insertIndex,MAX_ARRAY_LENGTH];\n    \n    _convoyVehicles resize _insertIndex;\n    _convoyIndex = _convoyVehicles pushBack _vehicle;\n    _convoyVehicles append _vehiclesToChangeIndex;\n    _convoyHashMap set [_convoyIndex,_vehicle];\n\n    _vehiclesToChangeIndex apply {\n        private _currentIndex = [_x] call KISKA_fnc_convoy_getVehicleIndex;\n        if (_currentIndex isEqualTo -1) then {\n            [[\"Could not find 'KISKA_convoy_index' in namespace of \", _x,\" to change\"],true] call KISKA_fnc_log;\n            continue\n        };\n\n        private _newIndex = _currentIndex + 1;\n        _convoyHashMap set [_newIndex,_x];\n        _x setVariable [\"KISKA_convoy_index\",_newIndex];\n    };\n\n    _indexToCopyFrom = _insertIndex;\n\n}; \n\n_vehicle setVariable [\"KISKA_convoy_drivePath\",[]];\nif (_indexToCopyFrom isNotEqualTo -1) then {\n    private _vehicleToCopyPathFrom = [\n        _convoyHashMap,\n        _indexToCopyFrom\n    ] call KISKA_fnc_convoy_getVehicleAtIndex;\n\n\n    [\n        _vehicle,\n        -1,\n        [_vehicleToCopyPathFrom] call KISKA_fnc_convoy_getVehicleDrivePath\n    ] call KISKA_fnc_convoy_modifyVehicleDrivePath;\n\n    private _lastAddedPointInDrivePath = [_vehicleToCopyPathFrom] call KISKA_fnc_convoy_getVehicleLastAddedPoint;\n    // if vehicles are added at a convoy inception, this point is often not defined yet for some vehicles\n    if !(isNil \"_lastAddedPointInDrivePath\") then {\n        _vehicle setVariable [\"KISKA_convoy_lastAddedPoint\",_lastAddedPointInDrivePath];\n    };\n\n} else {\n    _vehicle setVariable [\"KISKA_convoy_drivePath\",[]];\n};\n\n\nprivate _vehicleDimensions = [_vehicle] call KISKA_fnc_getBoundingBoxDimensions;\n_vehicleDimensions params [\"_length\",\"_width\",\"_height\"];\n// Not using half dimensions here because of the desire to have\n// the width and height doubled for making sure vehicles\n// don't accidentaly miss a point.\n// Length is not doubled, however, because if a point is deleted too soon, it will affect\n// the vehicle will try to immediately turn into the next point and may not \n// actually follow a path closely engough and crash into objects\n// _length = _length max MIN_COMPLETION_BOX_LENGTH;\n_vehicle setVariable [\n    \"KISKA_convoy_vehicleCompletionArea\",\n    [\n        [],\n        _width max MIN_COMPLETION_BOX_WIDTH,\n        _length,\n        0,\n        true,\n        _height\n    ]\n];\n\n_vehicle setVariable [\"KISKA_convoy_vehicleAreaOffset\",[0,_length / 2,0]];\n\n[_vehicle,true] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n[_vehicle,false] call KISKA_fnc_convoy_clearVehicleDebugFollowedPath;\n[_vehicle,false] call KISKA_fnc_convoy_clearVehicleDebugFollowPath;\n\n\n_vehicle setVariable [\"KISKA_convoy_hashMap\",_convoyHashMap];\n_vehicle setVariable [\"KISKA_convoy_index\",_convoyIndex];\nif (_convoySeperation < 0) then {\n    _convoySeperation = [\n        _convoyHashMap\n    ] call KISKA_fnc_convoy_getDefaultSeperation;\n};\n\n[\n    _vehicle,\n    _convoySeperation\n] call KISKA_fnc_convoy_setVehicleSeperation;\n\n\n[_vehicle] call KISKA_fnc_convoy_addVehicleKilledEvent;\n\n_vehicle setVariable [\"KISKA_convoy_unitGetOutTimesHashMap\",createHashMap];\nprivate _getOutEventHandlerId = _vehicle addEventHandler [\"GetOut\",{\n    params [\"_vehicle\", \"\", \"_unit\"];\n\n    private _unitGetOutTimeHashMap = _vehicle getVariable \"KISKA_convoy_unitGetOutTimesHashMap\";\n    if !(isNil \"_getOutTimeHashMap\") then {\n        [\n            _unitGetOutTimeHashMap,\n            _unit,\n            time\n        ] call KISKA_fnc_hashmap_set;\n    };\n}];\n\n_vehicle setVariable [\"KISKA_convoy_getOutEventHandlerId\",_getOutEventHandlerId];\n\n\n_convoyIndex\n",
    "fileName": "fn_convoy_addVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_addVehicleKilledEvent\n\nDescription:\n    Adds a killed event handler to a given vehicle in a convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to add the killed eventhandler to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_addVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_addVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _vehicleKilledEventId = _vehicle addMPEventHandler [\"MPKILLED\", {\n    if (isServer) then {\n        _this params [\"_vehicle\"];\n\n        private _convoyHashMap = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getConvoyHashMapFromVehicle;\n\n        if (isNil \"_convoyHashMap\") then {\n            [[\"_convoyHashMap was nil, event was for _vehicle: \",_vehicle],true] call KISKA_fnc_log;\n\n        } else {\n            private _function = [\n                _vehicle\n            ] call KISKA_fnc_convoy_getVehicleKilledEvent;\n            private _convoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n\n            [\n                _vehicle,\n                _convoyHashMap,\n                _convoyLead\n            ] call _function;\n\n        };\n    };\n\n}];\n\n_vehicle setVariable [\"KISKA_convoy_vehicleKilledEventID\",_vehicleKilledEventId];\n",
    "fileName": "fn_convoy_addVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_clearVehicleDebugFollowPath\n\nDescription:\n\tClears a vehicle's current debug follow path objects array. \n\n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions currently in the vehicle's drive path. This is the follow\n     path. \n    \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to clear the debug follow path of\n    1: _deleteExisting <BOOL> - Whether or not to delete the objects that are\n        currently in the array\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t[_vehicle] call KISKA_fnc_convoy_clearVehicleDebugFollowPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_clearVehicleDebugFollowPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_deleteExisting\",true,[true]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_deleteExisting) then {\n    ([_vehicle] call KISKA_fnc_convoy_getVehicleDebugFollowPath) apply {\n        deleteVehicle _x;\n    };\n};\n_vehicle setVariable [\"KISKA_convoy_debug_followPathObjects\",[]];\n",
    "fileName": "fn_convoy_clearVehicleDebugFollowPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_clearVehicleDebugFollowedPath\n\nDescription:\n\tClears a vehicle's current debug followed path objects array. \n\n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions the vehicle had followed while on its drive path. One \n     followed object is created each time a drive path point is considered \"complete\"\n     (vehicle within a radius of that point).\n    \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to clear the debug followed path of\n    1: _deleteExisting <BOOL> - Whether or not to delete the objects that are\n        currently in the array\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t[_vehicle] call KISKA_fnc_convoy_clearVehicleDebugFollowedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_clearVehicleDebugFollowedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_deleteExisting\",true,[true]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_deleteExisting) then {\n    ([_vehicle] call KISKA_fnc_convoy_getVehicleDebugFollowedPath) apply {\n        deleteVehicle _x;\n    };\n};\n_vehicle setVariable [\"KISKA_convoy_debug_followedPathObjects\",[]];\n",
    "fileName": "fn_convoy_clearVehicleDebugFollowedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_create\n\nDescription:\n    Creates an advanced KISKA convoy. Vehicles should be already physically placed in the order\n     that they intend to travel in. If creating in an urban setting, ensure vehicles \n     are in a straight line so that they do not initially crash into a building.\n    \n    This will create a CBA statemachine that processes one vehicle a frame. It manages the speed\n     of the vehicle relative to the vehicle in front to keep a desired spacing between them. \n     The space between each vehicle can be customized for that specific vehicle or any \n     individual one.\n    \n    The first vehicle added to the convoy WILL NOT have its movement managed in any capacity.\n     All other vehicles will essentially follow the path of the lead vehicle. You should \n     limit the speed and control the path of the lead vehicle for your specific use case.\n\n    A convoy requires at least one vehicle (the lead vehicle) to be valid at any given moment.\n     It will be automatically deleted otherwise.\n\nParameters:\n    0: _vics <OBJECT[]> - An array of convoy vehicles (that are in their travel order)\n    1: _convoySeperation <NUMBER> - The distance between each vehicle for the convoy (min of 10)\n\nReturns:\n    <HASHMAP> - A hash map containing data pertinent to the convoy's operation\n\nExamples:\n    (begin example)\n        private _convoyHashMap = [\n            [leadVehicle],\n            10\n        ] call KISKA_fnc_convoy_create;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_create\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n\t[\"_vics\",[],[[]]],\n    [\"_convoySeperation\",20,[123]]\n];\n\n\nif (_convoySeperation < 10) then {\n    _convoySeperation = 10;\n};\n\nprivate _stateMachine = [\n    [],\n    true\n] call CBA_stateMachine_fnc_create;\n\n\nprivate _convoyHashMap = createHashMap;\n// when using skip null in CBA_stateMachine_fnc_create\n// a new array will be created and saved in the statemachine's namespace\nprivate _convoyVehicles = _stateMachine getVariable \"CBA_statemachine_list\";\n_convoyHashMap set [\"_convoyVehicles\",_convoyVehicles];\n_convoyHashMap set [\"_speedLimitPoints\",createHashMap];\n\n_convoyHashMap set [\"_stateMachine\",_stateMachine];\n// set to default value\n[_convoyHashMap] call KISKA_fnc_convoy_setPointBuffer;\n[_convoyHashMap,_convoySeperation] call KISKA_fnc_convoy_setDefaultSeperation;\n\n_vics apply {\n    [\n        _convoyHashMap,\n        _x\n    ] call KISKA_fnc_convoy_addVehicle;\n};\n\n\nprivate _mainState = [\n    _stateMachine,\n    KISKA_fnc_convoy_onEachFrame\n] call CBA_stateMachine_fnc_addState;\n\n\n_convoyHashMap\n",
    "fileName": "fn_convoy_create.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_delete\n\nDescription:\n    Deletes an instance of a KISKA convoy. All vehicles (that aren't the lead)\n\t will halt. This can be executed at any time on a convoy.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to add to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _convoyHashMap = [\n            [leadVehicle],\n            10\n        ] call KISKA_fnc_convoy_create;\n        // some time later...\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_delete\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_convoyHashMap\",nil]\n];\n\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [\"_convoyHashMap is nil\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _convoyVehicles = [\n\t_convoyHashMap\n] call KISKA_fnc_convoy_getConvoyVehicles;\n_convoyVehicles apply {\n\t[_x] call KISKA_fnc_convoy_removeVehicle;\n};\n\nprivate _convoyStatemachine = [\n    _convoyHashMap\n] call KISKA_fnc_convoy_getConvoyStatemachine;\n[_convoyStatemachine] call CBA_statemachine_fnc_delete;\n\n\n(keys _convoyHashMap) apply { _convoyHashMap deleteAt _x };\n\nnil\n",
    "fileName": "fn_convoy_delete.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getBumperPosition\n\nDescription:\n    Gets the positionWorld of a vehicles front or rear bumper.\n    This function caches values in a hashmap for use in the frame by frame calls\n     in KISKA's advanced convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the bumper position of\n    1: _isRearBumper <BOOL> - True for rear bumper, false for front bumper\n\nReturns:\n    <PositionWorld> - The world position of the vehicle's bumper\n\nExamples:\n    (begin example)\n        private _rearBumperPositionWorld = [vic,true] call KISKA_fnc_convoy_getBumperPosition;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getBumperPosition\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_isRearBumper\",false,[true]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",false] call KISKA_fnc_log;\n    [0,0,0]\n};\n\n\nprivate _hashMapId = \"KISKA_convoy_vehicleRelativeRearHashMap\";\nif (!_isRearBumper) then {\n    _hashMapId = \"KISKA_convoy_vehicleRelativeFrontHashMap\";\n};\n\nprivate _relativePointHashMap = localNamespace getVariable _hashMapId;\nif (isNil \"_relativePointHashMap\") then {\n    _relativePointHashMap = createHashMap;\n    localNamespace setVariable [_hashMapId,_relativePointHashMap];\n};\n\n\nprivate _vehicleType = typeOf _vehicle;\nprivate _relativeBumperPosition = _relativePointHashMap get _vehicleType;\n\nif !(isNil \"_relativeBumperPosition\") exitWith {\n    _vehicle modelToWorldVisualWorld _relativeBumperPosition\n};\n\n\n_relativeBumperPosition = [_vehicle,_isRearBumper] call KISKA_fnc_getBumperPositionRelative;\n_relativePointHashMap set [_vehicleType,_relativeBumperPosition];\n\n\n_vehicle modelToWorldVisualWorld _relativeBumperPosition\n",
    "fileName": "fn_convoy_getBumperPosition.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyHashMapFromVehicle\n\nDescription:\n    Gets the corresponding hashmap of a convoy for a particular vehicle.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy hashmap of\n\nReturns:\n    <HASHMAP> - The hashmap of the convoy this vehicle belongs to \n        (nil in the case of the vehicle not belonging to a convoy)\n\nExamples:\n    (begin example)\n        private _convoyHashMap = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getConvoyHashMapFromVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyHashMapFromVehicle\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable \"KISKA_convoy_hashMap\"\n",
    "fileName": "fn_convoy_getConvoyHashMapFromVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyLeader\n\nDescription:\n    Gets the lead vehicle in a convoy. The convoy lead does not have his movement\n     regulated in any way by the advanced convoy system and will be the vehicle that\n     other units in the convoy follow.\n         \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n\nReturns:\n    <OBJECT> - The lead vehicle in the convoy\n\nExamples:\n    (begin example)\n        private _convoyLeader = [\n            _convoyHashMap\n\t\t] call KISKA_fnc_convoy_getConvoyLeader;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyLeader\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    objNull\n};\n\nparams [\"_convoyHashMap\"];\n\n\n_convoyHashMap getOrDefault [0,objNull]\n",
    "fileName": "fn_convoy_getConvoyLeader.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyStatemachine\n\nDescription:\n    Returns the CBA statemachine used to control convoy movement and speed. \n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap get the statemachine from\n\nReturns:\n    <LOCATION> - The CBA statemachine\n\nExamples:\n    (begin example)\n        private _convoyStatemachine = [\n            SomeConvoyHashMap\n        ] call KISKA_fnc_convoy_getConvoyStatemachine;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyStatemachine\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    locationNull\n};\n\nparams [\"_convoyHashMap\"];\n\n\n_convoyHashMap getOrDefault [\"_stateMachine\",locationNull]\n",
    "fileName": "fn_convoy_getConvoyStatemachine.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getConvoyVehicles\n\nDescription:\n    Returns the list of vehicles in a convoy. This is not a copy of the array used\n     for certain internal operations of the convoy. Make a copy if you intend to modify\n     the contents of the array (see example 2).\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap get vehicles from\n    1: _fromIndex <NUMBER> - If provided, only the vehicles from (and including) the\n        the given index will be returned\n\nReturns:\n    <OBJECT[]> - an array containing each vehicle (in there convoy order)\n\nExamples:\n    (begin example)\n        private _convoyVehicles = [\n            SomeConvoyHashMap\n        ] call KISKA_fnc_convoy_getConvoyVehicles;\n    (end)\n\n    (begin example)\n        private _convoyVehiclesCopy = +([\n            SomeConvoyHashMap\n        ] call KISKA_fnc_convoy_getConvoyVehicles);\n    (end)\n    \n    (begin example)\n        private _startingIndex = 1;\n        private _allVehiclesButLeader = [\n            SomeConvoyHashMap,\n            _startingIndex\n        ] call KISKA_fnc_convoy_getConvoyVehicles;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getConvoyVehicles\";\n\n#define MAX_ARRAY_LENGTH 1E7\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_fromIndex\",-1,[123]]\n];\n\nprivate _vehicles = _convoyHashMap getOrDefault [\"_convoyVehicles\",[]];\nif (_fromIndex <= 0) exitWith {_vehicles};\n\n\n_vehicles select [_fromIndex,MAX_ARRAY_LENGTH]\n",
    "fileName": "fn_convoy_getConvoyVehicles.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setDefaultSeperation\n\nDescription:\n    Gets the default seperation between NEWLY added vehicles to a convoy.\n    \n\tThis is the seperation that vehicles will get by default when they are\n\t added to the convoy.\n    \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n\nReturns:\n    <NUMBER> - The default sepration between newly added convoy vehicles\n\nExamples:\n    (begin example)\n        private _defaultSeperation = [\n            _convoyHashMap\n\t\t] call KISKA_fnc_convoy_getDefaultSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getDefaultSeperation\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\"_convoyHashMap\"];\n\n_convoyHashMap getOrDefault [\"_convoySeperation\",20]\n",
    "fileName": "fn_convoy_getDefaultSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getPointBuffer\n\nDescription:\n    Gets the minimum distance that must be between each position added to a vehicles\n     drive path. Essentially how often the lead vehicle's position is recorded.\n    \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n\nReturns:\n    <NUMBER> - The minimum distance between each drive path point\n\nExamples:\n    (begin example)\n        private _minBufferBetweenPoints = [\n            _convoyHashMap\n\t\t] call KISKA_fnc_convoy_getPointBuffer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getPointBuffer\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\"_convoyHashMap\"];\n\n\n_convoyHashMap getOrDefault [\"_minBufferBetweenPoints\",3]\n",
    "fileName": "fn_convoy_getPointBuffer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleAtIndex\n\nDescription:\n    Gets the a vehicle at the specified index of a convoy. \n    \n    For example, the convoy leader is the vehicle at index 0 \n     and the vehicle directly behind the leader is index 1.\n         \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n    1: _index <NUMBER> - The convoy hashmap to get the value from\n\nReturns:\n    <OBJECT> - The vehicle at the desired index\n\nExamples:\n    (begin example)\n        private _convoyLeader = [\n            _convoyHashMap,\n            0\n\t\t] call KISKA_fnc_convoy_getVehicleAtIndex;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleAtIndex\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    objNull\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_index\",1,[123]]\n];\n\n\n_convoyHashMap getOrDefault [_index,objNull]\n",
    "fileName": "fn_convoy_getVehicleAtIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugFollowPath\n\nDescription:\n    Gets a given convoy vehicle's current debug follow path.\n    \n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions currently in the vehicle's drive path. This is the follow\n     path. \n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the follow path of\n\nReturns:\n    <OBJECT[]> - An array of the vehicle's follow path objects\n\nExamples:\n    (begin example)\n        private _debugFollowPathObjects = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugFollowPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugFollowPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_debug_followPathObjects\",[]]\n",
    "fileName": "fn_convoy_getVehicleDebugFollowPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugFollowedPath\n\nDescription:\n    Gets a vehicle's current debug followed path objects array. \n    \n    When a vehicle is in debug mode, a path of objects will be drawn for the duration\n     that shows the positions the vehicle had followed while on its drive path. One \n     followed object is created each time a drive path point is considered \"complete\"\n     (vehicle within a radius of that point).\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the follow path of\n\nReturns:\n    <OBJECT[]> - An array of the vehicle's followed path objects\n\nExamples:\n    (begin example)\n        private _debugFollowedPathObjects = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugFollowedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugFollowedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_debug_followedPathObjects\",[]]\n",
    "fileName": "fn_convoy_getVehicleDebugFollowedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath\n\nDescription:\n    Gets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the marker type of\n\nReturns:\n    <STRING> - The classsName used for the 3d debug marker of the follow path\n     of the given convoy vehicle.\n\nExamples:\n    (begin example)\n        private _followPathMarkerType = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\n    \"KISKA_convoy_debugMarkerType_followPath\",\n    \"Sign_Arrow_Large_Cyan_F\"\n]\n",
    "fileName": "fn_convoy_getVehicleDebugMarkerType_followPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDebugMarkerType_followedPath\n\nDescription:\n    Sets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the marker type of\n\nReturns:\n    <STRING> - The classsName used for the 3d debug marker of the followed path\n     of the given convoy vehicle.\n\nExamples:\n    (begin example)\n        private _followedPathMarkerType = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleDebugMarkerType_followedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDebugMarkerType_followedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\n    \"KISKA_convoy_debugMarkerType_followedPath\",\n    \"Sign_Arrow_Large_blue_F\"\n]\n",
    "fileName": "fn_convoy_getVehicleDebugMarkerType_followedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleDrivePath\n\nDescription:\n    Gets a given convoy vehicle's current drive path. This will return the reference\n     to the actual array used with `setDriveOnPath` for the vehicle's following.\n    \n    You should not set a vehicle's drive path directly. If you want to overwrite a vehicle's\n     current path, use KISKA_fnc_convoy_modifyVehicleDrivePath.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the drive path of\n\nReturns:\n    <PositionATL[]> - An array of the current vehicle's path that it is following\n\nExamples:\n    (begin example)\n        private _currentDrivePath = [_vehicle] call KISKA_fnc_convoy_getVehicleDrivePath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleDrivePath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_drivePath\",[]]\n",
    "fileName": "fn_convoy_getVehicleDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleIndex\n\nDescription:\n    Gets the index in of the provided vehicle in its convoy.\n\n    `0` being the convoy leader and `1` being the vehicle directly behind the convoy\n     leader, for example. `-1` indicates the vehicle is not in a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy index of\n\nReturns:\n    <NUMBER> - The index of the vehicle in its convoy\n\nExamples:\n    (begin example)\n        private _indexOfVehicleInConvoy = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleIndex;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleIndex\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_index\",-1]\n",
    "fileName": "fn_convoy_getVehicleIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleKilledEvent\n\nDescription:\n    Gets the code that should execute when a vehicle dies in a convoy.\n    \n    This will by default return KISKA_convoy_handleVehicleKilled_default if\n     not explicitly set on the vehicle.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the killed event code of\n\nReturns:\n    <CODE> - The code that executes when a vehicle is killed in the convoy\n\nExamples:\n    (begin example)\n        private _eventCode = [\n            vic\n        ] call KISKA_fnc_convoy_getVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\n    \"KISKA_convoy_handleVehicleKilled\",\n    KISKA_fnc_convoy_handleVehicleKilled_default\n]\n",
    "fileName": "fn_convoy_getVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleLastAddedPoint\n\nDescription:\n    Gets the last position added to the vehicle's drive path from the LEAD VEHICLE.\n\n    This does not include modified positions from KISKA_fnc_convoy_modifyVehicleDrivePath.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the drive path of\n\nReturns:\n    <PositionATL or NIL> - The last position to be added to the vehicle's drive path\n     from the lead vehicles position.\n\nExamples:\n    (begin example)\n        private _lastAddedPositionFromLead = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleLastAddedPoint;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleLastAddedPoint\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable \"KISKA_convoy_lastAddedPoint\"\n",
    "fileName": "fn_convoy_getVehicleLastAddedPoint.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_getVehicleSeperation\n\nDescription:\n    Gets the distance that a given vehicle will keep from the vehicle in front\n     of it when in a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy seperation of\n\nReturns:\n    <NUMBER> - The distance the vehicle will keep from the vehicle in front\n        `-1` indicates that no seperation has been set for the vehicle.\n\nExamples:\n    (begin example)\n        private _vehicleConvoySeperation = [\n            _vehicle\n        ] call KISKA_fnc_convoy_getVehicleSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_getVehicleSeperation\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    -1\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_seperation\",-1]\n",
    "fileName": "fn_convoy_getVehicleSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleDeadDriver_default\n\nDescription:\n    The default function that runs when a driver is detected as dead in a vehicle convoy.\n    This is not fired based off an event handler but rather a check in the onEachFrame for\n     the convoy vehicles.\n    The function will wait 4 seconds before affecting its behavior on the vehicle.\n    \n    If the previous driver was a player, and a player is in the vehicle, nothing will happen.\n    If the previous driver was a player, and a player is NOT in the vehicle, an AI will take over\n     driving the vehicle.\n    If the previous driver was NOT a player, and a player is in the highest priority seat to\n     be the new driver, nothing will happen.\n    If the previous driver was NOT a player, and an AI is in the highest priority seat to\n     be the new driver, they will be automatically moved into the driver seat.\n    \n    The priority of vehicle role in the order of who the next driver is:\n        1. commander\n        2. cargo\n        3. turrets\n        4. gunner\n\n    This means commanders if present will be desired to move into the driver seat over\n     all other vehicle roles.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle that has a dead driver\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n    3: _deadDriver <OBJECT> - The dead driver\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleDeadDriver_default\";\n\n#define WAIT_TIME 4\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]]\n]; \n\n\nif (_vehicle isEqualTo _convoyLead) exitWith {\n    [_vehicle] call KISKA_fnc_convoy_removeVehicle;\n    \n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n};\n\n\n[{\n\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]],\n    [\"_deadDriver\",objNull,[objNull]]\n]; \n\n\nif (isNull _vehicle) exitWith {\n    [\n        [\n            \"null _vehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _deadDriver) exitWith {\n    [\n        [\n            \"null _deadDriver was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\nprivate _currentDriver = driver _vehicle;\nif (_currentDriver isNotEqualTo _deadDriver) exitWith {};\n\nprivate _driverWasPlayer = isPlayer [_deadDriver];\nprivate \"_preferredNewDriver\";\nprivate _preferredNewDriver_priority = -1;\nprivate _preferredNewDriver_isPlayer = false;\nprivate _rolePriorityHashMap = createHashMapFromArray [\n    [\"commander\",3],\n    [\"cargo\",2],\n    [\"turret\",1],\n    [\"gunner\",0]\n];\n\n(fullCrew _vehicle) apply {\n    _x params [\"_unit\",\"_role\",\"_index\"];\n    _role = toLowerANSI _role;\n    private _unitIsPlayer = isPlayer _unit;\n\n    // always want a player driver to not be replaced with an AI \n    // if there is another player in the vehicle\n    if (_driverWasPlayer AND _unitIsPlayer) then {\n        _preferredNewDriver = nil;\n        break \n    };\n\n    private _unitPriority = _rolePriorityHashMap getOrDefault [_role,-1];\n    if (_preferredNewDriver_priority < _unitPriority) then {\n        _preferredNewDriver_priority = _unitPriority;\n        _preferredNewDriver = _unit;\n        _preferredNewDriver_isPlayer = _unitIsPlayer;\n\n        private _unitIsCommander = _unitPriority isEqualTo 3;\n        private _isPriorityUnit = _unitIsCommander AND (!_driverWasPlayer) AND (!_unitIsPlayer);\n        if (_isPriorityUnit) then { break };\n    };\n};\n\nif (isNil \"_preferredNewDriver\" OR {_preferredNewDriver_isPlayer}) exitWith {};\n\n[_currentDriver, _vehicle] remoteExecCall [\"moveOut\", _currentDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveOut\", _preferredNewDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveInDriver\", _preferredNewDriver];\n\n_vehicle setVariable [\"KISKA_convoy_deadDriverBeingHandled\",false];\n\n\nnil\n   \n},_this,WAIT_TIME] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_convoy_handleDeadDriver_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleUnconsciousDriver_default\n\nDescription:\n    The default function that runs when a driver is detected as incapacitated in a vehicle convoy.\n\n    The function will wait 4 seconds before affecting its behavior on the vehicle.\n    \n    If the previous driver was a player, and a player is in the vehicle, nothing will happen.\n    If the previous driver was a player, and a player is NOT in the vehicle, an AI will take over\n     driving the vehicle.\n    If the previous driver was NOT a player, and a player is in the highest priority seat to\n     be the new driver, nothing will happen.\n    If the previous driver was NOT a player, and an AI is in the highest priority seat to\n     be the new driver, they will be automatically moved into the driver seat.\n    \n    The priority of vehicle role in the order of who the next driver is:\n        1. commander\n        2. cargo\n        3. turrets\n        4. gunner\n\n    This means commanders if present will be desired to move into the driver seat over\n     all other vehicle roles.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle that has an unconscious driver\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n    3: _unconsciousDriver <OBJECT> - The unconscious driver\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleUnconsciousDriver_default\";\n\n#define WAIT_TIME 4\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n\n[{\n\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]],\n    [\"_unconsciousDriver\",objNull,[objNull]]\n]; \n\n\nif (isNull _vehicle) exitWith {\n    [\n        [\n            \"null _vehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _unconsciousDriver) exitWith {\n    [\n        [\n            \"null _unconsciousDriver was passed, _vehicle is: \",\n            _vehicle\n        ],\n        false\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (_vehicle isEqualTo _convoyLead) exitWith {\n    [_vehicle] call KISKA_fnc_convoy_removeVehicle;\n    \n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n};\n\n\n\nprivate _currentDriver = driver _vehicle;\nif (_currentDriver isNotEqualTo _unconsciousDriver) exitWith {};\n\nprivate _driverWasPlayer = isPlayer [_unconsciousDriver];\nprivate \"_preferredNewDriver\";\nprivate _preferredNewDriver_priority = -1;\nprivate _preferredNewDriver_isPlayer = false;\nprivate _rolePriorityHashMap = createHashMapFromArray [\n    [\"commander\",3],\n    [\"cargo\",2],\n    [\"turret\",1],\n    [\"gunner\",0]\n];\n\n(fullCrew _vehicle) apply {\n    _x params [\"_unit\",\"_role\",\"_index\"];\n    _role = toLowerANSI _role;\n    private _unitIsPlayer = isPlayer _unit;\n\n    // always want a player driver to not be replaced with an AI \n    // if there is another player in the vehicle\n    if (_driverWasPlayer AND _unitIsPlayer) then {\n        _preferredNewDriver = nil;\n        break \n    };\n\n    private _unitPriority = _rolePriorityHashMap getOrDefault [_role,-1];\n    if (_preferredNewDriver_priority < _unitPriority) then {\n        _preferredNewDriver_priority = _unitPriority;\n        _preferredNewDriver = _unit;\n        _preferredNewDriver_isPlayer = _unitIsPlayer;\n\n        private _unitIsCommander = _unitPriority isEqualTo 3;\n        private _isPriorityUnit = _unitIsCommander AND (!_driverWasPlayer) AND (!_unitIsPlayer);\n        if (_isPriorityUnit) then { break };\n    };\n};\n\nif (isNil \"_preferredNewDriver\" OR {_preferredNewDriver_isPlayer}) exitWith {};\n\n[_currentDriver, _vehicle] remoteExecCall [\"moveOut\", _currentDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveOut\", _preferredNewDriver];\n[_preferredNewDriver, _vehicle] remoteExecCall [\"moveInDriver\", _preferredNewDriver];\n[_currentDriver, _vehicle] remoteExecCall [\"moveInAny\", _currentDriver];\n\n_vehicle setVariable [\"KISKA_convoy_currentUnconsciousDriver\",nil];\n\n\nnil\n   \n},_this,WAIT_TIME] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_convoy_handleUnconsciousDriver_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleVehicleCantMove_default\n\nDescription:\n\tThe default behaviour that happens when a vehicle in the convoy is disabled.\n\nParameters:\n    0: _disabledVehicle <OBJECT> - The vehicle that has been disabled\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleVehicleCantMove_default\";\n\n#define X_AREA_BUFFER 5\n#define Y_AREA_BUFFER 10\n#define MOVING_POSITIONS_BUFFER 2\n#define LEFT_AZIMUTH_RELATIVE_NORTH 270\n#define RIGHT_AZIMUTH_RELATIVE_NORTH 90\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_disabledVehicle\",objNull,[objNull]],\n    [\"_convoyHashmap\",nil],\n    [\"_convoyLead\",objNull,[objNull]]\n];\n\n[[_disabledVehicle,\" can't move handler called\"]] call KISKA_fnc_log;\n\n/* ----------------------------------------------------------------------------\n\tParameter check\n---------------------------------------------------------------------------- */\nif (isNull _disabledVehicle) exitWith {\n    [\n        [\n            \"null _disabledVehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _disabledVehicle is: \",\n            _disabledVehicle\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _convoyLead) exitWith {\n    [   \n        [\n            \"null _convoyLead was passed, _disabledVehicle is: \",\n            _disabledVehicle,\n\t\t\t\" and _convoyHashMap is: \",\n\t\t\t_convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\nif (_disabledVehicle isEqualTo _convoyLead) exitWith {\n    [_disabledVehicle] call KISKA_fnc_convoy_removeVehicle;\n    \n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\tFunction Defintions\n---------------------------------------------------------------------------- */\nprivate _getBlockedPositions = {\n    params [\"_vehicleBehind_drivePath\",\"_disabledVehicle\"];\n\n    private _disabledVehicle_dimensions = [_disabledVehicle] call KISKA_fnc_getBoundingBoxDimensions;\n    _disabledVehicle_dimensions params [\"_disabledVehicle_length\",\"_disabledVehicle_width\",\"_disabledVehicle_height\"];\n    // Adding buffers to X and Y because points that are too close to the _disabledVehicle\n    // will result in _vehicleBehind crashing into it.\n    private _areaX = (_disabledVehicle_width / 2) + X_AREA_BUFFER;\n    private _areaY = (_disabledVehicle_length / 2) + Y_AREA_BUFFER;\n    private _areaZ = _disabledVehicle_height / 2;\n\n    private _areaCenter = ASLToAGL (getPosASLVisual _disabledVehicle);\n    private _lastIndex = (count _vehicleBehind_drivePath) - 1;\n\n    private _blockedPositions_ATL = [];\n    private _lastBlockedIndex = _lastIndex;\n    {\n        if (_forEachIndex isEqualTo _lastIndex) then { break };\n\n        private _nextPointInPath = _vehicleBehind_drivePath select (_forEachIndex + 1);\n        private _azimuthToNextPoint = _x getDir _nextPointInPath;\n\n        private _currentPointIsInArea = _x inArea [\n            _areaCenter,\n            _areaX,\n            _areaY,\n            _azimuthToNextPoint,\n            true,\n            _areaZ\n        ];\n\n        private _aBlockedPositionWasAlreadyFound = _blockedPositions_ATL isNotEqualTo [];\n        if (_aBlockedPositionWasAlreadyFound AND (!_currentPointIsInArea)) then { break };\n\n        if (_currentPointIsInArea) then {\n            _blockedPositions_ATL pushBack _x;\n            _lastBlockedIndex = _forEachIndex;\n        };\n    } forEach _vehicleBehind_drivePath;\n\n\n    [_blockedPositions_ATL, _lastBlockedIndex]\n};\n\n\nprivate _findClearSide = {\n    params [\"_blockedPositions_ATL\",\"_disabledVehicle\",\"_requiredSpace\"];\n\n    private _firstBlockedPosition = _blockedPositions_ATL select 0;\n\n    private _blockedPositionsCount = count _blockedPositions_ATL;\n    private _middleIndex = (round (_blockedPositionsCount / 2)) - 1;\n    private _middleBlockedPosition = _blockedPositions_ATL select _middleIndex;\n\n    private _lastIndex = _blockedPositionsCount - 1;\n    private _lastBlockedPosition = _blockedPositions_ATL select _lastIndex;\n\n    private _disabledVehicle_dir = getDirVisual _disabledVehicle;\n    private _leftAzimuth = LEFT_AZIMUTH_RELATIVE_NORTH + _disabledVehicle_dir;\n    private _rightAzimuth = RIGHT_AZIMUTH_RELATIVE_NORTH + _disabledVehicle_dir;\n\n    private _clearSide = -1;\n    private _clearLeft = true;\n    private _clearRight = true;\n\n    [\n        _firstBlockedPosition,\n        _middleBlockedPosition,\n        _lastBlockedPosition\n    ] apply {\n        \n        private _positionASL = ATLToASL _x;\n\n        if (_clearLeft) then {\n            private _positionLeftASL = AGLToASL (_positionASL getPos [_requiredSpace, _leftAzimuth]);\n            private _objectsToDisabledVehiclesLeft = lineIntersectsObjs [\n                _positionASL, \n                _positionLeftASL, \n                _disabledVehicle,\n                objNull,\n                true,\n                32\n            ];\n            private _objectsAreOnTheLeft = _objectsToDisabledVehiclesLeft isNotEqualTo [];\n\n            if (_objectsAreOnTheLeft) then { _clearLeft = false };\n        };\n\n        if (_clearRight) then {\n            private _positionRightASL = AGLToASL (_positionASL getPos [_requiredSpace, _rightAzimuth]);\n            private _objectsToDisabledVehiclesRight = lineIntersectsObjs [\n                _positionASL, \n                _positionRightASL, \n                _disabledVehicle,\n                objNull,\n                true,\n                32\n            ];\n            private _objectsAreOnTheRight = _objectsToDisabledVehiclesRight isNotEqualTo [];\n            \n            if (_objectsAreOnTheRight) then { _clearRight = false };\n        };\n\n        if ((!_clearLeft) AND (!_clearRight)) then { break };\n    };\n\n    if (_clearLeft) then {\n        _clearSide = 0;\n    } else {\n        if (_clearRight) then { _clearSide = 1; };\n    };\n\n\n    _clearSide\n};\n\n\n\n/* ----------------------------------------------------------------------------\n\tDrive around disabled vehicles\n---------------------------------------------------------------------------- */\nprivate _disabledVehicle_index = [_disabledVehicle] call KISKA_fnc_convoy_getVehicleIndex;\nprivate _vehicleBehind_index = _disabledVehicle_index + 1;\nprivate _vehicleBehind = [_convoyHashMap, _vehicleBehind_index] call KISKA_fnc_convoy_getVehicleAtIndex;\n\n\n[_disabledVehicle] call KISKA_fnc_convoy_removeVehicle;\nif (isNull _vehicleBehind) exitWith {\n    [[\"No _vehicleBehind found at index: \",_vehicleBehind_index]] call KISKA_fnc_log;\n    nil\n};\n\n\n[_convoyHashMap] call KISKA_fnc_convoy_syncLatestDrivePoint;\n\nprivate _vehicleBehind_currentDrivePath = [_vehicleBehind] call KISKA_fnc_convoy_getVehicleDrivePath;\nprivate _blockedPositionsResult = [\n    _vehicleBehind_currentDrivePath,\n    _disabledVehicle\n] call _getBlockedPositions;\n\n\nprivate _positionsBlockedByDisabledVehicle_ATL = _blockedPositionsResult select 0;\nif (_positionsBlockedByDisabledVehicle_ATL isEqualTo []) exitWith {\n    [[\n        \"Did not find any blocked drive path positions: _vehicleBehind: \",\n        _vehicleBehind,\n        \" _disabledVehicle: \",\n        _disabledVehicle\n    ]] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _vehicleBehind_dimensions = [_vehicleBehind] call KISKA_fnc_getBoundingBoxDimensions;\nprivate _vehicleBehind_width = _vehicleBehind_dimensions select 1;\n\nprivate _disabledVehicle_dimensions = [_disabledVehicle] call KISKA_fnc_getBoundingBoxDimensions;\nprivate _disabledVehicle_width = _disabledVehicle_dimensions select 1;\nprivate _disabledVehicle_halfWidth = _disabledVehicle_width / 2;\n\nprivate _requiredSpace = _vehicleBehind_width + _disabledVehicle_halfWidth;\nprivate _clearSide = [\n    _positionsBlockedByDisabledVehicle_ATL,\n    _disabledVehicle,\n    _requiredSpace\n] call _findClearSide;\n\n\nprivate _noSideIsClear = _clearSide isEqualTo -1;\nif (_noSideIsClear) exitWith {\n    [_vehicleBehind] call KISKA_fnc_convoy_stopVehicle;\n    [_vehicleBehind, false] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n\n    [[\n        \"Could not find clear side for: _vehicleBehind: \",\n        _vehicleBehind,\n        \" _disabledVehicle: \",\n        _disabledVehicle\n    ]] call KISKA_fnc_log;\n\n\n    nil\n};\n\n\nprivate _distanceToMovePositions = _vehicleBehind_width + _disabledVehicle_halfWidth + MOVING_POSITIONS_BUFFER;\nprivate _disabledVehicle_dir = getDirVisual _disabledVehicle;\n\nprivate _movementDirectionBase = [LEFT_AZIMUTH_RELATIVE_NORTH, RIGHT_AZIMUTH_RELATIVE_NORTH] select _clearSide;\nprivate _movePositionAzimuth = _movementDirectionBase + _disabledVehicle_dir;\n\nprivate _firstPositionToMove = _positionsBlockedByDisabledVehicle_ATL select 0;\nprivate _firstPositionAdjusted_AGL = _firstPositionToMove getPos [_distanceToMovePositions, _movePositionAzimuth];\nprivate _firstPositionAdjusted_ATL = ASLToATL (AGLToASL _firstPositionAdjusted_AGL);\nprivate _movedPositionVectorOffset = _firstPositionToMove vectorDiff _firstPositionAdjusted_ATL;\n\nprivate _positionsBlockedByDisabledVehicle_ATL = _blockedPositionsResult select 0;\nprivate _adjustedPositions = _positionsBlockedByDisabledVehicle_ATL apply {_x vectorDiff _movedPositionVectorOffset};\n\nprivate _deletionRange = count _adjustedPositions;\nprivate _vehicleBehind_lastIndexToBeAdjustedInPath = _blockedPositionsResult select 1;\nprivate _lastIndexOffset = (count _vehicleBehind_currentDrivePath) - (_vehicleBehind_lastIndexToBeAdjustedInPath + 1);\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\n{\n    // don't need to adjust convoy lead\n    if (_forEachIndex isEqualTo 0) then { continue };\n\n    private _vehiclesDrivePath = [_x] call KISKA_fnc_convoy_getVehicleDrivePath;\n    private _vehiclesDrivePathCount = count _vehiclesDrivePath;\n    private _lastIndexToModify = _vehiclesDrivePathCount - _lastIndexOffset;\n    \n    [\n        _x,\n        _lastIndexToModify,\n        _adjustedPositions\n    ] call KISKA_fnc_convoy_modifyVehicleDrivePath;\n} forEach _convoyVehicles;\n\n\n\n/* ----------------------------------------------------------------------------\n\tHandle units that dismount disabled vehicle\n\n    // units may dismount in the path of the vehicle behind attempting to drive past\n    // the driving AI will try to avoid driving over friendlies and will\n    /// run into the back of the disabled vehicle in some cases\n---------------------------------------------------------------------------- */\nprivate _disabledVehicle_boundingBox = 0 boundingBoxReal _disabledVehicle;\nprivate _disabledVehicle_boundingBoxMins = _disabledVehicle_boundingBox select 0;\nprivate _disabledVehicle_boundingBoxMaxes = _disabledVehicle_boundingBox select 1;\n\nprivate _rightSide = _disabledVehicle_boundingBoxMaxes select 0;\nprivate _leftSide = _disabledVehicle_boundingBoxMins select 0;\n\n// Want to put units on the NOT clear side because that is where the vehicle behind will not drive\nprivate _xOffset = [\n    _rightSide,\n    _leftSide\n] select _clearSide;\n\nprivate _relativeDismountPosition = [\n    _xOffset,\n    _disabledVehicle_boundingBoxMins select 1,\n    _disabledVehicle_boundingBoxMins select 2\n];\n\n[\n    {\n        params [\"_disabledVehicle\"];\n        (speed _disabledVehicle) isEqualTo 0;\n    },\n    {\n        params [\"_disabledVehicle\",\"_relativeDismountPosition\"];\n\n        if (isNull _disabledVehicle) exitWith {};\n\n        private _unitsToAdjustDismountPosition = crew _disabledVehicle;\n        private _timeVehicleWasDiscoveredDisabled = time;\n        private _unitGetOutTimeHashMap = _disabledVehicle getVariable \"KISKA_convoy_unitGetOutTimesHashMap\";\n        if !(isNil \"_unitGetOutTimeHashMap\") then {\n            _unitGetOutTimeHashMap apply {  \n                private _timeSinceUnitGotOut = _timeVehicleWasDiscoveredDisabled - _y;\n                private _unitGotOutMoreThanASecondAgo = _timeSinceUnitGotOut >= 1;\n                if (_unitGotOutMoreThanASecondAgo) then { continue };\n\n                private _unit = [\n                    _x\n                ] call KISKA_fnc_hashmap_getObjectOrGroupFromRealKey;\n                \n                if !(alive _unit) then { continue };\n\n                _unitsToAdjustDismountPosition pushBackUnique _unit;\n            };\n        };\n\n        private _dismountPosition = _disabledVehicle modelToWorldVisualWorld _relativeDismountPosition;\n        _unitsToAdjustDismountPosition apply {\n            _x setPosWorld _dismountPosition\n        };\n    },\n    [_disabledVehicle,_relativeDismountPosition],\n    10\n] call CBA_fnc_waitUntilAndExecute;\n\n\nnil\n",
    "fileName": "fn_convoy_handleVehicleCantMove_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_handleVehicleKilled_default\n\nDescription:\n\tThe default behaviour that happens when a vehicle in the convoy dies.\n\nParameters:\n    0: _killedVehicle <OBJECT> - The vehicle that died\n    1: _convoyHashMap <HASHMAP> - The hashmap used for the convoy\n    2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_handleVehicleKilled_default\";\n\n#define WAIT_TIME_FOR_VEHICLE 2\n#define PUSH_LEFT_SPEED -10\n#define PUSH_RIGHT_SPEED -10\n#define PUSH_Z_VELOCITY 2\n#define MASS_DIVISION 2\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_killedVehicle\",objNull,[objNull]],\n    [\"_convoyHashMap\",nil],\n    [\"_convoyLead\",objNull,[objNull]]\n];\n\n/* ----------------------------------------------------------------------------\n\tParameter check\n---------------------------------------------------------------------------- */\nif (isNull _killedVehicle) exitWith {\n    [\n        [\n            \"null _killedVehicle was passed, _convoyHashMap is: \",\n            _convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNil \"_convoyHashMap\") exitWith {\n    [   \n        [\n            \"nil _convoyHashMap was passed, _killedVehicle is: \",\n            _killedVehicle\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\nif (isNull _convoyLead) exitWith {\n    [   \n        [\n            \"null _convoyLead was passed, _killedVehicle is: \",\n            _killedVehicle,\n\t\t\t\" and _convoyHashMap is: \",\n\t\t\t_convoyHashMap\n        ],\n        true\n    ] call KISKA_fnc_log;\n\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n\tLogic\n---------------------------------------------------------------------------- */\n[_killedVehicle] call KISKA_fnc_convoy_removeVehicle;\n\n// KISKA_fnc_convoy_removeVehicle will adjust the indexes\nif (_killedVehicle isEqualTo _convoyLead) exitWith {\n\n    private _newConvoyLead = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyLeader;\n    if (isNull _newConvoyLead) then {\n        [_convoyHashMap] call KISKA_fnc_convoy_delete;\n\n    } else {\n        // There's no consistent way to know what the former lead's intended path is, so stop\n\t    [_newConvoyLead] call KISKA_fnc_convoy_stopVehicle; \n\n    };\n\n};\n\n\n/* ---------------------------------\n\tGetting the rear vehicle to move to the lead vehicle\n--------------------------------- */\nprivate _vehicleIndex = [_killedVehicle] call KISKA_fnc_convoy_getVehicleIndex;\nprivate _vehicleThatWasBehind = [_convoyHashMap, _vehicleIndex] call KISKA_fnc_convoy_getVehicleAtIndex;\n[_vehicleThatWasBehind] call KISKA_fnc_convoy_stopVehicle;\n[_vehicleThatWasBehind, false] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n\n// push to the right by default\nprivate _pushToTheSideVelocity = PUSH_RIGHT_SPEED;\nprivate _killedVehicle_position = getPosWorldVisual _killedVehicle;\nfor \"_i\" from 1 to 25 do { \n    private _positionLeft = AGLToASL (_killedVehicle getRelPos [_i,270]);\n    private _objectsAreOnTheLeft = (lineIntersectsObjs [_killedVehicle_position, _positionLeft, _killedVehicle, objNull,false,32]) isNotEqualTo [];\n    if (_objectsAreOnTheLeft) then { break };\n    \n    private _positionRight = AGLToASL (_killedVehicle getRelPos [_i,90]);\n    private _objectsAreOnTheRight = (lineIntersectsObjs [_killedVehicle_position, _positionRight, _killedVehicle, objNull,false,32]) isNotEqualTo [];\n    if (_objectsAreOnTheRight) then {\n        _pushToTheSideVelocity = PUSH_LEFT_SPEED; \n        break \n    };\n};\n\n\n// shove vehicle to the side because AI drivers can't drive past consistently\n[_killedVehicle, [_pushToTheSideVelocity,0,PUSH_Z_VELOCITY]] remoteExecCall [\"setVelocityModelSpace\", _killedVehicle];\n\nprivate _killedVehicle_drivePath = [_killedVehicle] call KISKA_fnc_convoy_getVehicleDrivePath;\n// Waiting to give time for destroyed vehicle to settle from physics\n[\n    {\n        params [\n            \"_vehicleThatWasBehind\",\n            \"_killedVehicle_firstDrivePathPoint\",\n            \"_killedVehicle_drivePath\",\n            \"_killedVehicle\"\n        ];\n\n        // adjust mass so that a vehicle can push the dead one out of the way\n        // in case it runs into the dead one\n        [\n            _killedVehicle, \n            ((getMass _vehicleThatWasBehind) / MASS_DIVISION) \n        ] remoteExecCall [\"setMass\",_killedVehicle];\n\n\n        private _driver = driver _vehicleThatWasBehind;\n        [_driver,\"path\"] remoteExecCall [\"enableAI\",_driver];\n\n        [_vehicleThatWasBehind, true] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n    },\n    [\n        _vehicleThatWasBehind,\n        _killedVehicle_firstDrivePathPoint,\n        _killedVehicle_drivePath,\n        _killedVehicle\n    ],\n    WAIT_TIME_FOR_VEHICLE\n] call CBA_fnc_waitAndExecute;\n\n\nnil\n",
    "fileName": "fn_convoy_handleVehicleKilled_default.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_isVehicleInDebug\n\nDescription:\n    Gets whether or a given vehicle is in debug mode for a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the convoy index of\n\nReturns:\n    <BOOL> - `true` if the vehicle is in debug mode\n\nExamples:\n    (begin example)\n        private _isInDebug = [\n            _vehicle\n        ] call KISKA_fnc_convoy_isVehicleInDebug;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_isVehicleInDebug\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_debug\",false]\n",
    "fileName": "fn_convoy_isVehicleInDebug.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_modifyVehicleDrivePath\n\nDescription:\n\tChanges the drive path of a given convoy vehicle.\n\n    The drive path will be overwritten from the _lastIndexToModify (inclusive) backwards \n     until all of the _pointsToAdd have been placed in the array. This means that \n     this function is not capable of appending to the end of an array, but only adding \n     to the front.\n    \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to modify the drive path of\n    1: _lastIndexToModify <NUMBER> - The (inclusive) index to stop the modification at\n    2: _pointsToAdd <PositionATL[]> - The array of ATL positions to set to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t// overwrite array entirely\n\t\t[\n            _vehicle,\n            -1, // without deleting any points in current drive path, add positions to the front of path\n            [\n                [12,34,56],\n                [12,34,58]\n            ]\n        ] call KISKA_fnc_convoy_modifyVehicleDrivePath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_modifyVehicleDrivePath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_lastIndexToModify\",0,[123]],\n    [\"_pointsToAdd\",[],[[]]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _modificationRange = count _pointsToAdd;\nprivate _vehicleDrivePath = [_vehicle] call KISKA_fnc_convoy_getVehicleDrivePath;\nif (_vehicleDrivePath isEqualTo []) then {\n    _vehicleDrivePath insert [0,_pointsToAdd];\n\n} else {\n    private _vehiclesDrivePathCount = count _vehicleDrivePath;\n    private _startIndex = _lastIndexToModify - _modificationRange;\n    if (_startIndex < 0) then {\n        _modificationRange = _modificationRange + _startIndex;\n        _startIndex = 0;\n    };\n\n\n    if (_modificationRange >= 0) then {\n        _vehicleDrivePath deleteRange [_startIndex, _modificationRange];\n    };\n    _vehicleDrivePath insert [_startIndex, _pointsToAdd];\n\n};\n\n\nif ([_vehicle] call KISKA_fnc_convoy_shouldVehicleDriveOnPath) then {\n    _vehicle setDriveOnPath _vehicleDrivePath;\n};\n",
    "fileName": "fn_convoy_modifyVehicleDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_onEachFrame\n\nDescription:\n    Mananges an individual vehicle's position relative to the vehicle in front of\n     it in a convoy. This function is what the statemachine runs each frame/vehicle.\n\n    This function intentionally forgoes the use of several getter/setter functions \n     to reduce overhead because it runs every frame.\n\nParameters:\n    _this <OBJECT> - A convoy vehicle to be processed during the current frame\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // SHOULD NOT BE CALLED DIRECTLY\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_onEachFrame\";\n\n#define MIN_VEHICLE_SPEED_LIMIT_MODIFIER 5\n#define MIN_VEHICLE_SPEED_LIMIT 5\n#define VEHICLE_SPEED_LIMIT_MULTIPLIER 2.5\n#define SMALL_SPEED_LIMIT_DISTANCE_MODIFIER 1.25\n#define LEAD_VEHICLE_MAX_SPEED_TO_HALT_FOLLOW 2\n#define VEHICLE_SHOULD_CATCH_UP_DISTANCE 100\n#define SPEED_DIFFERENTIAL_LIMIT 20\n#define MIN_CONVOY_SEPERATION 10\n#define CONVOY_LEAD_MIN_RECORD_SPEED 5\n#define CONVOY_LEAD_MAX_RECORD_SPEED 20\n\nprivate _currentVehicle = _this;\n\nprivate _convoyHashMap = _currentVehicle getVariable \"KISKA_convoy_hashMap\";\nprivate _convoyLead = _convoyHashMap getOrDefault [0,objNull];\n\n\n/* ----------------------------------------------------------------------------\n    Exit states\n---------------------------------------------------------------------------- */\nif (isNull _convoyLead) exitWith {\n    [_convoyHashMap] call KISKA_fnc_convoy_delete;\n};\n\n\nif !(canMove _currentVehicle) exitWith {\n    private _cantMoveEventHandler = _currentVehicle getVariable [\n        \"KISKA_convoy_handleVehicleCantMove\",\n        KISKA_fnc_convoy_handleVehicleCantMove_default\n    ];\n\n    [\n        _currentVehicle,\n        _convoyHashMap,\n        _convoyLead\n    ] call _cantMoveEventHandler;\n};\n\n// did not use an eventhandler due to the complexity of handling\n// potentially remote units and/or changing drivers\n// and the limited cost of this check\nprivate _currentVehicle_driver = driver _currentVehicle;\nif !(alive _currentVehicle_driver) exitWith {\n    private _deadDriverBeingHandled = _currentVehicle getVariable [\"KISKA_convoy_deadDriverBeingHandled\",false];\n    if (_deadDriverBeingHandled) exitWith {};\n\n    _currentVehicle setVariable [\"KISKA_convoy_deadDriverBeingHandled\",true];\n    \n    private _driverKilledHandler = _currentVehicle getVariable [\n        \"KISKA_convoy_handleDeadDriver\",\n        KISKA_fnc_convoy_handleDeadDriver_default\n    ];\n\n    [\n        _currentVehicle,\n        _convoyHashMap,\n        _convoyLead,\n        _currentVehicle_driver\n    ] call _driverKilledHandler;\n};\t\n\nif ((lifeState _currentVehicle_driver) == \"INCAPACITATED\") exitWith {\n    private _currentUnconsciousDriver = _currentVehicle getVariable \"KISKA_convoy_currentUnconsciousDriver\";\n    if (!isNil \"_currentUnconsciousDriver\" AND {_currentUnconsciousDriver isEqualTo _currentVehicle_driver}) exitWith {};\n    \n    _currentVehicle setVariable [\"KISKA_convoy_currentUnconsciousDriver\",_currentVehicle_driver];\n    private _driverIncapcitatedEventHandler = _currentVehicle getVariable [\n        \"KISKA_convoy_handleUnconsciousDriver\",\n        KISKA_fnc_convoy_handleUnconsciousDriver_default\n    ];\n\n    [\n        _currentVehicle,\n        _convoyHashMap,\n        _convoyLead,\n        _currentVehicle_driver\n    ] call _driverIncapcitatedEventHandler;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Handle Convoy Lead Vehicle\n---------------------------------------------------------------------------- */\nprivate _speedLimitMap = _convoyHashMap get \"_speedLimitPoints\";\nif (_currentVehicle isEqualTo _convoyLead) exitWith {\n    private _convoyLead_currentPosition_ATL = getPosATLVisual _convoyLead;\n    // getOrDefaultCall is slightly faster than getOrDefault for this\n    private _latestPointOnPath = _convoyHashMap getOrDefaultCall [\"_latestPointOnPath\",{[0,0,0]}];\n   \n    private _distanceBetweenPoints = _convoyLead_currentPosition_ATL vectorDistance _latestPointOnPath;\n    private _minBufferBetweenPoints = _convoyHashMap get \"_minBufferBetweenPoints\";\n    if (_distanceBetweenPoints <= _minBufferBetweenPoints) exitWith {};\n\n    private _convoyLeadSpeed = speed _convoyLead;\n    if (\n        (_convoyLeadSpeed < CONVOY_LEAD_MAX_RECORD_SPEED) AND \n        (_convoyLeadSpeed > CONVOY_LEAD_MIN_RECORD_SPEED)\n    ) then {\n        _speedLimitMap set [_convoyLead_currentPosition_ATL, _convoyLeadSpeed];\n    };\n\n    (_convoyHashMap get \"_convoyPath\") pushBack _convoyLead_currentPosition_ATL;\n    _convoyHashMap set [\"_latestPointOnPath\",_convoyLead_currentPosition_ATL];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Handle speed\n---------------------------------------------------------------------------- */\nprivate _currentVehicle_drivePath = _currentVehicle getVariable \"KISKA_convoy_drivePath\";\nprivate _currentPointSpeedLimit = _speedLimitMap getOrDefaultCall [_currentVehicle_drivePath param [0,-1],{-1}];\nprivate _debug = _currentVehicle getVariable [\"KISKA_convoy_debug\",false];\n\nprivate _driverIsAI = !(isPlayer _currentVehicle_driver);\nif (_driverIsAI) then {\n\n    private _currentVehicle_index = _currentVehicle getVariable \"KISKA_convoy_index\";\n    private _vehicleAhead = _convoyHashMap get (_currentVehicle_index - 1);\n\n    private _currentVehicle_frontBumperPosition = [_currentVehicle,false] call KISKA_fnc_convoy_getBumperPosition;\n    private _vehicleAhead_rearBumperPosition = [_vehicleAhead,true] call KISKA_fnc_convoy_getBumperPosition;\n    private _distanceBetweenVehicles = _currentVehicle_frontBumperPosition vectorDistance _vehicleAhead_rearBumperPosition;\n\n    private _vehicleAhead_speed = speed _vehicleAhead;\n    private _currentVehicle_seperation = (_currentVehicle getVariable [\"KISKA_convoy_seperation\",20]) max MIN_CONVOY_SEPERATION;\n    private _vehiclesAreWithinBoundary = _distanceBetweenVehicles < _currentVehicle_seperation;\n\n    private _currentVehicle_isStopped = _currentVehicle getVariable [\"KISKA_convoy_isStopped\",false];\n    private _vehicleAhead_isStopped = _vehicleAhead_speed <= LEAD_VEHICLE_MAX_SPEED_TO_HALT_FOLLOW;\n    private _currentVehicle_shouldBeStopped = _vehicleAhead_isStopped AND _vehiclesAreWithinBoundary;\n\n    if (_currentVehicle_shouldBeStopped AND (!_currentVehicle_isStopped)) exitWith {\n        if (_debug) then {\n            private _currentVehicle_speed = speed _currentVehicle;\n            hint str [\"In Halt\",_currentVehicle_speed,_distanceBetweenVehicles];\n        };\n\n        _currentVehicle setVariable [\"KISKA_convoy_isStopped\",true];\n        [_currentVehicle] call KISKA_fnc_convoy_stopVehicle;\n    };\n\n\n    if ((!_currentVehicle_shouldBeStopped) AND _currentVehicle_isStopped) then {\n        _currentVehicle setVariable [\"KISKA_convoy_isStopped\",false];\n        if !(_currentVehicle_driver checkAIFeature \"path\") then {\n            _currentVehicle_driver enableAI \"path\";\n        };\n    };\n\n    /* ---------------------------------\n        Force speed based on distance\n    --------------------------------- */\n    private _currentVehicle_speed = speed _currentVehicle;\n    private \"_debugText\";\n    private _speedLimit = -1;\n    if (_vehiclesAreWithinBoundary) then {\n        private _modifier = (\n            (_currentVehicle_seperation - _distanceBetweenVehicles) * VEHICLE_SPEED_LIMIT_MULTIPLIER\n        ) max MIN_VEHICLE_SPEED_LIMIT_MODIFIER;\n\n        _speedLimit = (_vehicleAhead_speed - _modifier) max MIN_VEHICLE_SPEED_LIMIT;\n        \n        if (_debug) then {\n            _debugText = parseText format [\n                \"Limited Vehicle Speed\n                <br/>\n                <t align='left'>Within seperation boundary</t>\n                <br/>\n                <t align='left'>Distance To Vehicle In Front: %1</t>\n                <br/>\n                <t align='left'>Current Vehicle Speed: %2</t>\n                <br/>\n                <t align='left'>Speed Limited To: %3</t>\",\n                _distanceBetweenVehicles,\n                _currentVehicle_speed,\n                _speedLimit\n            ];\n        };\n\n    } else {\n        private _distanceToLimitToVehicleAheadSpeed = _currentVehicle_seperation * SMALL_SPEED_LIMIT_DISTANCE_MODIFIER;\n        if (_distanceBetweenVehicles < _distanceToLimitToVehicleAheadSpeed) exitWith {\n            _speedLimit = [_vehicleAhead_speed,5] select _vehicleAhead_isStopped;\n\n            if (_debug) then {\n                _debugText = parseText format [\n                    \"Limited Vehicle Speed To Vehicle Ahead\n                    <br/>\n                    <t align='left'>Vehicle outside of convoy seperation</t>\n                    <br/>\n                    <t align='left'>Distance To Vehicle In Front: %1</t>\n                    <br/>\n                    <t align='left'>Speed Limited To: %2</t>\",\n                    _distanceBetweenVehicles,\n                    _speedLimit\n                ];\n            };\n        };\n\n        if ((_distanceBetweenVehicles > VEHICLE_SHOULD_CATCH_UP_DISTANCE) AND _debug) exitWith { \n            _debugText = parseText format [\n                \"Unlimited Vehicle Speed\n                <br/>\n                <t align='left'>Outside of handle distance (%2)</t>\n                <br/>\n                <t align='left'>Distance To Vehicle In Front: %1</t>\",\n                _distanceBetweenVehicles,\n                VEHICLE_SHOULD_CATCH_UP_DISTANCE\n            ];\n        };\n        \n        private _speedDifferential = abs (_currentVehicle_speed - _vehicleAhead_speed);\n        if (_speedDifferential > SPEED_DIFFERENTIAL_LIMIT) exitWith {\n            _speedLimit = _distanceBetweenVehicles;\n            \n            if (_debug) then {\n                _debugText = parseText format [\n                    \"Limited Speed Based On Differential\n                    <br/>\n                    <t align='left'>Vehicle Speed: %1</t>\n                    <br/>\n                    <t align='left'>Distance To Vehicle In Front: %2</t>\",\n                    _currentVehicle_speed,\n                    _distanceBetweenVehicles\n                ];\n            };\n        };\n        \n        if (_debug) then {\n            _debugText = parseText format [\n                \"Unlimited Vehicle Speed\n                <br/>\n                <t align='left'>Met no handle conditions</t>\n                <br/>\n                <t align='left'>Distance To Vehicle In Front: %1</t>\",\n                _distanceBetweenVehicles\n            ];\n        };\n    };\n\n\n    if (\n        (_currentPointSpeedLimit isNotEqualTo -1) AND \n        (_speedLimit > _currentPointSpeedLimit)\n    ) then {\n        _speedLimit = _currentPointSpeedLimit;\n\n        if (_debug) then {\n            _debugText = parseText format [\n                \"Limited Vehicle Speed\n                <br/>\n                <t align='left'>Low Lead Vehicle Speed At Point</t>\n                <br/>\n                <t align='left'>Speed Limited To: %1</t>\",\n                _currentPointSpeedLimit\n            ];\n        };\n    };\n\n\n    if (_debug) then { hint _debugText };\n\n    _currentVehicle limitSpeed _speedLimit;\n};\n\n\n\n\n/* ----------------------------------------------------------------------------\n    Delete old points\n---------------------------------------------------------------------------- */\nprivate [\"_currentVehicle_debugDrivePathObjects\",\"_currentVehicle_debugDeletedDrivePathObjects\"];\nif (_debug) then {\n    _currentVehicle_debugDrivePathObjects = _currentVehicle getVariable \"KISKA_convoy_debug_followPathObjects\";\n    _currentVehicle_debugDeletedDrivePathObjects = _currentVehicle getVariable \"KISKA_convoy_debug_followedPathObjects\";\n};\n\nprivate _deleteStartIndex = -1;\nprivate _numberToDelete = 0;\n// getting by ASL (instead of getPosVisual) and then converting to AGL is more accurate, don't know why\nprivate _currentVehicle_position_ASL = getPosASLVisual _currentVehicle;\nprivate _offset = _currentVehicle getVariable \"KISKA_convoy_vehicleAreaOffset\";\nprivate _currentVehicle_position_AGL = ASLToAGL _currentVehicle_position_ASL;\nprivate _currentVehicle_direction = getDirVisual _currentVehicle;\nprivate _area = _currentVehicle getVariable \"KISKA_convoy_vehicleCompletionArea\";\n_area set [0,_currentVehicle_position_AGL vectorDiff (_currentVehicle vectorModelToWorldVisual _offset)];\n_area set [3,_currentVehicle_direction];\n{\n    // some points can include speed limit\n    // NOTE/TODO: it might be worth increasing the width/area in general as speed increases.\n    // Higher speed likely means that the probability of missing a point is higher\n\n    // TODO: extend area to be further behind the vehicle\n    private _pointReached = _x inArea _area;\n\n    if !(_pointReached) then { break };\n    _numberToDelete = _numberToDelete + 1;\n\n    private _deleteStartIndexDefined = _deleteStartIndex isNotEqualTo -1;\n    if (_deleteStartIndexDefined) then { continue };\n    _deleteStartIndex = _forEachIndex;\n\n} forEach _currentVehicle_drivePath;\n\nprivate _pointsCanBeDeleted = (_deleteStartIndex >= 0) AND (_numberToDelete > 0);\nif (_pointsCanBeDeleted) then {\n    _currentVehicle_drivePath deleteRange [_deleteStartIndex,_numberToDelete];\n\n    if (_debug) then {\n        private _lastIndexToDelete = _deleteStartIndex + (_numberToDelete - 1);\n        private _debugObjectType = _currentVehicle getVariable [\n            \"KISKA_convoy_debugMarkerType_followedPath\",\n            \"Sign_Arrow_Large_blue_F\"\n        ];\n        private _deletedPointMarker = createVehicle [_debugObjectType, _currentVehicle_position_AGL, [], 0, \"CAN_COLLIDE\"];\n        _currentVehicle_debugDeletedDrivePathObjects pushBack _deletedPointMarker;\n\n        for \"_i\" from _deleteStartIndex to _lastIndexToDelete do { \n            deleteVehicle (_currentVehicle_debugDrivePathObjects select _i);\n        };\n        _currentVehicle_debugDrivePathObjects deleteRange [_deleteStartIndex,_numberToDelete];\n    };\n};\n\n\n/* ----------------------------------------------------------------------------\n    Update current vehicle drive path with new point\n---------------------------------------------------------------------------- */\nprivate _pointToAdd = _convoyHashMap get \"_latestPointOnPath\";\nprivate _lastAddedPoint = _currentVehicle getVariable \"KISKA_convoy_lastAddedPoint\";\nif (_lastAddedPoint isEqualTo _pointToAdd) exitWith {};\n\n\n_currentVehicle setVariable [\"KISKA_convoy_lastAddedPoint\",_pointToAdd];\n\nif (_debug) then {\n    private _debugObjectType = _currentVehicle getVariable [\n        \"KISKA_convoy_debugMarkerType_followPath\",\n        \"Sign_Arrow_Large_Cyan_F\"\n    ];\n\n    // speed limit added to drive path point\n    private _debugObject = createVehicle [_debugObjectType, _pointToAdd, [], 0, \"CAN_COLLIDE\"];\n    _currentVehicle_debugDrivePathObjects pushBack _debugObject;\n};\n\nprivate _indexInserted = _currentVehicle_drivePath pushBack _pointToAdd;\nprivate _doDriveOnPath = _currentVehicle getVariable [\"KISKA_convoy_doDriveOnPath\",true];\nif (_driverIsAI AND {(_indexInserted >= 1) AND _doDriveOnPath}) then {\n    _currentVehicle setDriveOnPath _currentVehicle_drivePath;\n};\n",
    "fileName": "fn_convoy_onEachFrame.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_removeVehicle\n\nDescription:\n    Removes a given vehicle from its convoy.\n\n    This will shift the index's of all vehicles in the convoy that are lower\n     than the given vehicle to remove. If the vehicle is moving (speed > 0)\n     then the vehicle will be told to \"stop\" via a `move` order.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to remove\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_removeVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_removeVehicle\";\n\n#define MAX_ARRAY_LENGTH 1E7\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _convoyHashMap = [_vehicle] call KISKA_fnc_convoy_getConvoyHashMapFromVehicle;\nif (isNil \"_convoyHashMap\") exitWith {\n    [[_vehicle,\" does not have a KISKA_convoy_hashMap in its namespace\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\n[_vehicle] call KISKA_fnc_convoy_removeVehicleKilledEvent;\n[_vehicle,true] call KISKA_fnc_convoy_clearVehicleDebugFollowPath;\n[_vehicle,true] call KISKA_fnc_convoy_clearVehicleDebugFollowedPath;\n\n\nprivate _getOutEventHandlerId = _vehicle getVariable [\"KISKA_convoy_getOutEventHandlerId\",-1];\n_vehicle removeEventHandler [\"GetOut\",_getOutEventHandlerId];\n\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\nprivate _vehicleIndex = [_vehicle] call KISKA_fnc_convoy_getVehicleIndex;\n_convoyVehicles deleteAt _vehicleIndex;\n\nprivate _vehiclesToChangeIndex = _convoyVehicles select [_vehicleIndex, MAX_ARRAY_LENGTH];\n_vehiclesToChangeIndex apply {\n    private _currentIndex = [_x] call KISKA_fnc_convoy_getVehicleIndex;\n    if (_currentIndex isEqualTo -1) then {\n        [[\"Could not find 'KISKA_convoy_index' in namespace of \", _x,\" to change\"],true] call KISKA_fnc_log;\n        continue\n    };\n\n    private _newIndex = _currentIndex - 1;\n    _convoyHashMap set [_newIndex,_x];\n    _x setVariable [\"KISKA_convoy_index\",_newIndex];\n};\n\n[_vehicle,\"path\"] remoteExecCall [\"enableAI\",_vehicle];\n_vehicle limitSpeed -1;\n\n// `move` will cancel the setDriveOnPath\nif ((speed _vehicle) > 0) then {\n    [_vehicle, (getPosATLVisual _vehicle)] remoteExecCall [\"move\",_vehicle];\n};\n\n\n[\n    \"KISKA_convoy_isStopped\",\n    \"KISKA_convoy_drivePath\",\n    \"KISKA_convoy_debug_followPathObjects\",\n    \"KISKA_convoy_debug_followedPathObjects\",\n    \"KISKA_convoy_debug\",\n    \"KISKA_convoy_hashMap\",\n    \"KISKA_convoy_index\",\n    \"KISKA_convoy_debugMarkerType_followedPath\",\n    \"KISKA_convoy_debugMarkerType_followPath\",\n    \"KISKA_convoy_vehicleKilledEventID\",\n    \"KISKA_convoy_handleUnconsciousDriver\",\n    \"KISKA_convoy_handleDeadDriver\",\n    \"KISKA_convoy_handleVehicleCantMove\",\n    \"KISKA_convoy_handleVehicleKilled\",\n    \"KISKA_convoy_seperation\",\n    \"KISKA_convoy_lastAddedPoint\",\n    \"KISKA_convoy_deadDriverBeingHandled\",\n    \"KISKA_convoy_doDriveOnPath\",\n    \"KISKA_convoy_currentUnconsciousDriver\",\n    \"KISKA_convoy_getOutEventHandlerId\",\n    \"KISKA_convoy_getOutTimesHashMap\",\n    \"KISKA_convoy_vehicleCompletionArea\",\n    \"KISKA_convoy_vehicleAreaOffset\"\n] apply {\n    _vehicle setVariable [_x,nil];\n};\n\n\nnil\n",
    "fileName": "fn_convoy_removeVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_removeVehicleKilledEvent\n\nDescription:\n    Removes the \"MPKILLED\" event handler of a given vehicle in a convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to add the killed eventhandler to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_removeVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_removeVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _eventId = _vehicle getVariable [\"KISKA_convoy_vehicleKilledEventID\",-1];\n_vehicle removeMPEventHandler [\"MPKILLED\",_eventId];\n_vehicle setVariable [\"KISKA_convoy_vehicleKilledEventID\",nil];\n",
    "fileName": "fn_convoy_removeVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setDefaultSeperation\n\nDescription:\n    Sets the default seperation between NEWLY added vehicles to a convoy.\n    \n    This will NOT update the spacing between any vehicles currently in the convoy.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to set the value in\n    1: _seperation <NUMBER> - The default distance between vehicles\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_convoyHashMap,20] call KISKA_fnc_convoy_setDefaultSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setDefaultSeperation\";\n\n#define MIN_CONVOY_SEPERATION 10\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_seperation\",20,[123]]\n];\n\n\nif (_seperation < MIN_CONVOY_SEPERATION) then {\n    _seperation = MIN_CONVOY_SEPERATION;\n};\n_convoyHashMap set [\"_convoySeperation\",_seperation];\n",
    "fileName": "fn_convoy_setDefaultSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setPointBuffer\n\nDescription:\n    Sets the minimum distance that must be between each position added to a vehicles\n     drive path. Essentially how often the lead vehicle's position is recorded.\n    \nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy hashmap to get the value from\n    1: _minBufferBetweenPoints <NUMBER> - The distance between positions in order for\n        them to be added to the convoy drive path\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_convoyHashMap,1] call KISKA_fnc_convoy_setPointBuffer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setPointBuffer\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    \"_convoyHashMap\",\n    [\"_minBufferBetweenPoints\",3,[123]]\n];\n\n_convoyHashMap set [\"_minBufferBetweenPoints\",_minBufferBetweenPoints];\n",
    "fileName": "fn_convoy_setPointBuffer.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDebug\n\nDescription:\n    Sets whether or not a given vehicle is in debug mode for convoys.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the convoy seperation of\n    1: _debugMode <BOOL> - `true` to enable, `false` to disable debug\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // debug enabled \n        [\n            _vehicle,\n            true\n        ] call KISKA_fnc_convoy_setVehicleDebug;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDebug\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_debug\",false,[true]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_debug\",_debug];\n",
    "fileName": "fn_convoy_setVehicleDebug.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDebugMarkerType_followPath\n\nDescription:\n    Sets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have not been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the marker type of\n    1: _type <STRING> - The class name of the object to spawn as a marker\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            \"Sign_Arrow_Large_Cyan_F\"\n        ] call KISKA_fnc_convoy_setVehicleDebugMarkerType_followPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDebugMarkerType_followPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_type\",\"Sign_Arrow_Large_Cyan_F\",[\"\"]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_debugMarkerType_followPath\",_type];\n",
    "fileName": "fn_convoy_setVehicleDebugMarkerType_followPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDebugMarkerType_followedPath\n\nDescription:\n    Sets the 3d debug marker class name that will be used to mark waypoints for \n     a given vehicles path that have been completed.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the marker type of\n    1: _type <STRING> - The class name of the object to spawn as a marker\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            \"Sign_Arrow_Large_blue_F\"\n        ] call KISKA_fnc_convoy_setVehicleDebugMarkerType_followedPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDebugMarkerType_followedPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_type\",\"Sign_Arrow_Large_blue_F\",[\"\"]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_debugMarkerType_followedPath\",_type];\n",
    "fileName": "fn_convoy_setVehicleDebugMarkerType_followedPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleDriveOnPath\n\nDescription:\n    Sets whether or not the vehicle will initiate new `setDriveOnPath`'s whenever\n     new positions are added to its internal drive path.\n    \n    While false, a vehicle will continue to add points from the lead vehicle to its\n     drive path and will continue to drive on the path prior to the setting of this \n     to false unless otherwise stopped.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the doDriveOnPath var of\n    1: _mode <BOOL> - `true` to enable, `false` to disable driving on newly added points\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // do-drive-on-path enabled \n        [\n            _vehicle,\n            true\n        ] call KISKA_fnc_convoy_setVehicleDriveOnPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleDriveOnPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_mode\",false,[true]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_doDriveOnPath\",_mode];\n",
    "fileName": "fn_convoy_setVehicleDriveOnPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleKilledEvent\n\nDescription:\n    Sets the code that should execute when a vehicle dies in a convoy.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the killed event on\n    1: _eventCode <CODE> - The code to execute when the vehicle dies in a convoy\n        \n        Parameters:\n        - 0: _vehicle <OBJECT> - The vehicle that died\n        - 1: _convoyHashMap <OBJECT> - The hashmap used for the convoy\n        - 2: _convoyLead <OBJECT> - The lead vehicle of the convoy\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            vic,\n            {hint str _this}\n        ] call KISKA_fnc_convoy_setVehicleKilledEvent;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleKilledEvent\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_eventCode\",{},[{}]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\"] call KISKA_fnc_log;\n    nil\n};\n\n\n_vehicle setVariable [\n    \"KISKA_convoy_handleVehicleKilled\",\n    _eventCode\n];\n",
    "fileName": "fn_convoy_setVehicleKilledEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_setVehicleSeperation\n\nDescription:\n    Sets the distance that a given vehicle will keep from the vehicle in front\n     of it when in a convoy.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to set the convoy seperation of\n    1: _seperation <NUMBER> - The distance the vehicle should try to maintain\n        to the vehicle in front of it in a convoy (minimum of 10m)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            10\n        ] call KISKA_fnc_convoy_setVehicleSeperation;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_setVehicleSeperation\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_seperation\",20,[123]]\n];\n\n\n_vehicle setVariable [\"KISKA_convoy_seperation\",_seperation];\n",
    "fileName": "fn_convoy_setVehicleSeperation.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_shouldVehicleDriveOnPath\n\nDescription:\n    Gets whether or not the vehicle will initiate new `setDriveOnPath`'s whenever\n     a new point is added to the vehicle's drive path.\n    \n    While false, a vehicle will continue to receive new points in the vehicles drive path.\n         \nParameters:\n    0: _vehicle <OBJECT> - The vehicle to check the value of\n\nReturns:\n    <BOOL> - The vehicle's state of `KISKA_convoy_doDriveOnPath`\n\nExamples:\n    (begin example)\n        private _doDriveOnPath = [_vehicle] call KISKA_fnc_convoy_shouldVehicleDriveOnPath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_shouldVehicleDriveOnPath\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\n_vehicle getVariable [\"KISKA_convoy_doDriveOnPath\",false]\n",
    "fileName": "fn_convoy_shouldVehicleDriveOnPath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_stopVehicle\n\nDescription:\n    Used in the process of KISKA's advanced convoy to stop a given vehicle.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to stop\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [vic] call KISKA_fnc_convoy_stopVehicle;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_stopVehicle\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_vehicle\",objNull,[objNull]]\n];\n\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null\",false] call KISKA_fnc_log;\n    nil\n};\n\n// if !(local _vehicle) exitWith {\n//     [[\"_vehicle \",_vehicle,\" is not local!\"],true] call KISKA_fnc_log;\n//     nil\n// };\n\n_vehicle limitSpeed 1;\n// Limiting the speed is not enough for some vehicles (armor)\n// They will either not stop fast enough when follow distances are small\n// Or they start to move around and find random places to go\nprivate _driver = driver _vehicle;\n// TODO: figure out if an AI changes locality, that this disableAI will persist\n// it is not clear which disableAI's are truly Global Effects\n[_driver,\"path\"] remoteExecCall [\"disableAI\",_driver];\n",
    "fileName": "fn_convoy_stopVehicle.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_convoy_syncLatestDrivePoint\n\nDescription:\n    Ensures all vehicles in the convoy have the latest drive path point from the\n\t convoy lead as the last index of their drive path.\n\nParameters:\n    0: _convoyHashMap <HASHMAP> - The convoy's hashmap\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [ConvoyHashMap] call KISKA_fnc_convoy_syncLatestDrivePoint;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_convoy_syncLatestDrivePoint\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nparams [\"_convoyHashMap\"];\n\nprivate _latestPointToAdd = _convoyHashMap get \"_latestPointOnPath\";\n\nprivate _convoyVehicles = [_convoyHashMap] call KISKA_fnc_convoy_getConvoyVehicles;\n_convoyVehicles apply {\n\tprivate _lastAddedPoint = _x getVariable \"KISKA_convoy_lastAddedPoint\";\n\tif (_lastAddedPoint isEqualTo _latestPointToAdd) then { continue };\n\n\t_x setVariable [\"KISKA_convoy_lastAddedPoint\",_latestPointToAdd];\n\n\tif ([_x] call KISKA_fnc_convoy_isVehicleInDebug) then {\n\t\tprivate _debugObjectType = [_x] call  KISKA_fnc_convoy_getVehicleDebugMarkerType_followPath;\n\t\tprivate _debugObject = createVehicle [_debugObjectType, _latestPointToAdd, [], 0, \"CAN_COLLIDE\"];\n\n\t\tprivate _currentVehicle_debugDrivePathObjects = [_x] call KISKA_fnc_convoy_getVehicleDebugFollowPath;\n\t\t_currentVehicle_debugDrivePathObjects pushBack _debugObject;\n\t};\n\n\tprivate _indexInserted = _currentVehicle_drivePath pushBack _latestPointToAdd;\n\tif (_indexInserted >= 1) then {\n\t\t_x setDriveOnPath _currentVehicle_drivePath;\n\t};\n\n};\n",
    "fileName": "fn_convoy_syncLatestDrivePoint.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_eventHandler_addFromConfig\n\nDescription:\n    Adds a configed custom eventhandler.\n\nParameters:\n    0: _entityToAddEventHandlerTo <ANY> - The entity to add the eventhandler to\n    1: _config <CONFIG> - The config of the eventhandler\n    2: _code <CODE or STRING> - What to execute when the eventhandler is called\n        _thisScriptedEventHandler is available with the event id\n\nReturns:\n    <NUMBER> - The ID of the eventhandler\n\nExamples:\n    (begin example)\n        private _eventID = [\n            player,\n            myConfig\n        ] call KISKA_fnc_eventHandler_addFromConfig\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_eventHandler_addFromConfig\";\n\nparams [\n    \"_entityToAddEventHandlerTo\",\n    [\"_config\",configNull,[configNull]],\n    [\"_code\",{},[\"\",{}]]\n];\n\nif (isNull _config) exitWith {\n    [\"Could not find config!\",true] call KISKA_fnc_log;\n    -1\n};\n\nif !([_entityToAddEventHandlerTo] call (compile getText(_config >> \"entityCondition\"))) exitWith {\n    [\"_entityToAddEventHandlerTo failed condition check!\",true] call KISKA_fnc_log;\n    -1\n};\n\nprivate _stateMachine_config = _config >> \"stateMachine\";\nprivate _stateMachine_name = getText(_stateMachine_config >> \"name\");\nprivate _stateMachine = localNamespace getVariable [_stateMachine_name,locationNull];\nif (isNull _stateMachine) then {\n    _stateMachine = [_stateMachine_config] call KISKA_fnc_eventhandler_createCBAStateMachine;\n    localNamespace setVariable [_stateMachine_name,_stateMachine];\n    _stateMachine setVariable [\"KISKA_entity_eventhandlerCount_map\",createHashMap];\n};\n\nprivate _entityList = _stateMachine getVariable [\"CBA_statemachine_list\", []];\nif !(_entityToAddEventHandlerTo in _entityList) then {\n    _entityList pushBack _entityToAddEventHandlerTo;\n};\n\n// tracking number of events for use when removing events\nprivate _eventHandlerCount_map = _stateMachine getVariable \"KISKA_entity_eventhandlerCount_map\";\nprivate _currentNumberOfEventsOnEntity = [_eventHandlerCount_map,_entityToAddEventHandlerTo,0] call KISKA_fnc_hashmap_get;\n\nprivate _eventId = [\n    _entityToAddEventHandlerTo,\n    getText(_config >> \"eventName\"),\n    _code\n] call BIS_fnc_addScriptedEventhandler;\n\n_currentNumberOfEventsOnEntity = _currentNumberOfEventsOnEntity + 1;\n// update number of events on entity\n[_eventHandlerCount_map,_entityToAddEventHandlerTo,_currentNumberOfEventsOnEntity] call KISKA_fnc_hashmap_set;\n\n\n_eventId\n",
    "fileName": "fn_eventHandler_addFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_eventHandler_createCBAStateMachine\n\nDescription:\n    Adds a configed custom eventhandler\n\nParameters:\n    0: _config <CONFIG> - The config of the statemachine\n\nReturns:\n    <LOCATION> - The statemachine\n\nExamples:\n    (begin example)\n        _statemachine = [myConfig] call KISKA_fnc_eventHandler_createCBAStateMachine\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_eventHandler_createCBAStateMachine\";\n\nparams [\n    [\"_config\", configNull, [configNull]]\n];\n\nif (isNull _config) exitWith {\n    [\"_config passed was null!\",true] call KISKA_fnc_log;\n    locationNull;\n};\n\nprivate _skipNull = [_config >> \"skipNull\"] call BIS_fnc_getCfgDataBool;\nprivate _stateMachine = [[], _skipNull] call CBA_stateMachine_fnc_create;\n\nprivate _stateConfigClasses = configProperties [_config, \"isClass _x\", true];\n_stateConfigClasses apply {\n    private _stateName = configName _x;\n    [\n        _stateMachine,\n        compile (getText(_x >> \"onState\")),\n        compile (getText(_x >> \"onStateEntered\")),\n        compile (getText(_x >> \"onStateLeaving\")),\n        _stateName\n    ] call CBA_stateMachine_fnc_addState;\n\n};\n\n// We need to add the transitions in a second loop to make sure the states exist already\n_stateConfigClasses apply {\n    private _stateName = configName _x;\n\n    private _stateTransitionConfigClasses = configProperties [_x, \"isClass _x\", true];\n    _stateTransitionConfigClasses apply {\n        private _transitionName = configName _x;\n        private _targetState = _transitionName;\n        if (isText (_x >> \"targetState\")) then {\n            _targetState = getText (_x >> \"targetState\");\n        };\n\n        private _condition = compile (getText(_x >> \"condition\"));\n        private _onTransition = compile (getText(_x >> \"onTransition\"));\n        private _events = getArray (_x >> \"events\");\n\n        if (_events isEqualTo []) then {\n            [\n                _stateMachine,\n                _stateName,\n                _targetState,\n                _condition,\n                _onTransition,\n                _transitionName\n            ] call CBA_stateMachine_fnc_addTransition;\n\n        } else {\n            [\n                _stateMachine,\n                _stateName,\n                _targetState,\n                _events,\n                _condition,\n                _onTransition,\n                _transitionName\n            ] call CBA_stateMachine_fnc_addEventTransition;\n        };\n\n    };\n\n};\n\n\n_stateMachine\n",
    "fileName": "fn_eventHandler_createCBAStateMachine.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_eventHandler_remove\n\nDescription:\n    Removes a configed custom eventhandler.\n\n    Worth noting that this will still return `true` even after the event has been\n     removed as BIS_fnc_removeScriptedEventHandler essentially checks that the event\n     isn't one that never could have existed.\n\nParameters:\n    0: _entity <ANY> - The config of the eventhandler\n    1: _eventConfig <CONFIG> - The eventhandler config path\n    2: _id <NUMBER> - The event to remove\n\nReturns:\n    <BOOL> - `true` if removed, `false` if it never existed\n\nExamples:\n    (begin example)\n        private _removed = [\n            player,\n            configFile >> \"KISKA_EventHandlers\" >> \"KISKA_combatBehaviourChangedEvent\",\n            0\n        ] call KISKA_fnc_eventHandler_remove\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_eventHandler_remove\";\n\nparams [\n    \"_removeFrom\",\n    [\"_eventConfig\",configNull,[configNull]],\n    [\"_id\",-1,[123]]\n];\n\nif (isNull _eventConfig) exitWith {\n    [\"_eventConfig is null config!\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _stateMachine_name = getText(_eventConfig >> \"stateMachine\" >> \"name\");\nprivate _stateMachine = localNamespace getVariable [_stateMachine_name,locationNull];\nif (isNull _stateMachine) exitWith {\n    [[\"Statemachine: \", _stateMachine_name,\" has not been instantiated yet!\"],false] call KISKA_fnc_log;\n    false\n};\n\n\nprivate _eventName = getText(_eventConfig >> \"eventName\");\nprivate _removed = [_removeFrom, _eventName, _id] call BIS_fnc_removeScriptedEventHandler;\n\n// remove from statemachine list if no events are left for this machine\nif (_removed) then {\n    private _eventCountMap = _stateMachine getVariable \"KISKA_entity_eventhandlerCount_map\";\n    private _numberOfEvents = [_eventCountMap,_removeFrom] call KISKA_fnc_hashmap_get;\n\n    _numberOfEvents = _numberOfEvents - 1;\n\n    if (_numberOfEvents isEqualTo 0) then {\n        [_eventCountMap,_removeFrom] call KISKA_fnc_hashmap_deleteAt;\n\n        private _entityList = _stateMachine getVariable \"CBA_statemachine_list\";\n        _entityList deleteAt (_entityList find _removeFrom);\n    };\n};\n\n\n_removed\n",
    "fileName": "fn_eventHandler_remove.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_assignObjectOrGroupKey\n\nDescription:\n    Provides a unique hashmap key for a given object or group.\n\n\tThe key can be reverse looked up for the object or group with \n\t KISKA_fnc_hashmap_getObjectOrGroupFromRealKey.\n\nParameters:\n    0: _objectOrGroup <OBJECT or GROUP> - The object or group to assign a key to\n\nReturns:\n    <STRING> - The string key used to uniquely identify the given object or group\n\nExamples:\n    (begin example)\n        private _associatedKey = [\n\t\t\tsomeObject\n\t\t] call KISKA_fnc_hashmap_assignObjectOrGroupKey;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_assignObjectOrGroupKey\";\n\nparams [\n\t[\"_objectOrGroup\",objNull,[objNull,grpNull]]\n];\n\n\nprivate _keyInNamespace = _objectOrGroup getVariable \"KISKA_hashmap_key\";\nif !(isNil \"_keyInNamespace\") exitWith { _keyInNamespace };\n\n\nprivate _key = (hashValue _objectOrGroup) + ([_objectOrGroup] call KISKA_fnc_netId);\n_objectOrGroup setVariable [\"KISKA_hashmap_key\",_key];\n\nprivate _objectGroupKeyMap = call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n_objectGroupKeyMap set [_key,_objectOrGroup];\n        \n_objectOrGroup addEventHandler [\"Deleted\",{\n\tparams [\"_objectOrGroup\"];\n\n\tprivate _objectGroupKeyMap = [] call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n\tprivate _key = [_objectOrGroup] call KISKA_fnc_hashmap_getKeyFromObjectOrGroup;\n\t_objectGroupKeyMap deleteAt _key;\n}];\n\n\n_key\n",
    "fileName": "fn_hashmap_assignObjectOrGroupKey.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_deleteAt\n\nDescription:\n    Deletes a key/value pair if it's in a hashmap, supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to search in\n    1: _key <ANY> - The key to delete\n\nReturns:\n    <ANY> - The deleted value, nil if not found\n\nExamples:\n    (begin example)\n        private _value = [myMap,_key] call KISKA_fnc_hashmap_deleteAt;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_deleteAt\";\n\nparams [\n    \"_map\",\n    \"_key\"\n];\n\n_key = [_key] call KISKA_fnc_hashmap_getRealKey;\n\n\n_map deleteAt _key;\n",
    "fileName": "fn_hashmap_deleteAt.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_get\n\nDescription:\n    Gets a value from a hashmap but also supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to get the value from\n    1: _key <ANY> - The key to find in the map\n    2: _default <ANY> - The value to return if the map does not contain the value\n\nReturns:\n    <ANY> - The saved value, default value, or nil if not found and no default provided\n\nExamples:\n    (begin example)\n        private _value = [\n            myMap,\n            someObject,\n            \"Hello World\"\n        ] call KISKA_fnc_hashmap_get;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_get\";\n\nparams [\n    \"_map\",\n    \"_key\",\n    \"_default\"\n];\n\n_key = [_key] call KISKA_fnc_hashmap_getRealKey;\n\n// while not in every case, there are some instances in which \n// a nil _default will throw an error if called.\n/// in an eventhandler seems to be one such case\n/// hence why it is sectioned off instead of always used\n/// as `_map getOrDefault [_key,nil];`\nif !(isNil \"_default\") exitWith {\n    _map getOrDefault [_key,_default];\n};\n\n_map get _key;\n",
    "fileName": "fn_hashmap_get.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_getObjectOrGroupFromRealKey\n\nDescription:\n    Retrieves the global hashmap used to associate a given real key with either a\n\t group or object with KISKA hashmap functions.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - The hashmap used for finding the given object or group from\n\t a real key used in a KISKA hashmap\n\nExamples:\n    (begin example)\n        private _kiskaObjectOrGroupKeyHashMap = call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap\";\n\nprivate _objectGroupKeyMap = localNamespace getVariable \"KISKA_hashmapKeyMap\";\nif !(isNil \"_objectGroupKeyMap\") exitWith {_objectGroupKeyMap};\n\n_objectGroupKeyMap = createHashMap;\nlocalNamespace setVariable [\"KISKA_hashmapKeyMap\",_objectGroupKeyMap];\n\n\n_objectGroupKeyMap\n",
    "fileName": "fn_hashmap_getKiskaObjectGroupKeyMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_getObjectOrGroupFromRealKey\n\nDescription:\n    Translates a real key used be KISKA hashmaps for groups and objects back into\n\t the associated group or object.\n\nParameters:\n    0: _key <STRING> - The real key used to identify an object or group in a KISKA hashmap\n\nReturns:\n    <OBJECT, GROUP, or NIL> - The object or group that is associated with a given key.\n\t `NIL` if no object or group matches the given key.\n\nExamples:\n    (begin example)\n\t\tprivate _key = [someObject] call KISKA_fnc_hashmap_getRealKey;\n        private _someObject = [\n\t\t\t_key\n\t\t] call KISKA_fnc_hashmap_getObjectOrGroupFromRealKey;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_getObjectOrGroupFromRealKey\";\n\nparams [\n\t[\"_key\",\"\",[\"\"]]\n];\n\nprivate _objectGroupKeyMap = call KISKA_fnc_hashmap_getKiskaObjectGroupKeyMap;\n\n\n_objectGroupKeyMap get _key\n",
    "fileName": "fn_hashmap_getObjectOrGroupFromRealKey.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_getRealKey\n\nDescription:\n    Returns the actual value used for a key when using KISKA hashmap functions.\n\t\n\tThis really only applies to objects or groups as they will have a special string\n\t used to identify them in the hashmap. Use this function to get the key of them\n\t if you need to do multiple operations on a hashmap with the same object or group\n\t and do not want the overhead of the functions.\n\nParameters:\n    0: _key <ANY> - The key used with KISKA hashmap functions (such as object or group)\n\nReturns:\n    <ANY> - Whatever the key will be in a hashmap\n\nExamples:\n    (begin example)\n        private _keyUsedInKiskaHashmap = [someObject] call KISKA_fnc_hashmap_getRealKey;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_getRealKey\";\n\nparams [\"_key\"];\n\nif (_key isEqualType grpNull OR (_key isEqualType objNull)) exitWith {\n    [_key] call KISKA_fnc_hashmap_assignObjectOrGroupKey\n};\n\n\n_key\n",
    "fileName": "fn_hashmap_getRealKey.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_in\n\nDescription:\n    Checks if a key exists in a hashmap, supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to search in\n    1: _key <ANY> - The key to find\n\nReturns:\n    <BOOL> - True if the key is found, false if not\n\nExamples:\n    (begin example)\n        [myMap,_key] call KISKA_fnc_hashmap_in;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_in\";\n\nparams [\n    \"_map\",\n    \"_key\"\n];\n\n_key = [_key] call KISKA_fnc_hashmap_getRealKey;\n\n\n_key in _map\n",
    "fileName": "fn_hashmap_in.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hashmap_set\n\nDescription:\n    Sets a key/value pair in a hashmap but also supports objects and groups as keys.\n\n    Ideally, not something that should be used if the map is not intended to\n     also hold groups and objects as keys.\n\nParameters:\n    0: _map <HASHMAP> - The map to insert in to\n    1: _key <ANY> - The key to associate with the value\n    2: _value <ANY> - The value to associate witht the key\n    3: _insertOnly <BOOL> - When `true`, if the key already exists in the hashmap, \n     the value will not be overwritten\n\nReturns:\n    <BOOL> - False if key is new, true if overwriting\n\nExamples:\n    (begin example)\n        private _inserted = [\n            myMap,\n            someObject,\n            \"Hello World\"\n        ] call KISKA_fnc_hashmap_set;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hashmap_set\";\n\nparams [\n    \"_map\",\n    \"_key\",\n    \"_value\",\n    [\"_insertOnly\",false,[true]]\n];\n\n_key = [_key] call KISKA_fnc_hashmap_getRealKey;\n_map set [_key,_value,_insertOnly];\n",
    "fileName": "fn_hashmap_set.sqf"
  },
  {
    "text": "\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_assignUnitLoadout\n\nDescription:\n    Searches a config class for an array that matches the units classname.\n    This array is filled with potential loadout arrays for the unit.\n\nParameters:\n    0: _config <CONFIG> - The config to search for the array of loadouts in\n    1: _units <ARRAY, GROUP, or OBJECT> - The unit(s) to apply the function to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            missionConfigFile >> \"KISKA_loadouts\" >> \"ONL\",\n            unit1\n        ] call KISKA_fnc_assignUnitLoadout\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_assignUnitLoadout\";\n\nparams [\n    [\"_configPath\",configNull,[configNull]],\n    [\"_units\",[],[[],objNull,grpNull]]\n];\n\n\n// verify params\nif (isNull _configPath) exitWith {\n    [\"A null config was passed\",true] call KISKA_fnc_log;\n    nil\n};\nif (_units isEqualTo []) exitWith {\n    [\"Empty array for _units\",true] call KISKA_fnc_log;\n    nil\n};\nif (_units isEqualTypeAny [objNull,grpNull] AND {isNull _units}) exitWith {\n    [\"_units is null\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n// organize other data types into array\nif (_units isEqualType objNull) then {\n    _units = [_units];\n};\nif (_units isEqualType grpNull) then {\n    _units = units _units;\n};\n\n\n// assign loadouts\nprivate _loadoutHashmap = createHashMap;\n_units apply {\n    private _unit = _x;\n\n    if (alive _unit AND {!isNull _unit}) then {\n\n        private \"_loadoutsForClass\";\n        private _unitClass = typeOf _unit;\n        if (_unitClass in _loadoutHashmap) then {\n            _loadoutsForClass = _loadoutHashmap get _unitClass;\n\n        } else {\n            _loadoutsForClass = getArray(_configPath >> _unitClass);\n            _loadoutHashmap set [_unitClass,_loadoutsForClass];\n\n        };\n\n\n        if (_loadoutsForClass isEqualTo []) then {\n            [[\"Class \", _unitClass, \" does not have any configed loadouts in directory: \",_configPath],true] call KISKA_fnc_log;\n\n        } else {\n            private _newLoadout = selectRandom _loadoutsForClass;\n            private _oldLoadout = getUnitLoadout _unit;\n            // making sure changes took over network\n            [\n                {\n                    scriptName \"KISKA_fnc_assignUnitLoadout\";\n\n                    params [\"_unit\",\"_newLoadout\",\"_oldLoadout\"];\n\n                    private _attemptedSetLoadoutCount = _unit getVariable [\"KISKA_assignLoadout_attemptCount\",0];\n                    if (_attemptedSetLoadoutCount >= 5) then {\n                        [[\"Attempted to set the loadout of unit: \",_unit,\" \",_attemptedSetLoadoutCount,\" times without reaching completion\"]] call KISKA_fnc_log;\n                        [[\"unit's current loadout: \",endl,getUnitLoadout _unit]] call KISKA_fnc_log;\n                        [[\"loadout to set to: \",endl,_newLoadout]] call KISKA_fnc_log;\n                    };\n\n\n                    // units don't like being not simmed on dedicated servers while changing loadouts this, so do it temporarily if needed\n                    if (\n                        !(simulationEnabled _unit) AND \n                        !(_unit getVariable [\"KISKA_assignLoadout_enabledSimulation\",false])\n                    ) then {\n                        _unit setVariable [\"KISKA_assignLoadout_enabledSimulation\",true];\n                        [_unit,true] remoteExecCall [\"enableSimulationGlobal\",2];\n                    };\n                    \n                    _unit setUnitLoadout _newLoadout;\n                    _unit setVariable [\"KISKA_assignLoadout_attemptCount\",_attemptedSetLoadoutCount + 1];\n\n                    private _currentLoadout = getUnitLoadout _unit;\n                    if (_currentLoadout isEqualTo _newLoadout) exitWith { true };\n                    if (_currentLoadout isEqualTo _oldLoadout) exitWith { false };\n\n                    // Some loadouts may not have the exact bullet count (round in the chamber or not)\n                    // which causes isEqualTo to return false\n                    private _deepCompareMatches = true;\n                    {\n                        if (_forEachIndex > 5) then {break};\n\n                        private _currentLoadoutClassToCompare = _x select 0;\n                        private _newLoadoutClassToCompare = (_newLoadout select _foreachIndex) select 0;\n                        if (_currentLoadoutClassToCompare != _newLoadoutClassToCompare) then {\n                            _deepCompareMatches = false;\n                            break\n                        };\n                    } forEach _currentLoadout;\n\n\n                    _deepCompareMatches\n                },\n                {\n                    params [\"_unit\",\"_newLoadout\"];\n                    \n                    private _simulationWasDisabled = _unit getVariable [\"KISKA_assignLoadout_enabledSimulation\",false];\n                    // return units to being unsimmed if they were before\n                    if (_simulationWasDisabled) then {\n                        _unit setVariable [\"KISKA_assignLoadout_enabledSimulation\",nil];\n                        [_unit,false] remoteExecCall [\"enableSimulationGlobal\",2];\n                    };\n\n                    if !(isNil {_unit getVariable \"KISKA_ambientAnimMap\"}) then {\n                        [_unit,_newLoadout] call KISKA_fnc_ambientAnim_setStoredLoadout;\n                    };\n\n                    _unit setVariable [\"KISKA_assignLoadout_attemptCount\",nil];\n                },\n                0.5,\n                [_unit,_newLoadout,_oldLoadout]\n            ] call KISKA_fnc_waitUntil;\n\n        };\n\n    };\n};\n\n\nnil\n",
    "fileName": "fn_assignUnitLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomGear\n\nDescription:\n    Randomizes gear based upon input arrays for each slot. Be aware that this function\n     is very slow (can take >1ms) and should be used ideally on initialization for large\n     numbers of units. \n\n    The unit must be local to the machine where this function is executed.\n\n    All gear arrays can be weighted or unweighted arrays.\n\nParameters:\n    0: _unit : <OBJECT> - The unit to randomize gear\n    1: _uniforms : <STRING[] or (STRING,NUMBER)[]> - Potential uniforms to wear\n    2: _headgear : <STRING[] or (STRING,NUMBER)[]> - Potential headgear to wear\n    3: _facewear : <STRING[] or (STRING,NUMBER)[]> - Potential facewear (goggles) to wear\n    4: _vests : <STRING[] or (STRING,NUMBER)[]> - Potential vests to wear\n    5: _backpacks : <STRING[] or (STRING,NUMBER)[]> - Potential backpacks to wear\n    6: _primaryWeapons : <[STRING,(STRING[] | (STRING,NUMBER)[])][]> - Primary weapons and items to add to them (see example)\n    7: _handguns : <[STRING,(STRING[] | (STRING,NUMBER)[])][]> - Handgun weapons and items to add to them\n    8: _secondaryWeapons : <[STRING,(STRING[] | (STRING,NUMBER)[])][]> - Secondary (launcher) weapons and items to add to them\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        private _uniforms = [\"U_B_CombatUniform_mcam_vest\"];\n        private _headgear = [];\n        private _facewear = [];\n        private _vests = [];\n        private _backpacks = [];\n        private _primaryWeapons = [\n            // add a mag an optic to rifle\n            [\"arifle_MXC_F\",[\"optic_Aco\",\"30Rnd_65x39_caseless_mag\"]]\n        ];\n\n        [\n            _unit,\n            _uniforms,\n            _headgear,\n            _facewear,\n            _vests,\n            _backpacks,\n            _primaryWeapons\n        ] call KISKA_fnc_randomGear;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomGear\";\n\nparams [\n\t[\"_unit\",objNull,[objNull]],\n\t[\"_uniforms\",[],[[]]],\n\t[\"_headgear\",[],[[]]],\n\t[\"_facewear\",[],[[]]],\n\t[\"_vests\",[],[[]]],\n\t[\"_backpacks\",[],[[]]],\n\t[\"_primaryWeapons\",[],[[]]],\n\t[\"_handguns\",[],[[]]],\n\t[\"_secondaryWeapons\",[],[[]]]\n];\n\nif (isNull _unit) exitWith {\n\t[\"Null unit was passed\",true] call KISKA_fnc_log;\n\tnil\n};\n\nif (!local _unit) exitWith {\n\t[[_unit,\" is not a local unit; must be executed where unit is local!\"],true] call KISKA_fnc_log;\n\tnil\n};\n\n// remove all existing stuff\nremoveAllWeapons _unit;\nremoveAllItems _unit;\nremoveAllAssignedItems _unit;\nremoveUniform _unit;\nremoveVest _unit;\nremoveBackpack _unit;\nremoveHeadgear _unit;\nremoveGoggles _unit;\n\n\nprivate _primaryWeaponGearSelector = [\n\t_primaryWeapons, \n\t{ \n\t\t_selectedGear params [\n\t\t\t\"_weapon\",\n\t\t\t[\"_weaponItems\",[]]\n\t\t];\n\t\t_unit addWeapon _weapon;\n\t\t_weaponItems apply { _unit addPrimaryWeaponItem _x };\n\t},\n\t[]\n];\n\nprivate _handgunGearSelector = [\n\t_handguns, \n\t{ \n\t\t_selectedGear params [\n\t\t\t\"_weapon\",\n\t\t\t[\"_weaponItems\",[]]\n\t\t];\n\t\t_unit addWeapon _weapon;\n\t\t_weaponItems apply { _unit addHandgunItem _x };\n\t},\n\t[]\n];\n\nprivate _secondaryWeaponGearSelector = [\n\t_secondaryWeapons, \n\t{ \n\t\t_selectedGear params [\n\t\t\t\"_weapon\",\n\t\t\t[\"_weaponItems\",[]]\n\t\t];\n\t\t_unit addWeapon _weapon;\n\t\t_weaponItems apply { _unit addSecondaryWeaponItem _x };\n\t},\n\t[]\n];\n\n[\n\t[_uniforms, { _unit forceAddUniform _selectedGear }],\n\t[_headgear, { _unit addHeadgear _selectedGear; }],\n\t[_facewear, { _unit addGoggles _selectedGear; }],\n\t[_vests, { _unit addVest _selectedGear; }],\n\t[_backpacks, { _unit addBackpack _selectedGear; }],\n\t_primaryWeaponGearSelector,\n\t_handgunGearSelector,\n\t_secondaryWeaponGearSelector\n] apply {\n\t_x params [\n\t\t\"_availableGear\",\n\t\t\"_fn_addGear\",\n\t\t[\"_valueType\",\"\"]\n\t];\n\n\tif (_availableGear isEqualTo []) then { continue };\n\t\n\tprivate _selectedGear = [_availableGear,_valueType] call KISKA_fnc_selectRandom;\n\t[_unit,_selectedGear] call _fn_addGear;\n};\n\nnil\n",
    "fileName": "fn_randomGear.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomLoadout\n\nDescription:\n    Randomly assigns a loadout from the inputed array to the unit(s) provided.\n\nParameters:\n    0: _units <OBJECT, GROUP, or ARRAY> - The unit or units you want to select the\n        random loadout for. If array, accepts and array of objects.\n    1: _loadoutArray <ARRAY> - An array containing each loadout array.\n        Same syntax as getUnitLoadout return.\n\nReturns:\n    _unitsChanged <ARRAY> - All the units changed\n\nExamples:\n    (begin example)\n        [guy,[globalLoadout1,globalLoadout2]] call KISKA_fnc_randomLoadout;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomLoadout\";\n\nparams [\n    [\"_units\",objNull,[objNull,grpNull,[]]],\n    [\"_loadoutArray\",[],[[]]]\n];\n\nif (_units isEqualType grpNull) then {\n    _units = units _units;\n};\n\nif (_units isEqualType objNull) then {\n    _units = [_units];\n};\n\nprivate _unitsChanged = [];\n\n_units apply {\n    if (alive _x AND {!isNull _x}) then {\n        _x setUnitLoadout (selectRandom _loadoutArray);\n        _x pushBack _unitsChanged;\n    };\n};\n\n_unitsChanged\n",
    "fileName": "fn_randomLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_savePlayerLoadout\n\nDescription:\n    Adds a kill and respawn eventhandler to the player object that restores\n     saves and restores the player loadout (if set in CBA menu settings).\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_savePlayerLoadout\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_savePlayerLoadout;\n};\n\nwaitUntil {\n    if !(isNull player) then { breakWith true };\n    sleep 1;\n    false\n};\n\nplayer addEventHandler [\"KILLED\", {\n    params [\"_unit\"];\n\n    private _loadout = getUnitLoadout _unit;\n    localNamespace setVariable [\"KISKA_loadout\",_loadout];\n    localNamespace setVariable [\"KISKA_playersBody\",_unit];\n}];\n\nplayer addEventHandler [\"RESPAWN\", {\n    private _doRestoreLoadout = missionNamespace getVariable [\"KISKA_CBA_restorePlayerLoadout\",false];\n    if (_doRestoreLoadout AND !(isNil {localNamespace getVariable \"KISKA_loadout\"})) then {\n        [\n            {\n                player setUnitLoadout (localNamespace getVariable \"KISKA_loadout\");\n            },\n            [],\n            0.5\n        ] call CBA_fnc_waitAndExecute;\n    };\n\n    private _doDeleteBody = missionNamespace getVariable [\"KISKA_CBA_deleteBody\",false];\n    private _playerBody = localNamespace getVariable \"KISKA_playersBody\";\n    if (_doDeleteBody AND !(isNil \"_playerBody\")) then {\n        deleteVehicle _playerBody;\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_savePlayerLoadout.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_managedRun_execute\n\nDescription:\n    Allows multiple systems to manage a particular functionality or subset of code\n     by restricting runs to only the latest id for a given namespace\n\n    The code must be added with KISKA_fnc_managedRun_updateCode.\n\n    An example is having competing systems that need to adjust the damage of the player\n     at different times an perhaps with delays. Perhaps one system starts by taking ownership\n     of this functionality to not allow the player to be damaged, however, later this system\n     will reset wether or not the player has damage allowed after some delay.\n    If another system (or the same one again in the future) wants to take ownership of this\n     functionality to also set the player to not allow damage BEFORE the previous system\n     has reset the player's isDamageAllowed state, it could become complex to try and handle\n     the reset vs continuing to allow the player to not take damage. Instead, the previous\n     system's code will now be blocked from running, as another id has taken ownership.\n\nParameters:\n    0: _nameOfCode : <STRING> - The name of the code to run previously added with\n        KISKA_fnc_managedRun_updateCode\n    1: _args : <ARRAY> - An array of arguments that will be `_this` within the\n        code to run\n    2: _idNamespace : <GROUP, OBJECT, LOCATION, NAMESPACE, CONTROL, DISPLAY, TASK, TEAM-MEMBER> - \n        The namespace to restrict the id to. This is used to manage runs on two different\n         objects for example\n    3: _idToRunAgainst : <NUMBER> - The id the code is restricted to run against\n    4: _isScheduled : <BOOL> - Whether the code will be executed in a scheduled environment\n\nReturns:\n    <NUMBER> - The id of the run made, `-1` if code was not run or a new id to make future runs\n        against for a particular system.\n\nExamples:\n    (begin example)\n        // add code for given id\n        [\n            \"KISKA_manage_allowDamage\",\n            {\n                params [\"_unit\",\"_isDamageAllowed\"];\n                _unit allowDamage _isDamageAllowed;\n            }\n        ] call KISKA_fnc_managedRun_updateCode;\n\n        // initial run\n        private _idOfRun = [\n            \"KISKA_manage_allowDamage\",\n            [player, false],\n            player\n        ] call KISKA_fnc_managedRun_execute;\n\n        // try to change in the future\n        [_idOfRun] spawn {\n            params [\"_idOfRun\"];\n            sleep 3;\n            // does nothing because id was overwritten in the meantime\n            [\n                \"KISKA_manage_allowDamage\",\n                [player, true],\n                player,\n                _idOfRun\n            ] call KISKA_fnc_managedRun_execute;\n\n            hint str (isDamageAllowed player) // false\n        };\n\n        private _idOfADifferentRun = [\n            \"KISKA_manage_allowDamage\",\n            [player, false],\n            player\n        ] call KISKA_fnc_managedRun_execute;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_managedRun_execute\";\n\nparams [\n    [\"_nameOfCode\",\"\",[\"\"]],\n    [\"_args\",[],[[]]],\n    [\"_idNamespace\",localNamespace,[grpNull,objNull,locationNull,controlNull,displayNull,taskNull,teamMemberNull,localNamespace]],\n    [\"_idToRunAgainst\",-1,[123]],\n    [\"_isScheduled\",false,[true]]\n];\n\nprivate _codeMap = localNamespace getVariable [\"KISKA_managedRun_codeMap\",-1];\nif (_codeMap isEqualTo -1) exitWith { \n    [\n        [\n            \"KISKA_managedRun_codeMap is not defined, did you add \",\n            _nameOfCode,\n            \" with KISKA_fnc_managedRun_updateCode?\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n    -1 \n};\n\nif !(_nameOfCode in _codeMap) exitWith { \n    [\n        [\n            \"KISKA_managedRun_codeMap does not contain key for \",\n            _nameOfCode,\n            \". Did you add \",\n            _nameOfCode,\n            \" with KISKA_fnc_managedRun_updateCode?\"\n        ],\n        true\n    ] call KISKA_fnc_log;\n    -1 \n};\n\n\nprivate _isNewManagement = _idToRunAgainst isEqualTo -1;\nprivate _currentAdjustmentId = _idNamespace getVariable [\"KISKA_managedRun_latestId\",-1];\nprivate _idToAdjustIsCurrent = _currentAdjustmentId isEqualTo _idToRunAgainst;\nprivate _newAdjustmentIdExists = (!_isNewManagement) AND (!_idToAdjustIsCurrent) AND (_currentAdjustmentId isNotEqualTo -1);\n// new id was made, don't run code\nif (_newAdjustmentIdExists) exitWith { -1 };\n\nprivate _idOfRun = -1;\nif (_isNewManagement) then {\n    // assign new adjusment id as latest\n    _idOfRun = [\"KISKA_managedRun_latestId\",_idNamespace] call KISKA_fnc_idCounter;\n} else {\n    _idOfRun = _idToRunAgainst;\n};\n\nprivate _code = _codeMap get _nameOfCode;\n[_args,_code,_isScheduled] call KISKA_fnc_callBack;\n\n\n_idOfRun\n",
    "fileName": "fn_managedRun_execute.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_managedRun_isDefined\n\nDescription:\n    Checks if a given name is currently defined in the managedRun code map.\n\nParameters:\n    0: _nameOfCode : <STRING> - The name of the code to update\n\nReturns:\n    <BOOL> - Whether or not the managed run code is defined\n    \nExamples:\n    (begin example)\n        // false\n        private _isDefined = [\"KISKA_test\"] call KISKA_fnc_managedRun_isDefined;\n        [\"KISKA_test\",{hint \"Hello World\"}] call KISKA_fnc_managedRun_updateCode;\n        // true now\n        _isDefined = [\"KISKA_test\"] call KISKA_fnc_managedRun_isDefined;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_managedRun_isDefined\";\n\nparams [\n    [\"_nameOfCode\",\"\",[\"\"]]\n];\n\nprivate _codeMap = localNamespace getVariable [\"KISKA_managedRun_codeMap\",-1];\nif (_codeMap isEqualTo -1) exitWith { false };\n\n\n_nameOfCode in _codeMap\n",
    "fileName": "fn_managedRun_isDefined.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_managedRun_updateCode\n\nDescription:\n    Adjusts the code for a given ID that will run when called \n     from KISKA_fnc_managedRun_execute\n\nParameters:\n    0: _nameOfCode : <STRING> - The name of the code to update\n    1: _code : <CODE, STRING, ARRAY> - The code to run when ID is called \n        (see KISKA_fnc_callBack). Use `{}` to remove the handler all together.\n\nReturns:\n    NOTHING\n    \nExamples:\n    (begin example)\n        [\"KISKA_test\",{hint \"Hello World\"}] call KISKA_fnc_managedRun_updateCode;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_managedRun_updateCode\";\n\nparams [\n    [\"_nameOfCode\",\"\",[\"\"]],\n    [\"_code\",{},[{},[],\"\"]]\n];\n\nprivate _codeMap = localNamespace getVariable [\"KISKA_managedRun_codeMap\",-1];\nif (_codeMap isEqualTo -1) then {\n    _codeMap = createHashMap;\n    localNamespace setVariable [\"KISKA_managedRun_codeMap\",_codeMap];\n};\n\nif ((_nameOfCode in _codeMap) AND (_code isEqualTo {})) exitWith {\n    _codeMap deleteAt _nameOfCode;\n    nil\n};\n\n_codeMap set [_nameOfCode,_code];\n\n\nnil\n",
    "fileName": "fn_managedRun_updateCode.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic\n\nDescription:\n    Starts playing a random assortment of curated music tracks to all players on a server.\n    This is essentially a multiplayer jukebox. Should only be executed on the server.\n\n    All songs will be played in a random order and then loop back to play in another random order infinitely.\n\n    It will not interrupt music commanded to play by other means.\n\n    You can define quiet time space between tracks.\n\nParameters:\n    0: _musicTracks <STRING[]> - An array of classnames for music defined in `CfgMusic`\n    1: _interval <ARRAY or NUMBER> - A random or set time between tracks. Formats are `[min,mid,max]` & `[max]` for random numbers and\n        just a single number for a set time between (see example)\n    2: _canInterrupt <BOOL> - If this is a new random music set, will the initial song\n        be able to interrupt any playing music.\n    3: _tickId <NUMBER> - Used to superceed another random music loop, passs -1 to start a new one\n    4: _usedMusicTracks <STRING[]> - An array of already used music tracks, don't bother manually entering anyhting, this is for looping purposes\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // space tracks by 20 seconds exactly each\n        [-1,arrayOfTracks,20] call KISKA_fnc_randomMusic;\n    (end)\n\n    (begin example)\n        // space tracks by UP TO 20 seconds each\n        [-1,arrayOfTracks,[20]] call KISKA_fnc_randomMusic;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic\";\n\n#define SLEEP_BUFFER 3\n\nif !(isServer) exitWith {\n    [\"Was not executed on server, exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\n/* ----------------------------------------------------------------------------\n    Params\n---------------------------------------------------------------------------- */\nparams [\n    [\"_musicTracks\",call KISKA_fnc_randomMusic_getUnusedTracks,[[]]],\n    [\"_interval\",call KISKA_fnc_randomMusic_getTrackInterval,[[],123]],\n    [\"_canInterrupt\",true,[true]],\n    [\"_tickId\",-1,[123]],\n    [\"_usedMusicTracks\",call KISKA_fnc_randomMusic_getUsedTracks,[[]]]\n];\n\nprivate _latestTickID = GET_MUSIC_RANDOM_START_TIME;\nprivate _isNewRandomMusicSet = _tickId isEqualTo -1;\nif ((!_isNewRandomMusicSet) AND (_tickId < _latestTickID)) exitWith {\n    [[\"Tick ID: \",_tickId,\" was thrown out in favor of ID: \",_latestTickID],false] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_musicTracks isEqualTo [] AND (_usedMusicTracks isEqualTo [])) exitWith {\n    [\"No music tracks were passed! Can't start.\",true] call KISKA_fnc_log;\n    nil\n};\n\n// check if _interval is an array AND if it is the correct formats OR if it is just a single number\nif !([_interval] call KISKA_fnc_randomMusic_setTrackInterval) exitWith {\n    nil\n};\n\n\n/* ----------------------------------------------------------------------------\n    Select & Play Track\n---------------------------------------------------------------------------- */\nif (_musicTracks isEqualTo []) then {\n    _musicTracks = +_usedMusicTracks;\n    _usedMusicTracks = [];\n};\n\n\nprivate _selectedTrack = [_musicTracks] call KISKA_fnc_deleteRandomIndex;\n// get defined volume for random music system\nprivate _volume = call KISKA_fnc_randomMusic_getVolume;\n_canInterrupt = _canInterrupt AND _isNewRandomMusicSet;\n[\n    _selectedTrack,\n    0,\n    _canInterrupt,\n    _volume,\n    3,\n    true\n] remoteExec [\"KISKA_fnc_playMusic\",[0,-2] select isDedicated];\n\n\nif !(call KISKA_fnc_randomMusic_isSystemRunning) then {\n    [true] call KISKA_fnc_randomMusic_setSystemRunning;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Cleanup\n---------------------------------------------------------------------------- */\n[_musicTracks] call KISKA_fnc_randomMusic_setUnusedTracks;\n\n// store track as used\n_usedMusicTracks pushBackUnique _selectedTrack;\n[_usedMusicTracks] call KISKA_fnc_randomMusic_setUsedTracks;\n\n/* ----------------------------------------------------------------------------\n    Get Wait Time\n---------------------------------------------------------------------------- */\nprivate _durationOfTrack = [_selectedTrack] call KISKA_fnc_getMusicDuration;\n// decide how much time should be between tracks\nprivate \"_randomWaitTime\";\nif (_interval isEqualType []) then {\n    if (_interval isEqualTypeArray [1,2,3]) then {\n        _randomWaitTime = round (random _interval);\n\n    } else {\n        _randomWaitTime = round (random (_interval select 0));\n\n    };\n\n} else {\n    _randomWaitTime = _interval;\n\n};\n\n\n// track durations are not (always) exact enough, so there needs to be a bit of a buffer\n// else, if the time between tracks is something like 0 or 1, the sleep will be done,\n// and music will try to play, but because it does not interrupt,\n// and the previous track will not actually be done, no music will play until the next sleep is done\nif (_randomWaitTime < SLEEP_BUFFER) then {\n    _randomWaitTime = SLEEP_BUFFER;\n};\nprivate _waitTime = _durationOfTrack + _randomWaitTime;\n\n\n/* ----------------------------------------------------------------------------\n    Sleep till next track\n---------------------------------------------------------------------------- */\n/*\n    this is used with the intention of if another random music list is started (or multiple)\n    the latest one will take over this time slot forcing the others after their wait time to\n    not continue their own loops\n*/\n\nif (_isNewRandomMusicSet) then {\n    _tickId = diag_tickTime;\n    SET_MUSIC_VAR(MUSIC_RANDOM_START_TIME_VAR_STR,_tickId);\n};\n\n[\n    {\n        _this call KISKA_fnc_randomMusic;\n    },\n    [\n        _musicTracks,\n        _interval,\n        false,\n        _tickId,\n        _usedMusicTracks\n    ],\n    _waitTime\n] call CBA_fnc_waitAndExecute;\n\n\nnil\n",
    "fileName": "fn_randomMusic.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getCurrentTrack\n\nDescription:\n    Returns the most recent track selected by the random music system.\n    Will be an empty string \"\" if none is defined.\n\n    This is regardless of whether the song is actually playing.\n\nParameters:\n    NONE\n\nReturns:\n    <STRING> - The current randomly selected track\n\nExamples:\n    (begin example)\n        _mostRecentRandomTrack = call KISKA_fnc_randomMusic_getCurrentTrack;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getCurrentTrack\";\n\nGET_MUSIC_CURRENT_RANDOM_TRACK;\n",
    "fileName": "fn_randomMusic_getCurrentTrack.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getTrackInterval\n\nDescription:\n    Retrieves the current tracks in the random music system that could play.\n\n    Possible Values:\n        [NUMBER,NUMBER,NUMBER] - used with the \"random\" command's [min,mid,max]\n            to get a uniform random space between tracks.\n        [NNUMBER] - used with denotes that the space between tracks can be UP TO this number.\n        NUMBER - the exact time between tracks that will be the same every time.\n\nParameters:\n    NONE\n\nReturns:\n    <ARRAY or NUMBER> - see Description for details\n\nExamples:\n    (begin example)\n        private _interval = call KISKA_fnc_randomMusic_getTrackInterval;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getTrackInterval\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    -1\n};\n\nGET_MUSIC_RANDOM_TIME_BETWEEN\n",
    "fileName": "fn_randomMusic_getTrackInterval.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getUnusedTracks\n\nDescription:\n    Retrieves the current tracks in the random music system that could play.\n\nParameters:\n    NONE\n\nReturns:\n    <ARRAY> - An array of strings of the unused classnames of tracks\n\nExamples:\n    (begin example)\n        private _arrayOfTracks = call KISKA_fnc_randomMusic_getUnusedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getUnusedTracks\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    []\n};\n\nGET_MUSIC_RANDOM_UNUSED_TRACKS\n",
    "fileName": "fn_randomMusic_getUnusedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getUsedTracks\n\nDescription:\n    Retrieves the tracks in the random music system that have already been played\n\nParameters:\n    NONE\n\nReturns:\n    <ARRAY> - An array of strings of the used classnames of tracks\n\nExamples:\n    (begin example)\n        private _arrayOfTracks = call KISKA_fnc_randomMusic_getUsedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getUsedTracks\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    []\n};\n\nGET_MUSIC_RANDOM_USED_TRACKS\n",
    "fileName": "fn_randomMusic_getUsedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_getVolume\n\nDescription:\n    Retrieves the current volume that random music system plays tracks at\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - the volume\n\nExamples:\n    (begin example)\n        private _volume = call KISKA_fnc_randomMusic_getVolume;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_getVolume\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    -1\n};\n\n\nGET_MUSIC_RANDOM_VOLUME\n",
    "fileName": "fn_randomMusic_getVolume.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_isSystemRunning\n\nDescription:\n    Retrieves whether or not the random music system is currently running\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - True for running, false for not\n\nExamples:\n    (begin example)\n        private _isRunning = call KISKA_fnc_randomMusic_isSystemRunning;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_isSystemRunning\";\n\nif (!isServer) then {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    false\n};\n\n\nGET_MUSIC_RANDOM_SYS_RUNNING\n",
    "fileName": "fn_randomMusic_isSystemRunning.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setCurrentTrack\n\nDescription:\n    Sets the current random track from the random music system.\n\nParameters:\n    0: _trackClass <STRING> - a classname to check the duration of or its config path\n\nReturns:\n    <BOOL> - True when set\n\nExamples:\n    (begin example)\n        [\"Some_Music_Track\"] call KISKA_fnc_randomMusic_setCurrentTrack;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setCurrentTrack\";\n\nif (!isServer) exitWith {\n    [\"Must be executed on the server, exiting...\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_trackClass\",\"\",[\"\"]]\n];\n\nSET_MUSIC_VAR(MUSIC_CURRENT_RANDOM_TRACK_VAR_STR,_trackClass);\n[[\"Set Current Random Track \",_trackClass]] call KISKA_fnc_log;\n\n\ntrue\n",
    "fileName": "fn_randomMusic_setCurrentTrack.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setSystemRunning\n\nDescription:\n    Sets the boolean for determining if the random music system is running.\n\nParameters:\n    0: _setting <BOOL> - True for running, false for not\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // set to running\n        [true] call KISKA_fnc_randomMusic_setSystemRunning;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setSystemRunning\";\n\nif (!isServer) exitWith {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_setting\",true,[true]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_SYS_RUNNING_VAR_STR,true);\n\n\nnil\n",
    "fileName": "fn_randomMusic_setSystemRunning.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setTrackInterval\n\nDescription:\n    Sets the dwell time variable that handles the time between random music tracks\n     being played.\n\nParameters:\n    0: _interval <ARRAY or NUMBER> - A random or set time between tracks.\n        Formats are [min,mid,max] & [max] for random numbers and just a single\n         number for a set time between.\n\nReturns:\n    <BOOL> - true if updated, false if not\n\nExamples:\n    (begin example)\n        [20] remoteExecCall [\"KISKA_fnc_randomMusic_setTrackInterval\",2];\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setTrackInterval\";\n\nif (!isServer) exitWith {\n    [\"Needs to be executed on the server, exiting...\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_interval\",3,[123,[]]]\n];\n\n\nif (\n    (_interval isEqualType []) AND\n    {\n        !((count _interval) isEqualTo 1) AND\n        {\n            !((count _interval) isEqualTo 3) OR !(_interval isEqualTypeParams [1,2,3])\n        }\n    }\n) exitWith {\n    [[_interval,\" is not the correct format for _interval\"],true] call KISKA_fnc_log;\n    false\n\n};\n\n\n// update to new timebetween if needed\nif ((GET_MUSIC_RANDOM_TIME_BETWEEN) isNotEqualTo _interval) then {\n    SET_MUSIC_VAR(MUSIC_RANDOM_TIME_BETWEEN_VAR_STR,_interval);\n};\n\n\ntrue\n",
    "fileName": "fn_randomMusic_setTrackInterval.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setUnusedTracks\n\nDescription:\n    Sets the current tracks in the random music system that could play.\n\nParameters:\n    0: _musicTracks <ARRAY> - An array of strings (music tracks) to use\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [[\"someTrack\",\"anotherTrack\"]] call KISKA_fnc_randomMusic_setUnusedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setUnusedTracks\";\n\nif (!isServer) exitWith {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_musicTracks\",call KISKA_fnc_randomMusic_getUnusedTracks,[[]]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_UNUSED_TRACKS_VAR_STR,_musicTracks);\n\n\nnil\n",
    "fileName": "fn_randomMusic_setUnusedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setUsedTracks\n\nDescription:\n    Sets the tracks in the random music system that have already been played\n\nParameters:\n    0: _usedMusicTracks <ARRAY> - An array of already used music tracks\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [[\"SomeTrack\",\"AnotherTrack\"]] call KISKA_fnc_randomMusic_setUsedTracks;\n       (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setUsedTracks\";\n\nif (!isServer) exitWith {\n    [\"The random music system only runs on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_usedMusicTracks\",call KISKA_fnc_randomMusic_getUsedTracks,[[]]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_USED_TRACKS_VAR_STR,_usedMusicTracks);\n\n\nnil\n",
    "fileName": "fn_randomMusic_setUsedTracks.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_setVolume\n\nDescription:\n    Changes the volume at which random music specifically will play at (on all clients).\n\n    Only executes on server.\n\nParameters:\n    0: _volume <NUMBER> - volume to set\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [1] remoteExecCall [\"KISKA_fnc_randomMusic_setVolume\",2];\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_setVolume\";\n\nif (!isServer) exitWith {\n    [\"Needs to be executed on the server. There is no affect on clients.\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_volume\",0.5,[123]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_VOLUME_VAR_STR,_volume)\n",
    "fileName": "fn_randomMusic_setVolume.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_stopClient\n\nDescription:\n    The clientside part of stopping random music system.\n    Ideally, should not be called on its own but used from KISKA_fnc_randomMusic_stopServer\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - True if done, false if nothing done\n\nExamples:\n    (begin example)\n        call KISKA_fnc_randomMusic_stopClient;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_stopClient\";\n\nif (!hasInterface) exitWith {false};\n\nif ((call KISKA_fnc_getPlayingMusic) == (call KISKA_fnc_randomMusic_getCurrentTrack)) then {\n    /*\n        there should in the future be a more robust way of determining if a track did indeed come\n         from KISKA_fnc_randomMusic. As it stands, if a manual song is playing that is ALSO in the list\n         and was played from random music, then it will still stop it\n    */\n    [] spawn KISKA_fnc_stopMusic;\n    \n    true\n} else {\n    false\n};",
    "fileName": "fn_randomMusic_stopClient.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomMusic_stopServer\n\nDescription:\n    Stops the random music system either abrubtly or allows the last song to play.\n\nParameters:\n    0: _playLastSong <BOOL> - Should the last song play or not\n\nReturns:\n    <BOOL> - True if done, false if nothing done\n\nExamples:\n    (begin example)\n        call KISKA_fnc_randomMusic_stopServer;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomMusic_stopServer\";\n\nif (!isServer) exitWith {\n    [\"Needs to only be run on server, exiting...\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_playLastSong\",false,[true]]\n];\n\nSET_MUSIC_VAR(MUSIC_RANDOM_SYS_RUNNING_VAR_STR,false);\nSET_MUSIC_VAR(MUSIC_RANDOM_START_TIME_VAR_STR,nil);\nif (!_playLastSong) then {\n    remoteExecCall [\"KISKA_fnc_randomMusic_stopClient\",[0,-2] select isDedicated];\n};\n\ntrue\n",
    "fileName": "fn_randomMusic_stopServer.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getLatestPlayedMusicID\n\nDescription:\n    Returns the latest track ID of music that played (each song played increments)\n     the ID by one.\n\n    This DOES NOT indicated whether or not this ID is still playing.\n     See KISKA_fnc_getPlayingMusic to check what track is present (if any).\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The highest incremented track \"ID\". -1 indicates no music has ever been played\n\nExamples:\n    (begin example)\n        private _id = call KISKA_fnc_getLatestPlayedMusicID;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getLatestPlayedMusicID\";\n\nGET_MUSIC_CURRENT_TRACK_ID;\n",
    "fileName": "fn_getLatestPlayedMusicID.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMusicDuration\n\nDescription:\n    Returns the duration of a track of music. Will return 0 if undefined duration or class.\n\nParameters:\n    0: _track <STRING or CONFIG> - a classname to check the duration of or its config path\n\nReturns:\n    <NUMBER> - The duration of the requested track\n\nExamples:\n    (begin example)\n        _duration = [\"LeadTrack01_F_Curator\"] call KISKA_fnc_getMusicDuration;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMusicDuration\";\n\nparams [\n    [\"_track\",\"\",[\"\",configNull]]\n];\n\nprivate _duration = 0;\n\nif (_track isEqualTo \"\") exitWith {\n    [\"_track is empty string\",true] call KISKA_fnc_log;\n    _duration\n};\n\nprivate \"_config\";\nif (_track isEqualType configNull) then {\n    _config = _track;\n} else {\n    _config = [[\"cfgMusic\",_track]] call KISKA_fnc_findConfigAny;\n};\n\nif (isNull _config) exitWith {\n    [[\"_track \",_track,\" is not defined in any CfgMusic class\"],true] call KISKA_fnc_log;\n    _duration\n};\n\n_duration = getNumber(_config >> \"duration\");\n\n\n_duration\n",
    "fileName": "fn_getMusicDuration.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMusicFromClass\n\nDescription:\n    Returns an array of track names for the given class of music.\n\nParameters:\n    0: _musicClass <STRING> - a class of music to search for (e.g. \"stealth\")\n\nReturns:\n    <ARRAY> - list of tracks names from the class\n\nExamples:\n    (begin example)\n        [\"stealth\"] call KISKA_fnc_getMusicFromClass;\n    (end)\n\nAuthor(s):\n    Ansible2 (modified by)\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMusicFromClass\";\n\nparams [\n    [\"_musicClass\",\"\",[\"\"]]\n];\n\nif (_musicClass isEqualTo \"\") exitWith {\n    [\"_musicClass is empty. Exiting...\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _configCondition = [\"getText (_x >> 'musicClass') == \",str _musicClass] joinString \"\";\nprivate _configs = _configCondition configClasses (configFile >> \"CfgMusic\");\nprivate _trackNames = [];\n\n_configs apply {\n    private _class = configName _x;\n    _trackNames pushBackUnique _class;\n};\n\n\n_trackNames\n",
    "fileName": "fn_getMusicFromClass.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getPlayingMusic\n\nDescription:\n    Returns the current playing tracks class name.\n\nParameters:\n    NONE\n\nReturns:\n    <STRING> - The class name of music. Will be \"\" if nothing is playing.\n\nExamples:\n    (begin example)\n        private _track = call KISKA_fnc_getPlayingMusic;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getPlayingMusic\";\n\nGET_MUSIC_CURRENT_TRACK;\n",
    "fileName": "fn_getPlayingMusic.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isMusicPlaying\n\nDescription:\n    Returns whether or not music is currently playing\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - false if nothing is playing, true if something is\n\nExamples:\n    (begin example)\n        _isSomethingPlaying = call KISKA_fnc_isMusicPlaying;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isMusicPlaying\";\n\nGET_MUSIC_IS_PLAYING;\n",
    "fileName": "fn_isMusicPlaying.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_musicEventHandlers\n\nDescription:\n    A preInit function to create the required music event handlers for\n     KISKA music functions\n\nParameters:\n    NONE\n\nReturns:\n    NONE\n\nExamples:\n    (begin example)\n        PREINIT FUNCTION\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_musicEventHandlers\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\n[\"Added KISKA music event handlers\",false] call KISKA_fnc_log;\n\naddMusicEventHandler [\"MusicStart\", {\n    _this call KISKA_fnc_musicStartEvent;\n}];\n\n\naddMusicEventHandler [\"MusicStop\", {\n    [false] call KISKA_fnc_musicStopEvent;\n}];\n\n\nnil\n",
    "fileName": "fn_musicEventHandlers.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_musicStartEvent\n\nDescription:\n    The function that should be activated when music starts playing.\n\nParameters:\n    0: _trackClassname <STRING> - The classname of the track that started playing\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"trackThatStarted\"] call KISKA_fnc_musicStartEvent;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_musicStartEvent\";\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_trackClassname\",\"\",[\"\"]]\n];\n\n\nSET_MUSIC_VAR(MUSIC_IS_PLAYING_VAR_STR,true);\nSET_MUSIC_VAR(MUSIC_CURRENT_TRACK_VAR_STR,_trackClassName);\nSET_MUSIC_VAR(MUSIC_CURRENT_TRACK_ID_VAR_STR,(GET_MUSIC_CURRENT_TRACK_ID) + 1);\n// clear out any track. Any new MUSIC_CURRENT_RANDOM_TRACK_VAR_STR will be set to the new track in KISKA_fnc_playMusic after this event has fired\n// this is to avoid a track random music track not being cleared\n//[\"\"] call KISKA_fnc_randomMusic_setCurrentTrack;\n\n\n[[\"Started playing track: \", _trackClassname],false] call KISKA_fnc_log;\n\n\nnil\n",
    "fileName": "fn_musicStartEvent.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_musicStopEvent\n\nDescription:\n    The function that should be activated when music stops playing.\n\n    It can also be manually triggered and a param is added to stop the music audio\n     by playing an empty track (\"\").\n\nParameters:\n    0: _stopAudio <BOOL> - Play and empty track (\"\") to actually stop the audio\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_musicStopEvent;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_musicStopEvent\";\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_stopAudio\",false,[true]]\n];\n\nif (_stopAudio) then {\n    playMusic \"\";\n};\n\n\nSET_MUSIC_VAR(MUSIC_IS_PLAYING_VAR_STR,false);\nSET_MUSIC_VAR(MUSIC_CURRENT_TRACK_VAR_STR,\"\");\n[\"\"] call KISKA_fnc_randomMusic_setCurrentTrack;\n\n[\"Music stopped\",false] call KISKA_fnc_log;\n\n\nnil\n",
    "fileName": "fn_musicStopEvent.sqf"
  },
  {
    "text": "#include \"Headers\\Music Common Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playMusic\n\nDescription:\n    Plays music with smooth fade between tracks. Must be run in scheduled environment (spawn)\n\nParameters:\n    0: _track <STRING> - Music to play\n    1: _startTime <NUMBER OR ARRAY> - Starting time of music. -1 for random start time.\n        If array, duration of track can also be specified (SEE EXAMPLE 2).\n        THIS INCLUDES FADE TIME\n    2: _canInterrupt <BOOL> - Interrupt playing music\n    3: _volume <NUMBER> - Volume to play at\n    4: _fadeTime <NUMBER> - Time to fade tracks down & up\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"track\", 0, true, 1, 3] spawn KISKA_fnc_playMusic;\n    (end)\n\n    (begin example)\n        [\n            \"track\",\n            [10,60]    // start ten seconds into the song, and play for 60 seconds\n        ] spawn KISKA_fnc_playMusic;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playMusic\";\n\nif !(hasInterface) exitWith {};\n\nif !(canSuspend) exitWith {\n    [\"Wasn't run in scheduled environment, executing in scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_playMusic;\n};\n\n\nparams [\n    [\"_track\",\"\",[\"\"]],\n    [\"_startTime\",0,[123,[]]],\n    [\"_canInterrupt\",true,[true]],\n    [\"_volume\",1,[123]],\n    [\"_fadeTime\",3,[123]],\n    [\"_isRandomTrack\",false,[true]]\n];\n\nprivate _trackConfig = [[\"cfgMusic\",_track]] call KISKA_fnc_findConfigAny;\nif (isNull _trackConfig) exitWith {\n    [[_track,\" is not a defined track in any CfgMusic\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _musicPlaying = call KISKA_fnc_isMusicPlaying;\nprivate _exit = false;\nprivate _fadeDown = false;\nif (_musicPlaying) then {\n    if (_isRandomTrack) then {\n        private _playingMusicIsRandom = (call KISKA_fnc_randomMusic_getCurrentTrack) isNotEqualTo \"\";\n        if (_playingMusicIsRandom OR _canInterrupt) then {\n            _fadeDown = true;\n\n        } else {\n            _exit = true;\n\n        };\n\n    } else {\n        if (_canInterrupt) then {\n            _fadeDown = true;\n\n        } else {\n            _exit = true;\n\n        };\n\n    };\n\n};\n\n\nif (_exit) exitWith {};\n\n// handle end specified track duration\nprivate _durationToPlayTrack = -1;\nif (_startTIme isEqualType []) then {\n    _durationToPlayTrack = (_startTIme select 1) - (_fadeTime * 2);\n    _startTIme = _startTIme select 0;\n};\n\n// random start time\nif (_startTime < 0) then {\n    private _totalTrackDuration = [_track] call KISKA_fnc_getMusicDuration;\n    _startTIme = round (random [0, _totalTrackDuration / 2, _totalTrackDuration]);\n\n};\n\n\nif (_fadeDown) then {\n    // give the previous track time to fade out if required\n    _fadeTime fadeMusic 0;\n    sleep (_fadeTime + 0.1);\n\n} else {\n    // only need this setting of volume to 0 if there was no fade above that already set it to 0\n    0 fadeMusic 0;\n\n};\n\nprivate _previousTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n// clear out any track. Any new MUSIC_CURRENT_RANDOM_TRACK_VAR_STR will be set to the new track in KISKA_fnc_playMusic after this event has fired\n// this is to avoid a track random music track not being cleared\n[] call KISKA_fnc_musicStopEvent;\nplayMusic [_track,_startTime];\n_fadeTime fadeMusic _volume;\n\n\n\nif (_durationToPlayTrack > 0) then {\n    // it takes more then one frame after playing music for the eventhandler to be called/complete\n    // e.g. the music id will not be updated to the latest\n    [\n        {\n            call KISKA_fnc_getLatestPlayedMusicID > (_this select 3)\n        },\n        {\n            private _currentTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n            _this set [3,_currentTrackID];\n\n            // the primary concern of needing to wait for the fade time here is\n            /// to account for the fading out of the music.\n            // the _durationToPlayTrack includes the time to fade out\n            private _fadeTime = _this select 2;\n            [\n                {\n                    params [\n                        \"_durationToPlayTrack\",\n                        \"_track\",\n                        \"_fadeTime\",\n                        \"_trackID\"\n                    ];\n\n                    private _currentTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n                    private _currentTrackName = call KISKA_fnc_getPlayingMusic;\n                    if (_trackID isEqualTo _currentTrackID AND (_currentTrackName == _track)) then {\n                        [\n                            {\n                                params [\n                                    \"_track\",\n                                    \"_fadeTime\",\n                                    \"_trackID\"\n                                ];\n\n                                private _currentTrackID = call KISKA_fnc_getLatestPlayedMusicID;\n                                private _currentTrackName = call KISKA_fnc_getPlayingMusic;\n                                if (_trackID isEqualTo _currentTrackID AND (_currentTrackName == _track)) then {\n                                    [_fadeTime] spawn {\n                                        _this spawn KISKA_fnc_stopMusic;\n                                    };\n                                };\n                            },\n                            [\n                                _track,\n                                _fadeTime,\n                                _currentTrackID\n                            ],\n                            _durationToPlayTrack\n                        ] call CBA_fnc_waitAndExecute;\n                    };\n                },\n                _this,\n                _fadeTime\n            ] call CBA_fnc_waitAndExecute;\n\n        },\n        [\n            _durationToPlayTrack,\n            _track,\n            _fadeTime,\n            _previousTrackID\n        ]\n    ] call CBA_fnc_waitUntilAndExecute;\n};\n\n\n\nif (_isRandomTrack) then {\n    [_track] call KISKA_fnc_randomMusic_setCurrentTrack;\n\n};\n\n\nif (GET_MUSIC_SHOW_SONG_NAMES) then {\n    private _trackName = getText(_trackConfig >> \"name\");\n    if (_trackName isNotEqualTo \"\") then {\n        [\n            parseText (\"<t font='PuristaBold' size='1.6'>\" + _trackName + \"</t>\"),\n            true,\n            nil,\n            7,\n            0.7,\n            0\n        ] spawn BIS_fnc_textTiles;\n    };\n};\n\n\nnil\n",
    "fileName": "fn_playMusic.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopMusic\n\nDescription:\n    Stops the currently playing music with a fade if desired.\n\nParameters:\n    0: _fadeTime <NUMBER> - How long to fade out\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] spawn KISKA_fnc_stopMusic;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopMusic\";\n\nif (!hasInterface) exitWith {};\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled environment, executing in scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_stopMusic;\n};\n\nparams [\n    [\"_fadeTime\",3,[123]]\n];\n\nif !(call KISKA_fnc_isMusicPlaying) exitWith {};\n\nif (_fadeTime > 0) then {\n    _fadeTime fadeMusic 0;\n    sleep _fadeTime;\n};\n\n// reset event handler values as playMusic \"\" does not activate music events\n[true] call KISKA_fnc_musicStopEvent;\n",
    "fileName": "fn_stopMusic.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addRallyPointDiaryEntry\n\nDescription:\n    Adds a rally point diary entry to the local player. Pressing it enables the\n     player to drop a rally point if their group is registered as allowed to and\n     they are the leader of the group.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT Function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addRallyPointDiaryEntry\";\n\n\nif (!hasInterface) exitWith {\n    [\"Was run on machine without interface, needs an interface\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!isMultiplayer) exitWith {\n    [\"KISKA rally point system does not run in singlePlayer\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_addRallyPointDiaryEntry;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\n\n[\n    [\n        \"Rally Point\",\n        \"<execute expression='call KISKA_fnc_updateRespawnMarkerQuery'>Set Rally Point At Current Position</execute>\"\n    ]\n] call KISKA_fnc_addKiskaDiaryEntry;\n\n\nnil\n",
    "fileName": "fn_addRallyPointDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_allowGroupRally\n\nDescription:\n    Adds group's ability to place rally points by setting \"KISKA_canRally\" in\n     the group space to true.\n\nParameters:\n    0: _groupToAdd <GROUP or OBJECT> - The group or the unit whose group to add\n\nReturns:\n    <BOOL> - True if allowed, false if not allowed or error\n\nExamples:\n    (begin example)\n        // allows player's group to drop a rally point (if they're the server)\n        [player] call KISKA_fnc_allowGroupRally;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_allowGroupRally\";\n\nif !(isServer) exitWith {\n    [\"Needs to be run on the server\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_groupToAdd\",grpNull,[objNull,grpNull]]\n];\n\n_groupToAdd = [_groupToAdd] call CBA_fnc_getGroup;\n\nif (isNull _groupToAdd) exitWith {\n    [\"_groupToAdd was null\",true] call KISKA_fnc_log;\n\n    false\n};\n\n_groupToAdd setVariable [\"KISKA_canRally\",true];\n\n\ntrue\n",
    "fileName": "fn_allowGroupRally.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_disallowGroupRally\n\nDescription:\n    Removes a groups ability to rally an deletes its marker if requested.\n\nParameters:\n    0: _groupToRemove <GROUP or OBJECT> - The group or the unit whose group to remove\n    1: _deleteMarker <BOOL> - Should the group's latest rally marker (if present) be deleted\n\nReturns:\n    <BOOL> - True if no longer allowed or never was, false if error\n\nExamples:\n    (begin example)\n        // disallows player's group to drop a rally point (if they're the server)\n        [player] call KISKA_fnc_disallowGroupRally;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_disallowGroupRally\";\n\nif !(isServer) exitWith {\n    [\"Needs to be run on the server\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_groupToRemove\",grpNull,[objNull,grpNull]],\n    [\"_deleteMarker\",true,[true]]\n];\n\n_groupToRemove = [_groupToRemove] call CBA_fnc_getGroup;\n\nif (isNull _groupToRemove) exitWith {\n    [\"_groupToRemove was null\",true] call KISKA_fnc_log;\n    false\n};\n\n_groupToRemove setVariable [\"KISKA_canRally\",false];\n\nif (_deleteMarker) then {\n    private _markerID = _groupToRemove getVariable [\"KISKA_groupRespawnMarkerID\",[]];\n    // if marker ID exitsts\n    if !(_markerID isEqualTo []) then {\n        private _marker = _groupToRemove getVariable \"KISKA_groupRespawnMarker\";\n        [[\"Found marker id \",_markerID,\" for group \",_groupToRemove,\" ---Will remove marker \",_marker],false] call KISKA_fnc_log;\n\n        _markerID call BIS_fnc_removeRespawnPosition;\n        deleteMarker _marker;\n\n        _groupToRemove setVariable [\"KISKA_groupRespawnMarker\",nil];\n        _groupToRemove setVariable [\"KISKA_groupRespawnMarkerID\",nil];\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_disallowGroupRally.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isGroupRallyAllowed\n\nDescription:\n    Checks if a group is has KISKA_canRally saved to its namespace on the server\n     which allows its members to place down rally points.\n\nParameters:\n    0: _groupToCheck <GROUP or OBJECT> - The group or the unit whose group you want to check\n\nReturns:\n    <BOOL> - True if allowed, false if not or error\n\nExamples:\n    (begin example)\n        // checks if player's group can use the rally system (if they're the server)\n        [player] call KISKA_fnc_isGroupRallyAllowed;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isGroupRallyAllowed\";\n\nif !(isServer) exitWith {\n    [\"Needs to be run on server for proper returns\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_groupToCheck\",grpNull,[objNull,grpNull]]\n];\n\n_groupToCheck = [_groupToCheck] call CBA_fnc_getGroup;\n\nif (isNull _groupToCheck) exitWith {\n    [\"_groupToCheck was null\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _isRallyAllowed = _groupToCheck getVariable [\"KISKA_canRally\",false];\n\n\n_isRallyAllowed\n",
    "fileName": "fn_isGroupRallyAllowed.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateRallyPointNotification\n\nDescription:\n    Informs the player that their rally point was updated\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        remoteExec [\"KISKA_fnc_updateRallyPointNotification\",somePlayer];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateRallyPointNotification\";\n\n#define HEADER_COLOR [0,0.3,0.6,1]\n\nif (!hasInterface) exitWith {};\n\n[[\"MESSAGE\",1.1,HEADER_COLOR],\"Rally Point Was Updated\",false] call CBA_fnc_notify;\n\n\nnil\n",
    "fileName": "fn_updateRallyPointNotification.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateRespawnMarker\n\nDescription:\n    Deletes the old respawn marker and makes a new one.\n\nParameters:\n    0: _caller <OBJECT> - The person calling the respawn update action\n    1: _marker <MARKER> - The old marker to delete\n    2: _markerText <STRING> - The text of the new marker\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [player,myMarker,myMarkerText] call KISKA_fnc_updateRespawnMarker;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateRespawnMarker\";\n\nif !(isMultiplayer) exitWith {};\n\nif (!isServer) exitWith {\n    [\"This function is supposed to only run on the server\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_caller\",objNull,[objNull]],\n    [\"_marker\",\"\",[\"\"]],\n    [\"_markerText\",\"\",[\"\"]]\n];\n\nprivate _callerGroup = group _caller;\nif !([_callerGroup] call KISKA_fnc_isGroupRallyAllowed) exitWith {\n    [[\"Got marker request for \",_callerGroup,\" --- Did not create marker\"],true] call KISKA_fnc_log;\n    [\"Your group is not registered to allow for rally points\"] remoteExecCall [\"KISKA_fnc_notification\",_caller];\n};\n\nprivate _markerID = _callerGroup getVariable [\"KISKA_groupRespawnMarkerID\",[]];\n// if the group already has a rally point down, get rid of it before making a new one\nif !(_markerID isEqualTo []) then {\n    // delete map marker\n    private _currentMarker = (_callerGroup getVariable \"KISKA_groupRespawnMarker\");\n    deleteMarker _currentMarker;\n\n    // remove respawn position\n    private _wasRemoved = (_callerGroup getVariable \"KISKA_groupRespawnMarkerID\") call BIS_fnc_removeRespawnPosition;\n};\n\nprivate _position = ASLToAGL (getPosASL _caller);\nprivate _id = [missionNamespace,_position, _markerText] call BIS_fnc_addRespawnPosition;\n\n// set id to be used in this function in the future\n_callerGroup setVariable [\"KISKA_groupRespawnMarkerID\",_id];\n\n// check if marker is created already\nif (getMarkerType _marker isEqualTo \"\") then {\n    ([\"|\",_marker,\"|\",_position,\"|respawn_inf|ICON|[1,1]|0|Solid|\",\"color\",(side _caller),\"|1|\",_markerText] joinString \"\") call BIS_fnc_stringToMarker;\n\n    _callerGroup setVariable [\"KISKA_groupRespawnMarker\",_marker];\n\n} else {\n    _marker setMarkerPos _caller;\n};\n\n// send update message back to caller\nremoteExec [\"KISKA_fnc_updateRallyPointNotification\",_caller];\n",
    "fileName": "fn_updateRespawnMarker.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateRespawnMarkerQuery\n\nDescription:\n    Acts as a go between for use inside of a string in a diary entry expression.\n    (You can't use remoteExecCall with a string inside of double strings)\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_updateRespawnMarkerQuery;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateRespawnMarkerQuery\";\n\n#define KISKA_DIARY \"KISKA Systems\"\n\nif !(hasInterface) exitWith {};\n\nprivate _group = group player;\nif (isNull _group) exitWith {\n    [\"_group was found to be null\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _groupLeader = leader _group;\nif !(_groupLeader isEqualTo player) exitWith {\n    private _string = [\"You are not the leader of the group. \",name _groupLeader,\" is your group leader.\"] joinString \"\";\n    [_string] call KISKA_fnc_notification;\n};\n\nprivate _groupName = groupId _group;\n[\n    _groupLeader,\n    ([_groupName,\"spawnMarker\"] joinString \"_\"),\n    ([_groupName,\"Respawn Beacon\"] joinString \" \")\n] remoteExecCall [\"KISKA_fnc_updateRespawnMarker\",2];\n\n\nnil\n",
    "fileName": "fn_updateRespawnMarkerQuery.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_keepInGroup\n\nDescription:\n    Attempts to keep a player in the same group and team after they respawn.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT function\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_keepInGroup\";\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_keepInGroup;\n};\n\nwaitUntil {\n    if !(isNull player) exitWith {true};\n    sleep 0.1;\n    false\n};\n\nlocalNamespace setVariable [\"KISKA_playerGroup\",grpNull];\nlocalNamespace setVariable [\"KISKA_team\",\"\"];\n\nplayer addEventHandler [\"KILLED\", {\n    params [\"_corpse\"];\n    // set values player had just before death\n    localNamespace setVariable [\"KISKA_playerGroup\",group _corpse];\n    localNamespace setVariable [\"KISKA_team\",assignedTeam _corpse];\n}];\n\nplayer addEventHandler [\"RESPAWN\", {\n    params [\"_unit\"];\n\n    private _previousGroup = localNamespace getVariable [\"KISKA_playerGroup\",grpNull];\n    if (\n        !isNull _previousGroup AND\n        {(group _unit) isNotEqualTo _previousGroup}\n    ) then {\n        [_unit] joinSilent _previousGroup;\n\n        private _previousTeam = localNamespace getVariable [\"KISKA_team\",\"\"];\n        if (\n            _previousTeam isNotEqualTo \"\" AND\n            {_previousTeam isNotEqualTo \"MAIN\"}\n        ) then {\n            [_unit,_previousTeam] spawn {\n                (_this select 0) assignTeam (_this select 1);\n            };\n        };\n    };\n}];\n\n\nnil\n",
    "fileName": "fn_keepInGroup.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_ambientNewsRadio\n\nDescription:\n    Plays a selection of news sounds from the vanilla game at a given position.\n\nParameters:\n    0: _origin <OBJECT or ARRAY> - The position the sound will play at. If array\n        position is format ASL\n    1: _duration <NUMBER> - How long should this broadcast last. Negative value\n        will go on forever.\n    2: _distance <NUMBER> - How far away the sound can be heard\n    3: _volume <NUMBER> - The volume of the sounds (0-5).\n    3: _isInside <BOOL> - Are these sounds being played indoors\n\n\nReturns:\n    <NUMBER> - The KISKA_fnc_playRandom3dSoundLoop Handler ID for stopping the sound \n        with KISKA_fnc_stopRandom3dSoundLoop\n\nExamples:\n    (begin example)\n        [myRadio] call KISKA_fnc_ambientNewsRadio;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_ambientNewsRadio\";\n\nparams [\n    [\"_origin\",objNull,[[],objNull]],\n    [\"_duration\",60,[123]],\n    [\"_distance\",500,[[],123],[3]],\n    [\"_volume\",1,[123]],\n    [\"_isInside\",false,[true]]\n];\n\nprivate _sounds = [\n    \"News_arrest\",\n    \"News_BackOnline\",\n    \"News_checkpoints\",\n    \"News_CSAT_convoy_attacked\",\n    \"News_depot_success\",\n    \"News_execution\",\n    \"News_hostels\",\n    \"News_house_destroyed\",\n    \"News_idap\",\n    \"News_Infection01\",\n    \"News_Jingle\",\n    \"News_malaria_galili_secured\",\n    \"News_malaria_luganville_secured\",\n    \"News_malaria_savaka_secured\",\n    \"News_outbreak_Boise\",\n    \"News_power_plant\",\n    \"News_radar_destroyed\",\n    \"News_rebels_attack_Lugganville\",\n    \"News_rescued\",\n    \"News_weapons_prohibited\",\n    [\"radio_dialogues_042_am_radio_broadcast_news_first_in_BROADCASTER_0\",3],\n    [\"radio_dialogues_043_am_radio_broadcast_news_malaria_luganville_BROADCASTER_1\",7],\n    [\"radio_dialogues_044_am_radio_broadcast_news_malaria_luganville_secured_BROADCASTER_0\",7.5],\n    [\"radio_dialogues_045_am_radio_broadcast_news_malaria_savaka_BROADCASTER_2\",6],\n    [\"radio_dialogues_046_am_radio_broadcast_news_malaria_savaka_secured_BROADCASTER_0\",6],\n    [\"radio_dialogues_047_am_radio_broadcast_news_malaria_galili_BROADCASTER_2\",6],\n    [\"radio_dialogues_051_am_radio_broadcast_news_arrest_BROADCASTER_0\",6],\n    [\"radio_dialogues_052_am_radio_broadcast_news_execution_BROADCASTER_2\",10],\n    [\"radio_dialogues_027_am_radio_broadcast_forecast_rain_c_BROADCASTER_0\",6],\n    [\"radio_dialogues_024_am_radio_broadcast_forecast_cloud_staying_BROADCASTER_0\",6]\n];\n\n\n\nprivate _3dSoundLoopId = [\n    _origin,\n    _sounds,\n    5,\n    [\n        _distance,\n        _volume,\n        _isInside\n    ]\n] call KISKA_fnc_playRandom3dSoundLoop;\n\nif (_duration > 0) then {\n    [\n        {\n            params [\"_3dSoundLoopId\"];\n            hint \"timed stop\";\n            [_3dSoundLoopId] call KISKA_fnc_stopRandom3dSoundLoop;\n        },\n        [_3dSoundLoopId],\n        _duration\n    ] call CBA_fnc_waitAndExecute;\n};\n\n\n_3dSoundLoopId",
    "fileName": "fn_ambientNewsRadio.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_battleSound\n\nDescription:\n    Create ambient battlefield sounds for a specified duration\n\nParameters:\n    0: _source <OBJECT or ARRAY> - Where the sound is coming from. Can be an object or positions array (ASL)\n    1: _distance <NUMBER or ARRAY> - Distance at which the sounds can be heard,\n        if an array, will be used with the \"random\" command (random _distance)\n        for getting a random value between the numbers.\n    2: _duration <NUMBER> - How long the sounds should play for in seconds\n    3: _intensity <NUMBER> - Value between 1-5 that determines how frequent these sounds are played (5 being the fastest)\n\nReturns:\n    <NUMBER> - The Handler ID for stopping the sound with KISKA_fnc_stopBattleSound\n\nExamples:\n    (begin example)\n        [player,20,10] call KISKA_fnc_battleSound;\n    (end)\n    (begin example)\n        // distance will be between 10-30m, leaning towards 20m\n        [player,[10,20,30],10] call KISKA_fnc_battleSound;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_battleSound\";\n\n#define MAX_INTENSITY 5\n#define MIN_INTENSITY 1\n#define EXPLOSION_WEIGHT 0.25\n#define FIREFIGHT_WEIGHT 1\n\nparams [\n    [\"_source\",objNull,[objNull,[]],[3]],\n    [\"_distance\",500,[[],123],[3]],\n    [\"_duration\",60,[123]],\n    [\"_intensity\",1,[123]],\n    [\"_battleSoundId\",-1,[123]]\n];\n\nprivate _hasBattleSoundId = _battleSoundId > -1;\nprivate _idIsPlaying = localNamespace getVariable [\"KISKA_battleSoundIsPlaying_\" + (str _battleSoundId), false];\nif (\n    _hasBattleSoundId AND\n    (!_idIsPlaying)\n) exitWith {\n    -1\n};\n\nprivate _sourceIsObject = _source isEqualType objNull;\nif (_sourceIsObject AND {isNull _source}) exitWith {\n    [\"_source isNull\",true] call KISKA_fnc_log;\n    nil\n};\nif ((_distance isEqualType 123) AND {_distance <= 0}) exitWith {\n    [[\"_distance is: \",_distance,\". It must be higher then 0\"],true] call KISKA_fnc_log;\n    nil\n};\nprivate _sourceIsArray = _distance isEqualType [];\nif (_sourceIsArray AND {!(_distance isEqualTypeParams [0,0,0])}) exitWith {\n    [\"_distance random array is not configured properly\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _actualSource = _source;\nif (_sourceIsObject) then {\n    _actualSource = getPosASL _source;\n};\n\nif (_intensity > MAX_INTENSITY) then {\n    _intensity = MAX_INTENSITY;\n} else {\n    if (_intensity < MIN_INTENSITY) then {\n        _intensity = MIN_INTENSITY;\n    };\n};\n\nprivate _intensities = localNamespace getVariable [\"KISKA_battleSoundIntensities\",[]];\nif (_intensities isEqualTo []) then {\n    _intensities = [\n        [2.5,3,3.5],\n        [2,2.5,3],\n        [1.5,2,2.5],\n        [1,1.5,2],\n        [0.5,1,1.5]\n    ];\n    localNamespace setVariable [\"KISKA_battleSoundIntensities\",_intensities];\n};\nprivate _intensityArray = _intensities select (_intensity - 1);\n\n\nprivate _soundsArray = localNamespace getVariable [\"KISKA_battleSounds\",[]];\nif (_soundsArray isEqualTo []) then {\n    _soundsArray = [\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions1.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions2.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions3.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions4.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_explosions5.wss\",EXPLOSION_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight1.wss\",FIREFIGHT_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight2.wss\",FIREFIGHT_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight3.wss\",FIREFIGHT_WEIGHT,\n        \"A3\\Sounds_F\\environment\\ambient\\battlefield\\battlefield_firefight4.wss\",FIREFIGHT_WEIGHT\n    ];\n    localNamespace setVariable [\"KISKA_battleSounds\",_soundsArray];\n};\n\n\nprivate _distanceIsArray = _distance isEqualType [];\nprivate _volume = floor (random [3,4,5]);\nplaySound3D [\n    selectRandomWeighted _soundsArray,\n    objNull,\n    false,\n    _actualSource,\n    _volume,\n    random [-2,0,1],\n    [_distance,random _distance] select _distanceIsArray\n];\n\n\nif !(_hasBattleSoundId) then {\n    _battleSoundId = [\"KISKA_battleSoundId_latestIndex\"] call KISKA_fnc_idCounter;\n    private _stringBattleSoundId = str _battleSoundId;\n    localNamespace setVariable [(\"KISKA_battleSoundIsPlaying_\" + _stringBattleSoundId), true];\n};\n\nif (_duration > 0) then {\n    [\n        KISKA_fnc_stopBattleSound,\n        [_battleSoundId],\n        _duration\n    ] call CBA_fnc_waitAndExecute;\n\n    _duration = -1;\n};\n\n\nprivate _timeUntilSecondSound = random _intensityArray;\nprivate _timeBetweenNextCall = _intensityArray vectorMultiply 4;\n[\n    {\n        params [\n            \"_soundsArray\",\n            \"_actualSource\",\n            \"_volume\",\n            \"_distance\"\n        ];\n        playSound3D [\n            selectRandomWeighted _soundsArray,\n            objNull,\n            false,\n            _actualSource,\n            _volume,\n            random [-2,0,1],\n            _distance\n        ];\n    },\n    [\n        _soundsArray,\n        _actualSource,\n        _volume,\n        [_distance,random _distance] select _distanceIsArray\n    ],\n    _timeUntilSecondSound\n] call CBA_fnc_waitAndExecute;\n\n\n[\n    {\n        _this call KISKA_fnc_battleSound;\n    },\n    [\n        _source,\n        _distance,\n        _duration,\n        _intensity,\n        _battleSoundId\n    ],\n    (_timeUntilSecondSound + (random _timeBetweenNextCall))\n] call CBA_fnc_waitAndExecute;\n\n\n_battleSoundId\n",
    "fileName": "fn_battleSound.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playRandom3dSoundLoop\n\nDescription:\n    Randomly plays sounds (or music) in 3d space from a given list at one or multiple \n     origins.\n    \n    This function will produce synchronized audio on all machines.\n\nParameters:\n    0: _origin <OBJECT or ARRAY> - The position (ASL), object from which the sound comes from, \n        or an array of any combination of the two (effectively multiple origins)\n    1: _sounds <ARRAY> - An array of sounds to play randomly with any combination of three formats:\n        - <STRING>: A config name of a sound in either CfgSounds and/or CfgMusic. This config Must\n            have a \"duration\" number property. \n        - [<STRING>,<NUMBER>] ([<configClassName>,<duration>]): a config class name that is in CfgSounds \n            and/or CfgMusic and the duration the sound lasts.\n        - <CONFIG>: a config path to a class with a \"sound[]\" array property that has it's first entry\n            as a sound file path, and has a \"duration\" number property.\n    2: _timeBetweenSounds <NUMBER or ARRAY> - A buffer time between each sound once one completes. \n        If array, random syntax of random [min,mid,max] is used to get buffer each time a sound completes.\n    3: _soundParams <ARRAY> - An array of parameters for playSound3D:\n        \n        - 0. _distance <NUMBER> - Distance at which the sound can be heard\n        - 1. _volume <NUMBER> - Range from 0-5\n        - 2. _isInside <BOOL> - Is _origin inside\n        - 3. _pitch <NUMBER> - Range from 0-5\n\n    4: _onSoundPlayed <ARRAY, CODE, STRING> - A callback function that executes each time a sound is played\n        (See KISKA_fnc_callback). Parameters are:\n\n        - 0. <NUMBER> - An id that can be used with KISKA_fnc_stopRandom3dSoundLoop to stop sounds\n        - 1. <OBJECT or ARRAY> - The position the sound is playing at\n        - 2. <CONFIG> - The config of the current sound being played\n\nReturns:\n    <NUMBER> - An id that can be used with KISKA_fnc_stopRandom3dSoundLoop to stop\n        the sound loop.\n\nExamples:\n    (begin example)\n        [\n            player,\n            [],\n            5,\n            [],\n            {hint str _this}\n        ] call KISKA_fnc_playRandom3dSoundLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playRandom3dSoundLoop\";\n\nparams [\n    [\"_origin\",objNull,[objNull,[]]],\n    [\"_sounds\",[],[[]]],\n    [\"_timeBetweenSounds\",5,[[],123],[3]],\n    [\"_soundParams\",[],[[]]],\n    [\"_onSoundPlayed\",{},[[],{},\"\"]]\n];\n\n// verify params\n_soundParams params [\n    [\"_distance\",20,[123]],\n    [\"_volume\",1,[123]],\n    [\"_isInside\",false,[true]],\n    [\"_pitch\",1,[123]]\n];\n\n\nprivate _soundsParsed = _sounds apply {\n    private _sound = _x;\n    private [\"_soundConfig\",\"_duration\"];\n\n    if (_sound isEqualType []) then {\n        if ((count _sound) < 2) then {continue};\n        _soundConfig = _sound select 0;\n\n        if !(_soundConfig isEqualTypeAny [\"\",configNull]) then {continue};\n        if (_soundConfig isEqualType \"\") then {\n            private _soundConfigName = _soundConfig;\n            [\"CfgSounds\",\"CfgMusic\"] apply {\n                _soundConfig = [[_x,_soundConfigName]] call KISKA_fnc_findConfigAny;\n                if !(isNull _soundConfig) then {break};\n            };\n        };\n        _duration = _sound select 1;\n\n\n    } else {\n        if (_sound isEqualType \"\") then {\n            [\"CfgSounds\",\"CfgMusic\"] apply {\n                _soundConfig = [[_x,_sound]] call KISKA_fnc_findConfigAny;\n                if !(isNull _soundConfig) then {break};\n            };\n        } else {\n            _soundConfig = _sound;\n        };\n\n        _duration = getNumber(_soundConfig >> \"duration\");\n\n    };\n\n    if (isNull _soundConfig OR _duration <= 0) then {continue};\n    [_soundConfig,_duration]\n};\n\n\nprivate _playNextSound = {\n    params [\n        \"_origin\",\n        \"_unusedSounds\",\n        \"_usedSounds\",\n        \"_playNextSound\",\n        \"_timeBetweenSounds\",\n        \"_soundParams\",\n        \"_onSoundPlayed\",\n        \"_id\"\n    ];\n\n    private _isPlaying = localNamespace getVariable [(\"KISKA_random3dSoundLoopIsPlaying_\" + (str _id)), false];\n    if (!_isPlaying) exitWith {};\n\n    private _params = _this;\n    private _unusedIsEmpty = _unusedSounds isEqualTo [];\n    if (_unusedIsEmpty AND (_usedSounds isEqualTo [])) exitWith {\n        [\"Both _unusedSounds and _usedSounds were empty arrays. Exited loop...\",true] call KISKA_fnc_log;\n        nil\n    };\n\n    if (_unusedIsEmpty) then {\n        _unusedSounds = _usedSounds;\n        _usedSounds = [];\n        _params set [1,_unusedSounds];\n        _params set [2,_usedSounds];\n    };\n\n    private _selectedSound = [_unusedSounds] call KISKA_fnc_deleteRandomIndex;\n    private _soundConfig = _selectedSound select 0;\n    _soundParams params [\n        [\"_distance\",20,[123]],\n        [\"_volume\",1,[123]],\n        [\"_isInside\",false,[true]],\n        [\"_pitch\",1,[123]]\n    ];\n\n    [\n        _soundConfig,\n        _origin,\n        _distance,\n        _volume,\n        _isInside,\n        _pitch\n    ] call KISKA_fnc_playSound3d;\n    \n    [\n        [_id,_origin,_soundConfig],\n        _onSoundPlayed\n    ] call KISKA_fnc_callBack;\n\n    _usedSounds pushBack _selectedSound;\n\n    private _interval = [_timeBetweenSounds,random _timeBetweenSounds] select (_timeBetweenSounds isEqualType []);\n    private _soundDuration = _selectedSound select 1;\n    private _timeUntilNextSound = _soundDuration + _interval;\n    [\n        _playNextSound,\n        _params,\n        _timeUntilNextSound\n    ] call CBA_fnc_waitAndExecute;\n};\n\nprivate _id = [\"KISKA_random3dSoundLoop\"] call KISKA_fnc_idCounter;\nlocalNamespace setVariable [(\"KISKA_random3dSoundLoopIsPlaying_\" + (str _id)), true];\n\n[\n    _origin,\n    _soundsParsed,\n    [],\n    _playNextSound,\n    _timeBetweenSounds,\n    _soundParams,\n    _onSoundPlayed,\n    _id\n] call _playNextSound;\n\n\n_id\n",
    "fileName": "fn_playRandom3dSoundLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playSound2D\n\nDescription:\n    Plays a 2D sound if a player is within a given area.\n    Used due to say2D's broken \"maxTitlesDistance\".\n\nParameters:\n    0: _sound <STRING> - The sound name to play\n    1: _center <OBJECT or ARRAY> - The center position of the radius to search around\n    2: _radius <NUMBER> - How far can the player be from the _center and still \"hear\" the sound\n    3: _threeDimensional <BOOL> - Whether to measure the distance to the player in 2d or 3d space\n\nReturns:\n    <BOOL> - True if played, false if did not\n\nExamples:\n    (begin example)\n        [\"alarm\",player,20] call KISKA_fnc_playSound2D;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nif !(hasInterface) exitWith {false};\n\nparams [\n    [\"_sound\",\"alarm\",[\"\"]],\n    [\"_center\",player,[objNull,[]]],\n    [\"_radius\",10,[123]],\n    [\"_threeDimensional\",false,[true]]\n];\n\nif ((_center isEqualtype objNull) AND {isNull _center}) exitWith {\n    [\"Center object isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_radius isEqualTo 0) exitWith {\n    playsound _sound;\n    true\n};\n\nif (_radius < 0) exitWith {\n    [[\"Raidus is: \",_radius,\" ...less then 0. Must be more then 0\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate \"_distanceToPlayer\";\nif (_threeDimensional) then {\n    _distanceToPlayer = _center distance player;\n} else {\n    _distanceToPlayer = _center distance2D player;\n};\n\nif (_distanceToPlayer <= _radius) then {\n    playsound _sound;\n    true\n\n} else {\n    false\n\n};\n",
    "fileName": "fn_playSound2D.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playSound3D\n\nDescription:\n    Plays a sound 3D but the function accepts the CFGSounds name rather then the file path.\n\nParameters:\n    0: _sound <STRING or CONFIG> - The sound to play. The classname of a CfgSounds entry (if string)\n        or any config class that has a \"sound[]\" array and \"duration\" number property (such as CfgMusic classes)\n    1: _origin <OBJECT or ARRAY> - The position (ASL), object from which the sound comes from, \n        or an array of any combination of the two (effectively multiple origins)\n    2: _distance <NUMBER> - Distance at which the sound can be heard\n    3: _volume <NUMBER> - Range from 0-5\n    4: _isInside <BOOL> - Is _origin inside\n    5: _pitch <NUMBER> - Range from 0-5\n\nReturns:\n    <BOOL> - True if sound found and played, false if error\n\nExamples:\n    (begin example)\n        [\n            \"BattlefieldJet1_3D\",\n            (getPosASL player) vectorAdd [50,50,100],\n            2000\n        ] call KISKA_fnc_playSound3D;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playSound3D\";\n\n#define FILE_EXTENSIONS [\".wss\",\".ogg\",\".wav\"]\n\nparams [\n    [\"_sound\",\"\",[\"\",configNull]],\n    [\"_origin\",objNull,[objNull,[]]],\n    [\"_distance\",20,[123]],\n    [\"_volume\",1,[123]],\n    [\"_isInside\",false,[true]],\n    [\"_pitch\",1,[123]]\n];\n\nprivate _soundIsConfig = _sound isEqualType configNull;\nif (_soundIsConfig AND {isNull _sound}) exitWith {\n    [[\"_sound: \", _sound,\" is null config\"],true] call KISKA_fnc_log;\n    false\n};\n\n/* -----------------------------------\n    Verify Params\n----------------------------------- */\nif (_sound isEqualTo \"\") exitWith {\n    [\"_sound is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _originIsObject = _origin isEqualType objNull;\nif (_originIsObject AND {isNull _origin}) exitWith {\n    [\"_origin object isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _originIsArray = _origin isEqualType [];\nif (_originIsArray AND {_origin isEqualTo []}) exitWith {\n    [\"_origin is empty array\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_distance < 0) exitWith {\n    [[\"_distance is: \",_distance,\" and cannot be negative\"],true] call KISKA_fnc_log;\n    false\n};\n\n\n/* -----------------------------------\n    Verify Sound configuration\n----------------------------------- */\nprivate _soundConfig = configNull;\nif (_soundIsConfig) then {\n    _soundConfig = _sound;\n} else {\n    _soundConfig = [[\"CfgSounds\",_sound]] call KISKA_fnc_findConfigAny;\n};\n\nif (isNull _soundConfig) exitWith {\n    [[\"Could not find a config for the sound: \",_sound],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _soundArray = getArray(_soundConfig >> \"sound\");\nif (_soundArray isEqualTo []) exitWith {\n    [[\"'sound' property in config: \",_soundConfig,\" is either empty array or undefined\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _soundPath = _soundArray select 0;\nif ([_soundConfig, missionConfigFile] call CBA_fnc_inheritsFrom) then {\n    _soundPath = getMissionPath + _soundPath;\n};\n\nif (!(_soundPath isEqualType \"\") OR (_soundPath isEqualTo \"\")) exitWith {\n    [\"_sound: \",_sound,\" is configed incorrectly\",true] call KISKA_fnc_log;\n    false\n};\n\n\n/* -----------------------------------\n    Verify Audio file\n----------------------------------- */\n// Some Bohmemia sound paths had a \"@\" or \"\\\" at the front\n// playSound3D will not find the file if this is the case\nprivate _firstChar = _soundPath select [0,1];\nif (_firstChar in [\"@\",\"\\\"]) then {\n    _soundPath = _soundPath trim [_firstChar,1];\n};\nprivate _fileNotFound = false;\nprivate _tempPath = \"\";\nif !(fileExists _soundPath) then {\n    private _hasFileExtension = (toLowerANSI (_soundPath select [(count _soundPath) - 4,4])) in FILE_EXTENSIONS;\n    if !(_hasFileExtension) then {\n        _fileNotFound = true;\n\n        FILE_EXTENSIONS apply {\n            _tempPath = _soundPath + _x;\n            if (fileExists _tempPath) then {\n                _fileNotFound = false;\n                _soundPath = _tempPath;\n                break;\n            };\n\n        };\n\n    } else {\n        _fileNotFound = true;\n\n    };\n\n};\nif (_fileNotFound) exitWith {\n    [[\"Could not find file at path: \", _soundPath],true] call KISKA_fnc_log;\n    false\n};\n\n\n\n/* -----------------------------------\n    Playsound\n----------------------------------- */\nif (_originIsObject) exitWith {\n    playSound3D [\n        _soundPath,\n        objNull,\n        _isInside,\n        getPosASL _origin,\n        _volume,\n        _pitch,\n        _distance\n    ];\n\n    true\n};\n\nprivate _positionCompareArray = [1,2,3];\nif (_origin isEqualTypeParams _positionCompareArray) exitWith {\n    playSound3D [\n        _soundPath,\n        objNull,\n        _isInside,\n        _origin,\n        _volume,\n        _pitch,\n        _distance\n    ];\n\n    true\n};\n\n\nprivate _origins = _origin;\n_origins apply {\n    if (_x isEqualTypeParams _positionCompareArray) then {\n        playSound3D [\n            _soundPath,\n            objNull,\n            _isInside,\n            _x,\n            _volume,\n            _pitch,\n            _distance\n        ];\n        continue;\n    };\n\n    if ((_x isEqualType objNull) AND {!(isNull _x)}) then {\n        playSound3D [\n            _soundPath,\n            objNull,\n            _isInside,\n            getPosASL _x,\n            _volume,\n            _pitch,\n            _distance\n        ];\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_playSound3D.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_radioChatter\n\nDescription:\n    Plays a random radio ambient at the specified position.\n\n    This has a global effect now and should be executed on one machine.\n\nParameters:\n    0: _followSource <BOOL> - Should the radio audio be attached to the _source object?\n        This will use say3D instead of playSound3d.\n    1: _soundParams <ARRAY> - An array of parameters that are slightly different depending on the _followSource value\n        If _followSource is true:\n            - 0: _source <OBJECT> - Where the sound is coming from\n            - 1: _distance <NUMBER> - Max distance at which the sound can be heard\n            - 2: _offset <ARRAY> - AttachTo coordinates that can be used to offset the sound\n        If _followSource is false:\n            - 0: _source <OBJECT or ARRAY> - Where the sound is coming from.\n                If array format positionASL.\n            - 1: _distance <NUMBER> - Max distance at which the sound can be heard\n            - 2: _volume <NUMBER> - How loud the sound plays\n\nReturns:\n    <NUMBER> - the \"chatter ID\" that can be used with KISKA_fnc_stopRadioChatter. -1 if error\n\nExamples:\n    (begin example)\n        // radio sound follows player\n        [\n            true,\n            [player]\n        ] call KISKA_fnc_radioChatter;\n    (end)\n    (begin example)\n        // radio sound follows front of player\n        [\n            true,\n            [player,5,[0,1,0]]\n        ] call KISKA_fnc_radioChatter;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_radioChatter\";\n\n#define SOUND_PITCH 1\n#define HELPER_OBJECT_CLASS \"Sign_Arrow_Cyan_F\"\n#define DEFAULT_OFFSET [0,0,0]\n\nparams [\n    [\"_followSource\",false,[true]],\n    [\"_soundParams\",[],[[]]],\n    [\"_chatterId\",-1,[123]]\n];\n\nprivate _hasChatterId = _chatterId > -1;\nprivate _idIsPlaying = localNamespace getVariable [\"KISKA_radioChatterIsPlaying_\" + (str _chatterId), false];\nif (\n    _hasChatterId AND\n    (!_idIsPlaying)\n) exitWith {\n    -1\n};\n\nif (_soundParams isEqualTo []) exitWith {\n    [\"_soundParams is empty!\"] call KISKA_fnc_log;\n    -1\n};\n\n\nprivate _numberStr = str ([2,30] call BIS_fnc_randomInt);\nprivate _radioSound = \"KISKA_radioAmbient\" + _numberStr;\nprivate _soundCreated = false;\nprivate _helperObject = objNull;\nif (_followSource) then {\n    _soundParams params [\n        [\"_source\",objNull,[objNull]],\n        [\"_distance\",20,[123]],\n        [\"_offset\",DEFAULT_OFFSET,[[]],[3]]\n    ];\n\n    if (isNull _source) exitWith {\n        [\"Sound source isNull\"] call KISKA_fnc_log;\n        if (_hasChatterId) then {\n            // delete helper object if source is dead\n            [_chatterId] call KISKA_fnc_stopRadioChatter;\n        };\n    };\n\n    private _actualSource = objNull;\n    if (_hasChatterId) then {\n        _actualSource = localNamespace getVariable [\"KISKA_radioChatter_offsetObject_\" + (str _chatterId), objNull];\n    };\n\n    private _hasOffsetObject = !(isNull _actualSource);\n    if !(_hasOffsetObject) then {\n        _actualSource = _source;\n        if (_offset isNotEqualTo DEFAULT_OFFSET) then {\n            _actualSource = HELPER_OBJECT_CLASS createVehicle [0,0,0];\n            _helperObject = _actualSource;\n            [_actualSource, true] remoteExec [\"hideObjectGlobal\", 2];\n            _actualSource attachTo [_source,_offset];\n        };\n\n    };\n\n\n    [_actualSource, [_radioSound, _distance, SOUND_PITCH, true]] remoteExec [\"say3D\",0];\n    _soundCreated = true;\n\n} else {\n    _soundParams params [\n        [\"_source\",[],[objNull,[]],[3]],\n        [\"_distance\",20,[123]],\n        [\"_volume\",1,[123]]\n    ];\n\n    private _sourceIsObject = _source isEqualType objNull;\n    if (_sourceIsObject AND {isNull _source}) exitWith {\n        [\"Sound source isNull\"] call KISKA_fnc_log;\n        if (_hasChatterId) then {\n            [_chatterId] call KISKA_fnc_stopRadioChatter;\n        };\n    };\n\n    private _actualSource = _source;\n    if !(_sourceIsObject) then {\n        _actualSource = getPosASL _source;\n    };\n\n    [_radioSound,_actualSource,_distance,_volume] call KISKA_fnc_playSound3D;\n    _soundCreated = true;\n\n};\n\n\nif !(_soundCreated) exitWith {\n    [\"Failed to create radio chatter!\"] call KISKA_fnc_log;\n    -1\n};\n\nif !(_hasChatterId) then {\n    _chatterId = [\"KISKA_radioChatterId_latestIndex\"] call KISKA_fnc_idCounter;\n\n    private _stringChatterId = str _chatterId;\n    localNamespace setVariable [(\"KISKA_radioChatterIsPlaying_\" + _stringChatterId), true];\n    if !(isNull _helperObject) then {\n        localNamespace setVariable [\"KISKA_radioChatter_offsetObject_\" + _stringChatterId, _helperObject];\n    };\n};\n\n\nprivate _soundDuration = getNumber (configFile >> \"CfgSounds\" >> _radioSound >> \"duration\");\nprivate _randomBuffer = random [1,5,10];\n[\n    {\n        _this call KISKA_fnc_radioChatter;\n    },\n    [_followSource, _soundParams, _chatterId],\n    (_soundDuration + _randomBuffer)\n] call CBA_fnc_waitAndExecute;\n\n\n_chatterId\n",
    "fileName": "fn_radioChatter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopBattleSound\n\nDescription:\n    Stops battle sounds playing for the given id.\n\nParameters:\n    0: _chatterId <OBJECT> - Where the sound is coming from\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_stopBattleSound;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopBattleSound\";\n\nparams [\n    [\"_id\",-1,[123]]\n];\n\nif (_id < 0) exitWith {\n    [\"Invalid _id given!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _idAsString = str _id;\nlocalNamespace setVariable [(\"KISKA_battleSoundIsPlaying_\" + _idAsString), nil];\n",
    "fileName": "fn_stopBattleSound.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopRadioChatter\n\nDescription:\n    Stops radio chatter playing for the given id.\n\nParameters:\n    0: _chatterId <OBJECT> - Where the sound is coming from\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_radioChatter;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopRadioChatter\";\n\nparams [\n    [\"_chatterId\",-1,[123]]\n];\n\nif (_chatterId < 0) exitWith {\n    [\"Invalid _chatterId given!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _stringChatterId = str _chatterId;\nlocalNamespace setVariable [(\"KISKA_radioChatterIsPlaying_\" + _stringChatterId), nil];\n\nprivate _offsetObjectVar = \"KISKA_radioChatter_offsetObject_\" + _stringChatterId;\nprivate _offsetObject = localNamespace getVariable [_offsetObjectVar, objNull];\nif (isNull _offsetObject) exitWith {};\n\ndetach _offsetObject;\ndeleteVehicle _offsetObject;\nlocalNamespace setVariable [_offsetObjectVar, nil];\n",
    "fileName": "fn_stopRadioChatter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_stopRandom3dSoundLoop\n\nDescription:\n    Stops a 3d sound loop created with KISKA_fnc_playRandom3dSoundLoop;\n\nParameters:\n    0: _id <NUMBER> - The id returned from KISKA_fnc_playRandom3dSoundLoop\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_stopRandom3dSoundLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_stopRandom3dSoundLoop\";\n\nparams [\n    [\"_id\",-1,[123]]\n];\n\nif (_id < 0) exitWith {\n    [\"Invalid _id given!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _idAsString = str _id;\nlocalNamespace setVariable [(\"KISKA_random3dSoundLoopIsPlaying_\" + _idAsString), nil];\n",
    "fileName": "fn_stopRandom3dSoundLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_addSignal\n\nDescription:\n    Adds a signal that can be seen on a spectrum device. \n\nParameters:\n    0: _signalProperties : <ARRAY> - The all the properites of the signal\n\n        `_signalProperties` Layout:\n        - 0: _frequency <NUMBER> - The frequency of the signal in MHz\n        - 1: _origin <OBJECT or PositionASL[]> - The position of the signal\n        - 2: _decibels <NUMBER> - The base signal decibel level when when near the origin\n        - 3: _maxDistance <NUMBER> - The max distance that the signal can be seen on the spectrum\n        analyzer. This will be what governs how the signal strength increases/decreases depending\n        on the user's position. Default is `worldSize`.\n\n    1: _global : <BOOL> - `true` to broadcast the changes to all machines including JIP\n\nReturns:\n    <STRING> - The corresponding ID for the signal\n\nExamples:\n    (begin example)\n        private _signalId = [\n            [100,[0,0,0],100]\n        ] call KISKA_fnc_spectrum_addSignal;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_addSignal\";\n\nparams [\n    [\"_signalProperties\",[],[[]]],\n    [\"_global\",true,[true]]\n];\n\n_signalProperties params [\n    [\"_frequency\",100,[123]],\n    [\"_origin\",objNull,[[],objNull],[3]],\n    [\"_decibels\",-100,[123]],\n    [\"_maxDistance\",worldSize,[123]]\n];\n\n\nif (_frequency <= 0) exitWith {\n    [[\"Signal can't be added, must have a frequency above 0, current is: \",_frequency],true] call KISKA_fnc_log;\n    \"\"\n};\n\nif ((_origin isEqualType objNull) AND {isNull _origin}) exitWith {\n    [\"Provided origin is null object\",true] call KISKA_fnc_log;\n    \"\"\n};\n\nif (_maxDistance <= 0) exitWith {\n    [\"Max distance must be positive number\",true] call KISKA_fnc_log;\n    \"\"\n};\n\n\nprivate _tag = [\"KISKA\",\"spectrumSignal\",clientOwner] joinString \"_\";\nprivate _id = [_tag] call KISKA_fnc_generateUniqueId;\n\n[\n    [\n        _id,\n        _frequency,\n        _origin,\n        _decibels,\n        _maxDistance\n    ],\n    _global\n] call KISKA_fnc_spectrum_updateSignal;\n\n\n_id\n",
    "fileName": "fn_spectrum_addSignal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_deleteSignal\n\nDescription:\n    Deletes a signal with the given id.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to remove\n    1: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\tNOTHING\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\"] call KISKA_fnc_spectrum_deleteSignal;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_deleteSignal\";\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_global\",true,[true]]\n];\n\nif (_global AND isMultiplayer) then {\n    [\n        _id,\n        false\n    ] remoteExecCall [\"KISKA_fnc_spectrum_deleteSignal\",-clientOwner];\n\tremoteExec [\"\", \"JIPid\"];\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n_signalMap deleteAt (toLowerANSI _id);\n\n\nnil\n",
    "fileName": "fn_spectrum_deleteSignal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMaxDecibels\n\nDescription:\n    Gets the current max decibel level scale of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The max viewable decibel level of the spectrum device\n\nExamples:\n    (begin example)\n        private _max = call KISKA_fnc_spectrum_getMaxDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMaxDecibels\";\n\nmissionNamespace getVariable [\"#EM_SMax\", -10]\n",
    "fileName": "fn_spectrum_getMaxDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMaxFrequency\n\nDescription:\n    Gets the current max frequency of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The max viewable frequency (MHz) of the spectrum device\n\nExamples:\n    (begin example)\n        private _max = call KISKA_fnc_spectrum_getMaxFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMaxFrequency\";\n\nmissionNamespace getVariable [\"#EM_FMax\", 125]\n",
    "fileName": "fn_spectrum_getMaxFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMinDecibels\n\nDescription:\n    Gets the current min decibel level scale of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The min viewable decibel level of the spectrum device\n\nExamples:\n    (begin example)\n        private _min = call KISKA_fnc_spectrum_getMinDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMinDecibels\";\n\nmissionNamespace getVariable [\"#EM_SMin\", -60]\n",
    "fileName": "fn_spectrum_getMinDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getMinFrequency\n\nDescription:\n    Gets the current min frequency of the spectrum device for the local machine.\n\nParameters:\n    NONE\n\nReturns:\n    <NUMBER> - The min viewable frequency (MHz) of the spectrum device\n\nExamples:\n    (begin example)\n        private _min = call KISKA_fnc_spectrum_getMinFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getMinFrequency\";\n\nmissionNamespace getVariable [\"#EM_FMin\", 100]\n",
    "fileName": "fn_spectrum_getMinFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getSelection\n\nDescription:\n    Provides the current MHz area selected on the local machine. This is where the\n     blue bar that the player manipulates with the scroll wheel is positioned.\n\nParameters:\n    NONE\n\nReturns:\n    <[NUMBER,NUMBER]> - The min and max of the player's currently selected area\n\nExamples:\n    (begin example)\n        private _selection = call KISKA_fnc_spectrum_getSelection;\n        // _selection params [\"_min\",\"_max\"];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getSelection\";\n\n[\n    missionNamespace getVariable [\"#EM_SelMin\", 100],\n    missionNamespace getVariable [\"#EM_SelMax\", 102.5]\n]\n",
    "fileName": "fn_spectrum_getSelection.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_getSignalMap\n\nDescription:\n    Returns a map of all the signals and their corresponding ids that have been\n\t added on the local machine. \n\nParameters:\n\tNONE\n\nReturns:\n    <HASHMAP<STRING,ARRAY>> - A hashmap where a signal id as key will provide an\n\t \tarray of that signals base properties:\n\n\t \t- 0. <NUMBER> : The frequency of the signal in MHz\n\t \t- 1. <PositionASL[]> : The position of the signal\n\t \t- 2. <NUMBER> : The base signal decibel level when when near the origin\n\t \t- 3. <NUMBER> : The max distance that the signal can be seen on the spectrum analyzer\n\nExamples:\n    (begin example)\n        private _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_getSignalMap\";\n\nprivate _signalMap = localNamespace getVariable [\"KISKA_spectrum_signalMap\",-1];\nif (_signalMap isEqualTo -1) then {\n\t_signalMap = createHashMap;\n\tlocalNamespace setVariable [\"KISKA_spectrum_signalMap\",_signalMap];\n};\n\n\n_signalMap\n",
    "fileName": "fn_spectrum_getSignalMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_isInitialized\n\nDescription:\n    Determines whether the spectrum device display has been initialized.\n\n    This display will be created once a player has added the device to their\n     inventory. They do not have to equip the device.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - `true` if the spectrum device has been initialized, `false` if not\n\nExamples:\n    (begin example)\n        private _isInitialized = call KISKA_fnc_spectrum_isInitialized\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_isInitialized\";\n\n!(isNil { uiNamespace getVariable \"rscweaponspectrumanalyzergeneric\" })",
    "fileName": "fn_spectrum_isInitialized.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_isTransmitting\n\nDescription:\n    Checks whether or not the local machine is transimitting on the spectrum device.\n\n    This shows as a green tint to the player's selection area with the full spectrum\n     device ui open, and as a wifi esque signal when merely holding the spectrum device.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - `true` if transmitting, `false` if not\n\nExamples:\n    (begin example)\n        private _isTransmitting = call KISKA_fnc_spectrum_isTransmitting\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_isTransmitting\";\n\nmissionNamespace getVariable [\"#EM_Transmit\",false];\n",
    "fileName": "fn_spectrum_isTransmitting.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMaxDecibels\n\nDescription:\n    Sets the current max decibel range of spectrum device for the local machine.\n\nParameters:\n    0: _max : <NUMBER> - The decibel level\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [-10] call KISKA_fnc_spectrum_setMaxDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMaxDecibels\";\n\nparams [\n\t[\"_max\",-10,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_maxDecibels\",_max];\n};\n\nmissionNamespace setVariable [\"#EM_SMax\", _max];\n",
    "fileName": "fn_spectrum_setMaxDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMaxFrequency\n\nDescription:\n    Sets the current max frequency of the spectrum device for the local machine.\n\nParameters:\n    0: _max : <NUMBER> - The frequency in MHz\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [125] call KISKA_fnc_spectrum_setMaxFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMaxFrequency\";\n\nparams [\n\t[\"_max\",100,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_maxFreq\",_max];\n};\n\nmissionNamespace setVariable [\"#EM_FMax\", _max]\n",
    "fileName": "fn_spectrum_setMaxFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMinDecibels\n\nDescription:\n    Sets the current min decibel range of spectrum device for the local machine.\n\nParameters:\n    0: _min : <NUMBER> - The decibel level\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [-60] call KISKA_fnc_spectrum_setMinDecibels;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMinDecibels\";\n\nparams [\n\t[\"_min\",-60,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_minDecibels\",_min];\n};\n\nmissionNamespace setVariable [\"#EM_SMin\", _min];\n",
    "fileName": "fn_spectrum_setMinDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setMinFrequency\n\nDescription:\n    Sets the current min frequency of the spectrum device for the local machine.\n\nParameters:\n    0: _min : <NUMBER> - The frequency in MHz\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [80] call KISKA_fnc_spectrum_setMinFrequency;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setMinFrequency\";\n\nparams [\n\t[\"_min\",80,[123]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_minFreq\",_min];\n};\n\nmissionNamespace setVariable [\"#EM_FMin\", _min]\n",
    "fileName": "fn_spectrum_setMinFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSelectionWidth\n\nDescription:\n    Sets the selection area of the local machine's spectrum device. This is the\n\t bar that a user can \"scroll\" around the spectrum with.\n\nParameters:\n    0: _width : <NUMBER> - The width of the bar in MHz\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n\t\t// bar is 2 MHz wide\n        [2] call KISKA_fnc_spectrum_setSelectionWidth;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSelectionWidth\";\n\nparams [\n\t[\"_width\",2,[123]]\n];\n\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_spectrum_staged_selectionWidth\",_width];\n};\n\nprivate _currentSelectionMin = missionNamespace getVariable [\"#EM_SelMin\", \"\"];\n\n// selection adjusments do not stick if set outside of the frequency AND the spectrum device ui is NOT open\nprivate _minFrequency = call KISKA_fnc_spectrum_getMinFrequency;\nif ((_currentSelectionMin isEqualTo \"\") OR {_currentSelectionMin < _minFrequency}) then {\n    missionNamespace setVariable [\"#EM_SelMin\",_minFrequency];\n    _currentSelectionMin = _minFrequency;\n};\n\nmissionNamespace setVariable [\"#EM_SelMax\", _currentSelectionMin + _width];\n",
    "fileName": "fn_spectrum_setSelectionWidth.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalDecibels\n\nDescription:\n    Sets the signal's decibel level.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _decibels : <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",-100] call KISKA_fnc_spectrum_setSignalDecibels;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalDecibels\";\n\n#define ORIGIN_KEY \"_origin\"\n#define FREQUENCY_KEY \"_frequency\"\n#define DISTANCE_KEY \"_maxDistance\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_decibels\",-100,[123]],\n    [\"_global\",true,[true]]\n];\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_signalPropertiesMap get FREQUENCY_KEY,\n\t\t_signalPropertiesMap get ORIGIN_KEY,\n\t\t_decibels,\n\t\t_signalPropertiesMap get DISTANCE_KEY\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalDecibels.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalDistance\n\nDescription:\n    Sets the signal's distance that it can be heard from.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _maxDistance : <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",1000] call KISKA_fnc_spectrum_setSignalDistance;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalDistance\";\n\n#define ORIGIN_KEY \"_origin\"\n#define FREQUENCY_KEY \"_frequency\"\n#define DECIBEL_KEY \"_decibels\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_maxDistance\",1000,[123]],\n    [\"_global\",true,[true]]\n];\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_signalPropertiesMap get FREQUENCY_KEY,\n\t\t_signalPropertiesMap get ORIGIN_KEY,\n\t\t_signalPropertiesMap get DECIBEL_KEY,\n\t\t_maxDistance\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalDistance.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalFrequency\n\nDescription:\n    Sets the signal's frequency.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _frequency : <NUMBER> - The frequency of the signal in MHz\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",100] call KISKA_fnc_spectrum_setSignalFrequency;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalFrequency\";\n\n#define ORIGIN_KEY \"_origin\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_frequency\",100,[123]],\n    [\"_global\",true,[true]]\n];\n\n\nif (_frequency <= 0) exitWith {\n    [\n        [\n            \"Signal can't be added, must have a frequency above 0, current is: \",\n            _frequency,\n            \". Signal being updated: \",\n            _id\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_frequency,\n\t\t_signalPropertiesMap get ORIGIN_KEY,\n\t\t_signalPropertiesMap get DECIBEL_KEY,\n\t\t_signalPropertiesMap get DISTANCE_KEY\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalFrequency.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setSignalPosition\n\nDescription:\n    Sets the signal's origin position.\n\n\tNOTE: If you intend to update more than one property of a signal, use\n\t `KISKA_fnc_spectrum_updateSignal` as it is more efficient.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to update\n    1: _origin : <OBJECT or PositionASL[]> - The position of the signal\n    2: _global : <BOOL> - `true` to broadcast the change to all machines including JIP (default: `true`)\n\nReturns:\n\t<HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        [\"KISKA_spectrumSignal_2_1\",myOrigin] call KISKA_fnc_spectrum_setSignalPosition;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setSignalPosition\";\n\n#define FREQUENCY_KEY \"_frequency\"\n#define ORIGIN_KEY \"_origin\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n\nparams [\n\t[\"_id\",\"\",[\"\"]],\n    [\"_origin\",objNull,[[],objNull],[3]],\n    [\"_global\",true,[true]]\n];\n\n\nprivate _originIsObject = _origin isEqualType objNull;\nif (_originIsObject AND {isNull _origin}) exitWith {\n    [[\"Provided origin is null object; attempting to update signal: \",_id],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _signalPropertiesMap = _signalMap getOrDefaultCall [(toLowerANSI _id),{-1}];\n\nif (_signalPropertiesMap isEqualTo -1) exitWith {\n    [[\"Can't find signal to update with id: \",_id],true] call KISKA_fnc_log;\n\tnil\n};\n\n\n[\n\t[\n\t\t_id,\n\t\t_signalPropertiesMap get FREQUENCY_KEY,\n\t\t_origin,\n\t\t_signalPropertiesMap get DECIBEL_KEY,\n\t\t_signalPropertiesMap get DISTANCE_KEY\n\t],\n\t_global\n] call KISKA_fnc_spectrum_updateSignal;\n",
    "fileName": "fn_spectrum_setSignalPosition.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_setTransmitting\n\nDescription:\n    Adjusts whether or not the spectrum device is in transmit mode.\n\n    This shows as a green tint to the player's selection area with the full spectrum\n     device ui open, and as a wifi esque signal when merely holding the spectrum device.\n\nParameters:\n    0: _isTransmitting : <BOOL> - `true` to set the spectrum device as being in transmit mode\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [true] call KISKA_fnc_spectrum_setTransmitting;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_setTransmitting\";\n\nparams [\n    [\"_isTransmitting\",true,[true]]\n];\n\nif !(call KISKA_fnc_spectrum_isInitialized) then {\n    localNamespace setVariable [\"KISKA_fnc_spectrum_setTransmitting\",_isTransmitting];\n};\n\nmissionNamespace setVariable [\"#EM_Transmit\",_isTransmitting];\n",
    "fileName": "fn_spectrum_setTransmitting.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_signalExists\n\nDescription:\n    Checks if a given spectrum signal exists on the local machine.\n\nParameters:\n    0: _id : <STRING> - The id of the signal to check\n\nReturns:\n    <BOOL> - `true` if the signal exists on the local machine, `false` if not\n\nExamples:\n    (begin example)\n        private _signalExists = [\"KISKA_spectrumSignal_2_1\"] call KISKA_fnc_spectrum_signalExists\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_signalExists\";\n\nparams [\n\t[\"_id\",\"\",[\"\"]]\n];\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n(toLowerANSI _id) in _signalMap\n",
    "fileName": "fn_spectrum_signalExists.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_startSignalLoop\n\nDescription:\n    Handles starting a (sort of infinite) loop that will update a player's\n     spectrum device readings.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_spectrum_startSignalLoop;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_startSignalLoop\";\n\n#define SPECTRUM_WEAPON_CLASS \"hgun_esd_01\"\n#define SPECTRUM_GENERAL_CTRL_IDC 1999\n#define FREQUENCY_KEY \"_frequency\"\n#define ORIGIN_KEY \"_origin\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n#define DISTANCE_RATIO 0.65\n#define LOOP_TIME_WHEN_SEARCHING_FOR_DEVICE 3\n#define UPDATE_SIGNAL_EVERY 0.25\n\n// This function is less than ideal, but blame Bohemia's pretty abysmal implementation\n//  of the scripting interfaces with the spectrum analyzer.\n// And no, `destroy` and `unload` eventhandlers can not be used to mitigate this on the controls/displays for the thing.\n\nif (\n    !(hasInterface) OR \n    (localNamespace getVariable [\"KISKA_spectrum_updateLoopRunning\",false])\n) exitWith {};\n\nlocalNamespace setVariable [\"KISKA_spectrum_updateLoopRunning\",true];\n\n[\n    {\n        SPECTRUM_WEAPON_CLASS in (toLowerANSI (currentWeapon player))\n    },\n    {\t\n\n\n        [\n            [\"KISKA_spectrum_staged_transmit\",KISKA_fnc_spectrum_setTransmitting],\n            [\"KISKA_spectrum_staged_selectionWidth\",KISKA_fnc_spectrum_setSelectionWidth],\n            [\"KISKA_spectrum_staged_minFreq\",KISKA_fnc_spectrum_setMinFrequency],\n            [\"KISKA_spectrum_staged_minDecibels\",KISKA_fnc_spectrum_setMinDecibels],\n            [\"KISKA_spectrum_staged_maxFreq\",KISKA_fnc_spectrum_setMaxFrequency],\n            [\"KISKA_spectrum_staged_maxDecibels\",KISKA_fnc_spectrum_setMaxDecibels]\n        ] apply {\n            _x params [\"_varName\",\"_setter\"];\n            private _stagedValue = localNamespace getVariable [_varName,\"\"];\n            if (_stagedValue isEqualTo \"\") then { continue };\n\n            localNamespace setVariable [_varName,nil];\n            [_stagedValue] call _setter;\n        };\n \n\n        [\n            {\n                private _hasSpectrumDeviceEquipped = SPECTRUM_WEAPON_CLASS in (toLowerANSI (currentWeapon player));\n                if (!(alive player) OR !_hasSpectrumDeviceEquipped) exitWith {\n                    private _perframeId = _this select 1;\n                    [_perframeId] call CBA_fnc_removePerFrameHandler;\n                    localNamespace setVariable [\"KISKA_spectrum_updateLoopRunning\",false];\n                    call KISKA_fnc_spectrum_startSignalLoop;\n                };\n                \n                private _signalMap = call KISKA_fnc_spectrum_getSignalMap;\n                private _generatedSignalValues = [];\n                private _playerPositionASL = getPosASL player;\n                private _minDecibels = call KISKA_fnc_spectrum_getMinDecibels;\n                private _maxDecibels = call KISKA_fnc_spectrum_getMaxDecibels;\n                private _overallSignalRatioForDirection = 1 - DISTANCE_RATIO;\n                \n                _signalMap apply {\n                    private _maxDistance = _y get DISTANCE_KEY;\n                    private _origin = _y get ORIGIN_KEY;\n                    private _playerDistanceToSource = _playerPositionASL vectorDistance _origin;\n                    if (_playerDistanceToSource > _maxDistance) then {\n                        continue;\n                    };\n\n                    private _relativeDir = player getRelDir _origin;\n                    if ((_relativeDir > 90) AND (_relativeDir < 270)) then { continue };\n                    \n                    private \"_relativeDirScale\";\n                    if (_relativeDir <= 90) then {\n                        _relativeDirScale = _relativeDir\n                    } else {\n                        _relativeDirScale = 360 - _relativeDir;\n                    };\n\n                    private _frequency = _y get FREQUENCY_KEY;\n                    _generatedSignalValues pushBack _frequency;\n\n                    // Get the signal percentage of max based upon player's relative direction and distance\n                    private _percentageOfDistance = (1 - (_playerDistanceToSource / _maxDistance));\n                    private _percentageOfDirection = (1 - (_relativeDirScale / 90));\n                    \n                    private _percentageOfDistanceRatioed = _percentageOfDistance * DISTANCE_RATIO;\n                    private _percentageOfDirectionRatioed = _percentageOfDirection * _overallSignalRatioForDirection;\n\n                    private _currentSignalPercentage = _percentageOfDistanceRatioed + _percentageOfDirectionRatioed;\n                    \n                    private _baseSignalLevel = _y get DECIBEL_KEY;\n                    private _signalDecibelRange = _baseSignalLevel - _minDecibels;\n                    private _relativeSignalLevel = (_signalDecibelRange * _currentSignalPercentage) + _minDecibels;\n\n                    _generatedSignalValues pushBack _relativeSignalLevel;\n                };\n\n                missionNamespace setVariable [\"#EM_Values\", _generatedSignalValues];\n            },\n            UPDATE_SIGNAL_EVERY\n        ] call CBA_fnc_addPerFrameHandler;\n    },\n    LOOP_TIME_WHEN_SEARCHING_FOR_DEVICE\n] call KISKA_fnc_waitUntil;\n\n\nnil\n\n\n",
    "fileName": "fn_spectrum_startSignalLoop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_spectrum_updateSignal\n\nDescription:\n    Updates a signal's base properties for the local machine or creates it if it\n     did not exist prior. It is not recommended to directly create a signal with this\n     function. Rather use `KISKA_fnc_spectrum_addSignal`.\n\n    WARNING, this function updats ALL base properties. Meaning if you intend to\n     a single property, use the corresponding setter function. For example, to update\n     the origin position only and not every signal property, use \n     `KISKA_fnc_spectrum_setSignalPosition`.\n\nParameters:\n    0: _signalProperties : <ARRAY> - The all the properites of the signal\n\n        `_signalProperties` Layout:\n        - 0: _id <STRING> - The id of the signal to update\n        - 1: _frequency <NUMBER> - The frequency of the signal in MHz\n        - 2: _origin <OBJECT or PositionASL[]> - The position of the signal\n        - 3: _decibels <NUMBER> - The base signal decibel level when when near the origin\n        - 4: _maxDistance <NUMBER> - The max distance that the signal can be seen on the spectrum analyzer\n    \n    1: _global : <BOOL> - `true` to broadcast the changes to all machines including JIP\n\nReturns:\n    <HASHMAP> - Signal's updated property map:\n\n    - `_frequency`: <NUMBER> - The frequency of the signal in MHz\n    - `_origin`: <PositionASL[]> - The position of the signal\n    - `_maxDistance`: <NUMBER> - The maximum distance the signal can be seen on the analyzer\n    - `_decibels`: <NUMBER> - The max decibel level when the analyzer is directly on top of the origin\n\nExamples:\n    (begin example)\n        // should use KISKA_fnc_spectrum_updateSignal for snyched updates\n        // but if you only want a subset of machines:\n        [\n            [\n                \"KISKA_spectrumSignal_2_1\",\n                100,\n                [0,0,0],\n                100\n            ],\n            false\n        ] remoteExecCall [\n            \"KISKA_fnc_spectrum_updateSignal\",\n            [3,4]\n        ];\n    (end)\n\n    (begin example)\n        // broadcast to all machines by default\n        [\n            [\n                \"KISKA_spectrumSignal_2_1\",\n                100,\n                [0,0,0],\n                100\n            ]\n        ] call KISKA_fnc_spectrum_updateSignal;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_spectrum_updateSignal\";\n\n#define FREQUENCY_KEY \"_frequency\"\n#define DECIBEL_KEY \"_decibels\"\n#define DISTANCE_KEY \"_maxDistance\"\n#define ORIGIN_KEY \"_origin\"\n\nparams [\n    [\"_signalProperties\",[],[[]]],\n    [\"_global\",true,[true]]\n];\n\n_signalProperties params [\n    [\"_id\",\"\",[\"\"]],\n    [\"_frequency\",100,[123]],\n    [\"_origin\",objNull,[[],objNull],[3]],\n    [\"_decibels\",-100,[123]],\n    [\"_maxDistance\",worldSize,[123]]\n];\n\nif (_frequency <= 0) exitWith {\n    [\n        [\n            \"Signal can't be added, must have a frequency above 0, current is: \",\n            _frequency,\n            \". Signal being updated: \",\n            _id\n        ],\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\nprivate _originIsObject = _origin isEqualType objNull;\nif (_originIsObject AND {isNull _origin}) exitWith {\n    [[\"Provided origin is null object; attempting to update signal: \",_id],true] call KISKA_fnc_log;\n    nil\n};\n\nif (_maxDistance <= 0) exitWith {\n    [[\"Max distance must be positive number; attempting to update signal: \",_id],true] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_global AND isMultiplayer) then {\n    [\n        _signalProperties,\n        false\n    ] remoteExecCall [\"KISKA_fnc_spectrum_updateSignal\",-clientOwner,_id];\n};\n\n\nprivate _signalMap = call KISKA_fnc_spectrum_getSignalMap;\nprivate _idLowered = toLowerANSI _id;\nif (_originIsObject) then {\n    _origin = getPosASL _origin;\n};\n\n\nprivate _signalPropertyMap = _signalMap getOrDefaultCall [_idLowered,{-1}];\nprivate _signalExists = _signalPropertyMap isNotEqualTo -1;\nif (!_signalExists) then {\n    private _signalPropertyMap = createHashMapFromArray [\n        [FREQUENCY_KEY,_frequency],\n        [ORIGIN_KEY,_origin],\n        [DECIBEL_KEY,_decibels],\n        [DISTANCE_KEY,_maxDistance]\n    ];\n\n    _signalMap set [_idLowered,_signalPropertyMap];\n\n} else {\n    _signalPropertyMap set [FREQUENCY_KEY, _frequency];\n    _signalPropertyMap set [ORIGIN_KEY, _origin];\n    _signalPropertyMap set [DECIBEL_KEY, _decibels];\n    _signalPropertyMap set [DISTANCE_KEY, _maxDistance];\n\n};\n\ncall KISKA_fnc_spectrum_startSignalLoop;\n\n\n_signalMap\n",
    "fileName": "fn_spectrum_updateSignal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addCommMenuItem\n\nDescription:\n    This is an alias of sorts of Bohemia's BIS_fnc_addCommMenuItem.\n    It is mostly made with the purpose of using default values and specifically\n     passing a -1 by default to _expressionArguments.\n\n    Also initializes/adds entries to the KISKA_playersSupportMap which is used for\n     keeping track of the number of uses left on a support if they are passed between\n     the Support Manager.\n    \nParameters:\n    0: _owner <OBJECT> - The person to add the support to\n    1: _itemClass <STRING> - The class as defined in the CfgCommunicationMenu\n    2: _textArguements <ANY> - Any arguements to pass to the text displayed in the menu\n    3: _expressionArguments <ANY> - Any arguements to pass to the expression\n    4: _notification <STRING> - The class of notification to display when added\n    5: _addToHash <BOOL> - Add to KISKA_playersSupportMap\n\nReturns:\n    <NUMBER> - The comm menu ID\n\nExamples:\n    (begin example)\n        _id = [player,\"myClass\"] call KISKA_fnc_addCommMenuItem;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addCommMenuItem\";\n\nparams [\n    [\"_owner\",objNull,[objNull]],\n    [\"_itemClass\",\"\",[\"\"]],\n    [\"_textArguements\",\"\"],\n    [\"_expressionArguments\",-1,[]],\n    [\"_notification\",\"\",[\"\"]],\n    [\"_addToHash\",true,[true]]\n];\n\nprivate _id = [\n    _owner,\n    _itemClass,\n    _textArguements,\n    _expressionArguments,\n    _notification\n] call BIS_fnc_addCommMenuItem;\n\nif (!isNil \"_id\") then {\n    if (_addToHash) then {\n        if (isNil \"KISKA_playersSupportMap\") then {\n            KISKA_playersSupportMap = createHashMap;\n\n        };\n\n        KISKA_playersSupportMap set [_id,[_itemClass,_expressionArguments]];\n\n    };\n\n};\n\n\n_id\n",
    "fileName": "fn_addCommMenuItem.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Command Menu Macros.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_buildCommandMenu\n\nDescription:\n    Creates a showCommandingMenu compatible menu global array to be used with\n     KISKA_fnc_commandMenuTree.\n\n    This will be saved as a missionNamespace global var.\n\nParameters:\n    0: _menuName : <STRING> - The name of the menu global variable\n    1: _menuTitle : <STRING> - The title of the menu that will appear when it is openned\n    2: _menuParams : <ARRAY> - An array of arrays formatted as:\n        \n        - 0. <STRING> - The name of the menu option\n        - 1. <NUMBER> - The key code for quick menu select (key 1 is code 2, 2 is 3, etc. use 0 for no key)\n        - 2. <ANY> - The value to assign to this menu option\n\nReturns:\n    <ARRAY> - The created menu array\n\nExamples:\n    (begin example)\n        _createdMenu = [] call KISKA_fnc_buildCommandMenu\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_buildCommandMenu\";\n\nparams [\n    [\"_menuName\",\"\",[\"\"]],\n    [\"_menuTitle\",\"My Menu\",[\"\"]],\n    [\"_menuParams\",[],[[]]]\n];\n\nif (_menuName isEqualTo \"\") exitWith {\n    [\"_menuName is empty string! Exiting...\"] call KISKA_fnc_log;\n    []\n};\n\nif (!isNil _menuName) then {\n    [[\"WARNING: Overwriting \",_menuName,\" GVAR in missionNamespace!\"]] call KISKA_fnc_log;\n};\n\nif (_menuParams isEqualTo []) exitWith {\n    [\"_menuParams is empty array! Exiting...\"] call KISKA_fnc_log;\n    []\n};\n\n\nprivate _menuArray = [\n    [_menuTitle,false]\n];\n_menuParams apply {\n    STD_LINE(_x select 0,_x select 1,PUSHBACK_AND_PROCEED(_x select 2))\n};\n\n\nSAVE_AND_RETURN\n",
    "fileName": "fn_buildCommandMenu.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Command Menu Macros.hpp\"\n#include \"..\\Headers\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForArsenalSupplyDrop\n\nDescription:\n    Used as a means of expanding on the \"expression\" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n        \n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> - The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n        - 5. _supportType <NUMBER> - The Support Type ID\n\n    2: _count <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_callingForArsenalSupplyDrop;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callingForArsenalSupplyDrop\";\n\n#define ARSENAL_CRATE_TYPE \"B_supplyCrate_F\"\n#define FLYIN_RADIUS 2000\n#define ARSENAL_LIFETIME -1\n\nparams [\n    \"_supportClass\",\n    \"_commMenuArgs\",\n    [\"_useCount\",-1]\n];\n\n\nprivate _supportConfig = [[\"CfgCommunicationMenu\",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [[\"Could not find class: \",_supportClass,\" in any config!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _menuPathArray = [];\nprivate _menuVariables = []; // keeps track of global variable names to set to nil when done\n\n// get use count from config if -1\nprivate _args = _this; // just for readability\nprivate _useCountConfig = _supportConfig >> \"useCount\";\nif (_useCount < 0 AND (isNumber _useCountConfig)) then {\n    _useCount = getNumber _useCountConfig;\n    _args set [2,_useCount];\n};\n\n/* ----------------------------------------------------------------------------\n    Vehicle Select Menu\n---------------------------------------------------------------------------- */\nprivate _vehicles = [_supportConfig >> \"vehicleTypes\"] call BIS_fnc_getCfgDataArray;\nif (_vehicles isEqualTo []) then {\n    _vehicles = [side (_commMenuArgs select 0),_commMenuArgs select 5] call KISKA_fnc_getSupportVehicleClasses;\n};\n\nprivate _vehicleMenu = [_vehicles] call KISKA_fnc_createVehicleSelectMenu;\nSAVE_AND_PUSH(VEHICLE_SELECT_MENU_STR,_vehicleMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Bearings Menu\n---------------------------------------------------------------------------- */\n_bearingsMenu = BEARING_MENU;\n\nSAVE_AND_PUSH(BEARING_MENU_STR,_bearingsMenu)\n\n\n/* ----------------------------------------------------------------------------\n    flyInHeight Menu\n---------------------------------------------------------------------------- */\nprivate _flyInHeights = [_supportConfig >> \"flyinHeights\"] call BIS_fnc_getCfgDataArray;\nif (_flyInHeights isEqualTo []) then {\n    _flyInHeights = missionNamespace getVariable [\"KISKA_CBA_supp_flyInHeights_arr\",[]];\n\n    if (_flyInHeights isEqualTo []) then {\n        _flyInHeights = [50];\n    };\n};\n\nprivate _flyInHeightMenu = [\n    [\"Altitude\",false]\n];\n{\n    _flyInHeightMenu pushBackUnique DISTANCE_LINE(_x,0);\n} forEach _flyInHeights;\nSAVE_AND_PUSH(FLYIN_HEIGHT_MENU_STR,_flyInHeightMenu)\n\n\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu Path\n---------------------------------------------------------------------------- */\n_args pushBack _menuVariables;\n\n[\n    _menuPathArray,\n    [_args, {\n        params [\"_vehicleClass\",\"_approachBearing\",\"_flyinHeight\"];\n\n        private _useCount = _thisArgs select 2;\n        // if a ctrl key is held and one left clicks to select the support while in the map, they can call in an infinite number of the support\n        if (\n            visibleMap AND\n            (missionNamespace getVariable [\"KISKA_ctrlDown\",false])\n        ) exitWith {\n            [\"You can't call in a support while holding down a crtl key and in the map. It causes a bug with the support menu.\"] call KISKA_fnc_errorNotification;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        private _commMenuArgs = _thisArgs select 1;\n        private _dropPosition = _commMenuArgs select 1;\n\n        [\n            _dropPosition,\n            _vehicleClass,\n            [ARSENAL_CRATE_TYPE],\n            true,\n            true,\n            _flyinHeight,\n            _approachBearing,\n            FLYIN_RADIUS,\n            ARSENAL_LIFETIME,\n            side (_commMenuArgs select 0)\n        ] call KISKA_fnc_supplyDrop_aircraft;\n\n        [SUPPORT_TYPE_ARSENAL_DROP] call KISKA_fnc_supportNotification;\n\n        // if support still has uses left\n        if (_useCount > 1) then {\n            _useCount = _useCount - 1;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        UNLOAD_GLOBALS\n    }],\n    [_args, {\n        ADD_SUPPORT_BACK(_thisArgs select 2)\n        UNLOAD_GLOBALS\n    }]\n] spawn KISKA_fnc_commandMenuTree;\n\n\nnil\n",
    "fileName": "fn_callingForArsenalSupplyDrop.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Arty Ammo Classes.hpp\"\n#include \"..\\Headers\\Command Menu Macros.hpp\"\n#include \"..\\Headers\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForArty\n\nDescription:\n    Used as a means of expanding on the \"expression\" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n\n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n        - 5. _supportType <NUMBER> - The Support Type ID\n\n    2: _roundCount <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_callingForArty;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callingForArty\";\n\n#define AMMO_TYPE_MENU_GVAR \"KISKA_menu_ammoSelect\"\n#define ROUND_COUNT_MENU_GVAR \"KISKA_menu_roundCount\"\n#define RADIUS_MENU_GVAR \"KISKA_menu_radius\"\n#define MIN_RADIUS 0\n\n\nparams [\n    \"_supportClass\",\n    \"_commMenuArgs\",\n    \"_roundCount\"\n];\n\n\nprivate _supportConfig = [[\"CfgCommunicationMenu\",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [[\"Could not find class: \",_supportClass,\" in any config!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _menuPathArray = [];\nprivate _menuVariables = []; // keeps track of global variable names to set to nil when done\n\n\n/* ----------------------------------------------------------------------------\n    Ammo Menu\n---------------------------------------------------------------------------- */\nprivate _ammoMenu = [\n    [\"Select Ammo\",false] // menu title\n];\n// get allowed ammo types from config\nprivate _ammoIds = [_supportConfig >> \"ammoTypes\"] call BIS_fnc_getCfgDataArray;\n\n// create formatted array to use in menu\nprivate [\"_ammoClass\",\"_ammoTitle\",\"_keyCode\"];\n{\n    if (_forEachIndex <= MAX_KEYS) then {\n        // key codes are offset by 2 (1 on the number bar is key code 2)\n        _keyCode = _forEachIndex + 2;\n    } else {\n        _keyCode = 0;\n    };\n\n    // handling custom ammo types\n    if (_x isEqualType []) then {\n        _ammoClass = _x select 0;\n        _ammoTitle = _x select 1;\n\n    } else {\n        _ammoClass = [_x] call KISKA_fnc_getAmmoClassFromId;\n        _ammoTitle = [_x] call KISKA_fnc_getAmmoTitleFromId;\n\n    };\n\n\n    _ammoMenu pushBack STD_LINE_PUSH(_ammoTitle,_keyCode,_ammoClass);\n} forEach _ammoIds;\n\nSAVE_AND_PUSH(AMMO_TYPE_MENU_GVAR,_ammoMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Radius Menu\n---------------------------------------------------------------------------- */\nprivate _selectableRadiuses = [_supportConfig >> \"radiuses\"] call BIS_fnc_getCfgDataArray;\nif (_selectableRadiuses isEqualTo []) then {\n    _selectableRadiuses = missionNamespace getVariable [\"KISKA_CBA_supp_radiuses_arr\",[]];\n\n    if (_selectableRadiuses isEqualTo []) then {\n        _selectableRadiuses = [200];\n    };\n};\n\nprivate _radiusMenu = [\n    [\"Area Spread\",false] // title\n];\nprivate _keyCode = 0;\nprivate _pushedMinRadius = false;\nprivate _lasUsedIndex = 0;\n{\n    private _isMinRadius = _x <= MIN_RADIUS;\n    if (_pushedMinRadius AND _isMinRadius) then {\n        continue;\n    };\n\n    if (_lasUsedIndex <= MAX_KEYS) then {\n        // key codes are offset by 2 (1 on the number bar is key code 2)\n        _keyCode = _lasUsedIndex + 2;\n        _lasUsedIndex = _lasUsedIndex + 1;\n\n    } else {\n        // zero key code means that it has no key to press to activate it\n        _keyCode = 0;\n\n    };\n\n\n    if (_isMinRadius) then {\n        _pushedMinRadius = true;\n        _radiusMenu pushBack DISTANCE_LINE(MIN_RADIUS,_keyCode);\n        continue;\n    };\n\n    _radiusMenu pushBack DISTANCE_LINE(_x,_keyCode);\n\n} forEach _selectableRadiuses;\n\nSAVE_AND_PUSH(RADIUS_MENU_GVAR,_radiusMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Round Count Menu\n---------------------------------------------------------------------------- */\nprivate _roundsMenu = [\n    [\"Number of Rounds\",false]\n];\nprivate _canSelectRounds = [_supportConfig >> \"canSelectRounds\"] call BIS_fnc_getCfgDataBool;\n// get default round count from config\nprivate _args = _this; // just for readability\nif (_roundCount < 0) then {\n    _roundCount = [_supportConfig >> \"roundCount\"] call BIS_fnc_getCfgData;\n    _args set [2,_roundCount]; // update round count to be passed to KISKA_fnc_commandMenuTree\n};\n\nprivate _roundsString = \"\";\nif (_canSelectRounds) then {\n    for \"_i\" from 1 to _roundCount do {\n        if (_i <= MAX_KEYS) then {\n            _keyCode = _i + 1;\n        } else {\n            _keyCode = 0;\n        };\n        _roundsString = [_i,\"Round(s)\"] joinString \" \";\n        _roundsMenu pushBack STD_LINE_PUSH(_roundsString,_keyCode,_i);\n    };\n\n} else {\n    _roundsString = [_roundCount,\"Round(s)\"] joinString \" \";\n    _roundsMenu pushBack STD_LINE_PUSH(_roundsString,2,_roundCount);\n\n};\n\nSAVE_AND_PUSH(ROUND_COUNT_MENU_GVAR,_roundsMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu\n---------------------------------------------------------------------------- */\n_args pushBack _menuVariables;\n\n\n[\n    _menuPathArray,\n    [_args, {\n        params [\"_ammo\",\"_radius\",\"_numberOfRounds\"];\n\n        private _roundsAvailable = _thisArgs select 2;\n        // if a ctrl key is held and one left clicks to select the support while in the map, they can call in an infinite number of the support\n        if (\n            visibleMap AND\n            (missionNamespace getVariable [\"KISKA_ctrlDown\",false])\n        ) exitWith {\n            [\"You can't call in a support while holding down a crtl key and in the map. It causes a bug with the support menu.\"] call KISKA_fnc_errorNotification;\n            ADD_SUPPORT_BACK(_roundsAvailable)\n        };\n\n        private _commMenuArgs = _thisArgs select 1;\n        private _targetPosition = _commMenuArgs select 1;\n        [_targetPosition,_ammo,_radius,_numberOfRounds] spawn KISKA_fnc_virtualArty;\n\n        [SUPPORT_TYPE_ARTY] call KISKA_fnc_supportNotification;\n\n        // if support still has rounds available, add it back with the new round count\n        if (_numberOfRounds < _roundsAvailable) then {\n            _roundsAvailable = _roundsAvailable - _numberOfRounds;\n            ADD_SUPPORT_BACK(_roundsAvailable)\n        };\n\n        UNLOAD_GLOBALS\n    }],\n    [_args, {\n        ADD_SUPPORT_BACK(_thisArgs select 2)\n        UNLOAD_GLOBALS\n    }]\n] spawn KISKA_fnc_commandMenuTree;\n\n\nnil\n",
    "fileName": "fn_callingForArty.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Command Menu Macros.hpp\"\n#include \"..\\Headers\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForCAS\n\nDescription:\n    Used as a means of expanding on the \"expression\" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n        \n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n        - 5. _supportType <NUMBER> - The Support Type ID\n\n    2: _useCount <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_callingForCAS;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callingForCAS\";\n\n#define MIN_RADIUS 200\n\nparams [\n    \"_supportClass\",\n    \"_commMenuArgs\",\n    [\"_useCount\",-1]\n];\n\n\nprivate _supportConfig = [[\"CfgCommunicationMenu\",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [[\"Could not find class: \",_supportClass,\" in any config!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n// get use count from config if -1\nprivate _args = _this; // just for readability\nprivate _useCountConfig = _supportConfig >> \"useCount\";\nif (_useCount < 0 AND (isNumber _useCountConfig)) then {\n    _useCount = getNumber _useCountConfig;\n    _args set [2,_useCount];\n};\n\nprivate _menuPathArray = [];\nprivate _menuVariables = []; // keeps track of global variable names to set to nil when done\n\n\n/* ----------------------------------------------------------------------------\n    Vehicle Select Menu\n---------------------------------------------------------------------------- */\nprivate _vehicles = [_supportConfig >> \"vehicleTypes\"] call BIS_fnc_getCfgDataArray;\nif (_vehicles isEqualTo []) then {\n    _vehicles = [side (_commMenuArgs select 0),_commMenuArgs select 5] call KISKA_fnc_getSupportVehicleClasses;\n};\n\nprivate _vehicleMenu = [_vehicles] call KISKA_fnc_createVehicleSelectMenu;\nSAVE_AND_PUSH(VEHICLE_SELECT_MENU_STR,_vehicleMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Attack Type Menu\n---------------------------------------------------------------------------- */\nprivate _attackTypeMenu = [\n    [\"Attack Type\",false]\n];\n// get allowed ammo types from config\nprivate _attackTypes = [_supportConfig >> \"attackTypes\"] call BIS_fnc_getCfgDataArray;\n\n// create formatted array to use in menu\nprivate [\"_casTitle\",\"_keyCode\"];\n{\n    if (_forEachIndex <= MAX_KEYS) then {\n        // key codes are offset by 2 (1 on the number bar is key code 2)\n        _keyCode = _forEachIndex + 2;\n    } else {\n        _keyCode = 0;\n    };\n\n    if (_x isEqualType []) then { // custom magazine pylons will be arrays\n        // if a custom name was given in the config array for the custom ammo\n        if ((count _x) > 2) then {\n            _casTitle = _x select 2;\n        } else {\n            _casTitle = [configFile >> \"CfgMagazines\" >> (_x select 1)] call BIS_fnc_displayName;\n        };\n    } else {\n        _casTitle = [_x] call KISKA_fnc_getCasTitleFromId;\n    };\n\n    _attackTypeMenu pushBack STD_LINE_PUSH(_casTitle,_keyCode,_x);\n\n} forEach _attackTypes;\n\nSAVE_AND_PUSH(ATTACK_TYPE_MENU_STR,_attackTypeMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Bearings Menu\n---------------------------------------------------------------------------- */\n_bearingsMenu = BEARING_MENU;\n\nSAVE_AND_PUSH(BEARING_MENU_STR,_bearingsMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu Path\n---------------------------------------------------------------------------- */\n_args pushBack _menuVariables;\n\n\n[\n    _menuPathArray,\n    [_args, {\n        params [\"_vehicleClass\",\"_attackType\",\"_approachBearing\"];\n\n        private _useCount = _thisArgs select 2;\n        // if a ctrl key is held and one left clicks to select the support while in the map, they can call in an infinite number of the support\n        if (\n            visibleMap AND\n            (missionNamespace getVariable [\"KISKA_ctrlDown\",false])\n        ) exitWith {\n            [\"You can't call in a support while holding down a crtl key and in the map. It causes a bug with the support menu.\"] call KISKA_fnc_errorNotification;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        private _commMenuArgs = _thisArgs select 1;\n        private _targetPosition = _commMenuArgs select 1;\n        [\n            AGLToASL _targetPosition,\n            _attackType,\n            _approachBearing,\n            _vehicleClass,\n            side (_commMenuArgs select 0)\n        ] call KISKA_fnc_CAS;\n\n        [SUPPORT_TYPE_CAS] call KISKA_fnc_supportNotification;\n\n        // if support still has uses left\n        if (_useCount > 1) then {\n            _useCount = _useCount - 1;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        UNLOAD_GLOBALS\n    }],\n    [_args, {\n        ADD_SUPPORT_BACK(_thisArgs select 2)\n        UNLOAD_GLOBALS\n    }]\n] spawn KISKA_fnc_commandMenuTree;\n\n\nnil\n",
    "fileName": "fn_callingForCAS.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Command Menu Macros.hpp\"\n#include \"..\\Headers\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForHelicopterCAS\n\nDescription:\n    Used as a means of expanding on the \"expression\" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n        \n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> - The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n        - 5. _supportType <NUMBER> - The Support Type ID\n\n    2: _count <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_callingForHelicopterCAS;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callingForHelicopterCAS\";\n\n#define MIN_RADIUS 200\n#define SPEED_LIMIT 10\n\nparams [\n    \"_supportClass\",\n    \"_commMenuArgs\",\n    [\"_useCount\",-1]\n];\n\n\nprivate _supportConfig = [[\"CfgCommunicationMenu\",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [[\"Could not find class: \",_supportClass,\" in any config!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _menuPathArray = [];\nprivate _menuVariables = []; // keeps track of global variable names to set to nil when done\n\n// get use count from config if -1\nprivate _args = _this; // just for readability\nprivate _useCountConfig = _supportConfig >> \"useCount\";\nif (_useCount < 0 AND (isNumber _useCountConfig)) then {\n    _useCount = getNumber _useCountConfig;\n    _args set [2,_useCount];\n};\n\n/* ----------------------------------------------------------------------------\n    Vehicle Select Menu\n---------------------------------------------------------------------------- */\nprivate _vehicles = [_supportConfig >> \"vehicleTypes\"] call BIS_fnc_getCfgDataArray;\nif (_vehicles isEqualTo []) then {\n    _vehicles = [side (_commMenuArgs select 0),_commMenuArgs select 5] call KISKA_fnc_getSupportVehicleClasses;\n};\n\nprivate _vehicleMenu = [_vehicles] call KISKA_fnc_createVehicleSelectMenu;\nSAVE_AND_PUSH(VEHICLE_SELECT_MENU_STR,_vehicleMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Bearings Menu\n---------------------------------------------------------------------------- */\n_bearingsMenu = BEARING_MENU;\n\nSAVE_AND_PUSH(BEARING_MENU_STR,_bearingsMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Radius Menu\n---------------------------------------------------------------------------- */\nprivate _selectableRadiuses = [_supportConfig >> \"radiuses\"] call BIS_fnc_getCfgDataArray;\nif (_selectableRadiuses isEqualTo []) then {\n    _selectableRadiuses = missionNamespace getVariable [\"KISKA_CBA_supp_radiuses_arr\",[]];\n\n    if (_selectableRadiuses isEqualTo []) then {\n        _selectableRadiuses = [200];\n    };\n};\n\nprivate _radiusMenu = [\n    [\"Engagment Area\",false]\n];\nprivate _keyCode = 0;\nprivate _pushedMinRadius = false;\nprivate _lasUsedIndex = 0;\n{\n    private _isMinRadius = _x <= MIN_RADIUS;\n    if (_pushedMinRadius AND _isMinRadius) then {\n        continue;\n    };\n\n    if (_lasUsedIndex <= MAX_KEYS) then {\n        // key codes are offset by 2 (1 on the number bar is key code 2)\n        _keyCode = _lasUsedIndex + 2;\n        _lasUsedIndex = _lasUsedIndex + 1;\n\n    } else {\n        // zero key code means that it has no key to press to activate it\n        _keyCode = 0;\n\n    };\n\n\n    if (_isMinRadius) then {\n        _pushedMinRadius = true;\n        _radiusMenu pushBack DISTANCE_LINE(MIN_RADIUS,_keyCode);\n        continue;\n    };\n\n    _radiusMenu pushBack DISTANCE_LINE(_x,_keyCode);\n\n} forEach _selectableRadiuses;\nSAVE_AND_PUSH(RADIUS_MENU_STR,_radiusMenu)\n\n\n/* ----------------------------------------------------------------------------\n    flyInHeight Menu\n---------------------------------------------------------------------------- */\nprivate _flyInHeights = [_supportConfig >> \"flyinHeights\"] call BIS_fnc_getCfgDataArray;\nif (_flyInHeights isEqualTo []) then {\n    _flyInHeights = missionNamespace getVariable [\"KISKA_CBA_supp_flyInHeights_arr\",[]];\n\n    if (_flyInHeights isEqualTo []) then {\n        _flyInHeights = [50];\n    };\n};\n\nprivate _flyInHeightMenu = [\n    [\"Altitude\",false]\n];\n{\n    _flyInHeightMenu pushBackUnique DISTANCE_LINE(_x,0);\n} forEach _flyInHeights;\nSAVE_AND_PUSH(FLYIN_HEIGHT_MENU_STR,_flyInHeightMenu)\n\n\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu Path\n---------------------------------------------------------------------------- */\n_args pushBack _menuVariables;\n\nprivate _timeOnStation = [_supportConfig >> \"timeOnStation\"] call BIS_fnc_getCfgData;\n_args pushBack _timeOnStation;\n\n[\n    _menuPathArray,\n    [_args, {\n        params [\"_vehicleClass\",\"_approachBearing\",\"_attackRadius\",\"_flyinHeight\"];\n\n        private _useCount = _thisArgs select 2;\n        // if a ctrl key is held and one left clicks to select the support while in the map, they can call in an infinite number of the support\n        if (\n            visibleMap AND\n            (missionNamespace getVariable [\"KISKA_ctrlDown\",false])\n        ) exitWith {\n            [\"You can't call in a support while holding down a crtl key and in the map. It causes a bug with the support menu.\"] call KISKA_fnc_errorNotification;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        private _commMenuArgs = _thisArgs select 1;\n        private _targetPosition = _commMenuArgs select 1;\n        private _timeOnStation = _thisArgs select 4;\n        [\n            _targetPosition,\n            _attackRadius,\n            _vehicleClass,\n            _timeOnStation,\n            SPEED_LIMIT,\n            _flyinHeight,\n            _approachBearing,\n            side (_commMenuArgs select 0) // caller side\n        ] spawn KISKA_fnc_helicopterGunner;\n\n        [SUPPORT_TYPE_HELI_CAS] call KISKA_fnc_supportNotification;\n\n        // if support still has uses left\n        if (_useCount > 1) then {\n            _useCount = _useCount - 1;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        UNLOAD_GLOBALS\n    }],\n    [_args, {\n        ADD_SUPPORT_BACK(_thisArgs select 2)\n        UNLOAD_GLOBALS\n    }]\n] spawn KISKA_fnc_commandMenuTree;\n\n\nnil\n",
    "fileName": "fn_callingForHelicopterCAS.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Command Menu Macros.hpp\"\n#include \"..\\Headers\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForSupplyDrop_aircraft\n\nDescription:\n    Used as a means of expanding on the \"expression\" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n        \n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> - The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n        - 5. _supportType <NUMBER> - The Support Type ID\n\n    2: _count <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_callingForSupplyDrop_aircraft;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callingForSupplyDrop_aircraft\";\n\n#define FLYIN_RADIUS 2000\n#define ARSENAL_LIFETIME -1\n\nparams [\n    \"_supportClass\",\n    \"_commMenuArgs\",\n    [\"_useCount\",-1]\n];\n\n\nprivate _supportConfig = [[\"CfgCommunicationMenu\",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [[\"Could not find class: \",_supportClass,\" in any config!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _menuPathArray = [];\nprivate _menuVariables = []; // keeps track of global variable names to set to nil when done\n\n// get use count from config if -1\nprivate _args = _this; // just for readability\nprivate _useCountConfig = _supportConfig >> \"useCount\";\nif (_useCount < 0 AND (isNumber _useCountConfig)) then {\n    _useCount = getNumber _useCountConfig;\n    _args set [2,_useCount];\n};\n\n/* ----------------------------------------------------------------------------\n    Vehicle Select Menu\n---------------------------------------------------------------------------- */\nprivate _vehicles = [_supportConfig >> \"vehicleTypes\"] call BIS_fnc_getCfgDataArray;\nif (_vehicles isEqualTo []) then {\n    // caller side & _supportType id\n    _vehicles = [side (_commMenuArgs select 0),_commMenuArgs select 5] call KISKA_fnc_getSupportVehicleClasses;\n};\n\nprivate _vehicleMenu = [_vehicles] call KISKA_fnc_createVehicleSelectMenu;\nSAVE_AND_PUSH(VEHICLE_SELECT_MENU_STR,_vehicleMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Bearings Menu\n---------------------------------------------------------------------------- */\n_bearingsMenu = BEARING_MENU;\n\nSAVE_AND_PUSH(BEARING_MENU_STR,_bearingsMenu)\n\n\n/* ----------------------------------------------------------------------------\n    flyInHeight Menu\n---------------------------------------------------------------------------- */\nprivate _flyInHeights = [_supportConfig >> \"flyinHeights\"] call BIS_fnc_getCfgDataArray;\nif (_flyInHeights isEqualTo []) then {\n    _flyInHeights = missionNamespace getVariable [\"KISKA_CBA_supp_flyInHeights_arr\",[]];\n\n    if (_flyInHeights isEqualTo []) then {\n        _flyInHeights = [50];\n    };\n};\n\nprivate _flyInHeightMenu = [\n    [\"Altitude\",false]\n];\n_flyInHeights apply {\n    _flyInHeightMenu pushBackUnique DISTANCE_LINE(_x,0);\n};\n\nSAVE_AND_PUSH(FLYIN_HEIGHT_MENU_STR,_flyInHeightMenu)\n\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu Path\n---------------------------------------------------------------------------- */\n_args pushBack _menuVariables;\n\n_args pushBack ([_supportConfig >> \"crateList\"] call BIS_fnc_getCfgDataArray);\n_args pushBack ([_supportConfig >> \"deleteCargo\"] call BIS_fnc_getCfgDataBool);\n_args pushBack ([_supportConfig >> \"addArsenals\"] call BIS_fnc_getCfgDataBool);\n\n\n[\n    _menuPathArray,\n    [_args, {\n        params [\"_vehicleClass\",\"_approachBearing\",\"_flyinHeight\"];\n\n        private _useCount = _thisArgs select 2;\n        // if a ctrl key is held and one left clicks to select the support while in the map, they can call in an infinite number of the support\n        if (\n            visibleMap AND\n            (missionNamespace getVariable [\"KISKA_ctrlDown\",false])\n        ) exitWith {\n            [\"You can't call in a support while holding down a crtl key and in the map. It causes a bug with the support menu.\"] call KISKA_fnc_errorNotification;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        private _commMenuArgs = _thisArgs select 1;\n        private _dropPosition = _commMenuArgs select 1;\n\n        private _crateList = _thisArgs select 4;\n        private _deleteCargo = _thisArgs select 5;\n        private _addArsenals = _thisArgs select 6;\n\n        [\n            _dropPosition,\n            _vehicleClass,\n            _crateList,\n            _deleteCargo,\n            _addArsenals,\n            _flyinHeight,\n            _approachBearing,\n            FLYIN_RADIUS,\n            ARSENAL_LIFETIME,\n            side (_commMenuArgs select 0)\n        ] call KISKA_fnc_supplyDrop_aircraft;\n\n        [SUPPORT_TYPE_SUPPLY_DROP_AIRCRAFT] call KISKA_fnc_supportNotification;\n\n        // if support still has uses left\n        if (_useCount > 1) then {\n            _useCount = _useCount - 1;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        UNLOAD_GLOBALS\n    }],\n    [_args, {\n        ADD_SUPPORT_BACK(_thisArgs select 2)\n        UNLOAD_GLOBALS\n    }]\n] spawn KISKA_fnc_commandMenuTree;\n\n\nnil\n",
    "fileName": "fn_callingForSupplyDrop_aircraft.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Command Menu Macros.hpp\"\n#include \"..\\Headers\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForSupportMaster\n\nDescription:\n    Used as a means of expanding on the \"expression\" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n        \n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n\n    2: _count <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"myClass\",_this] call KISKA_fnc_callingForSupportMaster;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callingForSupportMaster\";\n\nparams [\n    [\"_supportClass\",\"\",[\"\"]],\n    \"_commMenuArgs\",\n    [\"_count\",-1]\n];\n\n// delete comm menu id from use hash\nKISKA_playersSupportMap deleteAt (_commMenuArgs select 4);\n\nprivate _supportConfig = [[\"CfgCommunicationMenu\",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [[\"Did not find a support class matching \",_supportClass,\" in any CfgCommunicationMenu config\"],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _supportTypeId = [_supportConfig >> \"supportTypeId\"] call BIS_fnc_getCfgData;\nif (isNil \"_supportTypeId\") exitWith {\n    [[\"Did not find a support _supportTypeId for CfgCommunicationMenu class \",_supportClass],true] call KISKA_fnc_log;\n    nil\n};\n\n_commMenuArgs pushBack _supportTypeId;\n\nif (_supportTypeId isEqualTo SUPPORT_TYPE_ARTY) exitWith {\n    _this call KISKA_fnc_callingForArty;\n};\n\nif (_supportTypeId isEqualTo SUPPORT_TYPE_SUPPLY_DROP) exitWith {\n\n};\n\nif (\n    (_supportTypeId isEqualTo SUPPORT_TYPE_HELI_CAS) OR\n    (_supportTypeId isEqualTo SUPPORT_TYPE_ATTACKHELI_CAS)\n) exitWith {\n    _this call KISKA_fnc_callingForHelicopterCAS;\n};\n\nif (_supportTypeId isEqualTo SUPPORT_TYPE_CAS) exitWith {\n    _this call KISKA_fnc_callingForCAS;\n};\n\nif (_supportTypeId isEqualTo SUPPORT_TYPE_ARSENAL_DROP) exitWith {\n    _this call KISKA_fnc_callingForArsenalSupplyDrop;\n};\n\nif (_supportTypeId isEqualTo SUPPORT_TYPE_SUPPLY_DROP_AIRCRAFT) exitWith {\n    _this call KISKA_fnc_callingForSupplyDrop_aircraft;\n};\n\n\n\n/*\n_commMenuArgs params [\n    \"_caller\",\n    \"_targetPosition\",\n    \"_target\",\n    \"_is3d\",\n    \"_commMenuId\"\n];\n*/\n\n[[\"Unknown _supportTypeId (\",_supportTypeId,\") used with _supportClass \",_supportClass],true] call KISKA_fnc_log;\n\nnil\n",
    "fileName": "fn_callingForSupportMaster.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_commandMenuTree\n\nDescription:\n    Creates a command menu tree dynamically instead of needing to define sub menus\n\nParameters:\n    0: _menuPath <ARRAY> - The menu global variable paths (in order)\n    1: _endExpression <STRING, CODE, or ARRAY> - The code to be executed at the end of the path.\n        It receives all menu parameters in _this. (see KISKA_fnc_callBack)\n    2: _exitExpression <STRING, CODE, or ARRAY> - The code to be executed in the event that\n        the menu is closed by the player. It gets all added params up to that point in _this.\n        (see KISKA_fnc_callBack)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            [\"#USER:myMenu_1\",\"#USER:myMenu_2\"],\n            \"hint str _this\"\n        ] spawn KISKA_fnc_commandMenuTree\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_commandMenuTree\";\n\nif (!hasInterface) exitWith {\n    [\"Can only run on machines with interface\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled, exiting to scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_commandMenuTree;\n};\n\nparams [\n    [\"_menuPath\",[],[[]]],\n    [\"_endExpression\",\"\",[\"\",{},[]]],\n    [\"_exitExpression\",\"\",[\"\",{},[]]]\n];\n\n// create a container for holding params from menu\nlocalNamespace setVariable [\"KISKA_commMenuTree_params\",[]];\n\nprivate _menuWasClosed = false;\n_menuPath apply {\n    // proceed immediatetly if only one option is in custom menu\n    private _menuName = toLower _x;\n\n    // #user: prepended on the menu name denotes a custom menu\n    // The menu options are saved to a global variable in the missionNamespace\n    /// that is the menu's name, minus the \"\"#user:\"\n    /// e.g. a menu with the name \"#USER:MY_SUBMENU_inCommunication\" would be\n    /// saved to a global variable MY_SUBMENU_inCommunication\n    _menuName = _menuName trim [\"#user:\",1];\n    if (_menuName != _x) then {\n        private _menuOptions = missionNamespace getVariable [_menuName,[]];\n        // _menuOptions will include the title at the start of the array, therefore, multiple actual options means at least 3 entries\n        if (count _menuOptions < 3) then {\n            // format of an option\n            // [\"Submenu\", [3], \"#USER:MY_SUBMENU_inCommunication\", -5, [[\"expression\", \"player sidechat \"\"Submenu\"\" \"]], \"1\", \"1\"]\n            private _singleMenuOption = _menuOptions select 1;\n            private _expression = ((_singleMenuOption select 4) select 0) select 1;\n            [] call (compile _expression);\n\n            continue;\n        };\n    };\n\n    // keeps track of whether or not to open the next menu\n    localNamespace setVariable [\"KISKA_commMenuTree_proceedToNextMenu\",false];\n    showCommandingMenu _x;\n    // wait for player to select and option from the current menu or for them to close the menu\n    waitUntil {\n        if (localNamespace getVariable \"KISKA_commMenuTree_proceedToNextMenu\") exitWith {true};\n        _menuWasClosed = commandingMenu isEqualTo \"\";\n        _menuWasClosed\n    };\n    if (_menuWasClosed) then {break};\n};\n\nprivate _params = localNamespace getVariable \"KISKA_commMenuTree_params\";\nprivate \"_expression\";\nif (_menuWasClosed) then {\n    _expression = _exitExpression;\n} else {\n    _expression = _endExpression;\n};\n\n[_params, _expression] call KISKA_fnc_callBack;\n\n\nlocalNamespace setVariable [\"KISKA_commMenuTree_params\",nil];\nlocalNamespace setVariable [\"KISKA_commMenuTree_proceedToNextMenu\",nil];\n",
    "fileName": "fn_commandMenuTree.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Command Menu Macros.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_createVehicleSelectMenu\n\nDescription:\n    Creates an array to be used with showCommandingMenu.\n    Specifically, this is to provide class names to the command menu and then\n     allow a player to select a class from the menu such as when requesting CAS.\n\nParameters:\n    0: _classes : <STRING[]> - The class names to add to the list (in the order to appear)\n\nReturns:\n    <ARRAY> - The created array\n\nExamples:\n    (begin example)\n        _menuArray = [\n            [\"B_Heli_Transport_01_F\",\"B_Heli_Attack_01_dynamicLoadout_F\"]\n        ] call KISKA_fnc_createClassSelectMenu;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_createVehicleSelectMenu\";\n\n#define CLASS_ARRAY(DISPLAY_NAME,CLASS) [DISPLAY_NAME,[0],\"\",CMD_EXECUTE,[[\"expression\", PUSHBACK_AND_PROCEED(CLASS)]], IS_ACTIVE, IS_VISIBLE]\n\nparams [\"_classes\"];\n\nif (_classes isEqualTo []) exitWith {\n    [\"_classes is empty array\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _formattedArray = [\n    [\"Vehicle Selection\",false]\n];\nprivate \"_displayName\";\n_classes apply {\n    _displayName = [configFile >> \"cfgVehicles\" >> _x] call BIS_fnc_displayName;\n    _formattedArray pushBack CLASS_ARRAY(_displayName,_x);\n};\n\n\n_formattedArray\n",
    "fileName": "fn_createVehicleSelectMenu.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_detectControlKeys\n\nDescription:\n    Arma 3's support system currently has a bug that allows players to call in\n     multiple supports by having the map open and holding down a ctrl key and left\n     - clicking while in the support menu. Each click will call in a support.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        PRE-INIT Function\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_detectControlKeys\";\n\n#define LEFT_CTRL_CODE 29\n#define RIGHT_CTRL_CODE 157\n\nif (!hasInterface) exitWith {};\n\nif (call KISKA_fnc_isMainMenu) exitWith {\n    [\"Main menu detected, will not init\",false] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled, exiting to scheduled...\",false] call KISKA_fnc_log;\n    [] spawn KISKA_fnc_detectControlKeys;\n};\n\n\nif ([\"ace_interact_menu\"] call KISKA_fnc_isPatchLoaded) then {\n    [\n        \"ace_interactMenuClosed\",\n        {\n            params [\"_menuType\"];\n\n            //diag_log \"(ACE EVENT) ACE interact menu is closed\";\n\n            // making sure _menuType is the seld interact menu\n            if (missionNamespace getVariable [\"KISKA_ctrlDown\",false] AND {_menuType isEqualTo 1}) then {\n                //hint \"(ACE EVENT) KISKA_ctrlDown is true, setting to false\";\n                //diag_log \"(ACE EVENT) KISKA_ctrlDown is true, setting to false\";\n\n                missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n            };\n        }\n    ] call CBA_fnc_addeventhandler;\n};\n\n\nwaitUntil {\n    if !(isNull (findDisplay 46)) exitWith {true};\n    [\"Looping for Display\",false] call KISKA_fnc_log;\n    sleep 0.1;\n    false\n};\n\n[\"Found display, loop ended\",false] call KISKA_fnc_log;\n\n\n(findDisplay 46) displayAddEventHandler [\"KeyDown\",{\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    // if a key other then a ctrl is pressed without ctrl down\n    if (!_ctrl AND {_key isNotEqualTo LEFT_CTRL_CODE} AND {_key isNotEqualTo RIGHT_CTRL_CODE}) then {\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        };\n\n    } else { // if ctrl is pressed\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        };\n    };\n\n\n    nil\n}];\n\n(findDisplay 46) displayAddEventHandler [\"KeyUp\",{\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    // if a key other then a ctrl is released without ctrl down OR the released key is a ctrl key\n    if (!_ctrl OR {_key isEqualTo LEFT_CTRL_CODE} OR {_key isEqualTo RIGHT_CTRL_CODE}) then {\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        };\n    } else { // if ctrl is still down or the released key is not a ctrl key\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        };\n    };\n\n\n    nil\n}];\n\n\n\n\n\n\n\n\n// debug code\n/*\n(findDisplay 46) displayAddEventHandler [\"KeyDown\",{\n    //params [\"\", \"_key\", \"\", \"_ctrl\", \"\"];\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    hint \"key down\";\n    diag_log \"------------------------------------------\";\n    diag_log \"Key down\";\n\n    // if a key other then a ctrl is pressed without ctrl down\n    if (!_ctrl AND {_key isNotEqualTo LEFT_CTRL_CODE} AND {_key isNotEqualTo RIGHT_CTRL_CODE}) then {\n        hint \"_ctrl is false (key-down)\";\n        diag_log \"_ctrl is false (key-down)\";\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            hint \"KISKA_ctrlDown is true (key-down), setting it to false\";\n            diag_log \"KISKA_ctrlDown is true (key-down), setting it to false\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        } else {\n            hint \"KISKA_ctrlDown is false (key-down) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is false (key-down) and it will remain so\";\n        };\n    } else { // if ctrl is pressed\n        hint \"_ctrl is true (key-down)\";\n        diag_log \"_ctrl is true (key-down)\";\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            hint \"KISKA_ctrlDown is false (key-down), setting it to true\";\n            diag_log \"KISKA_ctrlDown is false (key-down), setting it to true\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        } else {\n            hint \"KISKA_ctrlDown is true (key-down) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is true (key-down) and it will remain so\";\n        };\n    };\n\n\n    nil\n}];\n\n(findDisplay 46) displayAddEventHandler [\"KeyUp\",{\n    //params [\"\", \"_key\", \"\", \"_ctrl\", \"\"];\n    private _key = _this select 1;\n    private _ctrl = _this select 3;\n\n    hint \"key up\";\n    diag_log \"------------------------------------------\";\n    diag_log \"Key up\";\n\n    // if a key other then a ctrl is released without ctrl down OR the released key is a ctrl key\n    if (!_ctrl OR {_key isEqualTo LEFT_CTRL_CODE} OR {_key isEqualTo RIGHT_CTRL_CODE}) then {\n        hint \"_ctrl is false (key-up)\";\n        diag_log \"_ctrl is false (key-up)\";\n\n        // then if KISKA_ctrlDown is true, set it to false\n        if (missionNamespace getVariable [\"KISKA_ctrlDown\",true]) then {\n            hint \"KISKA_ctrlDown is true (key-up), setting it to false\";\n            diag_log \"KISKA_ctrlDown is true (key-up), setting it to false\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",false];\n        } else {\n            hint \"KISKA_ctrlDown is false (key-up) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is false (key-up) and it will remain so\";\n        };\n    } else { // if ctrl is still down or the released key is not a ctrl key\n        hint \"_ctrl is true (key-up)\";\n        diag_log \"_ctrl is true (key-up)\";\n\n        // then if KISKA_ctrlDown is false, set it to true\n        if !(missionNamespace getVariable [\"KISKA_ctrlDown\",false]) then {\n            hint \"KISKA_ctrlDown is false (key-up), setting it to true\";\n            diag_log \"KISKA_ctrlDown is false (key-up), setting it to true\";\n\n            missionNamespace setVariable [\"KISKA_ctrlDown\",true];\n        } else {\n            hint \"KISKA_ctrlDown is true (key-up) and it will remain so\";\n            diag_log \"KISKA_ctrlDown is true (key-up) and it will remain so\";\n        };\n    };\n\n\n    nil\n}];\n*/\n",
    "fileName": "fn_detectControlKeys.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Arty Ammo Classes.hpp\"\n#include \"..\\Headers\\Arty Ammo Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getAmmoClassFromId\n\nDescription:\n    Takes a number (id) and translates it into the class name for that number\n\nParameters:\n    0: _id : <NUMBER> - The ammo type ID\n\nReturns:\n    <STRING> - ClassName for the corresponding Id number, otherwise empty string\n\nExamples:\n    (begin example)\n        _class = [0] call KISKA_fnc_getAmmoClassFromId\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getAmmoClassFromId\";\n\n\n#define CHECK_ID(AMMO_TYPE,CLASS) if (_id isEqualTo AMMO_TYPE) exitWith {CLASS};\n\n\nparams [\n    [\"_id\",0,[123]]\n];\n\n// 155\nCHECK_ID(AMMO_155_HE_ID, AMMO_155_HE_CLASS)\nCHECK_ID(AMMO_155_CLUSTER_ID, AMMO_155_CLUSTER_CLASS)\nCHECK_ID(AMMO_155_MINES_ID, AMMO_155_MINES_CLASS)\nCHECK_ID(AMMO_155_ATMINES_ID, AMMO_155_ATMINES_CLASS)\n\n// 120\nCHECK_ID(AMMO_120_HE_ID, AMMO_120_HE_CLASS)\nCHECK_ID(AMMO_120_CLUSTER_ID, AMMO_120_CLUSTER_CLASS)\nCHECK_ID(AMMO_120_MINES_ID, AMMO_120_MINES_CLASS)\nCHECK_ID(AMMO_120_ATMINES_ID, AMMO_120_ATMINES_CLASS)\nCHECK_ID(AMMO_120_SMOKE_ID, AMMO_120_SMOKE_CLASS)\n\n// 82\nCHECK_ID(AMMO_82_HE_ID, AMMO_82_HE_CLASS)\nCHECK_ID(AMMO_82_FLARE_ID, AMMO_82_FLARE_CLASS)\nCHECK_ID(AMMO_82_SMOKE_ID, AMMO_82_SMOKE_CLASS)\n\n// 230\nCHECK_ID(AMMO_230_HE_ID, AMMO_230_HE_CLASS)\nCHECK_ID(AMMO_230_CLUSTER_ID, AMMO_230_CLUSTER_CLASS)\n\n\n// return empty string if not found\n\"\"\n",
    "fileName": "fn_getAmmoClassFromId.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Arty Ammo Titles.hpp\"\n#include \"..\\Headers\\Arty Ammo Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getAmmoClassFromId\n\nDescription:\n    Takes a number (id) and translates it into the title name for that number.\n    Used to fill out menus with a consistent string for the corresponding round type.\n\nParameters:\n    0: _id : <NUMBER> - The ammo type ID\n\nReturns:\n    <STRING> - ClassName for the corresponding Id number, otherwise empty string\n\nExamples:\n    (begin example)\n        _title = [0] call KISKA_fnc_getAmmoClassFromId\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getAmmoTitleFromId\";\n\n\n#define CHECK_ID(AMMO_TYPE,TITLE) if (_id isEqualTo AMMO_TYPE) exitWith {TITLE};\n\n\nparams [\n    [\"_id\",0,[123]]\n];\n\n// 155\nCHECK_ID(AMMO_155_HE_ID, AMMO_155_HE_TITLE)\nCHECK_ID(AMMO_155_CLUSTER_ID, AMMO_155_CLUSTER_TITLE)\nCHECK_ID(AMMO_155_MINES_ID, AMMO_155_MINES_TITLE)\nCHECK_ID(AMMO_155_ATMINES_ID, AMMO_155_ATMINES_TITLE)\n\n// 120\nCHECK_ID(AMMO_120_HE_ID, AMMO_120_HE_TITLE)\nCHECK_ID(AMMO_120_CLUSTER_ID, AMMO_120_CLUSTER_TITLE)\nCHECK_ID(AMMO_120_MINES_ID, AMMO_120_MINES_TITLE)\nCHECK_ID(AMMO_120_ATMINES_ID, AMMO_120_ATMINES_TITLE)\nCHECK_ID(AMMO_120_SMOKE_ID, AMMO_120_SMOKE_TITLE)\n\n// 82\nCHECK_ID(AMMO_82_HE_ID, AMMO_82_HE_TITLE)\nCHECK_ID(AMMO_82_FLARE_ID, AMMO_82_FLARE_TITLE)\nCHECK_ID(AMMO_82_SMOKE_ID, AMMO_82_SMOKE_TITLE)\n\n// 230\nCHECK_ID(AMMO_230_HE_ID, AMMO_230_HE_TITLE)\nCHECK_ID(AMMO_230_CLUSTER_ID, AMMO_230_CLUSTER_TITLE)\n\n\n// return empty string if not found\n\"\"\n",
    "fileName": "fn_getAmmoTitleFromId.sqf"
  },
  {
    "text": "#include \"..\\Headers\\CAS Titles.hpp\"\n#include \"..\\Headers\\CAS Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getCasTitleFromId\n\nDescription:\n    Takes a number (id) and translates it into the title name for that number.\n    Used to fill out menus with a consistent string for the corresponding round type.\n\nParameters:\n    0: _id : <NUMBER> - The ammo type ID\n\nReturns:\n    <STRING> - ClassName for the corresponding Id number, otherwise empty string\n\nExamples:\n    (begin example)\n        _title = [0] call KISKA_fnc_getCasTitleFromId\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getCasTitleFromId\";\n\n\n#define CHECK_ID(AMMO_TYPE,TITLE) if (_id isEqualTo AMMO_TYPE) exitWith {TITLE};\n\n\nparams [\n    [\"_id\",0,[123]]\n];\n\n\nCHECK_ID(GUN_RUN_ID,GUN_RUN_TITLE)\nCHECK_ID(GUNS_AND_ROCKETS_ARMOR_PIERCING_ID,GUNS_AND_ROCKETS_ARMOR_PIERCING_TITLE)\nCHECK_ID(GUNS_AND_ROCKETS_HE_ID,GUNS_AND_ROCKETS_HE_TITLE)\nCHECK_ID(ROCKETS_ARMOR_PIERCING_ID,ROCKETS_ARMOR_PIERCING_TITLE)\nCHECK_ID(ROCKETS_HE_ID,ROCKETS_HE_TITLE)\nCHECK_ID(AGM_ID,AGM_TITLE)\nCHECK_ID(BOMB_LGB_ID,BOMB_LGB_TITLE)\nCHECK_ID(BOMB_CLUSTER_ID,BOMB_CLUSTER_TITLE)\nCHECK_ID(BOMB_NAPALM_ID,BOMB_NAPALM_TITLE)\n\n\n// return empty string if not found\n\"\"\n",
    "fileName": "fn_getCasTitleFromId.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getSupportVehicleClasses\n\nDescription:\n    Gets mission configed default vehicle types available for KISKA supports.\n\nParameters:\n    0: _side <SIDE> - The side to search for\n    1: _typeId <NUMBER> - The type of vehicle to search for\n\nReturns:\n    <ARRAY> - A list of vehicles listed under the relevant config\n\nExamples:\n    (begin example)\n        _bluforCAS_types = [BLUFOR,SUPPORT_TYPE_CAS] call KISKA_fnc_getSupportVehicleClasses;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getSupportVehicleClasses\";\n\n#define RETURN_CONFIG_ARRAY(TYPE_OF,CONFIG) \\\n    if (_typeID isEqualTo TYPE_OF) exitWith { \\\n        getArray(missionConfigFile >> \"KISKA_supportVehicleTypes\" >> CONFIG); \\\n    };\n\nparams [\"_side\",\"_typeID\"];\n\nif (_side isEqualTo BLUFOR) exitWith {\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_CAS,\"CAS_BLUFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_ATTACKHELI_CAS,\"attackHeliCAS_BLUFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_HELI_CAS,\"heliCAS_BLUFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_ARSENAL_DROP,\"arsenalDrop_BLUFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_SUPPLY_DROP_AIRCRAFT,\"supplyDropAircraft_BLUFOR\")\n};\n\nif (_side isEqualTo OPFOR) exitWith {\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_CAS,\"CAS_OPFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_ATTACKHELI_CAS,\"attackHeliCAS_OPFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_HELI_CAS,\"heliCAS_OPFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_ARSENAL_DROP,\"arsenalDrop_OPFOR\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_SUPPLY_DROP_AIRCRAFT,\"supplyDropAircraft_OPFOR\")\n};\n\nif (_side isEqualTo independent) exitWith {\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_CAS,\"CAS_INDEP\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_ATTACKHELI_CAS,\"attackHeliCAS_INDEP\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_HELI_CAS,\"heliCAS_INDEP\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_ARSENAL_DROP,\"arsenalDrop_INDEP\")\n    RETURN_CONFIG_ARRAY(SUPPORT_TYPE_SUPPLY_DROP_AIRCRAFT,\"supplyDropAircraft_INDEP\")\n};\n\n\n[]\n",
    "fileName": "fn_getSupportVehicleClasses.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Type IDs.hpp\"\n#include \"..\\Headers\\Support Radio Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportNotification\n\nDescription:\n    Gives the player a sound or text notification that they called in a support\n     from the KISKA systems. Just used for feedback to know a call was placed.\n\n    Players can adjust the notifcation settings in the CBA addon menu.\n\nParameters:\n    0: _supportTypeId <NUMBER> - The support type that was called\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_supportNotification;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportNotification\";\n\n#define NONE 0\n#define RADIO_ONLY 1\n#define TEXT_ONLY 2\n#define BOTH 3\n\n#define GET_NOTIFCAITON(GVAR,SUPPORT_ID,RADIO_ID) \\\n    if (_supportTypeId isEqualTo SUPPORT_ID) exitWith { \\\n        private _notificationSetting = missionNamespace getVariable [GVAR,0]; \\\n        if (_notificationSetting isEqualTo NONE) exitWith {}; \\\n        if (_notificationSetting isEqualTo RADIO_ONLY) exitWith { \\\n            [RADIO_ID] call KISKA_fnc_supportRadio; \\\n        }; \\\n        if (_notificationSetting isEqualTo TEXT_ONLY) exitWith { \\\n            [\"Request Received\",0,false] call KISKA_fnc_datalinkMsg; \\\n        }; \\\n        if (_notificationSetting isEqualTo BOTH) exitWith { \\\n            [RADIO_ID] call KISKA_fnc_supportRadio; \\\n            [\"Request Received\",0,false] call KISKA_fnc_datalinkMsg; \\\n        }; \\\n    };\n\n\nif (!hasInterface) exitWith {};\n\nparams [\n    [\"_supportTypeId\",0,[123]]\n];\n\n\nGET_NOTIFCAITON(\"KISKA_CBA_suppNotif_arty\",SUPPORT_TYPE_ARTY,TYPE_ARTILLERY)\n\nGET_NOTIFCAITON(\"KISKA_CBA_suppNotif_cas\",SUPPORT_TYPE_CAS,TYPE_CAS_REQUEST)\n\nGET_NOTIFCAITON(\"KISKA_CBA_suppNotif_heliCas\",SUPPORT_TYPE_ATTACKHELI_CAS,TYPE_CAS_REQUEST)\nGET_NOTIFCAITON(\"KISKA_CBA_suppNotif_heliCas\",SUPPORT_TYPE_HELI_CAS,TYPE_CAS_REQUEST)\n\nGET_NOTIFCAITON(\"KISKA_CBA_suppNotif_supplyDrop\",SUPPORT_TYPE_ARSENAL_DROP,TYPE_SUPPLY_DROP_REQUEST)\nGET_NOTIFCAITON(\"KISKA_CBA_suppNotif_supplyDrop\",SUPPORT_TYPE_SUPPLY_DROP_AIRCRAFT,TYPE_SUPPLY_DROP_REQUEST)\n\nGET_NOTIFCAITON(\"KISKA_CBA_suppNotif_supplyDrop\",SUPPORT_TYPE_SUPPLY_DROP,TYPE_SUPPLY_DROP)\n",
    "fileName": "fn_supportNotification.sqf"
  },
  {
    "text": "#include \"..\\Headers\\Support Radio Defines.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supportRadio\n\nDescription:\n    Decides what radio message to play to provided targets.\n\nParameters:\n    0: _messageType <STRING> - The type of radio message to send\n    1: _caller <OBJECT> - The person sending the call (default is local player)\n    2: _targets <NUMBER, OBJECT, STRING, GROUP, SIDE, ARRAY> - The remoteExec targets for the radio call\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"artillery\"] call KISKA_fnc_supportRadio;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supportRadio\";\n\nparams [\n    \"_messageType\",\n    [\"_caller\",player,[objNull]],\n    [\"_targets\",player,[123,objNull,\"\",BLUFOR,grpNull,[]]]\n];\n\nprivate _fn_selectMessage = {\n    if (_messageType == TYPE_ARTILLERY) exitWith {\n        selectRandom [\n            \"mp_groundsupport_45_artillery_BHQ_0\",\n            \"mp_groundsupport_45_artillery_BHQ_1\",\n            \"mp_groundsupport_45_artillery_BHQ_2\",\n            \"mp_groundsupport_45_artillery_IHQ_0\",\n            \"mp_groundsupport_45_artillery_IHQ_1\",\n            \"mp_groundsupport_45_artillery_IHQ_2\"\n        ];\n    };\n\n    if (_messageType == TYPE_STRIKE) exitWith {\n        selectRandom [\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_0\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_1\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_2\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_3\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_4\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_0\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_1\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_2\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_3\",\n            \"mp_groundsupport_70_tacticalstrikeinbound_IHQ_4\"\n        ];\n    };\n\n    if (_messageType == TYPE_SUPPLY_DROP) exitWith {\n        selectRandom [\n            \"mp_groundsupport_10_slingloadsucceeded_BHQ_0\",\n            \"mp_groundsupport_10_slingloadsucceeded_BHQ_1\",\n            \"mp_groundsupport_10_slingloadsucceeded_BHQ_2\",\n            \"mp_groundsupport_10_slingloadsucceeded_IHQ_0\",\n            \"mp_groundsupport_10_slingloadsucceeded_IHQ_1\",\n            \"mp_groundsupport_10_slingloadsucceeded_IHQ_2\"\n        ];\n    };\n\n    if (_messageType == TYPE_SUPPLY_DROP_REQUEST) exitWith {\n        selectRandom [\n            \"mp_groundsupport_01_slingloadrequested_BHQ_0\",\n            \"mp_groundsupport_01_slingloadrequested_BHQ_1\",\n            \"mp_groundsupport_01_slingloadrequested_BHQ_2\",\n            \"mp_groundsupport_01_slingloadrequested_IHQ_0\",\n            \"mp_groundsupport_01_slingloadrequested_IHQ_1\",\n            \"mp_groundsupport_01_slingloadrequested_IHQ_2\"\n        ];\n    };\n\n    if (_messageType == TYPE_CAS_REQUEST) exitWith {\n        selectRandom [\n            \"mp_groundsupport_01_casrequested_BHQ_0\",\n            \"mp_groundsupport_01_casrequested_BHQ_1\",\n            \"mp_groundsupport_01_casrequested_BHQ_2\",\n            \"mp_groundsupport_01_casrequested_IHQ_0\",\n            \"mp_groundsupport_01_casrequested_IHQ_1\",\n            \"mp_groundsupport_01_casrequested_IHQ_2\",\n            \"mp_groundsupport_50_cas_BHQ_0\",\n            \"mp_groundsupport_50_cas_BHQ_1\",\n            \"mp_groundsupport_50_cas_BHQ_2\",\n            \"mp_groundsupport_50_cas_IHQ_0\",\n            \"mp_groundsupport_50_cas_IHQ_1\",\n            \"mp_groundsupport_50_cas_IHQ_2\"\n        ];\n    };\n\n    if (_messageType == TYPE_CAS_ABORT) exitWith {\n        selectRandom [\n            \"mp_groundsupport_05_casaborted_BHQ_0\",\n            \"mp_groundsupport_05_casaborted_BHQ_1\",\n            \"mp_groundsupport_05_casaborted_BHQ_2\",\n            \"mp_groundsupport_05_casaborted_IHQ_0\",\n            \"mp_groundsupport_05_casaborted_IHQ_1\",\n            \"mp_groundsupport_05_casaborted_IHQ_2\"\n        ];\n    };\n\n    if (_messageType == TYPE_HELO_DOWN) exitWith {\n        selectRandom [\n            \"mp_groundsupport_65_chopperdown_BHQ_0\",\n            \"mp_groundsupport_65_chopperdown_BHQ_1\",\n            \"mp_groundsupport_65_chopperdown_BHQ_2\",\n            \"mp_groundsupport_65_chopperdown_IHQ_0\",\n            \"mp_groundsupport_65_chopperdown_IHQ_1\",\n            \"mp_groundsupport_65_chopperdown_IHQ_2\"\n        ];\n    };\n\n    if (_messageType == TYPE_UAV_REQUEST) exitWith {\n        selectRandom [\n            \"mp_groundsupport_60_uav_BHQ_0\",\n            \"mp_groundsupport_60_uav_BHQ_1\",\n            \"mp_groundsupport_60_uav_BHQ_2\",\n            \"mp_groundsupport_60_uav_IHQ_0\",\n            \"mp_groundsupport_60_uav_IHQ_1\",\n            \"mp_groundsupport_60_uav_IHQ_2\"\n        ];\n    };\n\n    if (_messageType == TYPE_TRANSPORT_REQUEST) exitWith {\n        selectRandom [\n            \"mp_groundsupport_01_transportrequested_BHQ_0\",\n            \"mp_groundsupport_01_transportrequested_BHQ_1\",\n            \"mp_groundsupport_01_transportrequested_BHQ_2\",\n            \"mp_groundsupport_01_transportrequested_IHQ_0\",\n            \"mp_groundsupport_01_transportrequested_IHQ_1\",\n            \"mp_groundsupport_01_transportrequested_IHQ_2\"\n        ];\n    };\n\n    \"mp_groundsupport_70_tacticalstrikeinbound_BHQ_0\"\n};\n\nprivate _message = call _fn_selectMessage;\n\n[_caller,_message] remoteExecCall [\"globalRadio\",_targets];\n",
    "fileName": "fn_supportRadio.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_updateFlareEffects\n\nDescription:\n    Due to the local nature of many light commands, this function is used\n     to sync up the brightness increase of the flares launched in the support function.\n\nParameters:\n    0: _light <OBJECT> - The #lightPoint attached to the flare\n    1: _flare <OBJECT> - The flare object\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_light,_flare] remoteExecCall [\"KISKA_fnc_updateFlareEffects\",0,_flare];\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_updateFlareEffects\";\n\nif (!hasInterface) exitWith {};\n\nparams [\"_light\",\"_flare\"];\n\nif (isNull _flare) exitWith {\n    [\"_flare is null, exiting...\"] call KISKA_fnc_log;\n    nil\n};\n\n_light setLightColor [1, 1, 1];\n_light setLightAmbient [1, 1, 1];\n_light setLightIntensity 100000;\n_light setLightUseFlare true;\n_light setLightFlareSize 10;\n_light setLightFlareMaxDistance 600;\n_light setLightDayLight true;\n_light setLightAttenuation [4, 0, 0, 0.2, 1000, 2000];",
    "fileName": "fn_updateFlareEffects.sqf"
  },
  {
    "text": "#include \"Support Framework\\Headers\\CAS Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_CAS\n\nDescription:\n    Completes either a gun run, bomb run, rockets, or rocket and gun strike.\n\nParameters:\n    0: _attackPosition : <OBJECT or PositionASL[]> - ASL position or object to attack\n    1: _attackTypeID : <NUMBER or ARRAY> - See CAS Type IDs.hpp .\n        If an array, format needs to be [attackTypeId,pylonMagazineClass].\n        Custom mag classes, when used for napalm or UGB ids, will drop the ENTIRE payload\n         of that mag. e.g. mag class \"vn_bomb_f4_out_500_blu1b_fb_mag_x1\" is 1 bomb dropped,\n         \"vn_bomb_f4_out_500_blu1b_fb_mag_x4\" will be 4 dropped\n    2: _attackDirection : <NUMBER> - The direction the aircraft should approach from relative to North\n    3: _planeClass : <STRING> - The className of the aircraft\n    4: _side : <SIDE> - The side of the plane\n    5: _spawnHeight : <NUMBER> - At what height should the aircraft start firing\n    6: _spawnDistance : <NUMBER> - How far away to spawn the aircraft\n    7: _breakOffDistance : <NUMBER> - The distance to target at which the aircraft should definately disengage and fly away (to not crash)\n    8: _attackPositionOffset : <NUMBER> - This will offset the _attackPosition in meters and in the direction of the attack.\n        So for instance, if I wanted a gun run to be aimed 20m further in the _attackDirection from the _attackPosition, I'd\n         set this to 20\n    9: _attackDistance : <NUMBER> - The distance to target at which the aircraft can start completeing its attack\n    10: _allowDamage : <BOOL> - Allow damage of both the crew and aircraft\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myTarget] call KISKA_fnc_CAS;\n    (end)\n\nAuthor(s):\n    Bohemia Interactive,\n    Modified By: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_CAS\";\n\n#define DEFAULT_CANNON_CLASS \"Twin_Cannon_20mm\"\n#define DEFAULT_CANNON_MAG_CLASS \"PylonWeapon_300Rnd_20mm_shells\"\n\n#define DEFAULT_AIRCRAFT \"B_Plane_CAS_01_dynamicLoadout_F\"\n\n#define PLANE_SPEED 75// m/s\n#define PLANE_VELOCITY(THE_SPEED) [0,THE_SPEED,0]\n\n#define CUSTOM_OR_DEFAULT_MAG(defaultClass) [_customMagClass,defaultClass] select (_customMagClass isEqualTo \"\")\n\n#define STRAFE_INCREMENT 0.1\n#define FLARE_COUNT 4\n#define TIME_TILL_DELETE 64\n\nparams [\n    [\"_attackPosition\",objNull,[[],objNull]],\n    [\"_attackTypeID\",0,[123,[]]],\n    [\"_attackDirection\",0,[123]],\n    [\"_planeClass\",DEFAULT_AIRCRAFT,[\"\"]],\n    [\"_side\",BLUFOR,[sideUnknown]],\n    [\"_spawnHeight\",1300,[123]],\n    [\"_spawnDistance\",2000,[123]],\n    [\"_breakOffDistance\",500,[123]],\n    [\"_attackPositionOffset\",0,[123]],\n    [\"_attackDistance\",1200,[123]],\n    [\"_allowDamage\",false,[true]]\n];\n\n\nif (\n\t(_attackPosition isEqualType objNull) AND \n\t{isNull _attackPosition} OR \n\t{_attackPosition isEqualTo []}\n) exitWith {\n    [[_attackPosition,\" is an invalid target\"],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _planeCfg = configfile >> \"cfgvehicles\" >> _planeClass;\nif !(isclass _planeCfg) exitwith {\n    [[_planeClass,\" Vehicle class not found, moving to default aircraft...\"],true] call KISKA_fnc_log;\n    _this set [3,DEFAULT_AIRCRAFT];\n    _this call KISKA_fnc_CAS;\n};\n\n\n/* ----------------------------------------------------------------------------\n    select weapons to use\n---------------------------------------------------------------------------- */\nprivate _attackMagazines = [];\nprivate _customMagClass = \"\";\n\nif (_attackTypeID isEqualType []) then {\n    _customMagClass = _attackTypeID select 1;\n    _attackTypeID = _attackTypeID select 0;\n};\n\n_attackMagazines = switch _attackTypeID do {\n    case GUN_RUN_ID: {\n        [CANNON_TYPE]\n    };\n    case GUNS_AND_ROCKETS_ARMOR_PIERCING_ID: {\n        [\n\t\t\tCANNON_TYPE,\n\t\t\t[ROCKETS_AP_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_AP_F\")]\n\t\t]\n    };\n    case GUNS_AND_ROCKETS_HE_ID: {\n        [\n\t\t\tCANNON_TYPE,\n\t\t\t[ROCKETS_HE_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_HE_F\")]\n\t\t]\n    };\n    case ROCKETS_ARMOR_PIERCING_ID: {\n        [[ROCKETS_AP_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_AP_F\")]]\n    };\n    case ROCKETS_HE_ID: {\n        [[ROCKETS_HE_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_7Rnd_Rocket_04_HE_F\")]]\n    };\n    case AGM_ID: {\n        [[AGM_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonRack_1Rnd_Missile_AGM_02_F\")]]\n    };\n    case BOMB_LGB_ID: {\n        [[BOMB_LGB_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonMissile_1Rnd_Bomb_04_F\")]]\n    };\n    case BOMB_CLUSTER_ID: {\n        [[BOMB_UGB_TYPE, CUSTOM_OR_DEFAULT_MAG(\"PylonMissile_1Rnd_BombCluster_01_F\")]]\n    };\n    case BOMB_NAPALM_ID: {\n        [[BOMB_UGB_TYPE, CUSTOM_OR_DEFAULT_MAG(\"vn_bomb_f4_out_500_blu1b_fb_mag_x1\")]]\n    };\n};\n\n\nprivate _exitToDefault = false;\n\n\n////// Verify the plane has the right weapons for what is asked of it and adjust if it doesn't //////\nprivate _weaponsToUse = [];\nprivate _planeClassWeapons = _planeClass call BIS_fnc_weaponsEntityType;\nprivate _pylonConfig = _planeCfg >> \"Components\" >> \"TransportPylonsComponent\" >> \"pylons\";\n\n// if the plane has pylons\nif (isClass _pylonConfig) then {\n\n    private _allVehiclePylons = (\"true\" configClasses _pylonConfig) apply {configName _x};\n\n    // some planes (Buzzard) have their cannon as a pylon, don't want to replace it if needed\n    if (CANNON_TYPE in _attackMagazines) then {\n\n        // find the cannon weapon in the planes default loadout\n        private _cannonIndex = _planeClassWeapons findIf {\n            [\n                (configFile >> \"cfgWeapons\" >> _x),\n                (configFile >> \"cfgWeapons\" >> \"cannonCore\")\n            ] call CBA_fnc_inheritsFrom;\n        };\n\n        private _cannonClass = \"\";\n        // if a cannon is found, use it, else add one\n        private _canonPylonData = [];\n        if (_cannonIndex != -1) then {\n            _cannonClass = _planeClassWeapons select _cannonIndex;\n\n            // if the cannon is on a pylon delete the pylon from the list so it's not changed\n            private _cannonPylonIndex = _allVehiclePylons findIf {\n                getText(_pylonConfig >> _x >> \"attachment\") == _cannonClass;\n            };\n            if (_cannonPylonIndex isNotEqualTo -1) then {\n                _allVehiclePylons deleteAt _cannonPylonIndex;\n            };\n\n        } else {\n            _cannonClass = DEFAULT_CANNON_CLASS;\n            _canonPylonData pushBack DEFAULT_CANNON_MAG_CLASS;\n            private _pylonToUse = _allVehiclePylons deleteAt 0; // set the first pylon as the cannon\n            _canonPylonData pushBack _pylonToUse;\n\n        };\n\n        _weaponsToUse pushBack [CANNON_TYPE,_cannonClass,_canonPylonData];\n        // remove cannon so we don't need to check it later\n        _attackMagazines deleteAt (_attackMagazines find CANNON_TYPE);\n\n    };\n\n    // if there was more then just the cannon in the _attackMagazines array\n    if (_attackMagazines isNotEqualTo []) then {\n        {\n\t\t\t_x params [\"_attackTypeString\",\"_attackMagazineClass\"];\n            private _attackWeaponClass = [\n\t\t\t\tconfigFile >> \"cfgMagazines\" >> _attackMagazineClass >> \"pylonWeapon\"\n\t\t\t] call BIS_fnc_getCfgData;\n\n            // pushBack string for attack type, the weapon used, the mag for adding a pylon, and what pylon to add it to\n\t\t\tprivate _nextPylon = _allVehiclePylons deleteAt 0;\n            _weaponsToUse pushBack [\n\t\t\t\t_attackTypeString,\n\t\t\t\t_attackWeaponClass,\n\t\t\t\t[_attackMagazineClass, _nextPylon]\n\t\t\t];\n        } forEach _attackMagazines;\n    };\n\n} else {\n    _exitToDefault = true;\n\n};\n\n\nif (_exitToDefault) exitwith {\n    [\n\t\t[\n\t\t\t\"Weapon types of \",\n\t\t\t_attackMagazines,\n\t\t\t\" for plane class: \",\n\t\t\t_planeClass,\n\t\t\t\" not entirely found, moving to default Aircraft...\"\n\t\t],\n\t\ttrue\n\t] call KISKA_fnc_log;\n\n    // exit to default aircraft type\n    _this set [3,DEFAULT_AIRCRAFT];\n    _this call KISKA_fnc_CAS;\n};\n\n\n\n/* ----------------------------------------------------------------------------\n    Position plane towards target\n---------------------------------------------------------------------------- */\nprivate _planeSpawnPosition = [\n    _attackPosition,\n    _spawnDistance,\n    (_attackDirection + 180)\n] call KISKA_fnc_getPosRelativeSurface;\n\n_planeSpawnPosition = _planeSpawnPosition vectorAdd [0,0,_spawnHeight];\nprivate _planeArray = [\n\t_planeSpawnPosition,\n\t_attackDirection,\n\t_planeClass,\n\t_side,\n\tfalse\n] call KISKA_fnc_spawnVehicle;\n_planeArray params [\"_plane\",\"_crew\",\"_planeGroup\"];\n[_planeGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\nif !(_allowDamage) then {\n    _plane allowDamage false;\n    _crew apply {\n        _x allowDamage false;\n    };\n};\n\n\n// update the planes pylons\n_weaponsToUse apply {\n    private _pylonData = _x select 2;\n    // the cannon may not have any pylon data and therefore _pylonData will be []\n    if !(_pylonData isEqualTo []) then {\n        (_x select 2) params [\"_magClass\",\"_pylon\"];\n        _plane setPylonLoadout [_pylon,_magClass,true];\n    };\n};\n\n\n\n_plane setPosASL _planeSpawnPosition;\n_plane setDir _attackDirection;\n_plane disableAi \"autotarget\";\n_plane setCombatMode \"blue\";\n\nif (_attackPositionOffset isNotEqualTo 0) then {\n    _attackPosition = AGLToASL(_attackPosition getPos [_attackPositionOffset,_attackDirection]);\n};\n// angling the plane towards the target\nif (_attackPosition isEqualType objNull) then {\n    _attackPosition = getPosASLVisual _attackPosition;\n};\n\n\nprivate _planePositionASL = getPosASLVisual _plane;\nprivate _vectors = [_planePositionASL,_attackPosition] call KISKA_fnc_getVectorToTarget;\n_plane setVectorDirAndUp _vectors;\n_vectors params [\"_planeVectorDirTo\",\"_planeVectorUp\"];\n\n/* ----------------------------------------------------------------------------\n    Fix planes velocity towards the target\n---------------------------------------------------------------------------- */\n// get flight characteristics to steer the plane onto target\nprivate _vectorDistanceToTarget = _attackPosition vectorDistance _planePositionASL;\nprivate _flightTime = (_vectorDistanceToTarget - _breakOffDistance) / PLANE_SPEED;\nprivate _startTime = time;\nprivate _timeAfterFlight = time + _flightTime;\n\n[\n\t{\n\t\tparams [\"_args\",\"_id\"];\n\t\t_args params [\n\t\t\t\"_plane\",\n\t\t\t\"_originalAttackPosition\",\n\t\t\t\"_attackDirection\",\n\t\t\t\"_breakOffDistance\",\n\t\t\t\"_planeSpawnPosition\",\n\t\t\t\"_startTime\",\n\t\t\t\"_timeAfterFlight\",\n\t\t\t\"_planeSpawnPosition\",\n\t\t\t\"_planeArray\",\n\t\t\t\"_weaponsToUse\",\n\t\t\t\"_attackTypeID\",\n\t\t\t\"_planeVectorDirTo\",\n\t\t\t\"_planeVectorUp\",\n\t\t\t\"_side\",\n\t\t\t\"_attackDistance\",\n\t\t\t\"_spawnHeight\"\n\t\t];\n\n\t\tprivate _attackPosition = _plane getVariable [\"KISKA_CAS_attackPosition\",_originalAttackPosition];\n\t\tprivate _planePositionASL = getPosASLVisual _plane;\n\t\tprivate _vectorDistanceToTarget = _attackPosition vectorDistance _planePositionASL;\n\n\t\tif (\n\t\t\tisNull _plane OR\n\t\t\t{_plane getVariable [\"KISKA_CAS_completedFiring\",false]} OR\n\t\t\t{_vectorDistanceToTarget <= _breakOffDistance}\n\t\t)\n\t\texitWith {\n\t\t\t/* ----------------------------------------------------------------------------\n\t\t\t\tHandle After CAS complete\n\t\t\t---------------------------------------------------------------------------- */\n\t\t\t// telling the plane to ultimately fly past the target after we're done controlling it\n\t\t\t_plane move (_attackPosition getPos [5000,_attackDirection]);\n\n\t\t\t// after fire is complete\n\t\t\t_plane flyInHeight (_spawnHeight * 2);\n\n\t\t\t// pop flares\n\t\t\tprivate _pilot = currentPilot _plane;\n\t\t\tfor \"_i\" from 1 to FLARE_COUNT do {\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tparams [\"_pilot\"];\n\t\t\t\t\t\t_pilot forceweaponfire [\"CMFlareLauncher\",\"Burst\"];\n\t\t\t\t\t},\n\t\t\t\t\t[_pilot],\n\t\t\t\t\t_i\n\t\t\t\t] call CBA_fnc_waitAndExecute;\n\t\t\t};\n\n\t\t\t// give the plane some time to get out of audible distance before deletion\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tparams [\"_plane\",\"_crew\",\"_group\"];\n\n\t\t\t\t\t_crew apply {\n\t\t\t\t\t\tif (!isNull _x) then {\n\t\t\t\t\t\t\t_plane deleteVehicleCrew _x;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tif (alive _plane) then {\n\t\t\t\t\t\tdeleteVehicle _plane;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (!isNull _group) then {\n\t\t\t\t\t\tdeleteGroup _group;\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t_planeArray,\n\t\t\t\tTIME_TILL_DELETE\n\t\t\t] call CBA_fnc_waitAndExecute;\n\n\t\t\t[_id] call CBA_fnc_removePerFrameHandler;\n\t\t};\n\n\t\t//--- Set the plane approach vector\n\t\tprivate _interval = linearConversion [_startTime,_timeAfterFlight,time,0,1];\n\t\tprivate _velocity = (vectorNormalized (_attackPosition vectorDiff _planePositionASL)) vectorMultiply PLANE_SPEED;\n\t\t_plane setVelocityTransformation [\n\t\t\t_planeSpawnPosition, _attackPosition,\n\t\t\t_velocity, _velocity,\n\t\t\t_planeVectorDirTo, _planeVectorDirTo,\n\t\t\t_planeVectorUp, _planeVectorUp,\n\t\t\t_interval\n\t\t];\n\n\t\t// start firing\n\t\t// check if plane is from target and hasn't already started shooting\n\t\tif (_vectorDistanceToTarget > _attackDistance) exitWith {};\n\n\t\tif !(_plane getVariable [\"KISKA_CAS_startedFiring\",false]) then {\n\t\t\t_plane setVariable [\"KISKA_CAS_startedFiring\",true];\n\t\t\t// create a target to shoot at\n\t\t\tprivate _dummyTargetClass = [\"LaserTargetE\",\"LaserTargetW\"] select ((_side getfriend west) > 0.6);\n\t\t\tprivate _dummyTarget = createvehicle [_dummyTargetClass,[0,0,0],[],0,\"NONE\"];\n\t\t\t_plane setVariable [\"KISKA_CAS_dummyTarget\",_dummyTarget];\n\t\t\t_dummyTarget setPosASL _attackPosition;\n\t\t\tprivate _laserTarget = laserTarget _dummyTarget;\n\t\t\t_plane reveal _laserTarget;\n\t\t\t_plane dowatch _laserTarget;\n\t\t\t_plane dotarget _laserTarget;\n\n\t\t\t[\n\t\t\t\t_plane,\n\t\t\t\t_dummyTarget,\n\t\t\t\t_weaponsToUse,\n\t\t\t\t_attackTypeID,\n\t\t\t\t_attackPosition,\n\t\t\t\t_breakOffDistance\n\t\t\t] spawn KISKA_fnc_CASAttack;\n\n\t\t} else {\n\t\t\t// ensures strafing effect with the above setVelocityTransformation\n\t\t\tprivate _dummyTarget = _plane getVariable \"KISKA_CAS_dummyTarget\";\n\t\t\tprivate _nextAttackPostition = _dummyTarget getPos [STRAFE_INCREMENT,(getDirVisual _plane)];\n\t\t\t// did this here for readability\n\t\t\t_nextAttackPostition = AGLToASL _nextAttackPostition;\n\t\t\t\n\t\t\t_plane setVariable [\"KISKA_CAS_attackPosition\",_nextAttackPostition];\n\t\t\t_dummyTarget setPosASL _nextAttackPostition;\n\t\t};\n\n\t},\n\t0.01,\n\t[\n\t\t_plane,\n\t\t_attackPosition,\n\t\t_attackDirection,\n\t\t_breakOffDistance,\n\t\t_planeSpawnPosition,\n\t\t_startTime,\n\t\t_timeAfterFlight,\n\t\t_planeSpawnPosition,\n\t\t_planeArray,\n\t\t_weaponsToUse,\n\t\t_attackTypeID,\n\t\t_planeVectorDirTo,\n\t\t_planeVectorUp,\n\t\t_side,\n\t\t_attackDistance,\n\t\t_spawnHeight\n\t]\n] call CBA_fnc_addPerframeHandler;\n\n\nnil\n",
    "fileName": "fn_CAS.sqf"
  },
  {
    "text": "#include \"Support Framework\\Headers\\CAS Type IDs.hpp\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_CASAttack\n\nDescription:\n    Fires off the various weapons of a CAS strike.\n\nParameters:\n    0: _plane : <OBJECT> -\n    1: _dummyTarget : <OBJECT> -\n    2: _weaponsToUse : <OBJECT> -\n    3: _attackTypeID : <NUMBER> -\n    4: _attackPosition : <ARRAY> -\n    5: _breakOffDistance : <NUMBER> -\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        Should not be called on its own but in KISKA_fnc_CAS\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_CASAttack\";\n\n#define FIRE_GUN_INTERVAL 0.03\n#define FIRE_ROCKET_INTERVAL 0.5\n#define FIRE_BOMB_INTERVAL 0.5\n#define GUIDE_WEAPON_INTERVAL 0.05\n\nparams [\n    \"_plane\",\n    \"_dummyTarget\",\n    \"_weaponsToUse\",\n    \"_attackTypeID\",\n    \"_attackPosition\",\n    \"_breakOffDistance\"\n];\n\n_plane setVariable [\"KISKA_CAS_guidedFireEvent\",{\n    params [\"_plane\",\"_projectile\"];\n\n    private _projectileStartPosASL = getPosASLVisual _projectile;\n    private _dummyTarget = _plane getVariable [\"KISKA_CAS_dummyTarget\",objNull];\n    private _attackPosition = getPosASLVisual _dummyTarget;\n    private _vectors = [_projectileStartPosASL,_attackPosition] call KISKA_fnc_getVectorToTarget;\n\n    private _speed = speed _projectile;\n    _projectile setVectorDirAndUp _vectors;\n    _projectile setVelocityModelSpace [0,_speed,0];\n\n    _vectors params [\"_vectorDir\",\"_vectorUp\"];\n    private _vectorDistanceToTarget = _attackPosition vectorDistance _projectileStartPosASL;\n    private _flightTime = _vectorDistanceToTarget / _speed;\n    private _startTime = time;\n    private _timeAfterFlight = time + _flightTime;\n\n    [\n        {\n            params [\"_args\",\"_id\"];\n\n            if (isNull _projectile) exitWith { \n                [_id] call CBA_fnc_removePerFrameHandler;\n            };\n\n            _args params [\n                \"_projectile\",\n                \"_projectileStartPosASL\",\n                \"_vectorDir\",\n                \"_vectorUp\",\n                \"_startTime\",\n                \"_timeAfterFlight\",\n                \"_attackPosition\"\n            ];\n\n            private _interval = linearConversion [_startTime,_timeAfterFlight,time,0,1];\n            private _velocity = velocity _projectile;\n            _projectile setVelocityTransformation [\n                _projectileStartPosASL, _attackPosition,\n                _velocity, _velocity,\n                _vectorDir,_vectorDir,\n                _vectorUp, _vectorUp,\n                _interval\n            ];\n        },\n        GUIDE_WEAPON_INTERVAL,\n        [\n            _projectile,\n            _projectileStartPosASL,\n            _vectorDir,\n            _vectorUp,\n            _startTime,\n            _timeAfterFlight,\n            _attackPosition\n        ]\n    ] call CBA_fnc_addPerFrameHandler;\n}];\n\n\n// CUP planes in particular have an issue with rocket fire not being accurate\n// This will guide projectiles to where they should go\n_plane addEventHandler [\"Fired\", {\n    params [\"_plane\", \"_weapon\", \"\", \"\", \"\", \"\", \"_projectile\"];\n\n    private _isGuidedWeapon = _weapon == (_plane getVariable \"KISKA_CAS_guidedWeapon\");\n    if (_isGuidedWeapon) then {\n        [\n            _plane getVariable [\"KISKA_CAS_guidedFireEvent\",{}],\n            [_plane, _projectile],\n            0.1  // allow the projectile to get some speed\n        ] call CBA_fnc_waitAndExecute;\n    };\n}];\n\n\nprivate _fn_generateQueuedFireItems = {\n    params [\n        [\"_numberOfRounds\",-1,[123]],\n        [\"_weaponType\",\"\",[\"\"]],\n        [\"_fireInterval\",0.5,[123]],\n        [\"_isGuided\",false,[false]]\n    ];\n\n    private _indexOfWeaponInfoForType = _weaponsToUse findIf {(_x select 0) == _weaponType};\n    private _weaponArray = _weaponsToUse select _indexOfWeaponInfoForType;\n    _weaponArray params [\"\",\"_weaponClass\",\"_pylonInfo\"];\n    private _weaponMagClass = _pylonInfo select 0;\n\n    if (_numberOfRounds < 1) then {\n        private _configedNumberOfRoundsInMag = getNumber(configFile >> \"CfgMagazines\" >> _weaponMagClass >> \"count\");\n        if (_configedNumberOfRoundsInMag isEqualTo 0) then {\n            _numberOfRounds = 1;\n        } else {\n            _numberOfRounds = _configedNumberOfRoundsInMag;\n        };\n    };\n\n    private _fireModes = getArray(configFile >> \"CfgWeapons\" >> _weaponClass >> \"modes\");\n    private _primaryFireMode = _fireModes param [0,\"\"];\n\n    private _fireWeaponArgs = [\n        _fireInterval, \n        [_weaponClass, _primaryFireMode, _isGuided]\n    ];\n    private _queuedFireItems = [];\n    for \"_i\" from 1 to _numberOfRounds do { _queuedFireItems pushBack _fireWeaponArgs };\n\n\n    _queuedFireItems\n};\n\n\nprivate \"_fireQueue\";\n// decide how to fire\nswitch (_attackTypeID) do {\n    case GUN_RUN_ID: {\n        _fireQueue = [200, CANNON_TYPE, FIRE_GUN_INTERVAL] call _fn_generateQueuedFireItems;\n    };\n    case GUNS_AND_ROCKETS_ARMOR_PIERCING_ID: {\n        _fireQueue = [100, CANNON_TYPE, FIRE_GUN_INTERVAL] call _fn_generateQueuedFireItems;\n        _fireQueue append ([6, ROCKETS_AP_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems);\n    };\n    case GUNS_AND_ROCKETS_HE_ID: {\n        _fireQueue = [100, CANNON_TYPE, FIRE_GUN_INTERVAL] call _fn_generateQueuedFireItems;\n        _fireQueue append ([6, ROCKETS_HE_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems);\n    };\n    case ROCKETS_ARMOR_PIERCING_ID: {\n        _fireQueue = [8, ROCKETS_AP_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems;\n    };\n    case ROCKETS_HE_ID: {\n        _fireQueue = [8, ROCKETS_HE_TYPE, FIRE_ROCKET_INTERVAL, true] call _fn_generateQueuedFireItems;\n    };\n    case AGM_ID: {\n        _fireQueue = [1, AGM_TYPE, 0, true] call _fn_generateQueuedFireItems;\n    };\n    case BOMB_LGB_ID: {\n        _fireQueue = [1, BOMB_LGB_TYPE, 0] call _fn_generateQueuedFireItems;\n    };\n    case BOMB_NAPALM_ID;\n    case BOMB_CLUSTER_ID: {\n        _fireQueue = [-1, BOMB_UGB_TYPE, FIRE_BOMB_INTERVAL] call _fn_generateQueuedFireItems;\n    };\n};\n\nprivate _fireIntervalTotal = 0;\nprivate _maxFireQueueIndex = (count _fireQueue) - 1;\nprivate _planeInfo = [\n    _plane,\n    _attackPosition,\n    _breakOffDistance,\n    _dummyTarget,\n    currentPilot _plane\n];\n\n_plane setVariable [\"KISKA_CAS_completedFiring\",false];\n\n\n{\n    _x params [\"_fireInterval\",\"_fireInfo\"];\n\n    private _isFinal = _forEachIndex isEqualTo _maxFireQueueIndex;\n    [\n        {\n            // split in two so that constant info (_planeInfo) can remain the same array \n            // and only the dynamic info (_fireInfo) will be new arrays for each fire\n            params [\n                [\"_planeInfo\",[],[[]],5],\n                [\"_fireInfo\",[],[[]],3],\n                [\"_isFinal\",false,[false]]\n            ];\n            \n            _planeInfo params [\n                [\"_plane\",objNull,[objNull]],\n                [\"_attackPosition\",[],[[]],3],\n                [\"_breakOffDistance\",1,[123]],\n                [\"_dummyTarget\",objNull,[objNull]],\n                [\"_pilot\",objNull,[objNull]]\n            ];\n            \n            if (_plane getVariable [\"KISKA_CAS_completedFiring\",true]) exitWith {};\n\n\n            _fireInfo params [\n                [\"_weaponClass\",\"\",[\"\"]],\n                [\"_primaryFireMode\",\"\",[\"\"]],\n                [\"_isGuided\",false,[false]]\n            ];\n\n            if (_isGuided) then {\n                _plane setVariable [\"KISKA_CAS_guidedWeapon\",_weaponClass];\n            };\n\n            // certain vehicles seem to not work with fireAtTarget on the cannon (\"vn_b_air_f4c_cas\" from CDLC SOGPF)\n            private _canFireAtTarget = _pilot fireAtTarget [_dummyTarget,_weaponClass];\n            if (!_canFireAtTarget) then {\n                _pilot forceWeaponFire [_weaponClass,_primaryFireMode];\n            };\n\n            if (_isFinal OR ((_plane distance _attackPosition) < _breakOffDistance)) exitWith {\n                _plane setVariable [\"KISKA_CAS_completedFiring\",true];\n            };\n        },\n        [_planeInfo, _fireInfo, _isFinal],\n        _fireIntervalTotal\n    ] call CBA_fnc_waitAndExecute;\n\n    _fireIntervalTotal = _fireIntervalTotal + _fireInterval;\n} forEach _fireQueue;\n\n\nnil\n",
    "fileName": "fn_CASAttack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_arsenalSupplyDrop\n\n\n\n    ********\n    DEPRECIATED\n    USE KISKA_fnc_supplyDrop_aircraft\n    ********\n\n\n\nDescription:\n    Spawns in an aircraft that flies over a DZ to drop off an arsenal.\n\nParameters:\n    0: _dropPosition : <ARRAY> - The position (area) to drop the arsenal\n      1: _vehicleClass : <STRING> - The class of the vehicle to drop the arsenal\n    2: _dropAlt : <NUMBER> - The flyInHeight of the drop vehicle\n    3: _flyDirection : <NUMBER> - The compass bearing for the aircraft to apporach from (if < 0, it's random)\n    4: _flyInRadius : <NUMBER> - How far out the drop vehicle will spawn and then fly in\n    5: _lifeTime : <NUMBER> - How long until the arsenal is deleted\n    6: _side : <SIDE> - The side of the drop vehicle\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [position player] call KISKA_fnc_arsenalSupplyDrop;\n    (end)\n\nAuthor(s):\n    Hilltop(Willtop) & omNomios,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_arsenalSupplyDrop\";\n\n#define DEFAULT_CRATE_CLASS \"B_supplyCrate_F\"\n\nparams [\n    \"_dropPosition\",\n    [\"_vehicleClass\",\"B_T_VTOL_01_vehicle_F\",[\"\"]],\n    [\"_dropAlt\",200,[123]],\n    [\"_flyDirection\",-1,[123]],\n    [\"_flyInRadius\",2000,[123]],\n    [\"_lifeTime\",-1,[123]],\n    [\"_side\",BLUFOR,[sideUnknown]]\n];\n\n// get directions for vehicle to fly\nif (_flyDirection < 0) then {\n    _flyDirection = round (random 360);\n};\nprivate _flyFromDirection = [_flyDirection + 180] call CBA_fnc_simplifyAngle;\nprivate _spawnPosition = [\n    _dropPosition,\n    _flyInRadius,\n    _flyFromDirection\n] call KISKA_fnc_getPosRelativeSurface;\n_spawnPosition vectorAdd [0,0,_dropAlt];\n\nprivate _relativeDirection = _spawnPosition getDir _dropPosition;\n\n// spawn vehicle\nprivate _pilotClass = getText(configFile >> \"CfgVehicles\" >> _vehicleClass >> \"Crew\");\nprivate _vehicleArray = [\n    _spawnPosition,\n    _relativeDirection,\n    _vehicleClass,\n    _side,\n    false,\n    [_pilotClass] // spawn just a pilot\n] call KISKA_fnc_spawnVehicle;\n\nprivate _aircraftGroup = _vehicleArray select 2;\n_aircraftGroup setCombatBehaviour \"CARELESS\";\n_aircraftGroup setCombatMode \"BLUE\";\n[_aircraftGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\nprivate _aircraftCrew = _vehicleArray select 1;\n_aircraftCrew apply {\n    _x setCaptive true;\n};\n\n\n\nprivate _aircraft = _vehicleArray select 0;\n_airCraft move _dropPosition;\n_aircraft flyInHeight _dropAlt;\n\n// give it a waypoint and delete it after it gets there\nprivate _flyToPosition = _dropPosition getPos [_flyInRadius,_relativeDirection];\n\n[_aircraft,_dropPosition,_aircraftGroup,_flyToPosition,_lifeTime] spawn {\n    params [\"_aircraft\",\"_dropPosition\",\"_aircraftGroup\",\"_flyToPosition\",\"_lifeTime\"];\n    waitUntil {\n        if (_aircraft distance2D _dropPosition < 40) exitWith {true};\n        sleep 0.25;\n        false\n    };\n\n    // go to deletion point\n    [\n        _aircraftGroup,\n        _flyToPosition,\n        -1,\n        \"MOVE\",\n        \"SAFE\",\n        \"BLUE\",\n        \"NORMAL\",\n        \"NO CHANGE\",\n        \"\n            private _aircraft = objectParent this;\n            thisList apply {\n                _aircraft deleteVehicleCrew _x;\n            };\n            deleteVehicle _aircraft;\n        \",\n        [0,0,0],\n        50\n    ] call CBA_fnc_addWaypoint;\n\n\n    sleep 0.1;\n\n    private _aircraftAlt = (getPosATL _aircraft) select 2;\n    private _boxSpawnPosition = _aircraft getRelPos [15,180];\n    private _droppedContainers = [[DEFAULT_CRATE_CLASS],_aircraftAlt,_boxSpawnPosition] call KISKA_fnc_supplyDrop;\n\n    private _arsenalBox = _droppedContainers select 0;\n    [_arsenalBox] call KISKA_fnc_clearCargoGlobal;\n    [_arsenalBox] call KISKA_fnc_addArsenal;\n\n    if (_lifeTime > 0) then {\n        // make sure it's on the ground before we start the countdown to deletetion\n        waitUntil {\n            if (((getPosATL _arsenalBox) select 2) < 2) exitWith {true};\n            sleep 5;\n            false\n        };\n\n\n        sleep _lifeTime;\n\n        deleteVehicle _arsenalBox;\n    };\n};\n\n\nnil\n",
    "fileName": "fn_arsenalSupplyDrop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_cruiseMissileStrike\n\nDescription:\n    Spawns a cruise missile at designated \"launcher\" and then guides it to a target.\n\n    If you need a missile that terrain follows, see KISKA_fnc_vlsFireAt.\n\nParameters:\n    0: _target <OBJECT or ARRAY> - Target to hit missile with, can also be a position (ASL)\n    1: _side <SIDE> - The side that is launching the missile\n    2: _launchPos <OBJECT or ARRAY> - An object or position ASL to spawn the missile at.\n        If empty array array (default), a random position is chosen 2000m away.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [target_1] call KISKA_fnc_cruiseMissileStrike;\n    (end)\n\nAuthors:\n    Arma 3 Discord,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_cruiseMissileStrike\";\n\n#define VLS_CLASS \"B_Ship_MRLS_01_F\"\n#define MISSILE_CLASS \"ammo_Missile_Cruise_01\"\n#define LASER_TARGET_CLASS \"LaserTargetC\"\n#define LAUNCHER_RAND_SPAWN_DISTANCE 2000\n#define LAUNCHER_RAND_SPAWN_ALT 1000\n\nparams [\n    [\"_target\",objNull,[objNull,[]]],\n    [\"_side\",BLUFOR,[sideUnknown]],\n    [\"_launchPos\",[],[[],objNull]]\n];\n\nprivate _targetIsObject = _target isEqualType objNull;\nif (_targetIsObject AND {isNUll _target}) exitWith {\n    [\"Null _target provided!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _launchPosIsObject =_launchPos isEqualType objNull;\nif (_launchPosIsObject AND {isNUll _launchPos}) exitWith {\n    [\"Null _launchPos provided!\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_launchPos isEqualTo []) then {\n    // get firing position and give it some alititude\n    _launchPos = [_target,LAUNCHER_RAND_SPAWN_DISTANCE] call CBA_fnc_randPos;\n    _launchPos = _launchPos vectorAdd [0,0,LAUNCHER_RAND_SPAWN_ALT];\n};\nif (_launchPosIsObject) then {\n    _launchPos = getPosASL _launchPos;\n};\n\n\n// spawn the launcher a little lower so missile does not collide\nprivate _launcherGroup = createGroup _side;\n// can't use createUnit, causes missile not to track\nprivate _launcher = VLS_CLASS createVehicle [0,0,0];\n_launcher allowDamage false;\n[_launcherGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n_launcher setPosASL (_launchPos vectorDiff [0,0,7]);\nprivate _tempGroup = createVehicleCrew _launcher;\n(units _tempGroup) joinSilent _launcherGroup;\n\n// doesn't need to be simmed to act as shot parent\n_launcher enableSimulationGlobal false;\n\n\n//create Missile\nprivate _missile = MISSILE_CLASS createVehicle [0,0,0];\n_missile setPosASL _launchPos;\n_missile setVectorDirAndUp [[0, 0, 1], [1, 0, 0]];\n\nif (_targetIsObject) then {\n    _target = getPosASL _target;\n};\n// any (implemented) lasertarget will do, and since independent does not have one, just use civilian\nprivate _laserTarget = createVehicle [LASER_TARGET_CLASS,_target,[],0,\"CAN_COLLIDE\"];\n_laserTarget setPosASL _target;\n_side reportRemoteTarget [_laserTarget, 3600];\n\n// Do not remotexec setShotParents on server, causes undefined behaviour\n_missile setShotParents [_launcher,gunner _launcher];\n_missile setMissileTarget _laserTarget;\n\n\n[\n    [[_missile],{\n        _thisArgs params [\"_missile\"];\n\n        !alive _missile\n    }],\n    [[_launcher,_laserTarget],{\n        _thisArgs params [\"_launcher\",\"_laserTarget\"];\n\n        deleteVehicle _laserTarget;\n        deleteVehicleCrew _launcher;\n        deleteVehicle _launcher;\n    }],\n    5\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_cruiseMissileStrike.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_helicopterGunner\n\nDescription:\n    Spawns a helicopter (or uses an existing one) to partol a given area for a period of time and\n     engage enemy targets in a given area.\n\nParameters:\n    0: _centerPosition : <Position[], OBJECT> - The position around which the helicopter will patrol\n    1: _radius : <NUMBER> - The size of the radius to patrol around\n    2: _aircraftType : <STRING or OBJECT> - The class of the helicopter to spawn\n        If object, it is expected that this is a helicopter with crew\n    3: _timeOnStation : <NUMBER> - How long will the aircraft be supporting\n    4: _supportSpeedLimit : <NUMBER> - The max speed the aircraft can fly while in the support radius\n    5: _flyinHeight : <NUMBER> - The altittude the aircraft flys at\n    6: _approachBearing : <NUMBER> - The bearing from which the aircraft will approach from (if below 0, it will be random)\n        This has no effect if an object is used for _aircraftType\n    7: _side : <SIDE> - The side of the created helicopter\n    8: _postSupportCode : <CODE, ARRAY, or STRING> - Code to execute after the support completes.\n            See KISKA_fnc_callBack.\n            The default behaviour is for the aircraft to move 2000 meters away and for\n             its complete crew and self to be deleted. The _postSupportCode should return a `BOOL`\n             that if `false` will NOT perform the default behaviour in addition to the callback.\n        \n        Parameters:\n        - 0: <OBJECT> - The helicopter confucting support\n        - 1: <GROUP> - The group the pilot belongs to\n        - 2: <OBJECT[]> - The full vehicle crew\n        - 3: <OBJECT> - The unit that *should* be the pilot of the helicopter\n        - 4: <ARRAY> - The position the helicopter was supporting\n\nReturns:\n    ARRAY - The vehicle info\n        0: <OBJECT> - The vehicle created\n        1: <OBJECT[]> - The vehicle crew\n        2: <GROUP> - The group the crew is a part of\n\nExamples:\n    (begin example)\n        [\n            player,\n            250,\n            \"B_Heli_Attack_01_dynamicLoadout_F\"\n        ] call KISKA_fnc_helicopterGunner;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_helicopterGunner\";\n\n#define SPAWN_DISTANCE 2000\n#define DETECT_ENEMY_RADIUS 700\n#define MIN_RADIUS 200\n#define STAR_BEARINGS [0,144,288,72,216]\n\nparams [\n    [\"_centerPosition\",[],[objNull,[]],[2,3]],\n    [\"_radius\",200,[123]],\n    [\"_aircraftType\",\"\",[\"\",objNull]],\n    [\"_timeOnStation\",180,[123]],\n    [\"_supportSpeedLimit\",10,[123]],\n    [\"_flyInHeight\",30,[123]],\n    [\"_approachBearing\",-1,[123]],\n    [\"_side\",BLUFOR,[sideUnknown]],\n    [\"_postSupportCode\",{},[\"\",{},[]]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    verify vehicle has turrets that are not fire from vehicle and not copilot positions\n---------------------------------------------------------------------------- */\nprivate _vehicleArray = [];\nprivate _vehicleExistedBeforeFunction = _aircraftType isEqualType objNull;\nif (_vehicleExistedBeforeFunction) then {\n    private _aircraft = _aircraftType;\n    _aircraftType = typeOf _aircraft;\n\n    _vehicleArray pushBack _aircraft;\n    _vehicleArray pushBack (crew _aircraft);\n    _vehicleArray pushBack (group (currentPilot _aircraft));\n};\nprivate _turretsWithWeapons = [_aircraftType] call KISKA_fnc_classTurretsWithGuns;\n\nif (_turretsWithWeapons isEqualTo []) exitWith {\n    [[_aircraftType,\" does not meet standards for function!\"],true] call KISKA_fnc_log;\n    []\n};\n\n\n/* ----------------------------------------------------------------------------\n    Create vehicle\n---------------------------------------------------------------------------- */\nif (!_vehicleExistedBeforeFunction) then {\n    if (_approachBearing < 0) then {\n        _approachBearing = round (random 360);\n    };\n\n    private _spawnPosition = [\n        _centerPosition,\n        SPAWN_DISTANCE,\n        (_approachBearing + 180),\n        _flyInHeight\n    ] call KISKA_fnc_getPosRelativeSurface;\n\n    _vehicleArray = [\n        _spawnPosition,\n        0,\n        _aircraftType,\n        _side, \n        false\n    ] call KISKA_fnc_spawnVehicle;\n};\n\n_vehicleArray params [\"_heli\",\"_heliCrew\",\"_pilotsGroup\"];\nprivate _pilot = currentPilot _heli;\n\n[_pilotsGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n// if using an already exisiting aircraft, the enigne must be on prior to getting a \"move\" command\nif !(isEngineOn _heli) then {\n    _heli engineOn true;\n};\n_heli flyInHeight _flyInHeight;\n\n\n_heli setVariable [\"KISKA_helicopterGunner_vehicleInfo\",[_heli,_pilotsGroup,_heliCrew,_pilot]];\n_pilot setVariable [\"KISKA_helicopterGunner_vehicleInfo\",[_heli,_pilotsGroup,_heliCrew,_pilot]];\n\n/* ----------------------------------------------------------------------------\n    Eventhandlers\n---------------------------------------------------------------------------- */\n/* ---------------------------------------\n    Heli Killed Event\n--------------------------------------- */\nprivate _heliKilledEventId = _heli addEventHandler [\"KILLED\", {\n    params [\"_heli\"];\n\n    private _args = _heli getVariable [\"KISKA_helicopterGunner_vehicleInfo\",[]];\n    [\n        _heli, \n        \"KISKA_helicopterGunner_event_heliKilled\", \n        _args, \n        false\n    ] call BIS_fnc_callScriptedEventHandler;\n\n    [_heli,\"KISKA_helicopterGunner_event_heliKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    _heli setVariable [\"KISKA_helicopterGunner_stop\",true];\n}];\n_heli setVariable [\"KISKA_helicopterGunner_heliKilledEventId\",_heliKilledEventId];\n\n\n/* ---------------------------------------\n    Pilot Killed Event\n--------------------------------------- */\nprivate _pilotKilledEventId = _pilot addEventHandler [\"KILLED\", {\n    params [\"_pilot\"];\n\n    private _args = _pilot getVariable [\"KISKA_helicopterGunner_vehicleInfo\",[]];\n    [\n        _pilot, \n        \"KISKA_helicopterGunner_event_pilotKilled\", \n        _args, \n        false\n    ] call BIS_fnc_callScriptedEventHandler;\n\n    [_pilot,\"KISKA_helicopterGunner_event_pilotKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    private _heli = _args param [0,objNull];\n    _heli setVariable [\"KISKA_helicopterGunner_stop\",true];\n}];\n_pilot setVariable [\"KISKA_helicopterGunner_pilotKilledEventId\",_pilotKilledEventId];\n\n\n/* ---------------------------------------\n    Pilot Getout Event\n--------------------------------------- */\nprivate _pilotGetOutEventId = _pilot addEventHandler [\"GetOutMan\", {\n    params [\"_pilot\"];\n\n    private _args = _pilot getVariable [\"KISKA_helicopterGunner_vehicleInfo\",[]];\n    [\n        _pilot, \n        \"KISKA_helicopterGunner_event_pilotGotOut\", \n        _args, \n        false\n    ] call BIS_fnc_callScriptedEventHandler;\n\n    [_pilot,\"KISKA_helicopterGunner_event_pilotGotOut\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    private _heli = _args param [0,objNull];\n    _heli setVariable [\"KISKA_helicopterGunner_stop\",true];\n}];\n_pilot setVariable [\"KISKA_helicopterGunner_pilotGotOutEventId\",_pilotGetOutEventId];\n\n\n/* ---------------------------------------\n    Add default events\n--------------------------------------- */\nif (!_vehicleExistedBeforeFunction) then {\n    [\n        _heli,\n        \"KISKA_helicopterGunner_event_heliKilled\",\n        { \n            params [\"_heli\",\"\",\"_heliCrew\"];\n\n            \n            _heliCrew apply {\n                _heli deleteVehicleCrew _x;\n            };\n        }\n    ] call BIS_fnc_addScriptedEventHandler;\n\n    [\n        _heli,\n        \"KISKA_helicopterGunner_event_pilotKilled\",\n        { \n            params [\"_heli\"];\n            _heli setDamage 1;\n        }\n    ] call BIS_fnc_addScriptedEventHandler;\n\n    [\n        _heli,\n        \"KISKA_helicopterGunner_event_pilotGotOut\",\n        { \n            params [\"_heli\"];\n            _heli setDamage 1;\n        }\n    ] call BIS_fnc_addScriptedEventHandler;\n};\n\n/* ----------------------------------------------------------------------------\n    Post Support Function\n---------------------------------------------------------------------------- */\nprivate _fn_supportEnded = {\n    params [\n        [\"_heli\",objNull,[objNull]],\n        [\"_pilotsGroup\",grpNull,[grpNull]],\n        [\"_heliCrew\",[],[[]]],\n        [\"_pilot\",objNull,[objNull]],\n        [\"_centerPosition\",[],[[]]],\n        [\"_postSupportCode\",{},[{},\"\",[]]],\n        [\"_approachBearing\",0,[123]]\n    ];\n\n    private _runDefault = true;\n    private _postSupportCodeIsNotEmpty = (_postSupportCode isNotEqualTo {}) AND (_postSupportCode isNotEqualTo \"\") AND (_postSupportCode isNotEqualTo []);\n    if (_postSupportCodeIsNotEmpty) then {\n        _runDefault = [\n            _this,\n            _postSupportCode\n        ] call KISKA_fnc_callBack;\n    };\n\n\n    if (\n        (!_runDefault) OR \n        (_heli getVariable [\"KISKA_helicopterGunner_stop\",true])\n    ) exitWith {\n        [_heli,\"KISKA_helicopterGunner_event_heliKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n        [_pilot,\"KISKA_helicopterGunner_event_pilotKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n        [_pilot,\"KISKA_helicopterGunner_event_pilotGotOut\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n        _heli removeEventHandler [\n            \"KILLED\",\n            _heli getVariable [\"KISKA_helicopterGunner_heliKilledEventId\",-1]\n        ];\n        _pilot removeEventHandler [\n            \"KILLED\",\n            _pilot getVariable [\"KISKA_helicopterGunner_pilotKilledEventId\",-1]\n        ];\n        _pilot removeEventHandler [\n            \"GetOutMan\",\n            _pilot getVariable [\"KISKA_helicopterGunner_pilotGotOutEventId\",-1]\n        ];\n    };\n\n\n    // get helicopter to disengage and rtb\n    _pilot disableAI \"AUTOTARGET\";\n    _pilotsGroup setCombatMode \"BLUE\";\n\n    // not using waypoints here because they are auto-deleted for an unkown reason a few seconds after being created for the unit\n\n    // return to spawn position area\n    private _deletePosition = _centerPosition getPos [SPAWN_DISTANCE,_approachBearing + 180];\n    _heli doMove _deletePosition;\n\n    waitUntil {\n        private _isOnGround = ((getPosATL _heli) select 2) < 2;\n        if (\n            _isOnGround OR\n            (_heli getVariable [\"KISKA_helicopterGunner_stop\",true]) OR\n            {(_heli distance2D _deletePosition) <= 200}\n        ) then {\n            if (_isOnGround) then {\n                _heli setDamage 1;\n            };\n\n            breakWith true\n        };\n\n        sleep 2;\n        false\n    };\n\n    // killed event shousld have taken care of cleanup\n    if !(alive _heli) exitWith {};\n\n    [_heli,\"KISKA_helicopterGunner_event_heliKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n    [_pilot,\"KISKA_helicopterGunner_event_pilotKilled\"] call BIS_fnc_removeAllScriptedEventHandlers;\n    [_pilot,\"KISKA_helicopterGunner_event_pilotGotOut\"] call BIS_fnc_removeAllScriptedEventHandlers;\n\n    _heliCrew apply {\n        _heli deleteVehicleCrew _x;\n    };\n    deleteVehicle _heli;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Move to support zone\n---------------------------------------------------------------------------- */\n// move command only supports position arrays\nif (_centerPosition isEqualType objNull) then {\n    _centerPosition = getPosATL _centerPosition;\n};\n\n_heli setVariable [\"KISKA_helicopterGunner_stop\",false];\n\n\nprivate _params = [\n    _centerPosition,\n    _radius,\n    _timeOnStation,\n    _supportSpeedLimit,\n    _approachBearing,\n    _side,\n    _heli,\n    _pilotsGroup,\n    _heliCrew,\n    _pilot,\n    _postSupportCode,\n    _fn_supportEnded\n];\n\n_params spawn {\n    params [\n        \"_centerPosition\",\n        \"_radius\",\n        \"_timeOnStation\",\n        \"_supportSpeedLimit\",\n        \"_approachBearing\",\n        \"_side\",\n        \"_heli\",\n        \"_pilotsGroup\",\n        \"_heliCrew\",\n        \"_pilot\",\n        \"_postSupportCode\",\n        \"_fn_supportEnded\"\n    ];\n\n    // once you go below a certain radius, it becomes rather unnecessary\n    if (_radius < MIN_RADIUS) then {\n        _radius = MIN_RADIUS;\n    };\n\n    // move to support zone\n    // checking driver instead of cache to see if they got out of the vehicle\n    private _vehicleEffective = true;\n    waitUntil {\n        private _isOnGround = ((getPosATL _heli) select 2) < 2;\n        if (\n            _isOnGround OR \n            (_heli getVariable [\"KISKA_helicopterGunner_stop\",true])\n        ) then {\n            _vehicleEffective = false;\n            breakWith true\n        };\n\n        _pilotsGroup move _centerPosition;\n        sleep 2;\n\n        ((_heli distance2D _centerPosition) <= _radius)\n    };\n\n    \n    if !(_vehicleEffective) exitWith {\n        [\n            _heli,\n            _pilotsGroup,\n            _heliCrew,\n            _pilot,\n            _centerPosition,\n            _postSupportCode,\n            _approachBearing\n        ] call _fn_supportEnded;\n    };\n\n\n    /* ----------------------------------------------------------------------------\n        Do support\n    ---------------------------------------------------------------------------- */\n    [\n        _heli,\n        5,\n        4,\n        _radius * 2,\n        1,\n        true\n    ] spawn KISKA_fnc_engageHeliTurretsLoop;\n\n    // to keep helicopters from just wildly flying around\n    _heli limitSpeed _supportSpeedLimit;\n    private _sleepTime = 20;\n    private _numberOfBearings = count STAR_BEARINGS;\n    private _elapsedTime = 0;\n    private _bearingIndex = 0;\n    while {_timeOnStation > _elapsedTime} do {\n         private _isOnGround = ((getPosATL _heli) select 2) < 2;\n        if (\n            _isOnGround OR \n            (_heli getVariable [\"KISKA_helicopterGunner_stop\",true])\n        ) then {\n            break;\n        };\n\n        private _movePos = _centerPosition getPos [_radius,STAR_BEARINGS select _bearingIndex];\n        _bearingIndex = _bearingIndex + 1;\n        if (_bearingIndex >= _numberOfBearings) then {\n            _bearingIndex = 0;\n        };\n\n        _heli doMove _movePos;\n\n        private _newElapsedTime = _elapsedTime + _sleepTime;\n        private _isLastRotation = _newElapsedTime > _timeOnStation;\n        if (_isLastRotation) then {\n            sleep (_timeOnStation - _elapsedTime);\n        } else {\n            sleep _sleepTime;\n        };\n\n        _elapsedTime = _newElapsedTime;\n    };\n\n    // end engage heli turrets loop\n    _heli setVariable [\"KISKA_heliTurrets_endLoop\",true];\n\n    /* ----------------------------------------------------------------------------\n        After support is done\n    ---------------------------------------------------------------------------- */\n    //[TYPE_CAS_ABORT,_heliCrew select 0,_side] call KISKA_fnc_supportRadio;\n\n    // remove speed limit\n    _heli limitSpeed 99999;\n\n    [\n        _heli,\n        _pilotsGroup,\n        _heliCrew,\n        _pilot,\n        _centerPosition,\n        _postSupportCode,\n        _approachBearing\n    ] call _fn_supportEnded;\n};\n\n\n_vehicleArray\n",
    "fileName": "fn_helicopterGunner.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_paratroopers\n\nDescription:\n    Takes a set of units and moves them into aircraft to be dropped over a position\n     via parachute from a spawned vehicle\n\nParameters:\n    0: _dropZone : <OBJECT or ARRAY> - Target of where to drop the units\n    1: _unitsThatCanDrop : <ARRAY> - An array of units that can be dropped\n    2: _dropVehicleClass : <STRING> - What vehicle class will drop the units\n    3: _numToDrop : <NUMBER> - The number of units out of the array to drop\n        (if -1, will resize to the amount of units in _unitsToDrop)\n    4: _flyDirection : <NUMBER> - The direction that the aircraft will fly towards _dropZone\n        (if -1, will be random direction)\n    5: _flyInHeight : <NUMBER> - The flyInHeight of the aircraft\n    6: _side : <SIDE> - What side is the drop aircraft\n    7: _spawnDistance : <NUMBER> - How far away should the aircraft spawn\n    8: _invincibleOnDrop : <BOOL> - Should the units be invincible while parachuting down\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] spawn KISKA_fnc_paratroopers;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_paratroopers\";\n\n#define WAIT_TILL_NEAR(pos,dist,checkRate) \\\n    waitUntil { \\\n        if ((_aircraft distance2D pos) <= dist) exitWith {true}; \\\n        if (isNull _aircraft) exitWith {true}; \\\n        sleep checkRate; \\\n        false \\\n    };\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled; Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_paratroopers;\n};\n\nparams [\n    [\"_dropZone\",objNull,[objNull,[]]],\n    [\"_unitsThatCanDrop\",[],[[]]],\n    [\"_dropVehicleClass\",\"\",[\"\"]],\n    [\"_numToDrop\",-1,[123]],\n    [\"_flyDirection\",-1,[123]],\n    [\"_flyInHeight\",200,[123]],\n    [\"_side\",BLUFOR,[BLUFOR]],\n    [\"_spawnDistance\",2000,[123]],\n    [\"_invincibleOnDrop\",false,[true]]\n];\n\n/* ----------------------------------------------------------------------------\n    Check params\n---------------------------------------------------------------------------- */\nif ((_dropZone isEqualType objNull AND {isNull _dropZone}) OR {_dropzone isEqualTo []}) exitWith {\n    [[str _dropZone,\" is an invalid _dropZone\"],true] call KISKA_fnc_log;\n    nil\n};\nif (_dropVehicleClass isEqualTo \"\") exitWith {\n    [\"_dropVehicleClass isEqualTo ''\",true] call KISKA_fnc_log;\n    nil\n};\nif (_unitsThatCanDrop isEqualTo []) exitWith {\n    [\"_unitsThatCanDrop isEqualTo []\",true] call KISKA_fnc_log;\n    nil\n};\nif (_numToDrop < -1 OR {_numToDrop isEqualTo 0}) exitWith {\n    [[\"_numToDrop is improper number: \",_numToDrop],true] call KISKA_fnc_log;\n    nil\n};\nif (_spawnDistance < 0) exitWith {\n    [[\"_spawnDistance can't be a negative number: \",_spawnDistance],true] call KISKA_fnc_log;\n    nil\n};\n\n\n// make sure vehicle can hold the number of units to drop and adjust accordingly\nprivate _unitCount = count _unitsThatCanDrop;\nif (_numToDrop isEqualTo -1 OR {_unitCount < _numToDrop}) then {\n    _numToDrop = _unitCount;\n};\nprivate _vehicleCargoCapacity = ([_dropVehicleClass,true] call BIS_fnc_crewCount) - ([_dropVehicleClass,false] call BIS_fnc_crewCount);\nif (_numToDrop > _vehicleCargoCapacity) then {\n    [[\"vehicle class: \",_dropVehicleClass,\" has \",_vehicleCargoCapacity,\" cargo positions, requested \",_numToDrop,\" to be dropped!\"],false] call KISKA_fnc_log;\n    _numToDrop = _vehicleCargoCapacity;\n};\n\nif (_dropZone isEqualType objNull) then {\n    _dropZone = getPosATL _dropZone;\n};\n\nif (_flyDirection < 0) then {\n    _flyDirection = round (random 360);\n};\n\n\nprivate _flyFromDirection = [_flyDirection + 180] call CBA_fnc_simplifyAngle;\n_dropZone set [2,_flyInHeight];\n\nprivate _spawnPosition = [\n    _dropZone,\n    _spawnDistance,\n    _flyFromDirection\n] call KISKA_fnc_getPosRelativeSurface;\n_spawnPosition vectorAdd [0,0,_flyInHeight];\n\n/* ----------------------------------------------------------------------------\n    Create vehicle to drop units\n---------------------------------------------------------------------------- */\nprivate _vehicleArray = [_spawnPosition,_flyDirection,_dropVehicleClass,_side,false] call KISKA_fnc_spawnVehicle;\nprivate _aircraft = _vehicleArray select 0;\nallCurators apply {\n    [_x,[[_aircraft],true]] remoteExec [\"addCuratorEditableObjects\",2];\n};\n_aircraft flyInHeight _flyInHeight;\nprivate _aircraftGroup = _vehicleArray select 2;\n_aircraftGroup setCombatBehaviour \"CARELESS\";\n\n// move units into vehicle cargo\nprivate _unitsToDrop = [];\n_unitsThatCanDrop apply {\n    if (_numToDrop isEqualTo 0) exitWith {};\n    _x moveInCargo _aircraft;\n    _unitsToDrop pushBack _x;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Move to drop zone\n---------------------------------------------------------------------------- */\nprivate _leader = leader _aircraftGroup;\n_leader doMove _dropZone;\n\n// get the ai near the DZ, if just used a position past the dz (_deletePosition), the AI might veer off course\nWAIT_TILL_NEAR(_dropZone,200,0.25)\nif (isNull _aircraft) exitWith {};\n\n// now fly past the dz and when close enough, drop units so there is a decent spread\nprivate _deletePosition = _dropZone getPos [2000,_flyDirection];\n_leader doMove _deletePosition;\nWAIT_TILL_NEAR(_dropZone,100,0.25)\n// get units out of aircraft\n[_aircraft,_unitsToDrop,_invincibleOnDrop] call KISKA_fnc_staticLine;\n_leader doMove _deletePosition;\n\n\n/* ----------------------------------------------------------------------------\n    Delete Aircraft and Crew\n---------------------------------------------------------------------------- */\nWAIT_TILL_NEAR(_deletePosition,200,2)\n(_vehicleArray select 1) apply {\n    _aircraft deleteVehicleCrew _x;\n};\ndeleteVehicle _aircraft;\n\n\nnil\n",
    "fileName": "fn_paratroopers.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supplyDrop\n\nDescription:\n    Spawns a supply drop near the requested position. Crates will parachute in.\n\nParameters:\n    0: _classNames <ARRAY> - Classnames of boxes you want dropped. Also determines the number of crates\n    1: _altittude <NUMBER> - Start height of drop\n    2: _dropPosition <OBJECT, GROUP, ARRAY, LOCATION, TASK> - Position you want the drop to be near\n\n    OPTIONAL:\n    3: _stopAdjustingHeight <NUMBER> - The height (ATL) at which the velocity of the crates should top being managed\n    4: _chuteVelocityFreq <NUMBER> - The frequency in seconds at which the velocity of the crates should be managed\n    5: _stage_1_height <NUMBER> - The height above which the _stage_1_velocityDiff is used to manage the downward velocity of the crates\n    6: _stage_1_velocityDiff <NUMBER> - The downward velocity of the crates above _stage_1_height\n    7: _stage_2_velocityDiff <NUMBER> - The downward velocity of the crates below _stage_1_height\n\nReturns:\n    <ARRAY> - The containers dropped\n\nExamples:\n    (begin example)\n        [[\"className1\",\"className2\"], 500, player] call KISKA_fnc_supplyDrop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supplyDrop\";\n\nparams [\n    [\"_classNames\",[\"B_supplyCrate_F\"],[[]]],\n    [\"_altittude\",100,[1]],\n    [\"_dropPosition\",objNull,[objNull,[],grpNull,locationNull,taskNull]],\n    [\"_stopAdjustingHeight\",80,[123]],\n    [\"_chuteVelocityFreq\",0.25,[123]],\n    [\"_stage_1_height\",500,[123]],\n    [\"_stage_1_velocityDiff\",90,[123]],\n    [\"_stage_2_velocityDiff\",35,[123]]\n];\n\nif (_classNames isEqualTo []) exitWith {\n    [\"No classnames passed!\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _containersArray = [];\nprivate [\"_container_temp\",\"_dropZone_temp\",\"_chute_temp\"];\n_classNames apply {\n    // create Container\n    _container_temp = createVehicle [_x,[0,0,0],[],0];\n    _containersArray pushBack _container_temp;\n\n    _dropZone_temp = [_dropPosition,50] call CBA_fnc_randPos;\n    _dropZone_temp set [2,0];\n    _container_temp allowDamage false;\n\n    // create it's parachutes\n    _chute_temp = createVehicle [\"b_parachute_02_F\",[0,0,0]];\n    _chute_temp setPosATL (_dropZone_temp vectorAdd [random [-10,0,10],random [-10,0,10],_altittude]);\n    _container_temp attachTo [_chute_temp,[0,0,0]];\n\n    // speed up the drop\n    [_chute_temp,_container_temp,_chuteVelocityFreq,_stage_1_height,_stage_1_velocityDiff,_stage_2_velocityDiff,_stopAdjustingHeight] spawn {\n        params [\n            \"_chute\",\n            \"_container\",\n            \"_chuteVelocityFreq\",\n            \"_stage_1_height\",\n            \"_stage_1_velocityDiff\",\n            \"_stage_2_velocityDiff\",\n            \"_stopAdjustingHeight\"\n        ];\n        // give chute time to deploy\n        sleep 3;\n\n\n        private \"_chuteVelocity\";\n        private _chuteHeight = (getPosATLVisual _chute) select 2;\n        waitUntil {\n            sleep _chuteVelocityFreq;\n            _chuteVelocity = velocity _chute;\n\n            if (_chuteHeight > _stage_1_height) then {\n                _chute setVelocity (_chuteVelocity vectorDiff [0,0,_stage_1_velocityDiff]);\n            } else {\n                _chute setVelocity (_chuteVelocity vectorDiff [0,0,_stage_2_velocityDiff]);\n            };\n            _chuteHeight = (getPosATLVisual _chute) select 2;\n\n\n            _chuteHeight < _stopAdjustingHeight\n        };\n\n        waitUntil {\n            _chuteHeight = (getPosATL _chute) select 2;\n            if (_chuteHeight < 15) exitWith {\n                detach _container;\n                true\n            };\n            sleep 1;\n            false\n        };\n    };\n};\n\n\n[_containersArray select 0] spawn {\n    params [\"_firstContainer\"];\n\n    private _containerHeight = (getPosATL _firstContainer) select 2;\n    waitUntil {\n        if (_containerHeight < 5) exitWith {true};\n        sleep 2;\n        _containerHeight = (getPosATL _firstContainer) select 2;\n        false\n    };\n\n    private _position = [_firstContainer,10] call CBA_fnc_randPos;\n    private _chemlight = createvehicle [\"Chemlight_green_infinite\",_position,[],0,\"NONE\"];\n    private _smoke = createvehicle [\"G_40mm_SmokeBlue_infinite\",_position,[],0,\"NONE\"];\n    private _deleteTime = time + 60;\n    waitUntil {\n        // waitUntil a player is within 10m of the first container\n        if (\n            (((call CBA_fnc_players) findIf {\n                (_x distance2D _firstContainer) <= 10\n            }) isNotEqualTo -1) OR\n            {time > _deleteTime}\n        ) exitWith {true};\n\n        sleep 2;\n        false\n    };\n    // delete markers\n    [_chemlight,_smoke] apply {\n        if (!isNull _x) then {\n            deleteVehicle _x;\n        };\n    };\n};\n\n\n_containersArray\n",
    "fileName": "fn_supplyDrop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_supplyDrop_aircraft\n\nDescription:\n    Spawns in an aircraft that flies over a DZ to drop off supplies.\n\nParameters:\n    0: _dropPosition : <ARRAY or OBJECT> - The position (area) to drop the arsenal\n      1: _vehicleClass : <STRING> - The class of the vehicle to drop the arsenal\n    2: _crates : <ARRAY> - An array of strings that are the classnames of the crates to drop\n    3: _deleteCargo : <BOOL> - Delete all the default cargo inside the crates\n    4: _addArsenal : <BOOL> - add an arsenal to all the crates\n\n    5: _flyinHeight : <NUMBER> - The flyInHeight of the drop vehicle\n    6: _flyDirection : <NUMBER> - The compass bearing for the aircraft to apporach from (if < 0, it's random)\n    7: _flyInRadius : <NUMBER> - How far out the drop vehicle will spawn and then fly in\n    8: _lifeTime : <NUMBER> - How long until the arsenal is deleted\n    9: _side : <SIDE> - The side of the drop vehicle\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [position player] call KISKA_fnc_supplyDrop_aircraft;\n    (end)\n\nAuthor(s):\n    Hilltop(Willtop) & omNomios,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_supplyDrop_aircraft\";\n\nparams [\n    [\"_dropPosition\",[],[[],objNull]],\n    [\"_vehicleClass\",\"B_T_VTOL_01_vehicle_F\",[\"\"]],\n    [\"_crates\",[\"B_supplyCrate_F\"],[[]]],\n    [\"_deleteCargo\",true,[true]],\n    [\"_addArsenal\",true,[true]],\n\n    [\"_flyinHeight\",500,[123]],\n    [\"_flyDirection\",-1,[123]],\n    [\"_flyInRadius\",2000,[123]],\n    [\"_lifeTime\",-1,[123]],\n    [\"_side\",BLUFOR,[sideUnknown]]\n];\n\n// get directions for vehicle to fly\nif (_flyDirection < 0) then {\n    _flyDirection = round (random 360);\n};\n\nprivate _flyFromDirection = [_flyDirection + 180] call CBA_fnc_simplifyAngle;\nprivate _spawnPosition = [\n    _dropPosition,\n    _flyInRadius,\n    _flyFromDirection\n] call KISKA_fnc_getPosRelativeSurface;\n_spawnPosition vectorAdd [0,0,_flyInHeight];\n\nprivate _relativeDirection = _spawnPosition getDir _dropPosition;\n\n// spawn vehicle\nprivate _pilotClass = getText(configFile >> \"CfgVehicles\" >> _vehicleClass >> \"Crew\");\nprivate _vehicleArray = [\n    _spawnPosition,\n    _relativeDirection,\n    _vehicleClass,\n    _side,\n    false,\n    [_pilotClass] // spawn just a pilot\n] call KISKA_fnc_spawnVehicle;\n\nprivate _aircraftCrew = _vehicleArray select 1;\n_aircraftCrew apply {\n    _x setCaptive true;\n};\n\nprivate _aircraftGroup = _vehicleArray select 2;\n_aircraftGroup setCombatBehaviour \"CARELESS\";\n_aircraftGroup setCombatMode \"BLUE\";\n\n[_aircraftGroup,true] call KISKA_fnc_ACEX_setHCTransfer;\n\n\n\nprivate _aircraft = _vehicleArray select 0;\nif !(_dropPosition isEqualType []) then {\n    _dropPosition = getPosWorld _dropPosition;\n};\n\n_aircraft move _dropPosition;\n_aircraft flyInHeight _flyinHeight;\n\n// give it a waypoint and delete it after it gets there\nprivate _flyToPosition = _dropPosition getPos [_flyInRadius,_relativeDirection];\n\n[_aircraft,_dropPosition,_aircraftGroup,_flyToPosition,_lifeTime,_crates,_deleteCargo,_addArsenal] spawn {\n    params [\"_aircraft\",\"_dropPosition\",\"_aircraftGroup\",\"_flyToPosition\",\"_lifeTime\",\"_crates\",\"_deleteCargo\",\"_addArsenal\"];\n    waitUntil {\n        if (_aircraft distance2D _dropPosition <= 40) exitWith {true};\n        sleep 0.25;\n        false\n    };\n\n    sleep 0.1;\n\n    private _aircraftAlt = (getPosATL _aircraft) select 2;\n    private _boxSpawnPosition = _aircraft getRelPos [10 * (count _crates),180];\n    private _containers = [\n        _crates,\n        _aircraftAlt,\n        _boxSpawnPosition\n    ] call KISKA_fnc_supplyDrop;\n\n\n    if (_deleteCargo) then {\n        _containers apply {\n            [_x] call KISKA_fnc_clearCargoGlobal;\n        };\n    };\n\n    if (_addArsenal) then {\n        [_containers] call KISKA_fnc_addArsenal;\n    };\n\n\n    // go to deletion point\n    _aircraft move _flyToPosition;\n    waitUntil {\n        if (_aircraft distance2D _flyToPosition <= 100) exitWith {true};\n        sleep 0.25;\n        false\n    };\n\n    (units _aircraftGroup) apply {\n        _aircraft deleteVehicleCrew _x;\n    };\n    deleteVehicle _aircraft;\n};\n\n\nnil\n",
    "fileName": "fn_supplyDrop_aircraft.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_virtualArty\n\nDescription:\n    Calls for an artillery or mortar strike at a designated position and marks the spot.\n\nParameters:\n    0: _target <OBJECT, ARRAY, or STRING(marker)> - The target you want to cluter fire around\n    1: _ammoType <STRING> - The ammo type from cfgAmmo \n    2: _radius <NUMER> - Spread of rounds\n    3: _numberOfRounds <NUMER> - The number of rounds to fire\n    4: _delayBetween <NUMER> - Time between shots\n    5: _markPosition <BOOL> - Marks the target position with smoke and chemlight (delete after 20 seconds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [target_1,\"Sh_155mm_AMOS\"] spawn KISKA_fnc_virtualArty;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\n#define FLARE_ALT 200\n#define FLARE_VELOCITY -10\n\nscriptName \"KISKA_fnc_virtualArty\";\n\nif (!canSuspend) exitWith {\n    [\"Needs to be run in scheduled; Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_virtualArty;\n};\n\nparams [\n    [\"_fireAtPosition\",objNull,[[],objNull]],\n    [\"_ammoType\",\"Sh_155mm_AMOS\",[\"\"]],\n    [\"_radius\",25,[123]],\n    [\"_numberOfRounds\",3,[123]],\n    [\"_delayBetween\",5,[123]],\n    [\"_markPosition\",false,[true]]\n];\n\n// flare round need to fall slower\nif (_ammoType == \"F_20mm_white\") exitWith {\n    // delay for fire\n    sleep 3;\n    \n    private _flare = \"F_20mm_white\" createvehicle (_fireAtPosition vectorAdd [0,0,FLARE_ALT]);  \n    _flare setVelocity [0,0,FLARE_VELOCITY];\n    private _light = \"#lightpoint\" createVehicle (getPosASL _flare);\n    _light attachTo [_flare, [0, 0, 0]];\n    \n    // light characteristic adjustments must be done locally for each player\n    [_light,_flare] remoteExecCall [\"KISKA_fnc_updateFlareEffects\",0,_flare];\n\n    waitUntil {\n        sleep 0.5;\n        !alive _flare;\n    };\n    deletevehicle _light;\n};\n\nif (_markPosition) then {\n    [_fireAtPosition] spawn {\n        params [\"_fireAtPosition\"];        \n        private _chemlight = createvehicle [\"Chemlight_green_infinite\",_fireAtPosition,[],0,\"NONE\"];\n        private _smoke = createvehicle [\"G_40mm_SmokeRed_infinite\",_fireAtPosition,[],0,\"NONE\"];\n        //private _flare = createvehicle [\"F_40mm_Red\",_fireAtPosition,[],0,\"NONE\"];\n        sleep 20;\n        deleteVehicle _chemlight;\n        deleteVehicle _smoke;\n        //deleteVehicle _flare;\n    };\n};\n\n// some delay for \"sim\" purposes\nsleep 5;\n\n[_fireAtPosition,_ammoType,_radius,_numberOfRounds,_delayBetween,{},nil,1300] spawn BIS_fnc_fireSupportVirtual;",
    "fileName": "fn_virtualArty.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_createTaskFromConfig\n\nDescription:\n    Creates a task from a config entry. Config should be placed inside KISKA_cfgTasks,\n     just the string is needed to reference the config entry.\n\n    Parameters from index 2 onwards will accept configNull as an alias for retrieving\n     the configed value of the param if it is not changed (see example 2)\n\nParameters:\n    0: _config <STRING or CONFIG> - The config entry to convert to a task\n    1: _owner <BOOL, OBJECT, GROUP, SIDE, or ARRAY> - Whom the task is assigned to\n\n    (OPTIONAL)\n    2: _taskState <STRING, BOOL, or configNull> - The state of the task, will overwrite config entry\n    3: _destination <OBJECT, ARRAY, or configNull> The position of the task. Array can be either\n        [x,y,z] or [OBJECT,precision] (see setSimpleTaskTarget). The destination can be a configed array, however, this will\n        overwrite it if provided here.\n    4: _type <STRING or configNull> - The task type (defined in CfgTaskTypes)\n    5: _notifyOnCreate <BOOL or configNull> - Should a notification pop up when the task is created?\n    6: _visibleIn3D <BOOL or configNull> - Show a 3D task icon\n\nReturns:\n    <STRING> - Created Task Id\n\nExamples:\n    (begin example)\n        // simple task from config\n        [missionConfigFile >> MyTasks >> \"someTaskClass\",true] call KISKA_fnc_createTaskFromConfig;\n    (end)\n\n    (begin example)\n        [\n            \"someTaskClass\", // will search in missionConfigFile >> \"KISKA_cfgTasks\"\n            true,\n            \"ASSIGNED\",\n            configNull, // get configed destination value\n            \"ATTACK\"\n        ] call KISKA_fnc_createTaskFromConfig;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_createTaskFromConfig\";\n\n#define GET_CFG_TEXT(entry) getText(_config >> entry)\n#define GET_CFG_NUMBER(entry) getNumber(_config >> entry)\n#define GET_CFG_BOOL(entry) [_config >> entry] call BIS_fnc_getCfgDataBool\n#define GET_CFG_ARRAY(entry) getArray(_config >> entry)\n#define CHECK_VAR(gvar,taskState) if (missionNamespace getVariable [gvar,false]) exitWith {_setTaskState = taskState; true};\n\nparams [\n    [\"_config\",\"\",[configNull,\"\"]],\n    [\"_owner\",true,[true,objNull,grpNull,sideUnknown,[]]],\n    [\"_taskState\",configNull,[\"\",true,configNull]],\n    [\"_destination\",configNull,[objNull,[],configNull]],\n    [\"_type\",configNull,[\"\",configNull]],\n    [\"_notifyOnCreate\",configNull,[configNull,true]],\n    [\"_visibleIn3D\",configNull,[configNull,true]]\n];\n\n\n/* ----------------------------------------------------------------------------\n    Get Config Values\n---------------------------------------------------------------------------- */\nif (_config isEqualType \"\") then {\n    _config = (missionConfigFile >> \"KISKA_cfgTasks\" >> _config);\n};\n\nif (_config isEqualTo configNull) exitWith {\n    [\"_config is null!\",true] call KISKA_fnc_log;\n    \"\"\n};\n\nprivate _taskId = configName _config;\nif ([_taskId] call BIS_fnc_taskExists) exitWith {\n    [[\"The task with ID: \",_taskId,\" already exists\"],false] call KISKA_fnc_log;\n    \"\"\n};\n\nif (_taskState isEqualTo configNull) then {\n    _taskState = GET_CFG_TEXT(\"defaultState\");\n\n    if (_taskState isEqualTo \"\") then {\n        _taskState = \"CREATED\";\n    };\n};\n\nif (_destination isEqualTo configNull) then {\n\n    private _compiledDestination = GET_CFG_TEXT(\"compiledDestination\");\n    if (_compiledDestination isNotEqualTo \"\") then {\n        _destination = call (compileFinal _compiledDestination);\n    };\n\n    if ((_destination isEqualType objNull) AND {!(isNull _destination)}) exitWith {};\n    if (\n        (_destination isEqualTypeParams [123,123,123]) OR \n        (_destination isEqualTypeParams [objNull,123])\n    ) exitWith {};\n\n\n    _destination = GET_CFG_ARRAY(\"destination\");\n    if (_destination isEqualTo []) then {\n        _destination = objNull;\n    };\n};\n\nif (_type isEqualTo configNull) then {\n    _type = GET_CFG_TEXT(\"type\");\n\n    if (_type isEqualTo \"\") then {\n        _type = \"DEFAULT\";\n    };\n};\n\nif (_notifyOnCreate isEqualTo configNull) then {\n    if !(isNull (_config >> \"notifyOnCreate\")) then {\n        _notifyOnCreate = true;\n    } else {\n        _notifyOnCreate = GET_CFG_BOOL(\"notifyOnCreate\");\n    };\n};\n\nif (_visibleIn3D isEqualTo configNull) then {\n    _visibleIn3D = GET_CFG_BOOL(\"visibleIn3D\");\n};\n\n\nprivate _taskTitle = GET_CFG_TEXT(\"title\");\nprivate _taskDescription = GET_CFG_TEXT(\"description\");\nprivate _priority = GET_CFG_NUMBER(\"priority\");\n\nprivate _parentTaskId = GET_CFG_TEXT(\"parentTask\");\nif (_parentTaskId isNotEqualTo \"\") then {\n    _taskId = [_taskId,_parentTaskId];\n};\n\n\n/* ----------------------------------------------------------------------------\n    Create Task\n---------------------------------------------------------------------------- */\nprivate _createdTask = [\n    _owner,\n    _taskId,\n    [_taskDescription,_taskTitle],\n    _destination,\n    _taskState,\n    _priority,\n    _notifyOnCreate,\n    _type,\n    _visibleIn3D\n] call BIS_fnc_taskCreate;\n\n\nif (_createdTask isNotEqualTo \"\") then {\n    private _onCreateCode = GET_CFG_TEXT(\"onCreate\");\n\n    if (_onCreateCode isNotEqualTo \"\") then {\n        [_taskId,_config,_taskState] call (compile _onCreateCode);\n    };\n\n    // do onComplete code if already ended\n    if (\n        _taskState == \"SUCCEEDED\" OR\n        (_taskState == \"FAILED\") OR\n        (_taskState == \"CANCELED\")\n    ) then {\n        private _onCompleteCode = GET_CFG_TEXT(\"onComplete\");\n        [_taskId,_config,_taskState] call (compile _onCompleteCode);\n    };\n};\n\n\n_createdTask\n",
    "fileName": "fn_createTaskFromConfig.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_endTask\n\nDescription:\n    Either completes, cancels, or ends a task and calls the task's onComplete\n     event if it is defined in KISKA_cfgTasks.\n\n    Meant to be paired with KISKA_fnc_createTaskFromConfig.\n\nParameters:\n    0: _taskId <STRING> - The task id/KISKA_cfgTasks class name\n    1: _state <NUMBER> - 0 for SUCCEEDED, 1 for FAILED, 2 for CANCELED\n    2: _notify <BOOL> - Should a nortification be shown\n    4: _owner <BOOL, OBJECT, GROUP, SIDE, or ARRAY> - Whom the task is assigned to\n        (this is only needed in the event that the task is ended without it having been created)\n\nReturns:\n    <BOOL> - Whether or not the state of the task was set to the desired one\n\nExamples:\n    (begin example)\n        private _taskIsSucceeded = [\"mytaskID\",0] call KISKA_fnc_endTask;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_endTask\";\n\n#define STATE_SUCCEEDED 0\n#define STATE_FAILED 1\n#define STATE_CANCELED 2\n\nparams [\n    [\"_taskId\",\"\",[\"\",configNull]],\n    [\"_state\",0,[123]],\n    [\"_notify\",configNull],\n    [\"_owner\",true,[true,objNull,grpNull,sideUnknown,[]]]\n];\n\n\nif (isMultiplayer AND {!isServer}) exitWith {\n    [\"Not Server, remoteExecuting on server...\"] call KISKA_fnc_log;\n    _this remoteExecCall [\"KISKA_fnc_endTask\",2];\n    \"\"\n};\n\n\nprivate _config = _taskId;\nif (_taskId isEqualType \"\") then {\n    _config = missionConfigFile >> \"KISKA_cfgTasks\" >> _taskId;\n} else {\n    _taskId = configName _config;\n};\n\nprivate _taskHasClass = isClass _config;\n// if you want config default value\nif (_notify isEqualTo configNull) then {\n    if (_taskHasClass) then {\n        // if config entry for notifyOnComplete is present\n        if !(isNull (_config >> \"notifyOnComplete\")) then {\n            _notify = true;\n\n        } else {\n            _notify = [_config >> \"notifyOnComplete\"] call BIS_fnc_getCfgDataBool;\n\n        };\n\n    } else {\n        _notify = true;\n\n    };\n};\n\nswitch _state do {\n    case STATE_SUCCEEDED:{\n        _state = \"SUCCEEDED\";\n    };\n\n    case STATE_FAILED:{\n        _state = \"FAILED\";\n    };\n\n    case STATE_CANCELED:{\n        _state = \"CANCELED\";\n    };\n    default {};\n};\n\n\nprivate _taskSet = false;\nif ([_taskId] call BIS_fnc_taskExists) then {\n    _taskSet = [_taskId,_state,_notify] call BIS_fnc_taskSetState;\n\n    if (_taskHasClass) then {\n        private _completeEvent = getText(_config >> \"onComplete\");\n\n        if (_completeEvent isNotEqualTo \"\") then {\n            [_taskId,_config,_state] call (compile _completeEvent);\n        };\n    };\n\n} else {\n    [\n        _config,\n        _owner,\n        _state,\n        configNull,\n        configNull,\n        _notify\n    ] call KISKA_fnc_createTaskFromConfig;\n\n    _taskSet = true;\n};\n\n\n_taskSet\n",
    "fileName": "fn_endTask.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_executeEvent\n\nDescription:\n    Executes a recursive chain timeline events. This should not be executed on its\n     own but begins from KISKA_fnc_timeline_start.\n\nParameters:\n    0: _timelineEvents <ARRAY> - An array of timeline events that will happen. \n        See KISKA_fnc_timeline_start for formats\n    1: _timelineId <STRING> - The id of the timeline to stop\n    2: _timelineMap <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n    3: _previousReturn <ANY> - The returned value from the previous events function\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_timelineEvents,\"KISKA_timeline_1\"] call KISKA_fnc_timeline_executeEvent\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_executeEvent\";\n\nparams [\n    [\"_timelineEvents\",[],[[]]],\n    [\"_timelineId\",\"\",[\"\"]],\n    \"_timelineMap\",\n    \"_previousReturn\"\n];\n\n\nprivate _timelineIsRunning = [_timelineId,false] call KISKA_fnc_timeline_isRunning;\nif !(_timelineIsRunning) exitWith {\n    // execute call back function for when timeline is stopped here only\n    private _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\n    private _timelineValues = _overallTimelineMap getOrDefault [_timelineId,[]];\n    _timelineValues params [\n        [\"_timelineValueEvents\",[],[[]]],\n        \"_timelineMap\",\n        [\"_onTimelineStopped\",{},[[],{},\"\"]]\n    ];\n\n    if (_onTimelineStopped isNotEqualTo {}) then {\n        [[_timelineValueEvents,_timelineMap],_onTimelineStopped] call KISKA_fnc_callBack;\n    };\n\n    _overAllTimelineMap deleteAt _timelineId;\n\n\n    nil\n};\n\n\nprivate _event = _timelineEvents deleteAt 0;\n_event params [\n    [\"_code\",{},[[],{},\"\"]],\n    [\"_waitFor\",0,[123,{},\"\",[]]],\n    [\"_interval\",0,[123]]\n];\n\nprivate _eventReturn = [_this,_code] call KISKA_fnc_callBack;\n// this is checked right after event call in case timeline was cleared during event\nif (_timelineEvents isEqualTo []) then {\n    [_timelineId] call KISKA_fnc_timeline_stop;\n};\n\n\nprivate _nextEventParams = [_timelineEvents,_timelineId,_timelineMap];\nif !(isNil \"_eventReturn\") then {\n    _nextEventParams pushBack _eventReturn\n};\n\n\nif (_waitFor isEqualType 123) exitWith {\n    [\n        KISKA_fnc_timeline_executeEvent,\n        _nextEventParams,\n        _waitFor\n    ] call CBA_fnc_waitAndExecute;\n\n    nil\n};\n\n\n[\n    _waitFor,\n    KISKA_fnc_timeline_executeEvent,\n    _interval,\n    _nextEventParams\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_timeline_executeEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_getInfoMap\n\nDescription:\n    The Individual map defined for a specific timeline of the given ID. This is\n     the hashmap available in each timeline's event's code.\n\nParameters:\n    0: _timelineId <STRING> - The id of the timeline to get\n\nReturns:\n    <HASHMAP> - A hashmap containing information for the timeline events\n\nExamples:\n    (begin example)\n        private _timelineMapForId = [\"KISKA_timeline_1\"] call KISKA_fnc_timeline_getInfoMap;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_getInfoMap\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]]\n];\n\n\nprivate _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\nif !(_timelineId in _overallTimelineMap) then {\n    [[\"_timlineId: \",_timlineId,\" does not exist!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _timelineInfo = _overallTimelineMap get _timelineId;\n_timelineInfo select 1\n",
    "fileName": "fn_timeline_getInfoMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_getIsRunningMap\n\nDescription:\n    Returns the map that keeps track of whether or not a given KISKA timeline is\n\t currently running.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - The \"is running\" map\n\nExamples:\n    (begin example)\n        private _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_getIsRunningMap\";\n\nprivate _isRunningMap = localNamespace getVariable [\"KISKA_timeline_isRunningMap\",-1];\nif (_isRunningMap isEqualTo -1) then {\n\t_isRunningMap = createHashMap;\n\tlocalNamespace setVariable [\"KISKA_timeline_isRunningMap\",_isRunningMap];\n};\n\n\n_isRunningMap\n",
    "fileName": "fn_timeline_getIsRunningMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_getMainMap\n\nDescription:\n    The map that links a given timeline id to its info map. This is an internal function\n     that you (likely) don't need to use except for altering timelines that have already started.\n     \n    See KISKA_fnc_timeline_getInfoMap to retrieve an info map for a given timeline.\n\nParameters:\n    NONE\n\nReturns:\n    <HASHMAP> - The overall timeline map to get info on certain timelines\n\nExamples:\n    (begin example)\n        private _mainTimelineMap = call KISKA_fnc_timeline_getMainMap;\n        private _timelineId = \"KISKA_timeline_1\";\n        private _timelineValues = _mainTimelineMap get _timelineId;\n        _timelineValues params [\"_timelineEvents\",\"_timelineMap\",\"_onTimelineStopped\"];\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_getMainMap\";\n\nprivate _mainMap = localNamespace getVariable \"KISKA_timeline_mainMap\";\nif (isNil \"_mainMap\") then {\n    _mainMap = createHashMap;\n    localNamespace setVariable [\"KISKA_timeline_mainMap\",_mainMap];\n};\n\n\n_mainMap\n",
    "fileName": "fn_timeline_getMainMap.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_isRunning\n\nDescription:\n    Checks if a timeline has either fully been complete (_checkForFullCompletion = true) \n     or is simply qued for end at the start of its next event (_checkForFullCompletion = false).\n\nParameters:\n    0: _timelineId <STRING> - The id of the timeline to check\n    1: _checkForFullCompletion <BOOL> - Check if the timeline's onComplete function has \n        completed and the timeline is fully done.\n\nReturns:\n    <BOOL> - The state of the timeline\n\nExamples:\n    (begin example)\n        private _isRunning = [\"KISKA_timeline_1\",false] call KISKA_fnc_timeline_isRunning;\n    (end)\n\n    (begin example)\n        private _timelineIsNotComplete = [\"KISKA_timeline_1\",true] call KISKA_fnc_timeline_isRunning;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_isRunning\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]],\n    [\"_checkForFullCompletion\",true,[true]]\n];\n\n\nif (_checkForFullCompletion) exitWith {\n    private _timelineMap = call KISKA_fnc_timeline_getMainMap;\n    _timelineId in _timelineMap\n};\n\n\nprivate _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n_isRunningMap getOrDefault [_timelineId,false]\n",
    "fileName": "fn_timeline_isRunning.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_setIsRunning\n\nDescription:\n    Sets whether a given timeline is considered to be running.\n\nParameters:\n    0: _timelineId <STRING> - The timeline's id\n    1: _isRunning <BOOL> - `true` to set as running, `false` to set as NOT\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // internal function that should not be directly called\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_setIsRunning\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]],\n    [\"_isRunning\",true,[true]]\n];\n\n\nprivate _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n_isRunningMap set [_timelineId,_isRunning];\n\n\nnil\n",
    "fileName": "fn_timeline_setIsRunning.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_start\n\nDescription:\n    Creates a timeline of events that can happen. Waits/executes in an unscheduled\n     environment. \n    \n    There is a non-trivial amount of overhead to this, however, so\n     do not use with the intention of needing precise events to happen but rather to\n     not clog the scheduler or use a decent interface with smaller units of code.\n\n    (begin example)\n        // A timeline is made up of events:\n        [\n            [], // event 1\n            [] // event 2\n        ]\n    (end)\n\n    (begin example)\n        // Each event is made up of code to execute when the event comes up in the timeline,\n        /// and what to wait for when executing the NEXT event in the timeline AFTER the \n        /// current event completes:\n        [\n            [\n                {\n                    hint \"executed event #1\"\n                },\n                3 // wait 3 seconds AFTER current event to execute event 2\n            ],\n            [\n                {\n                    hint \"executed event #2 3 seconds after event 1 completed\"\n                },\n                1 // wait 1 second to run _onTimelineStopped code\n            ]\n        ]\n    (end)\n    \n    (begin example)\n        // Alternativeley, you can also wait for a condition before proceeeding to the next event:\n        private _endTime = time + 10;\n        [\n            [\n                {hint \"executed event #1\"},\n                3 // wait 3 seconds AFTER current event to execute event 1\n            ],\n            [\n                {hint \"executed event #2 3 seconds after event 1 completed\"},\n                [[_endTime],{\n                    _thisArgs params [\"_endTime\"];\n                    time >= (_endTime) // wait until current time is more than _endTime\n                }],\n                1 // check condition every second\n            ]\n        ]\n    (end)\n\n    (begin example)\n        // You can chain timeline events together by returning\n        [\n            [\n                {\n                    hint \"executed event #1\";\n                    time + 3 // return/send to the next event and current wait condition\n                },\n                {\n                    params [\"\",\"\",\"\",\"_eventReturn\"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint \"executed event #2 ~3 seconds after event 1 completed\"}\n            ]\n        ]\n    (end)\n\nParameters:\n    0: _timeline <ARRAY> - An array of timeline events that will happen. \n        See description above for formats\n    1: _onTimelineStopped <CODE, STRING, or ARRAY> - (see KISKA_fnc_callBack),\n        code that will be executed once a timeline is stopped. \n            \n        Parameters:\n        - 0: <ARRAY> - The timeline array in the state when the stoppage actually happens.\n        - 1: <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n\nReturns:\n    <STRING> - The id of the new timeline\n\nExamples:\n    (begin example)\n        private _timeline = [\n            [\n                {\n                    hint \"executed event #1\";\n                    time + 3 // return/send to next and current wait condition\n                },\n                {\n                    params [\"\",\"\",\"_eventReturn\"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint \"executed event #2 ~3 seconds after event 1 completed\"}, 2\n            ]\n        ];\n        private _timelineId = [_timeline,{hint \"timeline end\"}] call KISKA_fnc_timeline_start;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_start\";\n\nparams [\n    [\"_timeline\",[],[[]]],\n    [\"_onTimelineStopped\",{},[[],{},\"\"]]\n];\n\nif (_timeline isEqualTo []) exitWith {\n    [\"Empty _timeline provided\"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _timelineId = [\"KISKA_timeline\"] call KISKA_fnc_generateUniqueId;\n[_timelineId,true] call KISKA_fnc_timeline_setIsRunning;\n\nprivate _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\nprivate _timelineHashmap = createHashMap;\nprivate _timelineValues = [_timeline,_timelineHashmap];\nif (_onTimelineStopped isNotEqualTo {}) then {\n    _timelineValues pushBack _onTimelineStopped;\n};\n\n_overallTimelineMap set [_timelineId,_timelineValues];\n\n[\n    _timeline,\n    _timelineId,\n    _timelineHashmap\n] call KISKA_fnc_timeline_executeEvent;\n\n\n_timelineId\n",
    "fileName": "fn_timeline_start.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_stop\n\nDescription:\n    Ques a timeline to end on the next execution of an event in it or at the very\n     end of the timeline. This will immediately set KISKA_fnc_timeline_isRunning\n     (where _isFullyComplete-is-false) to be true.\n\nParameters:\n    0: _timelineId <STRING> - The id of the timeline to stop\n    1: _onTimelineStopped <CODE, STRING, or ARRAY> - (see KISKA_fnc_callBack),\n        code that will be executed once a timeline is stopped. \n        \n        Parameters:\n        - 0: <ARRAY> - The timeline array in the state when the stoppage actually happens.\n        - 1: <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"KISKA_timeline_1\"] call KISKA_fnc_timeline_stop;\n    (end)\n\n    (begin example)\n        [\"KISKA_timeline_1\",{hint str [\"timeline stopped!\",_this]}] call KISKA_fnc_timeline_stop;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_timeline_stop\";\n\nparams [\n    [\"_timelineId\",\"\",[\"\"]],\n    [\"_onTimelineStopped\",{},[[],{},\"\"]]\n];\n\n\nif (_onTimelineStopped isNotEqualTo {}) then {\n    private _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\n    private _timelineValues = _overallTimelineMap getOrDefault [_timelineId,[]];\n    private _timelineHasNotEnded = _timelineValues isNotEqualTo [];\n    if (_timelineHasNotEnded) then {\n        _timelineValues set [2,_onTimelineStopped];\n    };\n};\n\n\nprivate _isRunningMap = call KISKA_fnc_timeline_getIsRunningMap;\n_isRunningMap deleteAt _timelineId;\n\n\nnil\n",
    "fileName": "fn_timeline_stop.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addArsenal\n\nDescription:\n    Adds both BIS and ACE arsenals to several or a single object.\n    This has a global effect.\n\nParameters:\n    0: _arsenals <ARRAY or OBJECT> - An array of objects or a single one to add arsenals to\n\nReturns:\n    <BOOL> - True if arsenal added, false if not\n\nExamples:\n    (begin example)\n        [[arsenal1, arsenal2]] call KISKA_fnc_addArsenal;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addArsenal\";\n\nparams [\n    [\"_arsenals\",[],[[],objNull]]\n];\n\nif (_arsenals isEqualTo [] OR {(_arsenals isEqualType objNull) AND {isNull _arsenals}}) exitWIth {\n    [[\"_arsenals are invalid: \",str _arsenals],true] call KISKA_fnc_log;\n    false\n};\n\nif !(_arsenals isequalType []) then {\n    _arsenals = [_arsenals];\n};\n\nprivate _aceLoaded = [\"ace_arsenal\"] call KISKA_fnc_isPatchLoaded;\n\n_arsenals apply {\n    \n    if (_aceLoaded) then {\n        [_x, true, true] call ace_Arsenal_fnc_InitBox;\n    };\n    \n    [\"AmmoboxInit\",[_x,true]] call BIS_fnc_arsenal;\n};\n\n\ntrue",
    "fileName": "fn_addArsenal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addEntityKilledEventHandler\n\nDescription:\n    Adds a killed event handler to a given entity that will persist even if the\n     unit becomes remote. The order of execution is not guaranteed to be in the\n     order added.\n\nParameters:\n    0: _entity <OBJECT> - The entity to add the object to\n    1: _event <CODE, STRING, or ARRAY> - The code to execute (SEE KISKA_fnc_callBack for array syntax).\n        Parmeters:\n\n            - 0. <OBJECT> - The killed entity\n            - 1. <OBJECT> - The killer entity (vehicle or person)\n            - 2. <OBJECT> - The instigator entity\n            - 3. <BOOL> - same as useEffects in `setDamage` alt syntax\n\nReturns:\n    <NUMBER> - The entity killed event handler ID for the unit\n\nExamples:\n    (begin example)\n        private _id = [aUnit,{hint _this}] call KISKA_fnc_addEntityKilledEventHandler;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addEntityKilledEventHandler\";\n\nparams [\n    [\"_entity\",objNull,[objNull]],\n    [\"_event\",{},[\"\",{},[]]]\n];\n\n\nif (isNull _entity) exitWith {\n    [\"null _entity was passed\",true] call KISKA_fnc_log;\n    -1\n};\n\n\nif (localNamespace getVariable [\"KISKA_entityKilledHandlerInitialized\",false]) then {\n    localNamespace setVariable [\"KISKA_entityKilledHandlerInitialized\",true];\n    addMissionEventHandler [\"EntityKilled\",{\n        params [\"_unit\"];\n        \n        private _entityKilledEventHashMap = _unit getVariable \"KISKA_entityKilledEventHashMap\";\n        if !(isNil \"_entityKilledEventHashMap\") then {\n            private _codeForEvents = values _entityKilledEventHashMap;\n            _codeForEvents apply {\n                [_this, _x] call KISKA_fnc_callBack;\n            };\n        };\n    }];\n};\n\n\nprivate _eventHashMap = _entity getVariable \"KISKA_entityKilledEventHashMap\";\nif (isNil \"_eventHashMap\") then {\n    _eventHashMap = createHashMap;\n    _entity setVariable [\"KISKA_entityKilledEventHashMap\",_eventHashMap];\n};\n\nprivate _id = [\"KISKA_entityKilledIdCount\",_entity] call KISKA_fnc_idCounter;\n_eventHashMap set [_id,_event];\n\n\n_id\n",
    "fileName": "fn_addEntityKilledEventHandler.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addKiskaDiaryEntry\n\nDescription:\n    Used as a unified point of adding diary entries for KISKA.\n\nParameters:\n    0: _textEntry <STRING or ARRAY> - The text entry in createDiaryRecord.\n        If array, format is [title,description,icon].\n    1: _task <TASK> - A task attached to the diary record\n    2: _taskState <STRING> - The state of the task\n    3: _showTitle <BOOL> - Whether or not to show title in the description section as well\n\nReturns:\n    <DIARY-RECORD> - An entry in the users diary\n\nExamples:\n    (begin example)\n        [[\"test title\",\"test text\"]] call KISKA_fnc_addKiskaDiaryEntry;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\n#define KISKA_DIARY \"KISKA Systems\"\nscriptName \"KISKA_fnc_addKiskaDiaryEntry\";\n\nif !(hasInterface) exitWith {diaryRecordNull};\n\nif !(player diarySubjectExists KISKA_DIARY) then {\n    player createDiarySubject [KISKA_DIARY, KISKA_DIARY];\n};\n\nparams [\n    [\"_textEntry\",\"\",[\"\",[]]],\n    [\"_task\",taskNull,[taskNull]],\n    [\"_taskState\",\"\",[\"\"]],\n    [\"_showTitle\",true,[true]]\n];\n\nplayer createDiaryRecord [KISKA_DIARY,_textEntry,_task,_taskState,_showTitle];\n",
    "fileName": "fn_addKiskaDiaryEntry.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addMagRepack\n\nDescription:\n    Adds a mag repack to the player via Ctrl+R.\n    To remove see KISKA_fnc_removeMagRepack.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_addMagRepack;\n    (end)\n\nAuthor(s):\n    Quicksilver,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addMagRepack\";\n\n#define DISPLAY_CODE 46\n#define R_KEY_CODE 19\n\nif (!hasInterface) exitWith {};\n\nif (localNamespace getVariable [\"KISKA_magRepackEventId\",-1] isNotEqualTo -1) exitWith {\n    [\"Mag repack has already been added\",true] call KISKA_fnc_log;\n    nil\n};\n\n[\n    {\n        !(isNull (findDisplay DISPLAY_CODE))\n    },\n    {\n        // possibility of two mag repack waitUntils runnning at once\n        if (localNamespace getVariable [\"KISKA_magRepackEventId\",-1] isNotEqualTo -1) exitWith {\n            [\"Mag repack has already been added\",true] call KISKA_fnc_log;\n            nil\n        };\n\n        private _eventId = (findDisplay DISPLAY_CODE) displayAddEventHandler [\"KeyDown\",{\n            params [\"\", \"_key\", \"\", \"_ctrlPressed\"];\n            // passes the pressed key and whether or not a ctrl key is down. The proper combo is ctrl+R\n            if ((_key isEqualTo R_KEY_CODE) AND (_ctrlPressed)) then {\n                [player] call KISKA_fnc_doMagRepack;\n            };\n\n            false\n        }];\n\n        localNamespace setVariable [\"KISKA_magRepackEventId\",_eventId];\n    },\n    0.1\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_addMagRepack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addProximityPlayerAction\n\nDescription:\n    Adds an action to the player that will be activated and deactivated when within\n     a certain radius of a given position.\n\nParameters:\n    0: _center : <OBJECT or ARRAY> - The position the player needs to be close to.\n        If array, format as Postion2D or PositionAGL.\n    1: _radius : <NUMBER> - The max distance the player can be from the _center to\n        get the action.\n    2: _action : <ARRAY> - The action array used with \"addAction\" command\n    3: _refreshInterval : <NUMBER> - How often to look to update action visibility\n\nReturns:\n    <NUMBER> - The porximity action id to be used with KISKA_fnc_removeProximityPlayerAction\n        (-1 if failure)\n\nExamples:\n    (begin example)\n        [\n            cursorObject,\n            15,\n            [\"test\",{hint \"action\"},[]]\n        ] call KISKA_fnc_addProximityPlayerAction\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addProximityPlayerAction\";\n\nif (!hasInterface) exitWith {\n    [\"Can't be added to headless user\", false] call KISKA_fnc_log;\n    -1\n};\n\n\nparams [\n    [\"_center\",objNull,[[],objNull]],\n    [\"_radius\",5,[123]],\n    [\"_action\",[],[[]]],\n    [\"_refreshInterval\",1,[123]]\n];\n\nif (_center isEqualType objNull AND {isNull _center}) exitWith {\n    [\"_center is null object\", true] call KISKA_fnc_log;\n    -1\n};\n\n\nprivate _proximityActionId = [\"KISKA_proximityPlayerActionLatestId\"] call KISKA_fnc_idCounter;\nprivate _varBase = \"KISKA_proximityAction_\" + (str _proximityActionId);\nprivate _actionShouldBeRemovedVar = _varBase + \"_remove\";\nprivate _actionIdVar = _varBase + \"_currentId\";\nlocalNamespace setVariable [_actionShouldBeRemovedVar, false];\nlocalNamespace setVariable [_actionIdVar, -1];\n\n[\n    {\n        params [\n            \"_center\",\n            \"_radius\",\n            \"_action\",\n            \"_refreshInterval\",\n            \"_actionShouldBeRemovedVar\",\n            \"_actionIdVar\"\n        ];\n\n        private _actionId = localNamespace getVariable [_actionIdVar, -1];\n        private _playerInRange = player distance _center <= _radius;\n        private _actionIsVisible = _actionId isNotEqualTo -1;\n\n        if (_playerInRange AND !(_actionIsVisible)) exitWith {\n            _actionId = player addAction _action;\n            localNamespace setVariable [_actionIdVar, _actionId];\n            false;\n        };\n\n        private _endAction = localNamespace getVariable [_actionShouldBeRemovedVar, false];\n        if (\n            _actionIsVisible AND\n            (!_playerInRange OR _endAction)\n        ) then {\n            player removeAction _actionId;\n            localNamespace setVariable [_actionIdVar, -1];\n        };\n\n        _endAction\n    },\n    {\n        params [\"\",\"\",\"\",\"\",\"_actionShouldBeRemovedVar\",\"_actionIdVar\"];\n\n        localNamespace setVariable [_actionShouldBeRemovedVar, nil];\n        localNamespace setVariable [_actionIdVar, nil];\n    },\n    _refreshInterval,\n    [\n        _center,\n        _radius,\n        _action,\n        _refreshInterval,\n        _actionShouldBeRemovedVar,\n        _actionIdVar\n    ]\n] call KISKA_fnc_waitUntil;\n\n\n_proximityActionId\n",
    "fileName": "fn_addProximityPlayerAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addTeleportAction\n\nDescription:\n    Adds a hold action to an object to teleport to a desired location.\n\nParameters:\n    0: _objectToAddTo <OBJECT> - The object the action will be attached to\n    1: _teleportPosition <ARRAY OR OBJECT> - The position to be teleported to upon completion\n    2: _text <STRING> - The action text, can be structured text\n    3: _conditionShow <STRING> - A string that will compile into an expression that\n        evals to a boolean. True means that the action will be shown.\n\nReturns:\n    <NUMBER> - action id, -1 if not added\n\nExamples:\n    (begin example)\n        [player,[0,0,0],\"go to the Zero\"] call KISKA_fnc_addTeleportAction;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_addTeleportAction\";\n\nparams [\n    [\"_objectToAddTo\",objNull,[objNull]],\n    [\"_teleportPosition\",[0,0,0],[objNull,[]]],\n    [\"_text\",\"<t color='#FFAA00'>Teleport</t>\",[\"\"]],\n    [\"_conditionShow\",\"true\",[\"\"]]\n];\n\nif (isNull _objectToAddTo) exitWith {\n    [\"_objectToAddTo is null\"] call KISKA_fnc_log;\n    -1\n};\n\nif (_teleportPosition isEqualType objNull) then {\n    _teleportPosition = getPosWorld _teleportPosition;\n};\n\n[\n    _objectToAddTo,\n    _text,\n    \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_takeOff1_ca.paa\",\n    \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_connect_ca.paa\",\n    _conditionShow,\n    \"true\",\n    {},\n    {},\n    {\n        (_this select 1) setPosWorld ((_this select 3) select 0);\n    },\n    {},\n    [_teleportPosition],\n    0.5,\n    991,\n    false,\n    false,\n    true\n] call BIS_fnc_holdActionAdd;\n",
    "fileName": "fn_addTeleportAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_alivePlayers\n\nDescription:\n    FInds all alive players with or without headless clients\n\nParameters:\n    0: _noHeadless <BOOL> - Seperate Headless Clients\n\nReturns:\n    _alivePlayers <ARRAY> - All alive players\n\nExamples:\n    (begin example)\n        [true] call KISKA_fnc_alivePlayers;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_alivePlayers\";\n\nparams [\n    [\"_seperateHeadless\",true,[true]]\n];\n\nprivate \"_alivePlayers\";\n\nif (_seperateHeadless) then {\n    _alivePlayers = (call CBA_fnc_players) select {alive _x};\n} else {\n    _alivePlayers = allPlayers select {alive _x};\n};\n\n_alivePlayers\n",
    "fileName": "fn_alivePlayers.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_balanceHeadless\n\nDescription:\n    Balances AI among all logged Headless Clients in a very simple fashion.\n    Designed to be run once and also should only be done when all HC are logged onto the server.\n\n    Excluded groups and units can be added to the array KISKA_hcExcluded.\n\nParameters:\n    0: _checkInterval <NUMBER> - How often to redistribute, if -1, will not loop\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] spawn KISKA_fnc_balanceHeadless;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_balanceHeadless\";\n\nif (!isServer OR {!isMultiplayer}) exitWith {\n    [\"Needs to be run on server in multiplayer\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (!canSuspend) exitWith {\n    [\"Was not run in scheduled; running in scheduled\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_balanceHeadless;\n};\n\nparams [\n    [\"_checkInterval\",-1,[123]]\n];\n\nprivate _headlessClients = entities \"HeadlessClient_F\";\n\nif (_headlessClients isEqualTo []) exitWith {\n    if (_checkInterval > 0) then {\n        [\n            {\n                _this spawn KISKA_fnc_balanceHeadless;\n            },\n            [_checkInterval],\n            _checkInterval\n        ] call CBA_fnc_waitAndExecute;\n    };\n};\n\nif !((missionNamespace getVariable [\"KISKA_hcExcluded\",[]]) isEqualTo []) then {\n    private _excluded = missionNamespace getVariable [\"KISKA_hcExcluded\",[]];\n\n    if !(_excluded isEqualTo []) then {\n        {\n            if !(_x isEqualTypeAny [grpNull,objNull]) then {\n                [[_x,\" is not an object or group in KISKA_hcExcluded!\"],true] call KISKA_fnc_log;\n            };\n\n            // replace object excluded with their groups\n            if (_x isEqualType objNull) then {\n                _excluded set [_forEachIndex,group _x];\n            };\n        } forEach _excluded;\n    };\n\n    missionNamespace setVariable [\"KISKA_hcExcluded\",_excluded];\n};\n\n// everyone goes basck to 0 for even redistribution\n_headlessClients apply {\n    _x setVariable [\"KISKA_hcLocalUnitsCount\",0];\n};\n\n[\"Headless ReBalance Is Beginning\"] remoteExecCall [\"hint\",0];\n\nallGroups apply {\n    private _group = _x;\n\n    if !(_group in (missionNamespace getVariable [\"KISKA_hcExcluded\",[]])) then {\n        // each headless client has a count of how many local units it has\n        private _localUnitsCountArray = [];\n        // an array of each of the headless client entities\n        private _headlessArray = [];\n\n        _headlessClients apply {\n            _localUnitsCountArray pushBack (_x getVariable [\"KISKA_hcLocalUnitsCount\",0]);\n            _headlessArray pushBackUnique _x;\n        };\n\n        // see who has the least units\n        private _leastUnits = selectMin _localUnitsCountArray;\n        // get the index of them in _headlessArray so that we can see how many local units they have in _localUnitsCountArray\n        private _index = _localUnitsCountArray findIf {_leastUnits isEqualTo _x};\n        // select that headless client\n        private _bestHeadless = _headlessArray select _index;\n        // And lastly get their actual ID\n        private _bestHeadlessID = owner _bestHeadless;\n\n        // verify units are migrated before proceeding\n        waitUntil {\n            if ((owner _group) isEqualTo _bestHeadlessID) exitWith {true};\n            _group setGroupOwner _bestHeadlessID;\n\n            uiSleep 0.1;\n            false\n        };\n\n        // get the units migrated and how many\n        private _unitsInGroup = units _group;\n        private _newTotal = _leastUnits + (count _unitsInGroup);\n\n        // update HC global count of its local units\n        _bestHeadless setVariable [\"KISKA_hcLocalUnitsCount\",_newTotal];\n\n        // add the units to a global attached to the HC so they can be referenced and subtracted at death\n        private _localUnitsArray = _bestHeadless getVariable [\"KISKA_hcLocalUnits\",[]];\n        _unitsInGroup apply {\n            _localUnitsArray pushBack _x;\n        /*\n            // add a MP eventhandler that runs on the server for when the AI is killed so that they can be subtracted from the count and array of local units\n            _x addMPEventHandler [\"MPKilled\",{\n\n                params [\"_unit\"];\n\n                if (isServer) then {\n                    private _headlessClients = entities \"HeadlessClient_F\";\n\n                    _headlessClients apply {\n                        private _headlessClient = _x;\n                        private _localUnitsArray = _headlessClient getVariable [\"KISKA_hcLocalUnits\",[]];\n\n                        if (_unit in _localUnitsArray) exitWith {\n\n                            // take unit out of array\n                            _localUnitsArray deleteAt (_localUnitsArray findIf {_x isEqualTo _unit});\n\n                            _unit removeMPEventHandler [\"MPKilled\",_thisEventHandler];\n\n                            true\n                        };\n                    };\n                };\n\n            }];\n        */\n        };\n    };\n\n    uiSleep 0.5;\n};\n\naddMissionEventHandler [\"EntityKilled\", {\n    params [\"_unit\"];\n\n    if (_unit isKindOf \"MAN\" AND {!(local _unit)} AND {!(_unit in allPlayers)}) then {\n        private _owner = owner _unit;\n        private _allHeadlessClients = entities \"HeadlessClient_F\";\n        private _index = _allHeadlessClients findIf {_owner isEqualTo (owner _x)};\n\n        if (_index isEqualTo -1) then {\n            private _headlessClient = _allHeadlessClients select _index;\n            private _localUnitsArray = _headlessClient getVariable [\"KISKA_hcLocalUnits\",[]];\n\n            if (_unit in _localUnitsArray) then {\n                private _localUnitsCount = _headlessClient getVariable [\"KISKA_hcLocalUnitsCount\",1];\n                _headlessClient setVariable [\"KISKA_hcLocalUnitsCount\",_localUnitsCount - 1];\n                /*\n                    For eventual smarter redistribution of totals...\n\n                    // get current total local units\n                    private _localUnitsCount = _headlessClient getVariable \"KISKA_hcLocalUnitsCount\";\n                    _localUnitsCount = _localUnitsCount - 1;\n                    // set new total\n                    _headlessClient setVariable [\"KISKA_hcLocalUnitsCount\",_localUnitsCount];\n                */\n\n                // take unit out of array\n                _localUnitsArray deleteAt (_localUnitsArray findIf {_x isEqualTo _unit});\n            };\n        };\n\n    };\n}];\n\n[\"Headless ReBalance Is COMPLETE\"] remoteExec [\"hint\",0];\n\nif (_checkInterval > 0 AND {_checkInterval != -1}) then {\n    sleep _checkInterval;\n\n    [_checkInterval] spawn KISKA_fnc_balanceHeadless;\n};\n",
    "fileName": "fn_balanceHeadless.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callBack\n\nDescription:\n    Standerdizes a means of passing a callback function to another function\n    along with custom arguments.\n\nParameters:\n    0: _defaultArgs <ARRAY> - Default arguements. These would be what a function\n        writer would put inside of their code as arguements that will always be passed\n        in the _this magic variable\n    1: _callBackFunction <CODE, STRING, ARRAY> - Code to call, compile and call, and/or\n        arguements to pass to the code (in _thisArgs variable). Array is formatted as\n        [<args array>,code or string (to compile)]\n    2: _runInScheduled <BOOL> - Spawns the code in a scheduled thread\n\nReturns:\n    <ANY> - Whatever the callback function returns or scripthandle if run in scheduled\n\nExamples:\n    (begin example)\n        [\n            [],\n            [\n                // hint player\n                [player],\n                {hint (_thisArgs select 0)}\n            ]\n        ] call KISKA_fnc_callBack\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_callBack\";\n\nparams [\n    [\"_defaultArgs\",[],[[]]],\n    [\"_callBackFunction\",{},[[],\"\",{}]],\n    [\"_runInScheduled\",false,[true]]\n];\n\nif (_callBackFunction isEqualType {}) exitWith {\n    [\n        _callBackFunction,\n        _defaultArgs\n    ] call CBA_fnc_directCall;\n};\n\nif (_callBackFunction isEqualType \"\") exitWith {\n    [\n        compile _callBackFunction,\n        _defaultArgs\n    ] call CBA_fnc_directCall;\n};\n\nif (\n    !(_callBackFunction isEqualTypeParams [[],\"\"]) AND\n    {!(_callBackFunction isEqualTypeParams [[],{}])}\n) exitWith {\n    [[\"_callBackFunction improperly configured array. Must be [ARRAY,STRING] or [ARRAY,CODE]. Got: \", _callBackFunction],true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _thisArgs = _callBackFunction select 0;\n_callBackFunction = _callBackFunction select 1;\nif (_callBackFunction isEqualType \"\") then {\n    _callBackFunction = compile _callBackFunction;\n};\n\n\nif (_runInScheduled) exitWith {\n    [\n        _defaultArgs,\n        _thisArgs,\n        _callBackFunction\n    ] spawn {\n        params [\"_defaultArgs\",\"_thisArgs\",\"_callBackFunction\"];\n        _defaultArgs call _callBackFunction;\n    };\n};\n\n\n[\n    {\n        params [\"_defaultArgs\",\"_thisArgs\",\"_callBackFunction\"];\n        _defaultArgs call _callBackFunction;\n    },\n    [\n        _defaultArgs,\n        _thisArgs,\n        _callBackFunction\n    ]\n] call CBA_fnc_directCall;\n",
    "fileName": "fn_callBack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_classTurretsWithGuns\n\nDescription:\n    Checks a given vehicle class to see if it has turrets that have guns\n     and returns those turret paths\n\nParameters:\n    0: _classToCheck <STRING> - The vehicle class to check\n\nReturns:\n    <NUMBER[][]> - The turret paths\n\nExamples:\n    (begin example)\n        _turretPaths = [\"B_Heli_Transport_01_F\"] call KISKA_fnc_classTurretsWithGuns;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_classTurretsWithGuns\";\n\nparams [\n    [\"_classToCheck\",\"\",[\"\"]]\n];\n\n\nif (_classToCheck isEqualTo \"\") exitWith {\n    [\"_classToCheck is empty string!\",true] call KISKA_fnc_log;\n    []\n};\n\n\nif !(isClass(configFile >> \"CfgVehicles\" >> _classToCheck)) exitWith {\n    [\"_classToCheck is not defined withing CfgVehicles!\",true] call KISKA_fnc_log;\n    []\n};\n\n\n// excludes fire from vehicle turrets\nprivate _allVehicleTurrets = [_classToCheck, false] call BIS_fnc_allTurrets;\nprivate _turretsWithWeapons =  [];\n\n_allVehicleTurrets apply {\n    private _turretPath = _x;\n    private _turretWeapons = getArray([_classToCheck,_turretPath] call BIS_fnc_turretConfig >> \"weapons\");\n    private _noTurretWeaponsFound = _turretWeapons isEqualTo [];\n    \n    if (_noTurretWeaponsFound) then { continue };\n    \n    // some turrets are just optics, need to see they actually have ammo to shoot\n    private _indexOfValidMagazine = _turretWeapons findIf {\n        private _mags = [_x,true] call BIS_fnc_compatibleMagazines;\n        // some turrets are just laser designators, hence checking that there are no laserbatteries\n        (_mags isNotEqualTo []) AND {!((_mags select 0) == \"laserbatteries\")}\n    };\n\n    private _validTurretMagazineFound = _indexOfValidMagazine isNotEqualTo -1;\n    if (_validTurretMagazineFound) then {\n        _turretsWithWeapons pushBack _turretPath;\n    };\n};\n\n\n_turretsWithWeapons\n",
    "fileName": "fn_classTurretsWithGuns.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_clearCargoGlobal\n\nDescription:\n    Deletes all cargo from the specified object on all machines.\n\nParameters:\n    0: _object <OBJECT> - The object to delete all cargo from.\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [myVehicle] call KISKA_fnc_clearCargoGlobal;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_clearCargoGlobal\";\n\nparams [\n    [\"_object\",objNull,[objNull]]\n];\n\nif (isNull _object) exitWith {};\n\nclearMagazineCargoGlobal _object;\nclearWeaponCargoGlobal _object;\nclearBackpackCargoGlobal _object;\nclearItemCargoGlobal _object;\n",
    "fileName": "fn_clearCargoGlobal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_countdown\n\nDescription:\n    Sleeps for a given time and eventually displays a certain amount on screen.\n\nParameters:\n    0: _countDownTotal : <NUMBER> - The amount to countdown from\n    1: _shownCountDown : <NUMBER> - The number at which a print out of the\n        current countdown will show on screen.\n    2: _soundedCountDown : <NUMBER> - The number at which a beep should play for each second\n    3: _soundName : <STRING> - The cfgSournds entry to play for the sound portion of the countdown\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        // print numbers when at 15 and play sound at 10\n        [30,15,10] spawn KISKA_fnc_countdown;\n    (end)\n    (begin example)\n        // print numbers when at 15 and play no sound\n        [30,15,-1] spawn KISKA_fnc_countdown;\n    (end)\n\nAuthor(s):\n    Hilltop(Willtop) & omNomios,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_countdown\";\n\nif (!canSuspend) exitWith {\n    [\"Needs to be called from a scheduled environment!\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_countdown;\n};\n\nparams [\n    [\"_countDownTotal\",15,[123]],\n    [\"_shownCountDown\",15,[123]],\n    [\"_soundedCountDown\",10,[123]],\n    [\"_soundName\",\"beep_target\",[\"\"]]\n];\n\nif (_countDownTotal < _shownCountDown) then {\n    [\n        [\n            \"_shownCountDown: \",\n            _shownCountDown ,\n            \" should be less then _countDownTotal: \",\n            _countDownTotal\n        ],\n        false\n    ] call KISKA_fnc_log;\n    _shownCountDown = _countDownTotal;\n};\n\nif (_soundedCountDown > _shownCountDown) then {\n    [\n        [\n            \"_soundedCountDown: \",\n            _soundedCountDown ,\n            \" should be less then _shownCountDown: \",\n            _shownCountDown\n        ],\n        false\n    ] call KISKA_fnc_log;\n    _soundedCountDown = _shownCountDown;\n};\n\n\nif (_countDownTotal < 0) exitWith {\n    [[\"Negative countdown was passed: \",_countDownTotal],true] call KISKA_fnc_log;\n    nil\n};\n\nif (hasInterface) then {\n    private _timeToSleepBeforeShown = _countDownTotal - _shownCountDown;\n    sleep _timeToSleepBeforeShown;\n\n    while {_shownCountDown >= 0} do {\n        if (_shownCountDown <= _soundedCountDown) then {\n            playSound _soundName;\n        };\n\n        [str _shownCountDown, 0, 0, 1, 0] spawn BIS_fnc_dynamicText;\n\n        sleep 1;\n        _shownCountDown = _shownCountDown - 1;\n    };\n\n} else {\n    sleep _countDownTotal;\n\n};\n\n\n\nnil\n",
    "fileName": "fn_countdown.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_datalinkMsg\n\nDescription:\n    Displays a message to the player and creates a diary entry of that message.\n    Also can play a sound when the notification pops up.\n\nParameters:\n    0: _message : <STRING or ARRAY> - If string, the message to display as title.\n        \n        If array:\n        - 0: _text : <STRING> - Text to display or path to .paa or .jpg\n            image (may be passed directly if only text is required)\n        - 1: _size : <NUMBER> - Scale of text\n        - 2: _color : <ARRAY> - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1])\n\n    1: _canSkip : <BOOL> - Can the notification be skipped when another is in the queue\n    2: _lifetime : <NUMBER> - How long the notification will be visible (min of 2 seconds)\n    3: _sound : <STRING> - A sound\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"this is the message\", 5] call KISKA_fnc_datalinkMsg;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_datalinkMsg\";\n\n#define RED_RGBA [0.75,0,0,1]\n\nif !(hasInterface) exitWith {};\n\n// if function is not run in the same environment, causes an issue where there will be two\n/// at least \"Datalink Messages\" sub-subjects\nif (canSuspend) exitWith {\n    [\n        KISKA_fnc_datalinkMsg,\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_message\",\"\",[\"\",[]]],\n    [\"_canSkip\",false,[true]],\n    [\"_lifetime\",4,[123]],\n    [\"_sound\",\"\",[\"\"]]\n];\n\n\n[\n    {\n        params [\n            \"_message\",\n            \"_sound\"\n        ];\n\n        if (_sound isNotEqualTo \"\") then {\n            playSound _sound;\n        };\n\n        [\n            [\"DATALINK\",1.1,RED_RGBA],\n            _message,\n            _lifetime,\n            _canSkip\n        ] call KISKA_fnc_notify;\n\n        [[\"Datalink Messages\",\"- \" + _message]] call KISKA_fnc_addKiskaDiaryEntry;\n    },\n    [_message,_playSound],\n    _waitTime\n] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_dataLinkMsg.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_deleteAtArray\n\nDescription:\n    Removes an index from a global array.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The global array in string format\n    1: _indexToRemove : <ANY> - The index to remove\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL,DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - True if done, false if not\n\nExamples:\n    (begin example)\n        [\"myGlobalArrayVar\",someInfoHere] call KISKA_fnc_deleteAtArray;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_deleteAtArray\";\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_indexToRemove\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\nif (_array isEqualTo []) exitWith {false};\n\n_array deleteAt _indexToRemove;\n\n\ntrue",
    "fileName": "fn_deleteAtArray.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_deleteAtArray_interface\n\nDescription:\n    Removes an index from a global array. Checks if machine hasInterface before.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The global array in string format\n    1: _indexToRemove : <ANY> - The index to remove\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL,DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - True if done, false if not\n\nExamples:\n    (begin example)\n        [\"myGlobalArrayVar\",someInfoHere] call KISKA_fnc_deleteAtArray;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_deleteAtArray_interface\";\n\nif (!hasInterface) exitWith {false};\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_indexToRemove\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\nif (_array isEqualTo []) exitWith {false};\n\n_array deleteAt _indexToRemove;\n\n\ntrue\n",
    "fileName": "fn_deleteAtArray_interface.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_deleteRandomIndex\n\nDescription:\n    Removes and returns a random item from an array\n\nParameters:\n    0: _array <ARRAY> - The array to find a random index of.\n\nReturns:\n    <ANY> - The random item removed from the array\n\nExamples:\n    (begin example)\n        private _randomDeletedItem = [[1,2,3]] call KISKA_fnc_deleteRandomIndex;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_deleteRandomIndex\";\n\nparams [\n    [\"_array\",[],[[]]]\n];\n\n\nprivate _randomIndex = floor (random (count _array));\n_array deleteAt _randomIndex",
    "fileName": "fn_deleteRandomIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_doMagRepack\n\nDescription:\n    Completes a repack on the units current weapon.\n\nParameters:\n    0: _unit : <OBJECT> - The person doing the repack\n    1: _doHint : <BOOL> - Should the local client be informed of packs?\n\nReturns:\n    <BOOL> - false if not completed, true if it was\n\nExamples:\n    (begin example)\n        [player] call KISKA_fnc_doMagRepack;\n    (end)\n\nAuthor(s):\n    Quicksilver,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_doMagRepack\";\n\nparams [\n    [\"_unit\",player,[objNull]],\n    [\"_doHint\",true,[true]]\n];\n\n// get all mags except for empty ones\nprivate _unitMags = (magazinesAmmoFull _unit) select {(_x select 1) != 0};\nif (_unitMags isEqualTo []) exitWith {\n    if (_doHint) then {\n     [    \"You have no mags to repack\"] call KISKA_fnc_notification;\n    };\n\n    false\n};\n\nprivate _sortedMagClasses = [];\nprivate [\"_currentMagazineClass_temp\",\"_magType_temp\",\"_numberOfMags_temp\",\"_magInfo_temp\",\"_allMagsOfClass_temp\",\"_totalBulletsForClass_temp\"];\nprivate _fn_pushToSorted = {\n    _sortedMagClasses pushBack _currentMagazineClass_temp;\n};\n\n// sort the mags in on the player to find those that can be repacked\nprivate \"_totalBulletsForClass_temp\";\nprivate _unitMagsSorted = [];\n_unitMags apply {\n    _magInfo_temp = _x;\n    _currentMagazineClass_temp = _magInfo_temp select 0;\n\n    // see if mag class was already sorted\n    if !(_currentMagazineClass_temp in _sortedMagClasses) then {\n        _magType_temp = ([_currentMagazineClass_temp] call BIS_fnc_itemType) select 1;\n        // sort through mags to get those that aren't are grenades, flares, etc.\n        if (_magType_temp == \"Bullet\" OR {_magType_temp == \"Missile\"} OR {_magType_temp == \"Rocket\"}) then {\n            // check to make sure there are multiple mags of this type in the units inventory\n            _allMagsOfClass_temp = _unitMags select {(_x select 0) == _currentMagazineClass_temp};\n            if ((count _allMagsOfClass_temp) > 1) then {\n\n                // get the total number of bullets for this mag className\n                _totalBulletsForClass_temp = 0;\n                _allMagsOfClass_temp apply {\n                    _totalBulletsForClass_temp = _totalBulletsForClass_temp + (_x select 1);\n                };\n                _unitMagsSorted pushBack [_currentMagazineClass_temp,_totalBulletsForClass_temp];\n            };\n        }\n        call _fn_pushToSorted;\n    };\n};\n\n\n\n// if there are no mags to repack, just hint\nif !(_unitMagsSorted isEqualTo []) then {\n    _unit playMove \"AinvPknlMstpSnonWnonDr_medic2\";\n\n    // get mags loaded into current handgun and primary\n    private _primaryMag = primaryWeaponMagazine _unit;\n    private _primaryWeaponMagClass = \"\";\n    if !(_primaryMag isEqualTo []) then { // if there is a primary magazine\n        _primaryWeaponMagClass = _primaryMag select 0;\n    };\n\n    private _handgunMag = handgunMagazine _unit;\n    private _handgunWeaponMagClass = \"\";\n    if !(_handgunMag isEqualTo []) then { // if there is a handgun magazine\n        _handgunWeaponMagClass = _handgunMag select 0;\n    };\n\n    private _secondaryMag = secondaryWeaponMagazine _unit;\n    private _secondaryWeaponMagClass = \"\";\n    if !(_secondaryMag isEqualTo []) then { // if there is a secondary magazine\n        _secondaryWeaponMagClass = _secondaryMag select 0;\n    };\n\n\n    private _fn_magTypeInWeapon = {\n        params [\n            [\"_doAddMag\",true]\n        ];\n\n        if (_magClassnameTemp == _primaryWeaponMagClass) exitWith {\n            if (_doAddMag) then {\n                _unit removePrimaryWeaponItem _magClassnameTemp;\n                _unit addPrimaryWeaponItem _magClassnameTemp;\n            };\n            true\n        };\n        if (_magClassnameTemp == _handgunWeaponMagClass) exitWith {\n            if (_doAddMag) then {\n                _unit removeHandgunItem _magClassnameTemp;\n                _unit addHandgunItem _magClassnameTemp;\n            };\n            true\n        };\n        if (_magClassnameTemp == _secondaryWeaponMagClass) exitWith {\n            if (_doAddMag) then {\n                _unit removeSecondaryWeaponItem _magClassnameTemp;\n                _unit addSecondaryWeaponItem _magClassnameTemp;\n            };\n            true\n        };\n\n        false\n    };\n\n\n    private [\"_magCapacity\",\"_numberOfFullMagsToAdd\",\"_totalBulletCountForClass\",\"_remainderMagBulletCount\",\"_magClassnameTemp\"];\n    _unitMagsSorted apply {\n        _magClassnameTemp = _x select 0;\n        _totalBulletCountForClass = _x select 1;\n        _magCapacity = getNumber (configFile >> \"CfgMagazines\" >> _magClassnameTemp >> \"Count\");\n\n        // remove every mag (that's not in the gun) including empty ones\n        _unit removeMagazines _magClassnameTemp;\n\n        // if the total bullets for the mag are not going to equal more than one mag\n        if (_totalBulletCountForClass <= _magCapacity) then {\n            if ([false] call _fn_magTypeInWeapon) then {\n                private _index = [_primaryWeaponMagClass,_handgunWeaponMagClass,_secondaryWeaponMagClass] findIf {_x == _magClassnameTemp};\n                switch _index do {\n                    case 0: {_unit setAmmo [primaryWeapon _unit,_totalBulletCountForClass]};\n                    case 1: {_unit setAmmo [handgunWeapon _unit,_totalBulletCountForClass]};\n                    case 2: {_unit setAmmo [secondaryWeapon _unit,_totalBulletCountForClass]};\n                };\n            } else {\n                _unit addMagazine [_magClassnameTemp,_totalBulletCountForClass];\n            };\n        } else {\n            _numberOfFullMagsToAdd = floor (_totalBulletCountForClass / _magCapacity);\n\n            // if the mag type is currently inserted into a weapon\n            if ([true] call _fn_magTypeInWeapon) then {\n                _numberOfFullMagsToAdd = _numberOfFullMagsToAdd - 1;\n            };\n\n            _unit addMagazines [_magClassnameTemp,_numberOfFullMagsToAdd];\n\n            // check for if we need that one not full mag to hold the excess ammo\n            _remainderMagBulletCount = _totalBulletCountForClass mod _magCapacity;\n            if !(_remainderMagBulletCount isEqualTo 0) then {\n                _unit addMagazine [_magClassnameTemp,_remainderMagBulletCount];\n            };\n        };\n    };\n\n    true;\n} else {\n    if (_doHint) then {\n        hint \"You have no mags that need to be repacked\";\n    };\n    false\n};\n",
    "fileName": "fn_doMagRepack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_errorNotification\n\nDescription:\n    Prints a simple KISKA Notify error notification on screen.\n\nParameters:\n    0: _message : <STRING or ARRAY> - The second line of the notification.\n        Formatted the same as the parameters for CBA_fnc_notify:\n            _lineN - N-th content line (may be passed directly if only 1 line is required). <ARRAY>\n                _text  - Text to display or path to .paa or .jpg image (may be passed directly if only text is required). <STRING, NUMBER>\n                _size  - Text or image size multiplier. (optional, default: 1) <NUMBER>\n                _color - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1]) <ARRAY>\n    1: _lifetime : <NUMBER> - How long the notification lasts in seconds (at least 2)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"You made and error\"] call KISKA_fnc_errorNotification;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_errorNotification\";\n\nparams [\n    [\"_message\",\"\",[\"\",[]]],\n    [\"_lifetime\",4,[123]]\n];\n\n[\n    [\"Error\",1.1,[0.75,0,0,1]],\n    _message,\n    _lifetime,\n    false\n] call KISKA_fnc_notify;\n\n\nnil\n",
    "fileName": "fn_errorNotification.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_exportLoadouts\n\nDescription:\n    Exports a given unit or units loadout into an array or loadouts. This can \n     be either a standard array or formatted for config files.\n\nParameters:\n    0: _units <OBJECT[] or OBJECT> - The units to get the loadouts of\n    1: _exportAsConfig <BOOL> - Will export list in config array format ({} instead of [])\n\nReturns:\n    <STRING> - An array of loadouts as a string. This will be either \n\nExamples:\n    (begin example)\n        private _loadouts = [_units,true] call KISKA_fnc_exportLoadouts;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_exportLoadouts\";\n\nparams [\n    [\"_units\",[],[[],objNull]],\n    [\"_exportAsConfig\",true,[false]]\n];\n\nif (_units isEqualType objNull) then {\n    _units = [_units];\n};\n\nprivate _loadoutsAsString = \"[\";\nprivate _loadouts = _units apply {\n    private _loadout = getUnitLoadout _x;\n    if (_loadout isEqualTo []) then {\n        continue;\n    };\n\n    _loadoutsAsString = _loadoutsAsString + (endl + str _loadout + \",\");\n};\n\n_loadoutsAsString = (_loadoutsAsString trim [\",\",2]) + endl + \"]\";\nif (_exportAsConfig) then {\n    _loadoutsAsString = _loadoutsAsString regexReplace [\"\\[\",\"{\"];\n    _loadoutsAsString = _loadoutsAsString regexReplace [\"\\]\",\"}\"];\n};\n\n\n_loadoutsAsString\n",
    "fileName": "fn_exportLoadouts.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_exportSpawnPositions\n\nDescription:\n    Takes a layer of objects and produces an array of arrays that are their 3d\n     ATL position and current direction ([0,0,0,0]).\n\n    Can also convert the arrays to config compatible format.\n\n    This will copy its output to the clipboard if run on the server;\n\nParameters:\n    0: _layer <STRING or NUMBER> - The name of the layer or if in 3den, its layer id\n    1: _convertToConfig <BOOL> - Change all square brackets ([]) to curly ({})\n\nReturns:\n    <STRING> - The converted Array\n\nExamples:\n    (begin example)\n        [\"someLayer\",true] call KISKA_fnc_exportSpawnPositions;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_exportSpawnPositions\";\n\nparams [\n    [\"_layer\",\"\",[\"\",123]],\n    [\"_convertToConfig\",true,[true]]\n];\n\nprivate _objects = [];\nif (is3den) then {\n    _objects = get3DENLayerEntities _layer;\n\n} else {\n    _objects = (getMissionLayerEntities _layer) select 0;\n\n};\n\n\nif (count _objects < 1) exitWith {\n    [[\"No objects were found in layer: \",_layer],true] call KISKA_fnc_log;\n    \"\"\n};\n\n\nprivate _returnArray = [];\n_objects apply {\n    private _objectArray = getPosATL _x;\n    _objectArray pushBack (getDir _x);\n\n    _returnArray pushBack _objectArray;\n};\n\nprivate _string = _returnArray joinString (\",\" + endl);\n_string = _string trim [\",\",2];\n\nif (_convertToConfig) then {\n    _string = [_string,\"[\",\"{\"] call CBA_fnc_replace;\n    _string = [_string,\"]\",\"}\"] call CBA_fnc_replace;\n};\ncopyToClipboard _string;\n\n\n_string\n",
    "fileName": "fn_exportSpawnPositions.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_findConfigAny\n\nDescription:\n    Searchs missionConfigFile, campaignConfigFile, and the configFile\n     (in that order) to find a config based upon the sub paths provided.\n\n    Returns the first one it finds.\n\n    The BIS counterpart to this is BIS_fnc_loadClass and while it can be about 0.0005-0.0010ms\n     faster if the path is short (about 2 entries). It can yield about 0.005ms faster in various cases.\n\nParameters:\n    0: _pathArray : <ARRAY> - The array in string format\n\nReturns:\n    <CONFIG> - The first config path if found or configNull if not\n\nExamples:\n    (begin example)\n        _configPath = [[\"CfgMusic\",\"Music_Intro_02_MissionStart\"]] call KISKA_fnc_findConfigAny;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_findConfigAny\";\n\nparams [\n    [\"_pathArray\",[],[[]]]\n];\n\nif (_pathArray isEqualTo []) exitWith {\n    [\"_pathArray is empty array!\",true] call KISKA_fnc_log;\n    configNull\n};\n\nprivate _configFound = false;\nprivate _configReturn = configNull;\n[missionConfigFile,campaignConfigFile,configFile] apply {\n    private _configPath = _x;\n    _pathArray apply {\n        // stop going down this config class path does not exist\n        if !(isClass(_configPath >> _x)) then {\n            _configFound = false;\n            break;\n        };\n        _configPath = _configPath >> _x;\n        _configFound = true;\n    };\n\n    if (_configFound) then {\n        _configReturn = _configPath;\n        break;\n    };\n};\n\n\n_configReturn\n",
    "fileName": "fn_findConfigAny.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_findIfBool\n\nDescription:\n    Checks if an array index satisfies the provided code, and returns a BOOL\n     for whether or not one was found.\n\nParameters:\n    0: _array : <ARRAY> - The array to check\n    1: _codeToCheck : <CODE> - The code to check against the array indexes.\n        Needs to return a BOOl.\n        Params are passed within _thisArgs.\n    2: _thisArgs : <ARRAY> - Any local arguements that can be passed\n\nReturns:\n    <BOOL> - True if an index meets the condition, false if not\n\nExamples:\n    (begin example)\n        // returns true if any player is alive\n        [allPlayers,{alive _x}] call KISKA_fnc_findIfBool;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_findIfBool\";\n\nparams [\n    [\"_array\",[],[[]]],\n    [\"_codeToCheck\",{},[{}]],\n    [\"_thisArgs\",[],[[]]]\n];\n\nprivate _index = _array findIf _codeToCheck;\n// if index is found, return true\n_index >= 0\n",
    "fileName": "fn_findIfBool.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_generateUniqueId\n\nDescription:\n    Creates a unique identifier with a given tag. \n    \n    The id format is: *tag*_*clientOwner*_*increment* which as an example could be\n     `KISKA_uid_0_0` as the first unique id made in a single player scenario.\n\nParameters:\n    0: _tag <STRING> - The tag to assign to the uid\n\nReturns:\n    <STRING> - the unique identifier\n\nExamples:\n    (begin example)\n        call KISKA_fnc_generateUniqueId;\n        // KISKA_uid_0_0\n    (end)\n    \n    (begin example)\n        [\"MYTAG\"] call KISKA_fnc_generateUniqueId;\n        // MYTAG_uid_0_0\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_generateUniqueId\";\n\nparams [\n    [\"_tag\",\"KISKA\",[\"\"]]\n];\n\nif (_tag isEqualTo \"\") then {\n    _tag = \"KISKA\";\n};\n\n// in an effort to avoid confusion between when using KISKA_fnc_idCounter\n// using the \"uid\" tagged on as the counter for consistent counts \n// in case someone uses that tag with KISKA_fnc_idCounter outside of this\n// function\nprivate _idPrepend = [_tag,\"uid\",clientOwner] joinString \"_\";\nprivate _idNumber = [_idPrepend] call KISKA_fnc_idCounter;\n\n\n[_idPrepend,_idNumber] joinString \"_\"\n",
    "fileName": "fn_generateUniqueId.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getBoundingBoxDimensions\n\nDescription:\n    Returns the length, width, and height of a given object's bounding box, for\n\t a given clipping type.\n\nParameters:\n    0: _object <OBJECT> - The object to get the dimensions of\n    1: _boxType <NUMBER or STRING> - The `boundingBoxReal` command's clipping type or\n\t\tthe LOD name/resolution if `_isLOD` is true.\n\t2: _isLOD <BOOL> - Whether or not to use the LOD syntax of `boundingBoxReal`\n\nReturns:\n    <NUMBER[]> - `[Length,Width,Height]` of the given object's dimensions \n\nExamples:\n    (begin example)\n        private _playerBoxDimensions = [player] call KISKA_fnc_getBoundingBoxDimensions;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getBoundingBoxDimensions\";\n\nparams [\n    [\"_object\",objNull,[objNull]],\n    [\"_boxType\",0,[123]],\n\t[\"_isLOD\",false,[false]]\n];\n\n\nif (isNull _object) exitWith {\n\t[\"null object passed\",true] call KISKA_fnc_log;\n\t[0,0,0]\n};\n\n\nprivate \"_boundingBox\";\nif (_isLOD) then {\n\t_boundingBox = boundingBoxReal [_object,_boxType];\n} else {\n\t_boundingBox = _boxType boundingBoxReal _object;\n};\n\n\n_boundingBox params [\"_boundingBoxMins\",\"_boundingBoxMaxes\"];\n_boundingBoxMins params [\"_xMin\",\"_yMin\",\"_zMin\"];\n_boundingBoxMaxes params [\"_xMax\",\"_yMax\",\"_zMax\"];\n\n\n[\n\tabs (_yMax - _yMin), // length\n\tabs (_xMax - _xMin), // width\n\tabs (_zMax - _zMin) // height\n]\n",
    "fileName": "fn_getBoundingBoxDimensions.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getBumperPositionRelative\n\nDescription:\n    Gets the PositionRelative of a vehicles front or rear bumper.\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to get the bumper position of\n    1: _isRearBumper <BOOL> - True for rear bumper, false for front bumper\n\nReturns:\n    <PositionRelative> - The world position of the vehicle's bumper\n\nExamples:\n    (begin example)\n        private _rearBumperPositionRelatives = [vic,true] call KISKA_fnc_getBumperPositionRelative;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getBumperPositionRelative\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_isRearBumper\",false,[true]]\n];\n\nprivate _boundingBoxIndex = 0;\nif (!_isRearBumper) then {\n    _boundingBoxIndex = 1;\n};\n\nprivate _vehicleBoundingBoxes = 0 boundingBoxReal _vehicle;\nprivate _boundingBox = _vehicleBoundingBoxes select _boundingBoxIndex;\nprivate _relativeBumperPosition = [0,_boundingBox select 1,0];\n\n\n_relativeBumperPosition\n",
    "fileName": "fn_getBumperPositionRelative.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getContainerCargo\n\nDescription:\n    Saves the cargo of a container in a formatterd array to be used with\n     KISKA_fnc_pasteContainerCargo for copying cargos of containers.\n\n    Exact ammo counts will be preserved even inside of an item such as magazines\n     inside of a vest or backpack.\n\nParameters:\n    0: _primaryContainer <OBJECT> - The container to save the cargo of\n\nReturns:\n    <ARRAY> - Formatted array of all items in cargo space of a container.\n        Used with KISKA_fnc_setContainerCargo.\n        Will return [] if no cargo is present.\n\nExamples:\n    (begin example)\n        [container] call KISKA_fnc_getContainerCargo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getContainerCargo\";\n\n#define EMPTY_RETURN [[[],[]],[],[],[[],[]],[]]\n\nparams [\n    [\"_primaryContainer\",objNull,[objNull]]\n];\n\nif (isNull _primaryContainer) exitWith {\n    [\"_primaryContainer isNull\",true] call KISKA_fnc_log;\n    []\n};\n\n// for containers within the primary container (vests, backpacks, etc.)\nprivate _containers = everyContainer _primaryContainer;\n\nprivate _containersInfo = [];\nif (_containers isNotEqualTo []) then {\n\n    _containers apply {\n\n        private _container = _x select 1;\n        private _cargoInContainer = [_container] call KISKA_fnc_getContainerCargo;\n\n        if (_cargoInContainer isNotEqualTo []) then {\n            private _containerClass = _x select 0;\n            _containersInfo pushBack [\n                _containerClass,\n                _cargoInContainer\n            ];\n        };\n\n    };\n\n};\n\n// sort through weapons\nprivate _weaponsCargo = [];\nprivate _weaponsInContainer = weaponsItemsCargo _primaryContainer;\nif (_weaponsInContainer isNotEqualTo []) then {\n    _weaponsInContainer apply {\n        _weaponsCargo pushBack [_x,1];\n    };\n};\n\nprivate _totalCargo = [\n\n    getItemCargo _primaryContainer,\n\n    magazinesAmmoCargo _primaryContainer,\n\n    _weaponsCargo,\n\n    getBackpackCargo _primaryContainer,\n    // containers within containers\n    _containersInfo\n];\n\nif (_totalCargo isEqualTo EMPTY_RETURN) exitWith {\n    [[\"No cargo found in \",_primaryContainer],true] call KISKA_fnc_log;\n    []\n};\n\n\n_totalCargo\n",
    "fileName": "fn_getContainerCargo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getCurrentWaypoint\n\nDescription:\n    Returns the units currentWaypoint\n\nParameters:\n    0: _group <GROUP or OBJECT> - The unit to get the currentWaypoint for.\n\nReturns:\n    <ARRAY> - The waypoint\n\nExamples:\n    (begin example)\n        private _waypoint = [myUnit] call KISKA_fnc_getCurrentWaypoint;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getCurrentWaypoint\";\n\n\nparams [\n    [\"_group\",grpNull,[objNull,grpNull]]\n];\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\nif (isNull _group) exitWith {\n    [\"Null group passed\",true] call KISKA_fnc_log;\n    []\n};\n\n\n(waypoints _group) select (currentWaypoint _group)\n",
    "fileName": "fn_getCurrentWaypoint.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getFromNetId\n\nDescription:\n    Gets an object or group from a netId.\n\nParameters:\n    0: _id <STRING> - The id of the object\n    1: _fromObject <BOOL> - false for getting object, true for group\n\nReturns:\n    <OBJECT or GROUP> - The Id of the entity\n\nExamples:\n    (begin example)\n        _entity = [\"0:0\"] call KISKA_fnc_netId;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getFromNetId\";\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_fromObject\",false,[false]]\n];\n\nif (!isMultiplayer) exitWith {\n    // create map if needed\n    private _map = localNamespace getVariable \"KISKA_objectNetId_map\";\n    if (isNil \"_map\") then {\n        _map = createHashMap;\n        localNamespace setVariable [\"KISKA_objectNetId_map\",_map];\n    };\n\n    _map getOrDefault [_id, [grpNull,objNull] select _fromObject];\n};\n\nif (_fromObject) then {\n    objectFromNetId _id;\n\n} else {\n    groupFromNetId _id;\n\n};\n",
    "fileName": "fn_getFromNetId.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMissionLayerObjects\n\nDescription:\n    Simply returns the objects of a mission layer.\n\nParameters:\n    0: _layer : <STRING or NUMBER> - The name or ID of the mission layer\n\nReturns:\n    <ARRAY> - The layer's objects\n\nExamples:\n    (begin example)\n        _objects = [\"myLayer\"] call KISKA_fnc_getMissionLayerObjects;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMissionLayerObjects\";\n\nparams [\n    [\"_layer\",\"\",[123,\"\"]]\n];\n\nprivate _entities = getMissionLayerEntities _layer;\n\nif (_entities isEqualTo []) exitWith {[]};\n\n\n_entities select 0\n",
    "fileName": "fn_getMissionLayerObjects.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getMostSpecificCfgValue\n\nDescription:\n    Picks the most specific value from a list of configs properties to check.\n\nParameters:\n    0: _property <STRING> - The config property to search for in all of the classes\n    1: _configs <ARRAY> - An array of CONFIGs that you would like to look for the\n        property. These should be within the same configHierarchy.\n    2: _ignoredValues <ARRAY of ARRAY, NUMBER, or STRING> - A list of invalid values\n        for the property to have in order to be ignored. (strings should be lowercase)\n        (NIL will always be ignored)\n    3: _ignoredTypes <ARRAY of ARRAY, NUMBER, or STRING> - A list of invalid types for the property\n\nReturns:\n    <NIL, ARRAY, NUMBER, or STRING> - The config value returned by the most specific config passed\n        that is valid.\n\nExamples:\n    (begin example)\n        private _valueFromMostSpecificClass = [\n            \"myProperty\"\n            [\n                missionConfigFile >> \"SomeClass\",\n                missionConfigFile >> \"SomeClass\" >> \"SomeSubClass\",\n                missionConfigFile >> \"SomeClass\" >> \"SomeSubClass\" >> \"SomeFurtherSubClass\",\n            ],\n            [\"\"], // shouldn't be an empty string,\n            [123] // ignore number properties\n        ] call KISKA_fnc_getMostSpecificCfgValue;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getMostSpecificCfgValue\";\n\nparams [\n    [\"_property\",\"\",[\"\"]],\n    [\"_configs\",[],[[]]],\n    [\"_ignoredValues\",0,[123,[],\"\"]],\n    [\"_ignoredTypes\",[],[[]]]\n];\n\nif (_property isEqualTo \"\") exitWith {\n    [\"_property is empty!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate \"_mostSpecificValue\";\nprivate _mostSpecificHierarchyCount = -1;\n_configs apply {\n    if !(_x isEqualType configNull) then {continue};\n    if (isNull _x) then {continue};\n\n    private _hierarchyCount = count (configHierarchy _x);\n    if (_hierarchyCount <= _mostSpecificHierarchyCount) then {continue};\n\n    private _propertyValue = (_x >> _property) call BIS_fnc_getCfgData;\n    if (\n        isNil \"_propertyValue\" OR\n        {_propertyValue isEqualTypeAny _ignoredTypes}\n    ) then {continue};\n\n    private _propertyValueCompare = _propertyValue;\n    if (_propertyValueCompare isEqualType \"\") then {\n        _propertyValueCompare = toLower _propertyValueCompare\n    };\n    if (_propertyValueCompare in _ignoredValues) then {continue};\n\n    _mostSpecificValue = _propertyValue;\n    _mostSpecificHierarchyCount = _hierarchyCount;\n};\n\n// returning _mostSpecificValue in the case of it being nil causes errors\nif (isNil \"_mostSpecificValue\") exitWith { nil };\n_mostSpecificValue\n",
    "fileName": "fn_getMostSpecificCfgValue.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getNearestIncriment\n\nDescription:\n    Rounds off a number to the nearest incriment.\n\nParameters:\n    0: _numberToCheck : <NUMBER> - The number to round off\n    1: _incriment : <NUMBER> - The incriment by which the number should be assessed\n\nReturns:\n    <NUMBER> - The nearest incriment to the given number\n\nExamples:\n    (begin example)\n        // -0.22\n        _nearestIncriment = [-0.223,0.01] call KISKA_fnc_getNearestIncriment;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getNearestIncriment\";\n\nparams [\n    [\"_numberToCheck\",0,[123]],\n    [\"_incriment\",1,[123]]\n];\n\n_incriment = abs _incriment;\nprivate _result = (abs _numberToCheck + (_incriment / 2));\n_result = _result - (_result mod _incriment);\n\nif (_numberToCheck < 0 AND (_result isNotEqualTo 0)) then {\n    _result * -1\n\n} else {\n    _result\n\n};\n",
    "fileName": "fn_getNearestIncriment.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getPosRelativeSurface\n\nDescription:\n    Returns a relative position but that the position is at the 0 position for the\n     surface beneath (being either water or the terrain) in an ATL format.\n\n    This means the z will always be 0 or the height of the sea above the terrain level\n     at the given _centerPosition.\n\nParameters:\n    0: _centerPosition <OBJECT or Position> - The center position to find a\n        relative position to. If a 2d position, height will be 0.\n    1: _distance <NUMBER> - The distance away from the _centerPosition to get the position\n    2: _bearing <NUMBER> - The direction relative to the position to find the new position\n    3: _zOffSet <NUMBER> - An offset to add to the Z-axis AFTER the surface position is found\n\nReturns:\n    PositionATL[] - the new position\n\nExamples:\n    (begin example)\n        [\n            player,\n            100,\n            180\n        ] call KISKA_fnc_getPosRelativeSurface;\n    (end)\n\n    (begin example)\n        [\n            player,\n            100,\n            180,\n            10 // 10 meters above water surface or terrain\n        ] call KISKA_fnc_getPosRelativeSurface;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getPosRelativeSurface\";\n\nparams [\n    [\"_centerPosition\",[],[objNull,[]],[2,3]],\n    [\"_distance\",0,[123]],\n    [\"_bearing\",0,[123]],\n    [\"_zOffSet\",0,[123]]\n];\n\n\nprivate _relativePosition = _centerPosition getPos [_distance,_bearing];\nprivate _height = _relativePosition select 2;\nprivate _isUnderwater = _height < 0;\nif (_isUnderwater) then {\n    _relativePosition set [2,0];\n    _relativePosition = ASLToATL _relativePosition;\n};\n\n\n_relativePosition vectorAdd [0,0,_zOffSet]\n",
    "fileName": "fn_getPosRelativeSurface.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getRelativeVectorAndPos\n\nDescription:\n    Returns the relative vector dir and up and world position from one object to\n     another.\n\nParameters:\n    0: _parent <OBJECT> - The object to make the coordinates relative to.\n    1: _child <OBJECT> - The object to find coordinates for.\n\nReturns:\n    <ARRAY> -\n        0: <PositionWorld[]> - Relative world pos\n        1: <Vector[]> - Relative vector dir\n        2: <Vector[]> - Relative vector up\n\nExamples:\n    (begin example)\n        private relativeArray = [\n            parentObject,\n            childObject\n        ] call KISKA_fnc_getRelativeVectorAndPos\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getRelativeVectorAndPos\";\n\nparams [\n    [\"_parent\",objNull,[objNull]],\n    [\"_child\",objNull,[objNull]]\n];\n\n\nif (isNull _parent) exitWith {\n    [\"Null parent object passed\",true] call KISKA_fnc_log;\n    []\n};\n\nif (isNull _child) exitWith {\n    [\"Null child object passed\",true] call KISKA_fnc_log;\n    []\n};\n\nprivate _relativePosWorld = _parent worldToModel (ASLToAGL (getPosASL _child));\nprivate _relativeVectorDir = _parent vectorWorldToModel (vectorDir _child);\nprivate _relativeVectorUp = _parent vectorWorldToModel (vectorUp _child);\n\n\n[_relativePosWorld,_relativeVectorDir,_relativeVectorUp]\n",
    "fileName": "fn_getRelativeVectorAndPos.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getVariableTarget\n\nDescription:\n    Gets a variable from a remote target object, id, or string (uses remoteExec targets)\n\n    Takes a bit of time and therefore needs to be scheduled.\n\nParameters:\n    0: _variableName : <STRING> - The string name of the varaible to get\n    1: _namespace : <NAMESPACE, OBJECT, STRING, CONTROL, GROUP, or LOCATION> - The namespace to get the variable from\n    2: _defaultValue : <ANY> - If the variable does not exist for the target, what should be returned instead\n    3: _target : <NUMBER, OBJECT, or STRING> - Where the _target is local will be where the variable is taken from \n        (the machine to get the variable from)\n    4: _awaitParams : <[NUMBER,NUMBER,BOOL]> - How the get from the target should be awaited\n\n        Parameters:\n        - 0: <NUMBER> - The sleep time between each check for the variable being received\n        - 1: <NUMBER> - The max time to wait for (this is not total game time but time slept)\n        - 2: <BOOL> - Whether or not the sleep time should be exponential (double every iteration)\n\n\nReturns:\n    <ANY> - Whatever the variable is, nil otherwise\n\nExamples:\n    (begin example)\n        [] spawn {\n            // need to call for direct return\n            private _serversSomeVariable = [\n                \"someVariable\",\n                missionNamespace,\n                \"\",\n                2\n            ] call KISKA_fnc_getVariableTarget;\n        };\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getVariableTarget\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled environment\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_variableName\",\"\",[\"\"]],\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,\"\",controlNull,locationNull,grpNull]],\n    [\"_defaultValue\",nil],\n    [\"_target\",2,[123,objNull,\"\"]],\n    [\"_awaitParams\",[],[[]]]\n];\n\nif ((_target isEqualType objNull) AND {isNull _target}) exitWith {\n    [\"_target is null object!\"] call KISKA_fnc_log;\n    _defaultValue\n};\n\nprivate _targetIsNetId = false;\nprivate _targetsMultipleUsers = false;\nprivate _exitForMultiUserTarget = false;\nprivate _regularMultiplayer = isMultiplayer AND (!isMultiplayerSolo);\nif (_regularMultiplayer) then {\n    private _targetsMultipleUsers = (_target isEqualType 123) AND {_target <= 0};\n    if (_targetsMultipleUsers) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n\n    private _targetIsString = _target isEqualType \"\";\n    if (!_targetIsString) exitWith {};\n\n    private _targetIsNetId = _targetIsString AND {\n            private _split = _target splitString \":\";\n            private _splitCount = count _split;\n            (_splitCount isEqualTo 2) AND {\n                private _splitParsed = _split apply {parseNumber _x};\n                private _splitCompare = _splitParsed apply {str _x};\n                _splitCompare isEqualTo _split\n            }\n        };\n\n    if (!_targetIsNetId) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n};\n\nif (_exitForMultiUserTarget) exitWith {\n    [[\"_target: \",_target,\" is invalid as it will be sent to more then one machine!\"],true] call KISKA_fnc_log;\n    _defaultValue\n};\n\nif (_variableName isEqualTo \"\") exitWith {\n    [\"_variableName is empty\",true] call KISKA_fnc_log;\n    _defaultValue\n};\n\n_awaitParams params [\n    [\"_awaitTime\",0.05,[123]],\n    [\"_maxWaitTime\",2,[123]],\n    [\"_exponentialBackOff\",false,[true]]\n];\n\n// create a unique variable ID for network tranfer\nprivate _messageNumber = missionNamespace getVariable [\"KISKA_getVarTargetQueue_count\",0];\n_messageNumber = _messageNumber + 1;\nmissionNamespace setVariable [\"KISKA_getVarTargetQueue_count\",_messageNumber];\nprivate _saveVariable = [\"KISKA_GVT\",clientOwner,\"_\",_messageNumber] joinString \"\";\n\n\n[_namespace,_variableName,_saveVariable,_defaultValue,clientOwner] remoteExecCall [\"KISKA_fnc_getVariableTarget_sendBack\",_target];\n\nprivate _timeWaited = 0;\nwaitUntil {\n    if (_timeWaited >= _maxWaitTime) then {\n        [\n            [\n                \"Max wait time of: \",\n                _maxWaitTime,\n                \" for variable \",\n                _saveVariable,\n                \" from target \",\n                _target,\n                \" was exceeded. Exiting with default value: \",\n                _defaultValue\n            ],\n            false\n        ] call KISKA_fnc_log;\n        breakWith true;\n    };\n\n    if (!isNil _saveVariable) exitWith {\n        [[\"Got variable \",_saveVariable,\" from target \",_target],false] call KISKA_fnc_log;\n        true\n    };\n    \n    sleep _awaitTime;\n    _timeWaited = _timeWaited + _awaitTime;\n    \n    if (_exponentialBackOff) then {\n        _awaitTime = _awaitTime * 2;\n    };\n\n    [[\"Waiting for variable from target: \",_target],false] call KISKA_fnc_log;\n    false\n};\n\nprivate _return = missionNamespace getVariable [_saveVariable,_defaultValue];\nmissionNamespace setVariable [_saveVariable,nil];\n\n\n_return\n",
    "fileName": "fn_getVariableTarget.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getVariableTarget_sendBack\n\nDescription:\n    The send back component of KISKA_fnc_getVariableTarget that is executed on the target.\n    Shouldn't be called on its own.\n\nParameters:\n    0: _namespace : <NAMESPACE, OBJECT, STRING, GROUP, CONTROL, or LOCATION> - The namespace to get the variable from\n    1: _variableName : <STRING> - The string name of the varaible to get\n    2: _saveVariable : <STRING> - A unique string name for the variable to be saved in on the sender's machine\n    3: _defaultValue : <ANY> - If the variable does not exist for the target, what should be returned instead\n    4: _sendBackTarget : <ANY> - The clientOwner id of whoever sent the request\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _namespace,\n            _variableName,\n            _saveVariable,\n            _defaultValue,\n            clientOwner\n        ] remoteExecCall [\"KISKA_fnc_getVariableTarget_sendBack\",_target];\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getVariableTarget_sendBack\";\n\nparams [\"_namespace\",\"_variableName\",\"_saveVariable\",\"_defaultValue\",\"_sendBackTarget\"];\nprivate _getVariableValue = _namespace getVariable [_variableName,_defaultValue];\n\nif (_sendBackTarget isEqualTo 0) then {\n\n    if (remoteExecutedOwner isEqualTo 0) then { // never broadcast to all clients\n        missionNamespace setVariable [_saveVariable,_getVariableValue];\n\n        [\n            [\n                \"Did not send back _saveVariable: \",\n                _saveVariable,\n                \" to 0 target, saved value, which is: \",\n                _getVariableValue,\n                \" locally.\"\n            ],\n            false\n        ] call KISKA_fnc_log;\n    } else {\n        missionNamespace setVariable [_saveVariable,_getVariableValue,remoteExecutedOwner];\n\n        [\n            [\n                \"Sent back _saveVariable: \",\n                _saveVariable,\n                \" to \",\n                remoteExecutedOwner,\n                \" ---Value sent was \",\n                _getVariableValue\n            ],\n            false\n        ] call KISKA_fnc_log;\n    };\n\n} else {\n    // setVariable with a public flag of 2 in singleplayer does not work\n    if (!isMultiplayer AND {_sendBackTarget isEqualTo 2}) then {\n        _sendBackTarget = 0;\n    };\n    missionNamespace setVariable [_saveVariable,_getVariableValue,_sendBackTarget];\n\n    [\n        [\n            \"Sent back _saveVariable: \",\n            _saveVariable,\n            \" to \",\n            _sendBackTarget,\n            \" ---Value sent was \",\n            _getVariableValue\n        ],\n        false\n    ] call KISKA_fnc_log;\n    \n};\n\n\nnil\n",
    "fileName": "fn_getVariableTarget_sendBack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getVectorToTarget\n\nDescription:\n    Returns vectorDir and vectorUp that should angle the object towards the target.\n\n    E.g. this will point the nose of a plane towards a target if paired with\n     setVector commands.\n\nParameters:\n    0: _object : <OBJECT, ARRAY> - The object to set the vectors of or its ASL position\n    1: _target : <OBJECT, ARRAY> - The target to angle towards or its ASL position\n\nReturns:\n    <ARRAY> - An array of arrays formatted as [directionVector,upVector]\n\nExamples:\n    (begin example)\n        // angles to player\n        myObject setVectorDirAndUp ([myObject,player] call KISKA_fnc_getVectorToTarget);\n    (end)\n\nAuthor(s):\n    Nelson Duarte,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_getVectorToTarget\";\n\nparams [\n    [\"_object\",objNull,[objNull,[]]],\n    [\"_target\",objNull,[objNull,[]]]\n];\n\n\nprivate _objectPosition = _object;\nif (_object isEqualType objNull) then {\n    _objectPosition = getPosASLVisual _object;\n};\n\nprivate _targetPosition = _target;\nif (_target isEqualType objNull) then {\n    _targetPosition = getPosASLVisual _target;\n};\n\nprivate _dirVector = vectorNormalized (_targetPosition vectorDiff _objectPosition);\nprivate _rightVector = (_dirVector vectorCrossProduct [0,0,1]) vectorMultiply -1;\nprivate _upVector = _dirVector vectorCrossProduct _rightVector;\n\n\n[_dirVector,_upVector]\n",
    "fileName": "fn_getVectorToTarget.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_hintDiary\n\nDescription:\n    Displays a hint to the player and (always) creates a chronological\n     diary entry and an entry in the defined subject if desired.\n\nParameters:\n    0: _hintText <STRING> - The actual text shown in the hint\n    1: _subject <STRING> - The subject line in the journal for the hint (OPTIONAL)\n    2: _silent <BOOL> - true for silent hint\n\nReturns:\n    <DIARY-RECORD> - The created diary record.\n    \nExamples:\n    (begin example)\n        [\"this is the message\", \"Subject\"] call KISKA_fnc_hintDiary;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_hintDiary\";\n\nif !(hasInterface) exitWith {};\n\n// if function is not run in the same environment, causes an issue where ther will be two\n/// at least \"Chronological Hint List\" sub-subjects\nif (canSuspend) exitWith {\n    [\n        {_this call KISKA_fnc_hintDiary},\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_hintText\",\"This is shown\",[\"\"]],\n    [\"_subject\",\"\",[\"\"]],\n    [\"_silent\",false,[true]]\n];\n\nif (_silent) then {\n    hintSilent _hintText;\n} else {\n    hint _hintText;\n};\n\n[[\"Chronological Hint List\",\"- \" + _hintText]] call KISKA_fnc_addKiskaDiaryEntry;\n\nprivate _diaryRecord = diaryRecordNull;\nif (_subject isNotEqualTo \"\") then {\n    _diaryRecord = [[_subject,\"- \" + _hintText]] call KISKA_fnc_addKiskaDiaryEntry;\n};\n\n\n_diaryRecord\n",
    "fileName": "fn_hintDiary.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_idCounter\n\nDescription:\n    For a given string id, return the latest \"index\" for that id.\n     This increments the id by one each time it is called. This function does not\n     check if the provided namespace is not null, so ensure it is checked\n\nParameters:\n    0: _id <string> - The id to increment\n    1: _namespace <GROUP, OBJECT, LOCATION, NAMESPACE, CONTROL, DISPLAY, TASK, TEAM-MEMBER> - The namespace\n     to check the id count in, this is `localNamespace` by default.\n\nReturns:\n    <NUMBER> - the latest index of the given id\n\nExamples:\n    (begin example)\n        private _latesIndexFor_myId = [\"myId\"] call KISKA_fnc_idCounter;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_idCounter\";\n\n#define NULL_TYPES [grpNull,objNull,locationNull,controlNull,displayNull,taskNull,teamMemberNull]\n\nparams [\n    [\"_id\",\"\",[\"\"]],\n    [\"_namespace\",localNamespace,[grpNull,objNull,locationNull,controlNull,displayNull,taskNull,teamMemberNull,localNamespace]]\n];\n\n\nif ((_namespace isEqualTypeAny NULL_TYPES) AND {isNull _namespace}) exitWith {\n    [[\"Null namespace passed for id \",_id,\" namespace \",_namespace],true] call KISKA_fnc_log;\n    -1\n};\n\nif (_id isEqualTo \"\") exitWith {\n    [\"Empty _id provided\",true] call KISKA_fnc_log;\n    -1\n};\n\n\n_id = toLowerANSI _id;\nprivate _indexMap = _namespace getVariable \"KISKA_indexMap\";\nif (isNil \"_indexMap\") then {\n    _indexMap = createHashMap;\n    _namespace setVariable [\"KISKA_indexMap\",_indexMap];\n};\n\nprivate _latestIndex = _indexMap getOrDefault [_id, 0];\n_indexMap set [_id,_latestIndex + 1];\n\n\n_latestIndex\n",
    "fileName": "fn_idCounter.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isAdminOrHost\n\nDescription:\n    Checks if the machine is an admin or host's.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL> - True if is, false if not\n\nExamples:\n    (begin example)\n        _isAdminOrHost = call KISKA_fnc_isAdminOrHost;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isAdminOrHost\";\n\n// singleplayer is always true\nif (isServer) exitWith {true};\n\nif (!(call BIS_fnc_admin > 0) AND {clientOwner isNotEqualTo 2}) then {\n    false\n} else {\n    true\n};\n",
    "fileName": "fn_isAdminOrHost.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isGroupAlive\n\nDescription:\n    Checks if any unit in the group is alive.\n\nParameters:\n    0: _group <GROUP or OBJECT> - The group or a unit in that group to check the status for\n\nReturns:\n    <BOOL> - True if a unit in the group is alive, false otherwise\n\nExamples:\n    (begin example)\n        [group player] call KISKA_fnc_isGroupAlive;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isGroupAlive\";\n\nparams [\n    [\"_group\",grpNull,[grpNull,objNull]]\n];\n\n\nif (isNull _group) exitWith {false};\n\nif (_group isEqualType objNull) then {\n    _group = group _group;\n};\n\nprivate _units = units _group;\nprivate _personInGroupIsAlive = (_units findIf {alive _x}) isNotEqualTo -1;\n\n\n_personInGroupIsAlive\n",
    "fileName": "fn_isGroupAlive.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isMainMenu\n\nDescription:\n    Checks if loaded mission is main menu.\n\nParameters:\n    NONE\n\nReturns:\n    <BOOL>\n\nExamples:\n    (begin example)\n        isMainMenu = call KISKA_fnc_isMainMenu;\n    (end)\n\nAuthor(s):\n    Leopard20\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isMainMenu\";\n\nallDisplays isEqualTo [findDisplay 0]\n",
    "fileName": "fn_isMainMenu.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_isPatchLoaded\n\nDescription:\n    Simply checks a config name to see if it is loaded under CFGPatches\n\nParameters:\n    0: _configName <STRING> - The patch config name to check for\n\nReturns:\n    <BOOL> - False if not, true if is loaded\n\nExamples:\n    (begin example)\n\n        [\"OPTRE_Core\"] call KISKA_fnc_isPatchLoaded;\n\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_isPatchLoaded\";\n\nparams [\n    [\"_configName\",\"\",[\"\"]]\n];\n\nif (_configName isEqualTo \"\") exitWith {\n    [\"_configName is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _isLoaded = isClass (configFile / \"cfgPatches\" / _configName);\n\n_isLoaded",
    "fileName": "fn_isPatchLoaded.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_log\n\nDescription:\n    Prints a log with a script name to console.\n\n    Whether or not something is logged depends on whether the script is set in\n     the KISKA_logScripts array. If the script name (or \"all\") is found in the array\n     a log is printed.\n\nParameters:\n    0: _message <ANY> - The message to send. If array and _joinString is true, will be used with the joinString command\n    1: _logWithError <BOOL> - Show error message on screen (BIS_fnc_error)\n    2: _forceLog <BOOL> - Print log regardless of KISKA_logScripts content\n    3: _joinString <BOOL> - Should this message joined into a string if an array\n    4: _scriptName <STRING> - The name of the script from where this message is being called\n\nReturns:\n    <ANY> - The message sent\n\nExamples:\n    (begin example)\n        missionNamespace setVariable [\"KISKA_doLog\",true];\n        scriptName \"My Script\";\n        private _myvar = 1;\n        [[\"Hello Number\",_myvar]] call KISKA_fnc_log;\n\n        // prints [\"My Script\"] \"Hello Number 1\" to console\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nif !(missionNamespace getVariable [\"KISKA_CBA_log\",true]) exitWith {};\n\nparams [\n    [\"_message\",\"\",[]],\n    [\"_logWithError\",missionNamespace getVariable [\"KISKA_CBA_logWithError\",false],[true]],\n    [\"_forceLog\",true,[true]],\n    [\"_joinString\",true,[true]],\n    [\"_scriptName\",\"\",[\"\"]]\n];\n\nif (_scriptName == \"\" AND {!isNil \"_fnc_scriptNameParent\"}) then {\n    _scriptName = _fnc_scriptNameParent;\n};\n\nif !(_forceLog) then {\n    // set _forceLog to true if the scripts name is in the log array KISKA_logScripts\n    private _scripts = missionNamespace getVariable [\"KISKA_CBA_logScripts_array\",[\"all\"]];\n    if (\"all\" in _scripts OR {(toLowerANSI _scriptName) in _scripts}) then {\n        _forceLog = true;\n    };\n};\n\nif !(_forceLog) exitWith {};\n\n// only start a new header message with script name when another script interrupts\nprivate _currentLoggedScript = missionNamespace getVariable [\"KISKA_currentLoggedScript\",\"\"];\nif (_currentLoggedScript != _scriptName) then {\n    missionNamespace setVariable [\"KISKA_currentLoggedScript\",_scriptName];\n    diag_log text(\"--------- KISKA Log \" + _scriptName + \" ---------\");\n};\n\nif (_message isEqualType [] AND {_joinString}) then {\n    _message = _message joinString \"\";\n};\n\ndiag_log text(\"[\" + _scriptName + \"] \" + _message);\n\nif (_logWithError) then {\n    (_scriptName + \" : \" + _message) call BIS_fnc_error;\n};\n\n\n_message\n",
    "fileName": "fn_log.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_markBorder\n\nDescription:\n    Places a number of objects around a given radius to mark an area.\n\nParameters:\n    0: _centerPos <POSITION_ASL or OBJECT> - The center of the area to mark\n    1: _radius <NUMBER> - The distance from the center to place markers around\n    2: _markerCount <NUMBER> - The number of markers to use for the area\n    3: _verticalOffset <NUMBER> - Objects will be placed at Z axis of 0, this will offset that position\n    4: _markerObjectClass <STRING> - The classname of the object to place to mark the area\n\nReturns:\n    <ARRAY> - An array of simple objects created to mark the area\n\nExamples:\n    (begin example)\n        _markers = [\n            player\n        ] call KISKA_fnc_markBorder;\n    (end)\n\nAuthor(s):\n    Leopard20\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_markBorder\";\n\nparams [\n    [\"_centerPos\",objNull,[objNull,[]]],\n    [\"_radius\",25,[123]],\n    [\"_markerCount\",10,[123]],\n    [\"_verticalOffset\",0,[123]],\n    [\"_markerObjectClass\",\"Sign_Sphere100cm_F\",[\"\"]]\n];\n\nif (_centerPos isEqualType objNull) then {\n    _centerPos = getPosASL _centerPos;\n};\n\nprivate _markerInterval = 360 / _markerCount;\nprivate _heading = 0;\nprivate _objects = [];\nfor \"_i\" from 1 to _markerCount do {\n    private _pos = AGLToASL(_centerPos getPos [_radius,_heading]) vectorAdd [0,0,_verticalOffset];\n    _heading = _heading + _markerInterval;\n\n    private _object = [_markerObjectClass,_pos,0,false,false] call BIS_fnc_createSimpleObject;\n    _objects pushback _object;\n};\n\n\n_objects\n",
    "fileName": "fn_markBorder.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_markPositions\n\nDescription:\n    Simply creates a 3d object helper marker on provided postitions. \n    Works in 3den also.\n\nParameters:\n    0: _positions <ARRAY> - An array of positions to place the markers on\n\nReturns:\n    _entities <ARRAY> - all created markers\n\nExamples:\n    (begin example)\n        [[0,0,0],[0,0,0]] call KISKA_fnc_markPositions;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nparams [\n    [\"_positions\",[],[[]]]\n];\n\nif (_positions isEqualTo []) exitWith {\n    []\n};\n\nprivate _entities = [];\n\nif (is3DEN) then {\n    _positions apply {\n        private _entity = create3DENEntity [\"OBJECT\",\"Sign_Arrow_Large_F\",_x];\n        _entities pushBack _entity;\n    };\n\n} else {\n    _positions apply {\n        private _entity = \"Sign_Arrow_Large_F\" createVehicle _x;\n        _entities pushBack _entity;\n    };\n\n};\n\n_entities\n",
    "fileName": "fn_markPositions.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_monitorFPS\n\nDescription:\n    Keeps track of the local machine's FPS for a given duration and prints\n     data to log file.\n\nParameters:\n    0: _duration <NUMBER> - How long the test will run\n    1: _frequency <NUMBER> - Time between checks\n    2: _print <BOOL> - Shows a hint on screen\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [60] call KISKA_fnc_monitorFPS;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_monitorFPS\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled evnironment, exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_monitorFPS;\n};\n\nparams [\n    [\"_duration\",60,[123]],\n    [\"_frequency\",0.1,[123]],\n    [\"_print\",false,[true]]\n];\n\nprivate _fpsArray = [];\nprivate _fps = 0;\n\nsleep 2; // in case somebody is leaving a menu from execution this gives a small buffer so the the min fps is actually representative\n\nprivate _timeToEnd = time + _duration;\nwhile {time < _timeToEnd} do {\n    _fps = diag_fps;\n    if (_print) then {\n        hint str _fps;\n    };\n\n    _fpsArray pushBack _fps;\n    sleep _frequency;\n};\n\nprivate _high = selectMax _fpsArray;\nprivate _low = selectMin _fpsArray;\n\nprivate _average = -1;\n_fpsArray apply {\n    _average =  _average + _x;\n};\n_average = _average / (count _fpsArray);\n\nprivate _printOut = \"FPS Test has ended: AVERAGE: \" + str _average + \" MAX: \" + str _high + \" MIN: \" + str _low;\nhint _printOut;\ndiag_log _printOut;\n\n\nnil\n",
    "fileName": "fn_monitorFPS.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_netId\n\nDescription:\n    Gets a \"netId\" for singleplayer and a `netId` when in multiplayer.\n\nParameters:\n    0: _entity <OBJECT or GROUP> - The group or object to get the id of\n\nReturns:\n    <STRING> - The Id of the entity\n\nExamples:\n    (begin example)\n        _id = [player] call KISKA_fnc_netId;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_netId\";\n\nif (canSuspend) exitWith {\n    [\n        {_this call KISKA_fnc_netId},\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nparams [\n    [\"_entity\",objNull,[grpNull,objNull]]\n];\n\nif (isNull _entity) exitWith {\n    [\"_entity is null!\",true] call KISKA_fnc_log\n    -1\n};\n\n\nif (isMultiplayer) exitWith {netId _entity};\n\nprivate _id = _entity getVariable [\"KISKA_netId\",\"\"];\nif (_id isNotEqualTo \"\") exitWith {_id};\n\n\n// if object is not saved\nprivate _netIdCount = [\"KISKA_netId_counter\"] call KISKA_fnc_idCounter;\n_id = [\"0:\",_netIdCount] joinString \"\";\n_entity setVariable [\"KISKA_netId\",_id];\n\n// create map if needed\nprivate _map = localNamespace getVariable \"KISKA_objectNetId_map\";\nif (isNil \"_map\") then {\n    _map = createHashMap;\n    localNamespace setVariable [\"KISKA_objectNetId_map\",_map];\n};\n\n\nif !(_id in _map) then {\n    _map set [_id,_entity];\n};\n\n\n_id\n",
    "fileName": "fn_netId.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_notification\n\nDescription:\n    Prints a simple KISKA Notify notification on screen.\n\nParameters:\n    0: _message : <STRING or ARRAY> - If string, the message to display as title.\n        \n        If array:\n        - 0: _text : <STRING> - Text to display or path to .paa or .jpg\n            image (may be passed directly if only text is required)\n        - 1: _size : <NUMBER> - Scale of text\n        - 2: _color : <NUMBER[]> - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1])\n\n    1: _lifetime : <NUMBER> - How long the notification will be visible (min of 2 seconds)\n    2: _canSkip : <BOOL> - Can the notification be skipped when another is in the queue\n    3: _headerColor : <NUMBER[]> - An array of [R,G,B,A] color values; defaults to green\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\"Hello World\"] call KISKA_fnc_notification;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_notification\";\n\n#define GREEN_RBGA [0.21,0.71,0.21,1]\n\nparams [\n    [\"_message\",\"\",[\"\",[]]],\n    [\"_lifetime\",4,[123]],\n    [\"_canSkip\",true,[true]],\n    [\"_headerColor\",GREEN_RBGA,[[]],[3,4]]\n];\n\n[\n    [\"Notification:\",1.1,_headerColor],\n    _message,\n    _lifetime,\n    _canSkip\n] call KISKA_fnc_notify;\n\n\nnil\n",
    "fileName": "fn_notification.sqf"
  },
  {
    "text": "#include \"\\a3\\ui_f\\hpp\\defineCommonGrids.inc\"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_notify\n\nDescription:\n    Display a text message. Multiple incoming messages are queued. Also controls\n     the lifetime of a notification\n\nParameters:\n    0: _titleLine : <STRING, STRUCTURED TEXT, or ARRAY> - If string, the message to display as title.\n        \n        If array:\n        - 0. _text : <STRING> - Text to display or path to .paa or .jpg\n            image (may be passed directly if only text is required)\n        - 1. _size : <NUMBER> - Scale of text\n        - 2. _color : <ARRAY> - RGB or RGBA color (range 0-1). (optional, default: [1, 1, 1, 1])\n\n    1: _subLine : <STRING, STRUCTURED TEXT, or ARRAY> - Formatted the same as _titleLine\n    2: _lifetime : <NUMBER> - How long the notification lasts in seconds (at least 2)\n    3: _skippable : <BOOL> - If there are more notifications behind in the queue and this notification\n        comes up, it will not be shown and thrown away\n\nExamples:\n    (begin example)\n        [\n            [\"Hello\",1.1,[0.75,0,0,1]],\n            \"World\",\n            5,\n            false\n        ] call KISKA_fnc_notify;\n    (end)\n\nReturns:\n    NOTHING\n\nAuthors:\n    commy2,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_notify\";\n\n#define NOTIFY_DEFAULT_X (safezoneX + safezoneW - 13 * GUI_GRID_W)\n#define NOTIFY_DEFAULT_Y (safezoneY + 6 * GUI_GRID_H)\n#define NOTIFY_MIN_WIDTH (12 * GUI_GRID_W)\n#define NOTIFY_MIN_HEIGHT (3 * GUI_GRID_H)\n\n#define TRIPLES(var1,var2,var3) var1##_##var2##_##var3\n\n#define FADE_IN_TIME 0.2\n#define FADE_OUT_TIME 1\n\n#define BACKGROUND_OPACITY 0.25\n\n#define GET_QUEUE localNamespace getVariable \"KISKA_notificationQueue\"\n#define SET_QUEUE(var) localNamespace setVariable [\"KISKA_notificationQueue\",var]\n\n\nif (canSuspend) exitWith {\n    [\n        KISKA_fnc_notify,\n        _this\n    ] call CBA_fnc_directCall;\n};\n\nif (!hasInterface) exitWith {};\n\nprivate _structuredText = text \"\";\nparams [\n    [\"_titleLine\",\"\",[[],\"\"]],\n    [\"_subLine\",\"\",[[],\"\",_structuredText]],\n    [\"_lifetime\",4,[123]],\n    [\"_skippable\",false,[true]]\n];\n\nif (_lifetime < 2) then {\n    _lifetime = 2;\n};\n\n\n/* ----------------------------------------------------------------------------\n    Build composition\n---------------------------------------------------------------------------- */\nprivate _composition = [];\n// top lineBreak is for gap at top of notification\n// bottom two lineBreaks create a gap at the bottom of the notification\n[lineBreak,_titleLine,lineBreak,_subLine,lineBreak,lineBreak] apply {\n    if (_x isEqualTo lineBreak) then {\n        _composition pushBack lineBreak;\n        continue;\n    };\n\n    private _isStructuredText = _x isEqualType (text \"\");\n    if (_isStructuredText) then {\n        _composition pushBack _x;\n        continue;\n    };\n\n    // Line\n    _x params [\n        [\"_text\",\"\",[\"\",text \"\"]],\n        [\"_size\",1,[123]],\n        [\"_color\",[1,1,1,1],[[]],[3,4]]\n    ];\n\n    if ((count _color) isEqualTo 3) then {\n        _color pushBack 1;\n    };\n\n    _color = _color call BIS_fnc_colorRGBAtoHTML;\n    _size = _size * 0.55 / (getResolution select 5);\n\n    private _isImage = (toLower _text) select [(count _text) - 4] in [\".paa\", \".jpg\"];\n    if (_isImage) then {\n        _composition pushBack (parseText format [\"<img align='center' valign='middle' size='%2' color='%3' image='%1'/>\", _text, _size, _color]);\n\n    } else {\n        _text = text _text;\n        _text setAttributes [\n            \"color\", _color,\n            \"size\", str _size\n        ];\n\n        _text = composeText [_text];\n        _composition pushBack _text;\n    };\n};\n\nprivate _notification = [_composition, _lifetime, _skippable];\n\n// add the queue\nif (isNil {GET_QUEUE}) then {\n    SET_QUEUE([]);\n};\n\n(GET_QUEUE) pushBack _notification;\n\n\n/* ----------------------------------------------------------------------------\n    loop\n---------------------------------------------------------------------------- */\nif !(localNamespace getVariable [\"KISKA_notificationLoopRunning\",false]) then {\n    localNamespace setVariable [\"KISKA_notificationLoopRunning\",true];\n\n    [] spawn {\n        /* ----------------------------------------------------------------------------\n            _fn_createNotification\n        ---------------------------------------------------------------------------- */\n        private _fn_createNotification = {\n            disableSerialization;\n            params [\n                \"_composition\",\n                \"_lifetime\"\n            ];\n\n            \"KISKA_ui_notify\" cutRsc [\"RscTitleDisplayEmpty\", \"PLAIN\", 0, true];\n            private _display = uiNamespace getVariable \"RscTitleDisplayEmpty\";\n\n            private _vignette = _display displayCtrl 1202;\n            _vignette ctrlShow false;\n\n            private _notificationCtrl = _display ctrlCreate [\"RscStructuredText\", -1];\n\n            private _structuredText = composeText _composition;\n            _structuredText setAttributes [\"align\",\"center\"];\n            _structuredText = composeText [_structuredText];\n            _notificationCtrl ctrlSetStructuredText _structuredText;\n            _notificationCtrl ctrlSetBackgroundColor [0,0,0,BACKGROUND_OPACITY];\n            _notificationCtrl ctrlCommit 0.1;\n\n            // using CBA notification position if available\n            private _left = profileNamespace getVariable ['TRIPLES(IGUI,cba_ui_notify,x)', NOTIFY_DEFAULT_X];\n            private _top = profileNamespace getVariable ['TRIPLES(IGUI,cba_ui_notify,y)', NOTIFY_DEFAULT_Y];\n            private _width = profileNamespace getVariable ['TRIPLES(IGUI, cba_ui_notify, w)', NOTIFY_MIN_WIDTH];\n            private _height = profileNamespace getVariable ['TRIPLES(IGUI, cba_ui_notify, h)', NOTIFY_MIN_HEIGHT];\n\n            _width = (ctrlTextWidth _notificationCtrl) max _width;\n            _height = (ctrlTextHeight _notificationCtrl) max _height;\n\n            // ensure the box not going off screen\n            private _right = _left + _width;\n            private _bottom = _top + _height;\n\n            private _leftEdge = safezoneX;\n            private _rightEdge = safezoneW + safezoneX;\n            private _topEdge = safezoneY;\n            private _bottomEdge = safezoneH + safezoneY;\n\n            if (_right > _rightEdge) then {\n                _left = _left - (_right - _rightEdge);\n            };\n\n            if (_left < _leftEdge) then {\n                _left = _left + (_leftEdge - _left);\n            };\n\n            if (_bottom > _bottomEdge) then {\n                _top = _top - (_bottom - _bottomEdge);\n            };\n\n            if (_top < _topEdge) then {\n                _top = _top + (_topEdge - _top);\n            };\n\n\n            _notificationCtrl ctrlSetPositionW _width;\n            _notificationCtrl ctrlSetPositionX _left;\n            _notificationCtrl ctrlSetPositionY _top;\n\n            _notificationCtrl ctrlSetFade 1;\n            _notificationCtrl ctrlCommit 0;\n            // in order to get the height of the background to be properly sized,\n            // need to commit other changes before checking ctrlTextHeight\n            _notificationCtrl ctrlSetPositionH (ctrlTextHeight _notificationCtrl);\n            _notificationCtrl ctrlSetFade 0;\n            _notificationCtrl ctrlCommit (FADE_IN_TIME);\n\n            sleep _lifetime - FADE_OUT_TIME;\n\n            _notificationCtrl ctrlSetFade 1;\n            _notificationCtrl ctrlCommit (FADE_OUT_TIME);\n\n            sleep FADE_OUT_TIME;\n        };\n\n\n        /* ----------------------------------------------------------------------------\n            Queue loop\n        ---------------------------------------------------------------------------- */\n        private [\"_notificationInfo\",\"_skippable\"];\n        private _queue = GET_QUEUE;\n\n        while {(count _queue) > 0} do {\n            _notificationInfo = _queue deleteAt 0;\n            _skippable = _notificationInfo deleteAt 2;\n\n            if !(_skippable AND ((count _queue) > 0)) then {\n                _notificationInfo call _fn_createNotification;\n            };\n        };\n\n        localNamespace setVariable [\"KISKA_notificationLoopRunning\",false];\n    };\n\n};\n\n\nnil\n",
    "fileName": "fn_notify.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_playDrivePath\n\nDescription:\n    Uses setDriveOnPath to move a vehicle. Additionally makes sure the vehicle\n     can move before starting (turn engineOn and use doStop).\n\nParameters:\n    0: _vehicle <OBJECT> - The vehicle to use setDriveOnPath command on\n    1: _pathArray <ARRAY> - An array of positions in [x,y,z] format or\n        [x,y,z,speed-in-meters-per-second] for the vehicle to drive on.\n        (see setDriveOnPath documentation)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            _vehicle,\n            _pathArray\n        ] call KISKA_fnc_playDrivePath;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_playDrivePath\";\n\nparams [\n    [\"_vehicle\",objNull,[objNull]],\n    [\"_pathArray\",[],[[]]]\n];\n\nif (isNull _vehicle) exitWith {\n    [\"_vehicle is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _driver = driver _vehicle;\nif (isNull _driver) exitWith {\n    [\"_vehicle has no driver!\",true] call KISKA_fnc_log;\n    nil\n};\n\n\n_vehicle engineOn true;\nif !(isAgent teamMember _driver) then {\n    doStop _driver;\n};\n\n// some time (more then one frame) is needed after doStop to execute setDriveOnPath\n[\n    {\n        (_this select 0) setDriveOnPath (_this select 1);\n    },\n    [_vehicle,_pathArray],\n    1\n] call CBA_fnc_waitAndExecute;\n",
    "fileName": "fn_playDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_pushBackToArray\n\nDescription:\n    Pushes back a value to a global array.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The array in string format\n    1: _entryToAdd : <ANY> - The value to pushBack\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL, or DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - true if added, false if not\n\nExamples:\n    (begin example)\n        [\"myGlobalArrayVar\",someInfoHere,missionNamespace] call KISKA_fnc_pushBackToArray;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_pushBackToArray\";\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_entryToAdd\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (isNil \"_entryToAdd\") exitWith {\n    [\"_entryToAdd was undefined, nothing to pushback\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\n//[[\"Called to add \",_entryToAdd,\" to array var name: \", _arrayVariableName],false] call KISKA_fnc_log;\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\n_array pushBack _entryToAdd;\n\nif (isNil {_namespace getVariable _arrayVariableName}) then {\n    _namespace setVariable [_arrayVariableName,_array];\n};\n\n\ntrue\n",
    "fileName": "fn_pushBackToArray.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_pushBackToArray_interface\n\nDescription:\n    Pushes back a value to a global array. Checks if machine hasInterface before pushing.\n\n    This was used in lieu of creating a public variable to sync the array.\n    In order to keep network traffic lower if the array becomes large.\n\nParameters:\n    0: _arrayVariableName : <STRING> - The array in string format\n    1: _entryToAdd : <ANY> - The value to pushBack\n    2: _namespace : <NAMESPACE,OBJECT,GROUP,LOCATION,CONTROL, or DISPLAY> - What namespace the array is in\n\nReturns:\n    <BOOL> - true if added, false if not\n\nExamples:\n    (begin example)\n        [\n            \"myGlobalArrayVar\",\n            someInfoHere,\n            missionNamespace\n        ] call KISKA_fnc_pushBackToArray_interface;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_pushBackToArray_interface\";\n\nif (!hasInterface) exitWith {false};\n\nparams [\n    [\"_arrayVariableName\",\"\",[\"\"]],\n    \"_entryToAdd\",\n    [\"_namespace\",missionNamespace,[missionNamespace,objNull,grpNull,controlNull,displayNull,locationNull]]\n];\n\nif (isNil \"_entryToAdd\") exitWith {\n    [\"_entryToAdd was undefined, nothing to pushback\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_arrayVariableName isEqualTo \"\") exitWith {\n    [\"Array variable name is empty string\",true] call KISKA_fnc_log;\n    false\n};\n\n//[[\"Called to add \",_entryToAdd,\" to array var name: \", _arrayVariableName],false] call KISKA_fnc_log;\n\nprivate _array = _namespace getVariable [_arrayVariableName,[]];\n_array pushBack _entryToAdd;\n\nif (isNil {_namespace getVariable _arrayVariableName}) then {\n    _namespace setVariable [_arrayVariableName,_array];\n};\n\n\ntrue\n",
    "fileName": "fn_pushBackToArray_interface.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_randomIndex\n\nDescription:\n    Returns a random index of an array ~2x faster than BIS_fnc_randomIndex;\n\nParameters:\n    0: _array <ARRAY> - The array to find a random index of.\n\nReturns:\n    <NUMBER> - The random index\n\nExamples:\n    (begin example)\n        private _randomIndex = [[1,2,3]] call KISKA_fnc_randomIndex;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_randomIndex\";\n\nparams [\n    [\"_array\",[],[[]]]\n];\n\n\nfloor (random (count _array))",
    "fileName": "fn_randomIndex.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_reassignCurator\n\nDescription:\n    Reassigns a curator object to the local player.\n\nParameters:\n    0: _curatorObject : <OBJECT or STRING> - The curator object to reassign\n    1: _isManual : <BOOL> - Was this called from the diary entry (keeps hints from showing otherwise)\n\nReturns:\n    <BOOL> - true if added to player, false otherwise\n\nExamples:\n    (begin example)\n        // show hint messages\n        [myCuratorObject,true] call KISKA_fnc_reassignCurator;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_reassignCurator\";\n\nif (!hasInterface) exitWith {false};\n\nparams [\n    [\"_curatorObject\",objNull,[objNull,\"\"]],\n    [\"_isManual\",false,[true]]\n];\n\n// check if player is host or admin\nif !(call KISKA_fnc_isAdminOrHost) exitWith {\n    if (_isManual) then {\n        [\"Only admins can be assigned curator\"] call KISKA_fnc_notification;\n    };\n    false\n};\n\nif (_curatorObject isEqualType \"\") then {\n    _curatorObject = missionNamespace getVariable [_curatorObject,objNull];\n};\n\nif (isNull _curatorObject) exitWith {\n    [\"_curatorObject isNull!\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _unitWithCurator = getAssignedCuratorUnit _curatorObject;\nif (isNull _unitWithCurator) then {\n    [player,_curatorObject] remoteExecCall [\"assignCurator\",2];\n} else {\n    if (alive _unitWithCurator) then {\n        // no sense in alerting player if they are the curator still\n        if (!(_unitWithCurator isEqualTo player)) then {\n            [\"Another currently alive admin has the curator assigned to them already\"] call KISKA_fnc_notification;\n        } else {\n            [\"You are already the curator\"] call KISKA_fnc_notification;\n        };\n\n        false\n    } else {\n        [_unitWithCurator,_isManual,_curatorObject] spawn {\n            params [\"_unitWithCurator\",\"_isManual\",\"_curatorObject\"];\n            [_curatorObject] remoteExec [\"unAssignCurator\",2];\n\n            // wait till curator doesn't have a unit to give it the player\n            waitUntil {\n                if !(isNull (getAssignedCuratorUnit _curatorObject)) exitWith {\n                    [player,_curatorObject] remoteExecCall [\"assignCurator\",2];\n                    if (_isManual) then {\n                        hint \"You are now the curator\";\n                    };\n                    true\n                };\n\n                [_curatorObject] remoteExec [\"unAssignCurator\",2];\n\n                sleep 5;\n                false\n            };\n        };\n\n        true\n    };\n};\n",
    "fileName": "fn_reassignCurator.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_recordDrivePath\n\nDescription:\n    Records an array of positons and speeds for use with setDriveOnPath command.\n\nParameters:\n    0: _unit <OBJECT> - The unit to record\n    1: _frequency <NUMBER> - How often to record, 0 for every frame\n    2: _recordSpeed <BOOL> - Should the speed of the _unit be recorded to\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            objectParent player,\n            0.25\n        ] call KISKA_fnc_recordDrivePath\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_recordDrivePath\";\n\nparams [\n    [\"_unit\",objNull,[objNull]],\n    [\"_frequency\",0.5,[123]],\n    [\"_recordSpeed\",true,[false]]\n];\n\nif (isNull _unit) exitWith {\n    [\"_unit is null!\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _path = [];\nprivate _id = [\n    {\n        params [\n            \"_args\",\n            \"_id\"\n        ];\n\n        _args params [\n            \"_unit\",\n            \"_path\",\n            \"_recordSpeed\"\n        ];\n        if (isNull _unit) then {\n            [\"Recording failed, _unit is null\"] call KISKA_fnc_errorNotification;\n            [_id] call CBA_fnc_removePerFrameHandler;\n\n            // remove display event\n            private _keyDownEventId = localNamespace getVariable [\"KISKA_drivePathRecordingDisplayEvent_id\", -1];\n            localNamespace setVariable [\"KISKA_drivePathRecordingDisplayEvent_id\", nil];\n            (findDisplay 46) displayRemoveEventHandler [\"KeyDown\", _keyDownEventId];\n\n        } else {\n            if (_unit getVariable [\"KISKA_fnc_recordDrivePath_\" + str _id, true]) then {\n                private _array = ASLToAGL (getPosASL _unit);\n\n                if (_recordSpeed) then {\n                    _array pushBack ((speed _unit) / 3.6);\n                };\n\n                _path pushBack _array;\n\n            } else {\n                copyToClipboard (str _path);\n                [_id] call CBA_fnc_removePerFrameHandler;\n\n            };\n        };\n\n\n    },\n    _frequency,\n    [_unit,_path,_recordSpeed]\n] call CBA_fnc_addPerFrameHandler;\n[\"Started unit recording, press escape key to stop\"] call KISKA_fnc_notification;\n\ndisableSerialization;\nprivate _display = findDisplay 46;\n// Stops Capture after pressing the ESC key\nprivate _displayId = [\n    _display,\n    \"KeyDown\",\n    {\n        _thisArgs params [\n            \"_id\",\n            \"_unit\"\n        ];\n\n        if ((_this select 1) == 1) then {\n            _unit setVariable [\"KISKA_fnc_recordDrivePath_\" + str _id, false];\n            [\"Stopped unit recording, data copied to clipboard\"] call KISKA_fnc_notification;\n\n            (_this select 0) displayRemoveEventHandler [_thisType, _thisID];\n        };\n    },\n    [_id,_unit]\n] call CBA_fnc_addBISEventHandler;\nlocalNamespace setVariable [\"KISKA_drivePathRecordingDisplayEvent_id\", _displayId];\n\n\nnil\n",
    "fileName": "fn_recordDrivePath.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_remoteReturn_receive\n\nDescription:\n    The send back component of KISKAs remote returns.\n    This catches what was sent in KISKA_fnc_remoteReturn_send and will send the\n     variable back to the remoteExecutedOwner.\n\nParameters:\n    0: _code <STRING> - The code to execute to get a return\n    1: _args : <ARRAY> - An array of arguements for the _code\n    2: _scheduled : <BOOL> - Should _code be run in a scheduled environment\n    3: _uniqueId <STRING> - The unique variable id used to send the return back to the requester\n\nReturns:\n    NOTHING\n\nExamples:\n    // called specifically from KISKA_fnc_remoteReturn_send\n    (begin example)\n        [\n            _code,\n            _args,\n            _scheduled,\n            _uniqueId,\n            clientOwner\n        ] remoteExecCall [\"KISKA_fnc_remoteReturn_receive\",_target];\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_remoteReturn_receive\";\n\nparams [\n    [\"_code\",\"\",[\"\"]],\n    [\"_args\",[],[[]]],\n    [\"_scheduled\",false,[true]],\n    \"_uniqueId\"\n];\n\nprivate _sendBackTarget = remoteExecutedOwner;\n// setVariable handling\nif (_sendBackTarget isEqualTo 0) then {\n\n    [[\"Found _sendBackTarget isEqualTo 0 for \",_uniqueId],false] call KISKA_fnc_log;\n\n    // if it's multiplayer, do not send all connected the value, just put it on server\n    if (isMultiplayer) then {\n        [\"Found to be multiplayer, setting target to 2 \",false] call KISKA_fnc_log;\n        _sendBackTarget = 2;\n    };\n} else {\n\n    [[\"Found _sendBackTarget ise \",_sendBackTarget,\" for \",_uniqueId],false] call KISKA_fnc_log;\n\n    // setVariable in single player does not work with 2 to set on the local machine\n    if (!isMultiplayer AND {_sendBackTarget isEqualTo 2}) then {\n        [[\"Not multiplayer and _sendBackTarget is 2, setting \",_uniqueId,\" to 0 target\"],false] call KISKA_fnc_log;\n        _sendBackTarget = 0;\n    };\n};\n\n\n\nprivate _compiledCode = compileFinal _code;\nif (_scheduled) then {\n\n    [_compiledCode,_args,_uniqueId,_sendBackTarget] spawn {\n        params [\"_code\",\"_args\",\"_uniqueId\",\"_sendBackTarget\"];\n\n        private \"_return\";\n        if (_args isEqualTo []) then {\n            _return = call _code;\n        } else {\n            _return = _args call _code;\n        };\n\n        missionNamespace setVariable [_uniqueId,_return,_sendBackTarget];\n    };\n} else {\n\n    private \"_return\";\n    if (_args isEqualTo []) then {\n        _return = call _compiledCode;\n    } else {\n        _return = _args call _compiledCode;\n    };\n\n    missionNamespace setVariable [_uniqueId,_return,_sendBackTarget];\n};\n",
    "fileName": "fn_remoteReturn_receive.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_remoteReturn_send\n\nDescription:\n    Gets a remote return from a scripting command on a target machine.\n    \n    Basically remoteExec but with a return.\n\n    Needs to be run in a scheduled environment as it takes time to receive\n     the return.\n\n    This should not be abused to obtain large returns over the network.\n    \n    Be smart and use for simple types (not massive arrays).\n\nParameters:\n    0: _code <STRING> - The command to execute on the target machine\n    1: _defaultValue : <ANY> - If the variable does not exist for the target, what should be returned instead\n    2: _target : <NUMBER, OBJECT, or STRING> - The target to execute the _code on\n    3: _scheduled : <BOOL> - Should _code be run in a scheduled environment (on target machine)\n    4: _awaitParams : <[NUMBER,NUMBER,BOOL]> - How the get from the target should be awaited\n\n        Parameters:\n        - 0: <NUMBER> - The sleep time between each check for the variable being received\n        - 1: <NUMBER> - The max time to wait for (this is not total game time but time slept)\n        - 2: <BOOL> - Whether or not the sleep time should be exponential (double every iteration)\n\n\nReturns:\n    <ANY> - Whatever the code returns\n\nExamples:\n    (begin example)\n        [] spawn {\n            // need to call for direct return but in scheduled environment\n            _clientIdFromServer = [\"owner (_this select 0)\",[player],2] call KISKA_fnc_remoteReturn_send;\n        };\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_remoteReturn_send\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled environment\",true] call KISKA_fnc_log;\n    nil\n};\n\nparams [\n    [\"_code\",\"\",[\"\"]],\n    [\"_args\",[],[[]]],\n    [\"_target\",2,[123,objNull,\"\"]],\n    [\"_scheduled\",false,[true]],\n    [\"_awaitParams\",[],[[]]]\n];\n\nif ((_target isEqualType objNull) AND {isNull _target}) exitWith {\n    [\"_target is null object!\"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _targetIsNetId = false;\nprivate _targetsMultipleUsers = false;\nprivate _exitForMultiUserTarget = false;\nprivate _regularMultiplayer = isMultiplayer AND (!isMultiplayerSolo);\nif (_regularMultiplayer) then {\n    private _targetsMultipleUsers = (_target isEqualType 123) AND {_target <= 0};\n    if (_targetsMultipleUsers) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n\n    private _targetIsString = _target isEqualType \"\";\n    if (!_targetIsString) exitWith {};\n\n    private _targetIsNetId = _targetIsString AND {\n            private _split = _target splitString \":\";\n            private _splitCount = count _split;\n            (_splitCount isEqualTo 2) AND {\n                private _splitParsed = _split apply {parseNumber _x};\n                private _splitCompare = _splitParsed apply {str _x};\n                _splitCompare isEqualTo _split\n            }\n        };\n\n    if (!_targetIsNetId) exitWith {\n        _exitForMultiUserTarget = true;\n    };\n};\n\n\nif (_exitForMultiUserTarget) exitWith {\n    [[\"_target: \",_target,\" is invalid as it will be sent to more then one machine!\"],true] call KISKA_fnc_log;\n    nil\n};\n\n_awaitParams params [\n    [\"_awaitTime\",0.05,[123]],\n    [\"_maxWaitTime\",2,[123]],\n    [\"_exponentialBackOff\",false,[true]]\n];\n\nprivate _uniqueId = [\"KISKA_RR_\" + (str clientOwner)] call KISKA_fnc_generateUniqueId;\n[_code,_args,_scheduled,_uniqueId] remoteExecCall [\"KISKA_fnc_remoteReturn_receive\",_target];\n\n\nprivate _timeWaited = 0;\nwaitUntil {\n    if (_timeWaited >= _maxWaitTime) then {\n        [\n            [\n                \"Max wait time of: \",\n                _maxWaitTime,\n                \" for variable \",\n                _uniqueId,\n                \" from target \",\n                _target,\n                \" was exceeded. Exiting with nil...\"\n            ],\n            false\n        ] call KISKA_fnc_log;\n        breakWith true;\n    };\n\n    if (!isNil _uniqueId) exitWith {\n        [[\"Got variable \",_uniqueId,\" from target \",_target],false] call KISKA_fnc_log;\n        true\n    };\n\n    sleep _awaitTime;\n    _timeWaited = _timeWaited + _awaitTime;\n    \n    if (_exponentialBackOff) then {\n        _awaitTime = _awaitTime * 2;\n    };\n    \n    [[\"Waiting for \",_uniqueId,\" from target: \",_target],false] call KISKA_fnc_log;\n    false\n};\n\nprivate _return = missionNamespace getVariable _uniqueId;\n// set to nil so that any other requesters don't get a duplicate\nmissionNamespace setVariable [_uniqueId,nil];\n\n\n_return\n",
    "fileName": "fn_remoteReturn_send.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeArsenal\n\nDescription:\n    Removes both BIS and ACE arsenals from several or a single object.\n    This has a global effect.\n\nParameters:\n    0: _arsenals <ARRAY or OBJECT> - An array of objects to add arsenals to\n\nReturns:\n    <BOOL> - true if done, false if not\n\nExamples:\n    (begin example)\n        [[arsenal1, arsenal2]] call KISKA_fnc_removeArsenal;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeArsenal\";\n\nparams [\n    [\"_arsenals\",[],[[],objNull]]\n];\n\nif (_arsenals isEqualTo [] OR {(_arsenals isEqualType objNull) AND {isNull _arsenals}}) exitWith {\n    [[\"_arsenals are invalid: \",str _arsenals],true] call KISKA_fnc_log;\n    false\n};\n\nif !(_arsenals isEqualType []) then {\n    _arsenals = [_arsenals];\n};\n\nprivate _aceLoaded = [\"ace_arsenal\"] call KISKA_fnc_isPatchLoaded;\n\n_arsenals apply {\n    if (_aceLoaded) then {\n        [_x, true] call ace_arsenal_fnc_removeBox\n    };\n\n    /* [\"AmmoboxExit\",_x] call BIS_fnc_arsenal; */\n    [_x] remoteExecCall [\"KISKA_fnc_removeBISArsenalAction\", 0, true];\n};\n\n\ntrue\n",
    "fileName": "fn_removeArsenal.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeBISArsenalAction\n\nDescription:\n    Removes the BIS arsenal action from the given object.\n\nParameters:\n    0: _arsenal <OBJECT> - The arsenal to remove from\n\nReturns:\n    <BOOL> - true if arsenal was removed, false if action does not currently exist\n\nExamples:\n    (begin example)\n        _done = [arsenal] call KISKA_fnc_removeBISArsenalAction;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeBISArsenalAction\";\n\nparams [\n    [\"_object\",objNull,[objNull]]\n];\n\nif (isNull _object) exitWith {\n    [\"_object is null!\",true] call KISKA_fnc_log;\n    false\n};\n\nprivate _actionId = _object getVariable [\"bis_fnc_arsenal_action\",-1];\nif (_actionId isNotEqualTo -1) exitWith {\n    _object setVariable [\"bis_fnc_arsenal_action\",nil];\n    _object removeAction _actionId;\n    true\n};\n\n\nfalse\n",
    "fileName": "fn_removeBISArsenalAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeEntityKilledEventHandler\n\nDescription:\n    Removes a killed KISKA entity event handler.\n\nParameters:\n    0: _entity <OBJECT> - The entity to remove event from\n    1: _eventId <NUMBER> - The Id of the event to remove\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [aUnit,{hint _this}] call KISKA_fnc_removeEntityKilledEventHandler;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeEntityKilledEventHandler\";\n\nparams [\n    [\"_entity\",objNull,[objNull]],\n    [\"_eventId\",-1,[123]]\n];\n\n\nif (isNull _entity) exitWith {\n    [\"null _entity was passed\",true] call KISKA_fnc_log;\n    -1\n};\n\n\nprivate _eventHashMap = _entity getVariable \"KISKA_entityKilledEventHashMap\";\nif (isNil \"_eventHashMap\") exitWith {};\n\n_eventHashMap deleteAt _eventId;\n\nnil\n",
    "fileName": "fn_removeEntityKilledEventHandler.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_addMagRepack\n\nDescription:\n    Adds a mag repack to the player via Ctrl+R.\n    To remove see KISKA_fnc_removeMagRepack.\n\nParameters:\n    NONE\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        call KISKA_fnc_addMagRepack;\n    (end)\n\nAuthor(s):\n    Quicksilver,\n    Modified by: Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeMagRepack\";\n\n#define DISPLAY_CODE 46\n\nif (!hasInterface) exitWith {};\n\nif (localNamespace getVariable [\"KISKA_magRepackEventId\",-1] isEqualTo -1) exitWith {\n    [\"Mag repack was not present\"] call KISKA_fnc_log;\n    nil\n};\n\n[\n    {\n        !(isNull (findDisplay DISPLAY_CODE))\n    },\n    {\n        private _eventId = localNamespace getVariable [\"KISKA_magRepackEventId\",-1];\n        // possibility of two mag repack waitUntils runnning at once\n        if (_eventId isEqualTo -1) exitWith {\n            [\"Mag repack was already removed never added\"] call KISKA_fnc_log;\n            nil\n        };\n\n        (findDisplay DISPLAY_CODE) displayRemoveEventHandler [\"KeyDown\", _eventId];\n        localNamespace setVariable [\"KISKA_magRepackEventId\",nil];\n    },\n    0\n] call KISKA_fnc_waitUntil;\n\n\nnil\n",
    "fileName": "fn_removeMagRepack.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_removeProximityPlayerAction\n\nDescription:\n    Stages an action added with KISKA_fnc_addProximityPlayerAction for removal.\n    This happens within the loop logic of KISKA_fnc_addProximityPlayerAction so\n     it is NOT instant.\n\nParameters:\n    0: _id : <NUMBER> - The proximity action id returned from KISKA_fnc_addProximityPlayerAction\n\nReturns:\n    <BOOL> - False if action still exists, true if it does not\n\nExamples:\n    (begin example)\n        [0] call KISKA_fnc_removeProximityPlayerAction;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_removeProximityPlayerAction\";\n\nparams [\n    [\"_id\",-1,[123]]\n];\n\nif (_id < 0) exitWith {\n    [[_id,\" is not valid\"],true] call KISKA_fnc_log;\n    false\n};\n\nprivate _varBase = \"KISKA_proximityAction_\" + (str _id);\nprivate _actionShouldBeRemovedVar = _varBase + \"_remove\";\nif !(localNamespace getVariable [_actionShouldBeRemovedVar,false]) exitWith {\n    localNamespace setVariable [_actionShouldBeRemovedVar,true];\n    true\n};\n\n\nfalse\n",
    "fileName": "fn_removeProximityPlayerAction.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_selectRandom\n\nDescription:\n    Call switchMove \"\" on a given unit. This function was created because as of release \n     2.10 there is an issue where remoteExec'ing switchMove \"\" on a unit directly within \n     some functions (KISKA_fnc_ambientAnim_stop) does not work as intended \n     (the intention being the unit returns to normal animations)\n    \n    Remoteexecuting this function, however, fixes the issue.\n\nParameters:\n    0: _unit <OBJECT> - The unit to reset animation on\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [_unit] remoteExecCall [\"KISKA_fnc_resetMove\"]\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_resetMove\";\n\nparams [\n    [\"_unit\",objNull,[objNull]]\n];\n\n_unit switchMove \"\";",
    "fileName": "fn_resetMove.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_selectRandom\n\nDescription:\n    Selects randomly an entry from an array be it weighted or unweighted.\n\nParameters:\n    0: _array <ARRAY> - An array either formatted as `[value, weight (number)]`, `[[array_of_values],[array_of_weights]]`, or\n        just values (`[value1,value2]`)\n    1: _valueType <ANY> - A variable that should have the same type as the value\n        entries in the array e.g. \"\" for string, [] for array\n        (only needed for possibly weighted arrays)\n\nReturns:\n    <ANY> - Random entry from the array\n\nExamples:\n    (begin example)\n        private _randomValue = [[\n            \"thing1\",\n            \"thing2\"\n        ]] call KISKA_fnc_selectRandom;\n    (end)\n    \n    (begin example)\n        private _weight1 = 0.5;\n        private _weight2 = 0.5;\n\n        private _randomWeightedValue = [\n            [\n                \"thing1\", _weight1,\n                \"thing2\", _weight2\n            ],\n            \"\"\n        ] call KISKA_fnc_selectRandom;\n    (end)\n\n    (begin example)\n        private _weight1 = 0.5;\n        private _weight2 = 0.5;\n\n        private _randomWeightedValue = [\n            [\n                [\"thing1\", \"thing2\"],\n                [_weight1, _weight2]\n            ],\n            \"\"\n        ] call KISKA_fnc_selectRandom;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_selectRandom\";\n\n#define VALUES_TO_SELECT (_array select 0)\n#define WEIGHTS (_array select 1)\n\nparams [\n    [\"_array\",[],[[]]],\n    \"_valueType\"\n];\n\nif (isNil \"_valueType\") exitWith {\n    selectRandom _array;\n};\n\nprivate _isWeightedArray_syntaxOne = (_array isEqualTypeParams [[],[]]) AND ((count _array) isEqualTo 2);\nif (_isWeightedArray_syntaxOne) exitWith {\n   VALUES_TO_SELECT selectRandomWeighted WEIGHTS;\n};\n\nprivate _isWeightedArray_syntaxTwo = _array isEqualTypeParams [_valueType,1];\nif (_isWeightedArray_syntaxTwo) exitWith {\n    selectRandomWeighted _array;\n};\n\n\nselectRandom _array;\n",
    "fileName": "fn_selectRandom.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_setContainerCargo\n\nDescription:\n    Takes a cargo array formatted from KISKA_fnc_getContainerCargo and adds it to another container.\n    Exact ammo counts will be preserved even inside of an item, such as magazines inside of a vest or backpack.\n\nParameters:\n    0: _containerToLoad <OBJECT> - The container to add the cargo to.\n    1: _cargo <ARRAY or OBJECT> - An array of various items, magazines, and weapons formatted from \n        KISKA_fnc_getContainerCargo or the object to copy from\n\nReturns:\n    <BOOL> - True if cargo was set\n\nExamples:\n    (begin example)\n        [container,otherContainer] call KISKA_fnc_setContainerCargo;\n    (end)\n\n    (begin example)\n        private _cargoToCopy = [otherContainer] call KISKA_fnc_getContainerCargo;\n        [container,_cargoToCopy] call KISKA_fnc_setContainerCargo;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setContainerCargo\";\n\nparams [\n    [\"_containerToLoad\",objNull,[objNull]],\n    [\"_cargo\",[],[[],objNull]]\n];\n\nif (isNull _containerToLoad) exitWith {\n    [\"_containerToLoad isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_cargo isEqualType objNull) then {\n    _cargo = [_cargo] call KISKA_fnc_getContainerCargo;\n};\n\nif (_cargo isEqualTo []) exitWith {\n    [\"_cargo is empty array '[]'\",true] call KISKA_fnc_log;\n    false\n};\n\n\n[_containerToLoad] call KISKA_fnc_clearCargoGlobal;\n\n\n// items\nprivate _items = _cargo select 0;\nprivate _itemTypes = _items select 0;\nprivate _itemTypeCounts = _items select 1;\nif (_items isNotEqualTo [[],[]]) then {\n    {\n        _containerToLoad addItemCargoGlobal [_x,_itemTypeCounts select _forEachIndex];\n    } forEach _itemTypes;\n};\n\n\n// magazines\nprivate _magazines = _cargo select 1;\nif (_magazines isNotEqualTo []) then {\n    _magazines apply {\n        _containerToLoad addMagazineAmmoCargo [_x select 0,1,_x select 1];\n    };\n};\n\n\n// weapons\nprivate _weapons = _cargo select 2;\nif (_weapons isNotEqualTo []) then {\n    _weapons apply {\n        _containerToLoad addWeaponWithAttachmentsCargoGlobal _x;\n    };\n};\n\n\n// backpacks\nprivate _backpacks = _cargo select 3;\nprivate _backpackTypes = _backpacks select 0;\nprivate _backpackTypeCounts = _backpacks select 1;\nif (_backpacks isNotEqualTo [[],[]]) then {\n    {\n        _containerToLoad addBackpackCargoGlobal [_x,_backpackTypeCounts select _forEachIndex];\n    } forEach _backpackTypes;\n};\n\n\n// containers within the conatainer (vests, backpacks, etc.)\nprivate _containers = _cargo select 4;\nif (_containers isNotEqualTo []) then {\n\n    private _containersIn_containerToLoad = everyContainer _containerToLoad;\n    _containers apply {\n        private _containerInfo = _x;\n        private _containerClass = _containerInfo select 0;\n\n        // find a contianer with the class\n        private _index = _containersIn_containerToLoad findIf {(_x select 0) == _containerClass};\n        private _containerWithinContainer = (_containersIn_containerToLoad deleteAt _index) select 1;\n\n        [_containerWithinContainer,_containerInfo select 1] call KISKA_fnc_setContainerCargo;\n    };\n};\n\n\ntrue\n",
    "fileName": "fn_setContainerCargo.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getRelativeVectorAndPos\n\nDescription:\n    Sets the position and vector dir and up of one object to another based on\n     relative coordinates to the parent object.\n\nParameters:\n    0: _parent <OBJECT> - The object to make the coordinates relative to.\n    1: _child <OBJECT> - The object to find coordinates for.\n    2: _relativeInfo <ARRAY> - An array containing the relative coordinates to\n        change to worldspace:\n        \n            - 0. <PoitionWorld[]> - Relative world pos\n            - 1. <Vector[]> - Relative vector dir\n            - 2. <Vector[]> - Relative vector up\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            parentObject,\n            childObject,\n            [[0,0,0],[0,1,0],[0,0,1]]\n        ] call KISKA_fnc_setRelativeVectorAndPos;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setRelativeVectorAndPos\";\n\nparams [\n    [\"_parent\",objNull,[objNull]],\n    [\"_child\",objNull,[objNull]],\n    [\"_relativeInfo\",[],[[]],3]\n];\n\nif (isNull _parent) exitWith {\n    [\"Null parent object passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (isNull _child) exitWith {\n    [\"Null child object passed\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _relativePosWorld = _relativeInfo select 0;\nprivate _relativeVectorDir = _relativeInfo select 1;\nprivate _relativeVectorUp = _relativeInfo select 2;\n\n_child setPosWorld (_parent modelToWorldWorld _relativePosWorld);\n_child setVectorDir (_parent vectorModelToWorld _relativeVectorDir);\n_child setVectorUp (_parent vectorModelToWorld _relativeVectorUp);\n",
    "fileName": "fn_setRelativeVectorAndPos.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_setWaypointExecStatement\n\nDescription:\n    Sets the (execution) statement of a given waypoint using an interface that allows\n     arg passing.\n\n    This statement will only be executed on the machine where added.\n\n    Be aware that this will create variables on the provided waypoint's group. If a waypoint\n     is deleted, the variable on the group will still remain.\n\nParameters:\n    0: _waypoint <WAYPOINT> - Default: `[]` - The waypoint you would like to the execution\n        statement of.\n    1: _statement <CODE, STRING, or ARRAY> - Default: `{}` - Code that executes once the given waypoint\n        is complete (see `KISKA_fnc_callBack` for examples).\n\n        Parameters:\n        - 0: <GROUP> - The group the waypoint belongs to\n        - 1: <OBJECT> - The group leader for the group the waypoint belongs to\n        - 2: <OBJECT[]> - The units of the group that own the waypoint\n\n    3: _existingId <STRING> - Default: `\"\"` - If updating an existing waypoint statement, provide the\n        id that was previously returned.\n\nReturns:\n    <STRING> - The id of the waypoint statment that can be used to update an existing statement\n\nExamples:\n    (begin example)\n        private _waypoint = myGroup addWaypoint [position player, 0];\n        private _id = [\n            _waypoint,\n            { hint str _this; }\n        ] call KISKA_fnc_setWaypointExecStatement\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setWaypointExecStatement\";\n\nparams [\n    [\"_waypoint\",[],[[]]],\n    [\"_statement\",{},[{},[],\"\"]],\n    [\"_existingId\",\"\",[\"\"]]\n];\n\nprivate _group = _waypoint param [0,grpNull];\nif (isNull _group) exitWith {\n    [\"Provided waypoint had null or missing group\",true] call KISKA_fnc_log;\n    nil\n};\n\nprivate _id = _existingId;\nif (_id isEqualTo \"\") then {\n    _id = [\"KISKA_waypointStatement\"] call KISKA_fnc_generateUniqueId;\n};\n\n_group setVariable [_id,_statement];\n\nprivate _idStringified = [_id] call KISKA_fnc_str;\nprivate _waypointStatementString = format [\n    \"\n        private _group = group this; \n        private _callBack = _group getVariable [%1,{}];\n        if (_callBack isNotEqualTo {}) then {\n            [[_group,this,thisList],_callBack] call KISKA_fnc_callBack;\n            _group setVariable [%1,nil];\n        };\n    \",\n    _idStringified\n];\n_waypoint setWaypointStatements [\"true\",_waypointStatementString];\n\n\n_id\n",
    "fileName": "fn_setWaypointExecStatement.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_setupMultiKillEvent\n\nDescription:\n    Sets up an event that will fire when a percentage of objects are killed.\n    Uses `\"KILLED\"` or `\"MPKILLED\"` eventhandlers.\n\n    This should be called where the arguements are local if `_useMPKilled` is `false`\n    or on the server if `_useMPKilled` is `true`.\n\nParameters:\n    0: _objects <ARRAY> - An array of objects to add some form of killed event handlers to\n    1: _onThresholdMet <CODE, ARRAY, or STRING> - Code that executes once it has been determined\n        that the threshold has been met or exceeded. (See KISKA_fnc_callBack). If attempting\n        to add more units to an existing event, use the event id here (see returned hashmap below for id)\n        and preceed the event id with a \"#\" (see examples)\n            \n        Params:\n        - 0. <ARRAY> - the killed evenhandler params\n        - 1. <HASHMAP> - the hashmap described below in \"Returns\"\n\n    // NOT USED if adding to existing event\n    2: _threshold <NUMBER> - A number between 0 and 1 that denotes the percentage of objects that\n        must've been killed to trigger the _onThresholdMet.\n        (e.g. 1 means 100% of them need to be killed, 0.5 means 50%, etc.)\n    3: _onKilled <CODE, ARRAY, or STRING> - Code that executes each time a unit has been\n        killed (after the _onThresholdMet if threshold has been met). (See KISKA_fnc_callBack)\n                \n        Params:\n        - 0. <ARRAY> - the killed evenhandler params\n        - 1. <HASHMAP> - the hashmap described below in \"Returns\"\n\n    4: _useMPKilled <BOOL> - Whether or not to use \"MPKILLED\" events instead of \"KILLED\".\n        IF TRUE, MUST BE RUN ON THE SERVER\n\nReturns:\n    <HASHMAP> - A hashmap containing info about the event:\n\n    - `id`: <STRING> - A localNamespace variable name to access this hashmap\n    - `total`: <NUMBER> - The total number of objects that have this killed event\n    - `killed`: <NUMBER> - The total number of objects that have been killed with this event\n    - `threshold`: <NUMBER> - A number that indicates the percentage of objects that\n        must be killed (relative to the total) for this event to fire\n        (e.g. 1 means 100% of them need to be killed, 0.5 means 50%, etc.)\n    - `thresholdMet`: <BOOL> - Whether or not the threshold has been met and therefore\n        onThresholdMet has fired\n    - `onKilled`: <CODE, ARRAY, or STRING> - Code that executes each time a unit has been\n        killed (after the _onThresholdMet if threshold has been met). (See KISKA_fnc_callBack)\n\n        Params:\n        - 0. <ARRAY> - the killed evenhandler params\n        - 1. <HASHMAP> - the hashmap described\n\n    - `onThresholdMet`: <CODE, ARRAY, or STRING> - Code that executes once it has been determined\n        that the threshold has been met or exceeded. (See KISKA_fnc_callBack)\n        \n        Params:\n        - 0. <ARRAY> - the killed evenhandler params\n        - 1. <HASHMAP> - the hashmap described\n\n    - `eventCode`: <CODE> - The code that is attached to the killed eventhandler\n    - `type`: <STRING> - Type of event, (`KILLED` or `MPKILLED`)\n    - `objectToEventIdMap`: <HASHMAP> -  A hashmap that uses objects as keys (should use KISKA_fnc_hashmap_get)\n        to get the killed eventhandler id attached to an object.\n\nExamples:\n    (begin example)\n        private _eventMap = [\n            [someObject, anotherObject],\n            {\n                params [\"_killedEventParams\",\"_eventMap\"];\n                _killedEventParams params [\"_killedObject\"];\n                hint str [_killedEventParams, _eventMap];\n            }\n        ] call KISKA_fnc_setupMultiKillEvent;\n    (end)\n\n    (begin example)\n        // add more objects to the existing event made above\n        private _eventMap = [\n            [andAdditionalObject],\n            (\"#\" + (_eventMap get \"id\"))\n        ] call KISKA_fnc_setupMultiKillEvent;\n    (end)\n    \nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_setupMultiKillEvent\";\n\nparams [\n    [\"_objects\",[],[[]]],\n    [\"_onThresholdMet\",{},[[],{},\"\"]],\n    [\"_threshold\",1,[123]],\n    [\"_onKilled\",{},[{},[],\"\"]],\n    [\"_useMPKilled\",false,[true]]\n];\n\n/* ----------------------------------------------------------------------------\n    Verify Params\n---------------------------------------------------------------------------- */\nif (_useMPKilled AND (!isServer)) exitWith {\n    [\"If using MPKILLED eventhandlers, this must be executed on the server!\",true] call KISKA_fnc_log;\n    []\n};\n\nif (_objects isEqualTo []) exitWith {\n    [\"Empty _objects passed!\",true] call KISKA_fnc_log;\n    []\n};\n\nif (_threshold > 1) then {\n    [[\"Provided invalid threshold (must be between 0 and 1): \",_threshold,\" and clamped to 1\"],false] call KISKA_fnc_log;\n    _threshold = 1;\n};\nif (_threshold < 0) then {\n    [[\"Provided invalid threshold (must be between 0 and 1): \",_threshold,\" and clamped to 0\"],false] call KISKA_fnc_log;\n    _threshold = 0;\n};\n\nprivate _existingEventId = \"\";\nif (_onThresholdMet isEqualType \"\") then {\n    private _startsWithHashTag = (_onThresholdMet select [0,1]) isEqualTo \"#\";\n    if (_startsWithHashTag) then {\n        _existingEventId = _onThresholdMet trim [\"#\",1];\n    };\n};\n\n\nprivate _aliveObjects = [];\n_objects apply {\n    if (_x isEqualType objNull AND {alive _x}) then {\n        _aliveObjects pushBackUnique _x;\n    };\n};\n\nif (_aliveObjects isEqualTo []) exitWith {\n    [\"There are no alive objects to setup kill event for...\",false] call KISKA_fnc_log;\n    []\n};\n\n\n/* ----------------------------------------------------------------------------\n    Handle existing event\n---------------------------------------------------------------------------- */\nif (_existingEventId isNotEqualTo \"\") exitWith {\n    private _eventMap = localNamespace getVariable [_existingEventId,[]];\n    if (_eventMap isEqualTo []) exitWith {\n        [[\"Could not locate event map for \", _existingEventId],true] call KISKA_fnc_log;\n        []\n    };\n    _useMPKilled = (_eventMap getOrDefault [\"type\",\"KILLED\"]) == \"MPKILLED\";\n    if (_useMPKilled AND (!isServer)) exitWith {\n        [\"If using MPKILLED eventhandlers, this must be executed on the server!\",true] call KISKA_fnc_log;\n        []\n    };\n\n    private _eventHandlerCode = _eventMap getOrDefault [\"eventHandlerCode\",{}];\n    _aliveObjects apply {\n        private _eventId = -1;\n        if (_useMPKilled) then {\n            _eventId = _x addMPEventHandler [\"MPKILLED\", _eventHandlerCode];\n\n        } else {\n            _eventId = _x addEventHandler [\"KILLED\", _eventHandlerCode];\n\n        };\n\n        [\n            _objectToEventIdMap,\n            _x,\n            _eventId\n        ] call KISKA_fnc_hashmap_set;\n    };\n\n    private _total = _eventMap getOrDefault [\"total\",0];\n    _eventMap set [\"total\", _total + (count _aliveObjects)];\n\n\n    _eventMap\n};\n\n\n/* ----------------------------------------------------------------------------\n    Setup Event Map\n---------------------------------------------------------------------------- */\nprivate _eventId = localNamespace getVariable [\"KISKA_killedManyEvent_idCount\",0];\nprivate _eventIdStr = str _eventId;\nlocalNamespace setVariable [\"KISKA_killedManyEvent_idCount\",_eventId + 1];\n\nprivate _eventMap = createHashMap;\nprivate _eventMapVar = \"KISKA_killedManyEvent_map_\" + _eventIdStr;\nlocalNamespace setVariable [_eventMapVar, _eventMap];\n_eventMap set [\"id\", _eventMapVar];\n_eventMap set [\"total\", count _aliveObjects];\n_eventMap set [\"killed\", 0];\n_eventMap set [\"threshold\", _threshold];\n_eventMap set [\"thresholdMet\", false];\n_eventMap set [\"onKilled\", _onKilled];\n_eventMap set [\"onThresholdMet\", _onthresholdMet];\n\n\n\n/* ----------------------------------------------------------------------------\n    Add eventhandlers\n---------------------------------------------------------------------------- */\nprivate _eventHandlerCode = [\n    // giving it and extra set of quotes with KISKA_fnc_str so that it is a string when compiled\n    \"private _eventMap = localNamespace getVariable [\", [_eventMapVar] call KISKA_fnc_str, \", []]; \",\n    \"private _eventCode = _eventMap getOrDefault ['eventCode',{}]; \",\n    \"[_this, [[_eventMap],_eventCode]] call KISKA_fnc_callBack;\"\n] joinString \"\";\n_eventMap set [\"eventHandlerCode\", _eventHandlerCode];\n\nprivate _type = \"\";\nif (_useMPKilled) then {\n    _type = \"MPKILLED\";\n    _eventHandlerCode = \"if (isServer) then { \" + _eventHandlerCode + \" };\";\n\n} else {\n    _type = \"KILLED\";\n\n};\n\nprivate _objectToEventIdMap = createHashMap;\n_aliveObjects apply {\n    private _eventId = -1;\n    if (_useMPKilled) then {\n        _eventId = _x addMPEventHandler [\"MPKILLED\", _eventHandlerCode];\n    } else {\n        _eventId = _x addEventHandler [\"KILLED\", _eventHandlerCode];\n    };\n\n    [\n        _objectToEventIdMap,\n        _x,\n        _eventId\n    ] call KISKA_fnc_hashmap_set;\n};\n\n\nprivate _eventCode = {\n    _thisArgs params [\"_eventMap\"];\n\n    if !(_eventMap getOrDefault [\"thresholdMet\",false]) then {\n        private _total = _eventMap getOrDefault [\"total\",0];\n        private _killedCount = _eventMap getOrDefault [\"killed\",0];\n        _killedCount = _killedCount + 1;\n        _eventMap set [\"killed\", _killedCount];\n\n        private _threshold = _eventMap getOrDefault [\"threshold\",1];\n        private _metThreshold = (_killedCount / _total) >= _threshold;\n\n        if (_metThreshold) then {\n            _eventMap set [\"thresholdMet\", true];\n            private _onThresholdMet = _eventMap getOrDefault [\"onThresholdMet\",{}];\n            [[_this, _eventMap], _onThresholdMet] call KISKA_fnc_callBack;\n        };\n    };\n\n    private _onKilled = _eventMap getOrDefault [\"onKilled\",{}];\n    // _this is normal eventhandler parameters from \"killed\" event\n    [[_this, _eventMap], _onKilled] call KISKA_fnc_callBack;\n};\n\n_eventMap set [\"eventCode\", _eventCode];\n_eventMap set [\"type\", _type];\n_eventMap set [\"objectToEventIdMap\",_objectToEventIdMap];\n\n\n\n_eventMap\n",
    "fileName": "fn_setupMultiKillEvent.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_showHide\n\nDescription:\n    On selected objects, will disable simulation and hide the object or the reverse.\n\nParameters:\n    0: _objects <ARRAY, GROUP, STRING, or OBJECT> - Units to show or hide, if string, it is a mission layer\n    1: _show <BOOL> - True to show and simulate, false to hide and disable simulation\n    2: _enableDynamicSim <BOOL> - Should the object be dynamically simulated after shown\n\nReturns:\n    <BOOL> - True if action performed, false otherwise\n\nExamples:\n    (begin example)\n        [group1, true, true] call KISKA_fnc_showHide;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_showHide\";\n\nif !(isServer) exitWith {\n    [\"Must be executed on Server\",true] call KISKA_fnc_log;\n    false\n};\n\nparams [\n    [\"_objects\",[],[[],grpNull,objNull,\"\"]],\n    [\"_show\",true,[true]],\n    [\"_enableDynamicSim\",false,[true]]\n];\n\nif (_objects isEqualTo []) exitWith {\n    [\"No objects to show or hide\"] call KISKA_fnc_log;\n    false\n};\n\nif (_objects isEqualType objNull) then {\n    _objects = [_objects];\n};\n\nif (_objects isEqualType grpNull) then {\n    _objects = units _objects;\n};\n\nif (_objcects isEqualType \"\") then {\n    _objects = getMissionLayerEntities _objects;\n};\n\n_objects apply {\n    if (!(isNull _x) OR {!(alive _x)}) then {\n        [_x,_show] remoteExecCall [\"allowDamage\",_x];\n        _x hideObjectGlobal !(_show);\n        _x enableSimulationGlobal _show;\n        \n        if (_x isKindOf \"Man\" AND {!((dynamicSimulationEnabled (group _x)) isEqualTo _enableDynamicSim)}) then {\n            (group _x) enableDynamicSimulation _enableDynamicSim;\n        };\n        \n        if (dynamicSimulationEnabled _x AND {!(_enableDynamicSim)}) then {\n            _x enableDynamicSimulation false;\n        } else {\n            _x enableDynamicSimulation _enableDynamicSim;\n        };\n        if (isDedicated AND {canSuspend}) then {\n            sleep 0.1;\n        };\n    };\n};\n\n\ntrue",
    "fileName": "fn_showHide.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_sortStringsNumerically\n\nDescription:\n    Takes an array or strings, where each string must end with an underscore and a digit\n     (`\"something_1\"`) and can handle one extra sub level digit (`\"something_1_1\"`).\n\nParameters:\n    0: _strings <STRING[]> - Default: `[]` - The strings you would like to sort\n    1: _order <BOOLEAN> - Default: `true` - ascending (`true`) or descending (`false`) \n\nReturns:\n    <STRING[]> - The sorted list of strings\n\nExamples:\n    (begin example)\n        [\n            [\"myString_2\",\"myString_3\",\"myString_1_1\",\"myString_1\"]\n        ] call KISKA_fnc_sortStringsNumerically;\n        // returns -> `[\"myString_1\",\"myString_1_1\",\"myString_2\",\"myString_3\"]`\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_sortStringsNumerically\";\n\nparams [\n    [\"_strings\",[],[[]]],\n    [\"_order\",true,[true]]\n];\n\nprivate _sortKeyMap = createHashMap;\n{\n    private _regexMatches = (_x regexFind [\"_(\\d+)_*(\\d*)\"]) param [0,[]];\n    _regexMatches params [\"\",\"_mainNumberMatch\",\"_subNumberMatch\"];\n    private _mainIndex = _mainNumberMatch select 0;\n    private _sortString = _mainIndex;\n\n    private _subIndex = _subNumberMatch select 0;\n    if (_subIndex isNotEqualTo \"\") then {\n        _sortString = [_sortString,_subIndex] joinString \".\";\n    };\n\n    _sortKeyMap set [_sortString,_x];\n} forEach _strings;\n\nprivate _sortedKeys = keys _sortKeyMap;\n_sortedKeys sort _order;\n\n\n_sortedKeys apply { _sortKeyMap get _x }\n",
    "fileName": "fn_sortStringsNumerically.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_staticLine\n\nDescription:\n    Ejects units from vehicle and deploys chutes, will select CUP T10 chute if available.\n\n    CAUTION:\n        All units from a group THAT ARE IN THE SAME AIRCRAFT should be dropped\n        with the same function call. Not doing so can see odd behaviour from the aircraft.\n\n        This is tied to KISKA_fnc_staticLine_eject and the use of the leaveVehicle\n        command. If there are units from the same group still in the aircraft when it is\n        executed, the aircraft will ignore all commands and attempt to pickup those units\n        that were dropped.\n\nParameters:\n    0: _aircraft <OBJECT> - The aircraft to drop units from\n    1: _dropArray <ARRAY, GROUP, OBJECT> - Units to drop. If array, can be groups and/or objects (example 2)\n    2: _invincibleOnDrop <BOOL> - Should the units be invincible while dropping?\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [plane,group] spawn KISKA_fnc_staticLine;\n    (end)\n\n    (begin example)\n        [plane,[group1,unit2]] spawn KISKA_fnc_staticLine;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_staticLine\";\n\nif !(canSuspend) exitWith {\n    [\"Should be run in scheduled. Exiting to scheduled...\",true] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_staticLine;\n};\n\nparams [\n    [\"_aircraft\",objNull,[objNull]],\n    [\"_dropArray\",[],[[],grpNull,objNull]],\n    [\"_invincibleOnDrop\",true,[true]]\n];\n\nif (isNull _aircraft OR !(alive _aircraft)) exitWith {\n    [\"_aircraft is null or not alive. Exiting...\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_dropArray isEqualTo []) exitWith {\n    [\"_dropArray is empty\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_dropArray isEqualTypeAny [objNull,grpNull] AND {isNull _dropArray}) exitWith {\n    [\"_dropArray isNull\",true] call KISKA_fnc_log;\n    nil\n};\n\nif (_dropArray isEqualType grpNull) then {\n    _dropArray = units _dropArray;\n};\n\nif (_dropArray isEqualType objNull) then {\n    _dropArray = [_dropArray];\n};\n\nprivate _dropArrayFiltered = [];\n_dropArray apply {\n    if (_x isEqualType grpNull) then {\n        (units _x) apply {\n            if (_x in _aircraft) then  {\n                _dropArrayFiltered pushBack _x;\n            };\n        };\n    };\n\n    if (!(_x isEqualType objNull) OR !(_x in _aircraft)) then { continue };\n\n    _dropArrayFiltered pushBack _x;\n};\n\n\nprivate _chuteType = [\"B_Parachute\",\"CUP_T10_Parachute_backpack\"] select (isClass (configfile >> \"CfgVehicles\" >> \"CUP_T10_Parachute_backpack\"));\n// execute eject\n{\n    [_aircraft,_x,_chuteType,_forEachIndex,_invincibleOnDrop] remoteExec [\"KISKA_fnc_staticLine_eject\",_x];\n} forEach _dropArrayFiltered;\n\nnil\n",
    "fileName": "fn_staticLine.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_staticLine\n\nDescription:\n    Ejects the unit from their airecraft and\n    Used to reduce network messages.\n\nParameters:\n    0: _aircraft <OBJECT> - The aircraft dropping off the unit\n    1: _unit <OBJECT> - The unit to parachute\n    2: _chuteType <STRING> - Class name of the chute\n    3: _index <NUMBER> - index in drop order\n    4: _invincibleOnDrop <BOOL> - Whether or not the unit is invincible on drop\n\nReturns:\n    NOTHING\n\nExamples:\n    Executed from KISKA_fnc_staticLine\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_staticLine_eject\";\n\nparams [\"_aircraft\",\"_unit\",\"_chuteType\",\"_index\",\"_invincibleOnDrop\"];\n\nprivate _loadout = getUnitLoadout _unit;\n\nif !(isNull (unitbackpack _unit)) then {\n    removeBackpackGlobal _unit;\n};\n// decided not to use addBackpackGlobal because of waiting for locality\nwaitUntil {\n    _unit addBackpack _chuteType;\n    if (!isNull (backpackContainer _unit) OR {!alive _unit}) exitWith {true};\n    sleep 0.25;\n    false\n};\n\nif (!(alive _aircraft) OR !(alive _unit)) exitWith {};\n\nsleep (_index / 5); // delay for getting a spread of units\n\n_unit moveOut _aircraft;\n\n// keep units from trying to enter vehicle after being moved out\n// leaveVehicle causes the aircraft to shift while in-flight\n[_unit] orderGetIn false;\n\n// determine the side of the aircraft to eject the person on\nprivate _sideOfAircraft = [10,-10] select ((_index mod 2) isEqualTo 0);\n\n\n// might need to waitUntil backpackContainer is not Null to be sure\n// delay chute open to create some distance with plane\n[_unit,_aircraft,_sideOfAircraft] spawn {\n    params [\"_unit\",\"_aircraft\",\"_sideOfAircraft\"];\n\n    // place unit to the side of the aircraft\n    _unit setPosATL ((getPosATLVisual _unit) vectorAdd (_aircraft vectorModelToWorldVisual [_sideOfAircraft,0,0]));\n    // if a unit is moving too fast when they open the chute, it will sometimes cause it to not attach\n    _unit setVelocity [0,0,0];\n    sleep 1;\n    _unit action [\"OpenParachute\", _unit];\n};\n\nsleep 3;\n\nif (_invincibleOnDrop) then {\n    _unit allowDamage false;\n};\n\nwaitUntil {\n    if (((getPosATL _unit) select 2) < 0.1 OR {isTouchingGround _unit}) exitWith {true};\n    sleep 2;\n    false;\n};\n\nif (alive _unit) then {\n    if (_invincibleOnDrop) then {\n        _unit allowDamage true;\n    };\n\n    _unit setUnitLoadout _loadout;\n\n    private _group = group _unit;\n    private _unitLeader = leader _group;\n    if !(_unitLeader in _aircraft) then {\n        /*\n            orderGetIn combined with unassignVehicle does NOT keep units\n            from trying to re-embark.\n\n            The only two commands that are capable of this are leaveVehicle\n            and allowGetIn. allowGetIn is the more invasive option, so I chose\n            leaveVehicle as it would not leave a lasting affect.\n        */\n        [_group,_aircraft] remoteExec [\"leaveVehicle\",_unitLeader];\n    };\n};\n\nnil\n",
    "fileName": "fn_staticLine_eject.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_str\n\nDescription:\n    Given that str command produces triple quoted strings if used on a string\n     (which can be incompatible with other commands) this function simply formats\n     them as \"'string'\" instead, and all other types as normal with str.\n\nParameters:\n    0: _value <ANY> - The value to convert to a string\n\nReturns:\n    <STRING> - The value as a string\n\nExamples:\n    (begin example)\n        _asString = [_someValue] call KISKA_fnc_str;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_str\";\n\nparams [\"_value\"];\n\nif (_value isEqualType \"\") exitWith {\n    format [\"'%1'\",_value]\n};\n\n\nstr _value\n",
    "fileName": "fn_str.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_vehicleFactory\n\nDescription:\n    Add an action to given object that allows the spawn of a vehicle\n\nParameters:\n    0: _controlPanel <OBJECT> - The object to add the action to\n    1: _spawnPosition <OBJECT or ARRAY> - Where to spawn the vehicle (ASL)\n    2: _vehicleTypes <ARRAY or STRING> - The class names of vehicles to create an action for (each will get its own action if in an array)\n    3: _clearRadius <NUMBER> - How far until pad is considered clear of entities\n    4: _onCreateCode <CODE> - Code to run upon vehicle creation. Passed arg is the created vehicle\n\nReturns:\n    <BOOL> - false if not added, true otherwise\n\nExamples:\n    (begin example)\n        [player,(getPosATL player) vectorAdd [2,2,0],\"B_MRAP_01_F\"] spawn KISKA_fnc_vehicleFactory;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_vehicleFactory\";\n\nif (!canSuspend) exitWith {\n    [\"Must be run in scheduled envrionment, exiting to scheduled\"] call KISKA_fnc_log;\n    _this spawn KISKA_fnc_vehicleFactory;\n};\n\nparams [\n    [\"_controlPanel\",objNull,[objNull]],\n    [\"_spawnPosition\",objNull,[[],objNull]],\n    [\"_vehicleTypes\",[],[[],\"\"]],\n    [\"_clearRadius\",10,[123]],\n    [\"_onCreateCode\",{},[{}]]\n];\n\nif (isNull _controlPanel) exitWith {\n    [\"_controlPanel isNull\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_vehicleTypes isEqualTo [] OR {_vehicleTypes isEqualTo \"\"}) exitWith {\n    [\"_vehicleTypes is empty\",true] call KISKA_fnc_log;\n    false\n};\n\nif (_vehicleTypes isEqualType \"\") then {\n    _vehicleTypes = [_vehicleTypes];\n};\n\nif (_spawnPosition isEqualType objNull) then {\n    _spawnPosition = getPosASL _spawnPosition;\n};\n\n\nprivate [\"_type\",\"_config\",\"_displayName\"];\n_vehicleTypes apply {\n\n    _type = _x;\n    _config = configFile >> \"cfgVehicles\" >> _type;\n\n    if (isClass _config) then {\n\n        // get displayName\n        _displayName = getText (_config >> \"displayname\");\n        if (_displayName isEqualTo \"\") then {\n\n            _displayName = getText (missionConfigFile >> \"cfgVehicles\" >> _type >> \"displayname\");\n            if (_displayName isEqualTo \"\") then {\n                _displayName = \"Unknown Vehicle\";\n            };\n        };\n\n        [\n            _controlPanel,\n            (\"Spawn \" + _displayName),\n            \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n            \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n            \"true\",\n            \"true\",\n            {},\n            {},\n            {\n                (_this select 3) params [\n                    \"_type\",\n                    \"_spawnPosition\",\n                    \"_clearRadius\",\n                    \"_onCreateCode\"\n                ];\n\n                if !(((ASLToAGL _spawnPosition) nearEntities [['landVehicle','air','ship'],_clearRadius]) isEqualTo []) exitWith {\n                    [\"Pad Must Be Clear Of Vehicles\"] call KISKA_fnc_notification;\n                    false\n                };\n\n                private _vehicle = createVehicle [_type,ASLToATL _spawnPosition,[],0,\"CAN_COLLIDE\"];\n\n                if !(_onCreateCode isEqualTo {}) then {\n                    [_vehicle] call _onCreateCode;\n                };\n\n                [\"Vehicle Created\"] call KISKA_fnc_notification;\n            },\n            {},\n            [_type,_spawnPosition,_clearRadius,_onCreateCode],\n            0.5,\n            10,\n            false,\n            false,\n            false\n        ] call BIS_fnc_holdActionAdd;\n    };\n\n    // hold action conditions seem to fail if added too quickly\n    sleep 0.1;\n};\n\n\nif !(_controlPanel getVariable [\"KISKA_vehicleFactory\",false]) then {\n\n    [\n        _controlPanel,\n        \"<t color='#ba1000'>Clear Spawn</t>\",\n        \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n        \"\\a3\\ui_f\\data\\IGUI\\Cfg\\holdactions\\holdAction_loaddevice_ca.paa\",\n        \"true\",\n        \"true\",\n        {},\n        {},\n        {\n            (_this select 3) params [\"_spawnPosition\",\"_clearRadius\"];\n            private _entities = (ASLToAGL _spawnPosition) nearEntities [['landVehicle','air','ship'],_clearRadius];\n\n            _entities apply {\n                [_x] remoteExecCall [\"deleteVehicle\",2];\n            };\n\n            [\"Pad Cleared\"] call KISKA_fnc_notification;\n        },\n        {},\n        [_spawnPosition,_clearRadius],\n        0.5,\n        20,\n        false,\n        false,\n        false\n    ] call BIS_fnc_holdActionAdd;\n\n    _controlPanel setVariable [\"KISKA_vehicleFactory\",true];\n};\n\n\ntrue\n",
    "fileName": "fn_vehicleFactory.sqf"
  },
  {
    "text": "/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_waitUntil\n\nDescription:\n    Waitunil that allows variable evaluation time instead of frame by frame.\n\nParameters:\n    0: _condition <CODE, STRING, or ARRAY> - Code that must evaluate as a `BOOL`.\n        If `(_interval <= 0) AND (_unscheduled isEqualTo true)`, this will only accept CODE\n        or `STRING` as an arguement for performance reasons and `_parameters` will be available in `_this`.\n        (See KISKA_fnc_callBack)\n    1: _function <CODE, STRING, or ARRAY> - The code to execute upon condition being reached.\n        (See KISKA_fnc_callBack)\n    2: _interval <NUMBER> - How often to check the condition\n    3: _parameters <ARRAY> - An array of local parameters that can be accessed with _this\n    4: _unscheduled <BOOL> - Run in unscheduled environment\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [\n            {\n                true\n            },\n            {\n                hint \"wait\";\n            },\n            0.5,\n            [],\n            true\n        ] call KISKA_fnc_waitUntil;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName \"KISKA_fnc_waitUntil\";\n\nparams [\n    [\"_condition\",{},[{},\"\",[]]],\n    [\"_function\",{},[{},\"\",[]]],\n    [\"_interval\",0.5,[123]],\n    [\"_parameters\",[],[[]]],\n    [\"_unscheduled\",true,[true]]\n];\n\n\nprivate _isPerFrame = _interval <= 0;\nif (\n    _unscheduled AND\n    _isPerFrame AND\n    (_condition isEqualType [])\n) exitWith {\n    [\n        \"Unscheduled, perframe waituntil will only support CODE or STRING as an arguement\",\n        true\n    ] call KISKA_fnc_log;\n    nil\n};\n\n\nif (_condition isEqualType \"\") then {\n    _condition = compileFinal _condition;\n};\nif (_function isEqualType \"\") then {\n    _function = compileFinal _function;\n};\n\n\n/* -----------------------------------\n    Perframe unscheduled\n----------------------------------- */\nif (_unscheduled AND _isPerframe) exitWith {\n    [\n        {\n            params [\"_parameters\",\"\",\"_condition\"];\n            _parameters call _condition\n        },\n        {\n            params [\"_parameters\",\"_function\",\"\"];\n            [_parameters,_function] call KISKA_fnc_callBack;\n        },\n        [_parameters,_function,_condition]\n    ] call CBA_fnc_waitUntilAndExecute;\n};\n\n\n/* -----------------------------------\n    Unscheduled with interval\n----------------------------------- */\nif (_unscheduled) exitWith {\n    [\n        {\n            (_this select 0) params [\n                \"_condition\",\n                \"_function\",\n                \"_interval\",\n                \"_parameters\"\n            ];\n\n            private _conditionMet = [_parameters,_condition] call KISKA_fnc_callBack;\n            if (_conditionMet) exitWith {\n                [_parameters,_function] call KISKA_fnc_callBack;\n\n                private _id = _this select 1;\n                [_id] call CBA_fnc_removePerFrameHandler;\n            };\n        },\n        _interval,\n        _this\n    ] call CBA_fnc_addPerFrameHandler;\n\n    nil\n};\n\n\n/* -----------------------------------\n    Scheduled\n----------------------------------- */\n[_interval,_function,_condition,_parameters] spawn {\n    params [\"_interval\",\"_function\",\"_condition\",\"_parameters\"];\n\n    waitUntil {\n        sleep _interval;\n        private _conditionMet = [_parameters,_condition] call KISKA_fnc_callBack;\n        if (_conditionMet) exitWith {\n            [_parameters,_function] call KISKA_fnc_callBack;\n            true\n        };\n\n        false\n    };\n\n};\n\n\nnil\n",
    "fileName": "fn_waitUntil.sqf"
  }
]