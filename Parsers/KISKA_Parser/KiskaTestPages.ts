import { SQFItemConfig } from "../../configuration/grammars/sqf.namespace";
import { UnparsedKiskaPage } from "./KiskaParser";

export const KiskaTestPages: { parsed: SQFItemConfig; unparsed: UnparsedKiskaPage }[] = [
    {
        parsed: {
            documentation: {
                documentationLink:
                    "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Timeline/fn_timeline_start.sqf",
                syntaxes: [
                    {
                        outline: "[_timeline, _onTimelineStopped] call `KISKA_fnc_timeline_start`",
                        parameters: [
                            {
                                name: "_timeline",
                                description:
                                    "*(ARRAY)* - An array of timeline events that will happen. See description above for formats",
                            },
                            {
                                name: "_onTimelineStopped",
                                description:
                                    "*(CODE, STRING, or ARRAY)* - (see KISKA_fnc_callBack), code that will be executed once a timeline is stopped.\n\n    Parameters:\n    - 0: *(ARRAY)* - The timeline array in the state when the stoppage actually happens.\n    - 1: *(HASHMAP)* - The Individual map defined for a specific timeline of the given ID",
                            },
                        ],
                        returns: "*(STRING)* - The id of the new timeline",
                    },
                ],
                examples: [
                    {
                        text: '```sqf\nprivate _timeline = [\n    [\n        {\n            hint "executed event #1";\n            time + 3 // return/send to next and current wait condition\n        },\n        {\n            params ["","","_eventReturn"];\n            private _timeAfterWait = _eventReturn;\n            time >= _timeAfterWait // wait until current time is more than time + 3\n        },\n    ],\n    [\n        {hint "executed event #2 ~3 seconds after event 1 completed"}, 2\n    ]\n];\nprivate _timelineId = [_timeline,{hint "timeline end"}] call KISKA_fnc_timeline_start;\n```',
                    },
                ],
                description:
                    'Creates a timeline of events that can happen. Waits/executes in an unscheduled environment.\n\nThere is a non-trivial amount of overhead to this, however, so do not use with the intention of needing precise events to happen but rather to not clog the scheduler or use a decent interface with smaller units of code.\n\n\n```sqf\n// A timeline is made up of events:\n[\n    [], // event 1\n    [] // event 2\n]\n```\n\n\n\n```sqf\n// Each event is made up of code to execute when the event comes up in the timeline,\n/// and what to wait for when executing the NEXT event in the timeline AFTER the\n/// current event completes:\n[\n    [\n        {\n            hint "executed event #1"\n        },\n        3 // wait 3 seconds AFTER current event to execute event 2\n    ],\n    [\n        {\n            hint "executed event #2 3 seconds after event 1 completed"\n        },\n        1 // wait 1 second to run _onTimelineStopped code\n    ]\n]\n```\n\n\n\n```sqf\n// Alternativeley, you can also wait for a condition before proceeeding to the next event:\nprivate _endTime = time + 10;\n[\n    [\n        {hint "executed event #1"},\n        3 // wait 3 seconds AFTER current event to execute event 1\n    ],\n    [\n        {hint "executed event #2 3 seconds after event 1 completed"},\n        [[_endTime],{\n            _thisArgs params ["_endTime"];\n            time >= (_endTime) // wait until current time is more than _endTime\n        }],\n        1 // check condition every second\n    ]\n]\n```\n\n\n\n```sqf\n// You can chain timeline events together by returning\n[\n    [\n        {\n            hint "executed event #1";\n            time + 3 // return/send to the next event and current wait condition\n        },\n        {\n            params ["","","","_eventReturn"];\n            private _timeAfterWait = _eventReturn;\n            time >= _timeAfterWait // wait until current time is more than time + 3\n        },\n    ],\n    [\n        {hint "executed event #2 ~3 seconds after event 1 completed"}\n    ]\n]\n```',
            },
            configuration: {
                label: "KISKA_fnc_timeline_start",
                grammarType: "function",
            },
        },
        unparsed: {
            text: '/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_start\n\nDescription:\n    Creates a timeline of events that can happen. Waits/executes in an unscheduled\n     environment. \n    \n    There is a non-trivial amount of overhead to this, however, so\n     do not use with the intention of needing precise events to happen but rather to\n     not clog the scheduler or use a decent interface with smaller units of code.\n\n    (begin example)\n        // A timeline is made up of events:\n        [\n            [], // event 1\n            [] // event 2\n        ]\n    (end)\n\n    (begin example)\n        // Each event is made up of code to execute when the event comes up in the timeline,\n        /// and what to wait for when executing the NEXT event in the timeline AFTER the \n        /// current event completes:\n        [\n            [\n                {\n                    hint "executed event #1"\n                },\n                3 // wait 3 seconds AFTER current event to execute event 2\n            ],\n            [\n                {\n                    hint "executed event #2 3 seconds after event 1 completed"\n                },\n                1 // wait 1 second to run _onTimelineStopped code\n            ]\n        ]\n    (end)\n    \n    (begin example)\n        // Alternativeley, you can also wait for a condition before proceeeding to the next event:\n        private _endTime = time + 10;\n        [\n            [\n                {hint "executed event #1"},\n                3 // wait 3 seconds AFTER current event to execute event 1\n            ],\n            [\n                {hint "executed event #2 3 seconds after event 1 completed"},\n                [[_endTime],{\n                    _thisArgs params ["_endTime"];\n                    time >= (_endTime) // wait until current time is more than _endTime\n                }],\n                1 // check condition every second\n            ]\n        ]\n    (end)\n\n    (begin example)\n        // You can chain timeline events together by returning\n        [\n            [\n                {\n                    hint "executed event #1";\n                    time + 3 // return/send to the next event and current wait condition\n                },\n                {\n                    params ["","","","_eventReturn"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint "executed event #2 ~3 seconds after event 1 completed"}\n            ]\n        ]\n    (end)\n\nParameters:\n    0: _timeline <ARRAY> - An array of timeline events that will happen. \n        See description above for formats\n    1: _onTimelineStopped <CODE, STRING, or ARRAY> - (see KISKA_fnc_callBack),\n        code that will be executed once a timeline is stopped. \n            \n        Parameters:\n        - 0: <ARRAY> - The timeline array in the state when the stoppage actually happens.\n        - 1: <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n\nReturns:\n    <STRING> - The id of the new timeline\n\nExamples:\n    (begin example)\n        private _timeline = [\n            [\n                {\n                    hint "executed event #1";\n                    time + 3 // return/send to next and current wait condition\n                },\n                {\n                    params ["","","_eventReturn"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint "executed event #2 ~3 seconds after event 1 completed"}, 2\n            ]\n        ];\n        private _timelineId = [_timeline,{hint "timeline end"}] call KISKA_fnc_timeline_start;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName "KISKA_fnc_timeline_start";\n\nparams [\n    ["_timeline",[],[[]]],\n    ["_onTimelineStopped",{},[[],{},""]]\n];\n\nif (_timeline isEqualTo []) exitWith {\n    ["Empty _timeline provided"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _timelineId = ["KISKA_timeline"] call KISKA_fnc_generateUniqueId;\n[_timelineId,true] call KISKA_fnc_timeline_setIsRunning;\n\nprivate _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\nprivate _timelineHashmap = createHashMap;\nprivate _timelineValues = [_timeline,_timelineHashmap];\nif (_onTimelineStopped isNotEqualTo {}) then {\n    _timelineValues pushBack _onTimelineStopped;\n};\n\n_overallTimelineMap set [_timelineId,_timelineValues];\n\n[\n    _timeline,\n    _timelineId,\n    _timelineHashmap\n] call KISKA_fnc_timeline_executeEvent;\n\n\n_timelineId\n',
            fileName: "fn_timeline_start.sqf",
            documentationLink:
                "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Timeline/fn_timeline_start.sqf",
        },
    },
    {
        parsed: {
            documentation: {
                documentationLink:
                    "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Supports/Support%20Framework/Functions/fn_callingForHelicopterCAS.sqf",
                syntaxes: [
                    {
                        outline:
                            "[_supportClass, _commMenuArgs, _count] call `KISKA_fnc_callingForHelicopterCAS`",
                        parameters: [
                            {
                                name: "_supportClass",
                                description:
                                    "*(STRING)* - The class as defined in the CfgCommunicationMenu",
                            },
                            {
                                name: "_commMenuArgs",
                                description:
                                    "*(ARRAY)* - The arguements passed by the CfgCommunicationMenu entry\n\n    - 0. _caller *(OBJECT)* - The player calling for support\n    - 1. _targetPosition *(ARRAY)* - The position (AGLS) at which the call is being made\n        (where the player is looking or if in the map, the position where their cursor is)\n    - 2. _target *(OBJECT)* - The cursorTarget object of the player\n    - 3. _is3d *(BOOL)* - False if in map, true if not\n    - 4. _commMenuId *(NUMBER)* - The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n    - 5. _supportType *(NUMBER)* - The Support Type ID",
                            },
                            {
                                name: "_count",
                                description:
                                    "*(NUMBER)* - Used for keeping track of how many of a count a support has left (such as rounds)",
                            },
                        ],
                        returns: "NOTHING",
                    },
                ],
                examples: [
                    {
                        text: "```sqf\n[] call KISKA_fnc_callingForHelicopterCAS;\n```",
                    },
                ],
                description:
                    'Used as a means of expanding on the "expression" property of the CfgCommunicationMenu.\n\nThis is essentially just another level of abrstraction to be able to more easily reuse code between similar supports and make things easier to read instead of fitting it all in the config.',
            },
            configuration: {
                label: "KISKA_fnc_callingForHelicopterCAS",
                grammarType: "function",
            },
        },
        unparsed: {
            text: '#include "..\\Headers\\Command Menu Macros.hpp"\n#include "..\\Headers\\Support Type IDs.hpp"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForHelicopterCAS\n\nDescription:\n    Used as a means of expanding on the "expression" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n        \n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> - The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n        - 5. _supportType <NUMBER> - The Support Type ID\n\n    2: _count <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_callingForHelicopterCAS;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName "KISKA_fnc_callingForHelicopterCAS";\n\n#define MIN_RADIUS 200\n#define SPEED_LIMIT 10\n\nparams [\n    "_supportClass",\n    "_commMenuArgs",\n    ["_useCount",-1]\n];\n\n\nprivate _supportConfig = [["CfgCommunicationMenu",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [["Could not find class: ",_supportClass," in any config!"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _menuPathArray = [];\nprivate _menuVariables = []; // keeps track of global variable names to set to nil when done\n\n// get use count from config if -1\nprivate _args = _this; // just for readability\nprivate _useCountConfig = _supportConfig >> "useCount";\nif (_useCount < 0 AND (isNumber _useCountConfig)) then {\n    _useCount = getNumber _useCountConfig;\n    _args set [2,_useCount];\n};\n\n/* ----------------------------------------------------------------------------\n    Vehicle Select Menu\n---------------------------------------------------------------------------- */\nprivate _vehicles = [_supportConfig >> "vehicleTypes"] call BIS_fnc_getCfgDataArray;\nif (_vehicles isEqualTo []) then {\n    _vehicles = [side (_commMenuArgs select 0),_commMenuArgs select 5] call KISKA_fnc_getSupportVehicleClasses;\n};\n\nprivate _vehicleMenu = [_vehicles] call KISKA_fnc_createVehicleSelectMenu;\nSAVE_AND_PUSH(VEHICLE_SELECT_MENU_STR,_vehicleMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Bearings Menu\n---------------------------------------------------------------------------- */\n_bearingsMenu = BEARING_MENU;\n\nSAVE_AND_PUSH(BEARING_MENU_STR,_bearingsMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Radius Menu\n---------------------------------------------------------------------------- */\nprivate _selectableRadiuses = [_supportConfig >> "radiuses"] call BIS_fnc_getCfgDataArray;\nif (_selectableRadiuses isEqualTo []) then {\n    _selectableRadiuses = missionNamespace getVariable ["KISKA_CBA_supp_radiuses_arr",[]];\n\n    if (_selectableRadiuses isEqualTo []) then {\n        _selectableRadiuses = [200];\n    };\n};\n\nprivate _radiusMenu = [\n    ["Engagment Area",false]\n];\nprivate _keyCode = 0;\nprivate _pushedMinRadius = false;\nprivate _lasUsedIndex = 0;\n{\n    private _isMinRadius = _x <= MIN_RADIUS;\n    if (_pushedMinRadius AND _isMinRadius) then {\n        continue;\n    };\n\n    if (_lasUsedIndex <= MAX_KEYS) then {\n        // key codes are offset by 2 (1 on the number bar is key code 2)\n        _keyCode = _lasUsedIndex + 2;\n        _lasUsedIndex = _lasUsedIndex + 1;\n\n    } else {\n        // zero key code means that it has no key to press to activate it\n        _keyCode = 0;\n\n    };\n\n\n    if (_isMinRadius) then {\n        _pushedMinRadius = true;\n        _radiusMenu pushBack DISTANCE_LINE(MIN_RADIUS,_keyCode);\n        continue;\n    };\n\n    _radiusMenu pushBack DISTANCE_LINE(_x,_keyCode);\n\n} forEach _selectableRadiuses;\nSAVE_AND_PUSH(RADIUS_MENU_STR,_radiusMenu)\n\n\n/* ----------------------------------------------------------------------------\n    flyInHeight Menu\n---------------------------------------------------------------------------- */\nprivate _flyInHeights = [_supportConfig >> "flyinHeights"] call BIS_fnc_getCfgDataArray;\nif (_flyInHeights isEqualTo []) then {\n    _flyInHeights = missionNamespace getVariable ["KISKA_CBA_supp_flyInHeights_arr",[]];\n\n    if (_flyInHeights isEqualTo []) then {\n        _flyInHeights = [50];\n    };\n};\n\nprivate _flyInHeightMenu = [\n    ["Altitude",false]\n];\n{\n    _flyInHeightMenu pushBackUnique DISTANCE_LINE(_x,0);\n} forEach _flyInHeights;\nSAVE_AND_PUSH(FLYIN_HEIGHT_MENU_STR,_flyInHeightMenu)\n\n\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu Path\n---------------------------------------------------------------------------- */\n_args pushBack _menuVariables;\n\nprivate _timeOnStation = [_supportConfig >> "timeOnStation"] call BIS_fnc_getCfgData;\n_args pushBack _timeOnStation;\n\n[\n    _menuPathArray,\n    [_args, {\n        params ["_vehicleClass","_approachBearing","_attackRadius","_flyinHeight"];\n\n        private _useCount = _thisArgs select 2;\n        // if a ctrl key is held and one left clicks to select the support while in the map, they can call in an infinite number of the support\n        if (\n            visibleMap AND\n            (missionNamespace getVariable ["KISKA_ctrlDown",false])\n        ) exitWith {\n            ["You can\'t call in a support while holding down a crtl key and in the map. It causes a bug with the support menu."] call KISKA_fnc_errorNotification;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        private _commMenuArgs = _thisArgs select 1;\n        private _targetPosition = _commMenuArgs select 1;\n        private _timeOnStation = _thisArgs select 4;\n        [\n            _targetPosition,\n            _attackRadius,\n            _vehicleClass,\n            _timeOnStation,\n            SPEED_LIMIT,\n            _flyinHeight,\n            _approachBearing,\n            side (_commMenuArgs select 0) // caller side\n        ] spawn KISKA_fnc_helicopterGunner;\n\n        [SUPPORT_TYPE_HELI_CAS] call KISKA_fnc_supportNotification;\n\n        // if support still has uses left\n        if (_useCount > 1) then {\n            _useCount = _useCount - 1;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        UNLOAD_GLOBALS\n    }],\n    [_args, {\n        ADD_SUPPORT_BACK(_thisArgs select 2)\n        UNLOAD_GLOBALS\n    }]\n] spawn KISKA_fnc_commandMenuTree;\n\n\nnil\n',
            fileName: "fn_callingForHelicopterCAS.sqf",
            documentationLink:
                "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Supports/Support Framework/Functions/fn_callingForHelicopterCAS.sqf",
        },
    },
    {
        parsed: {
            documentation: {
                documentationLink:
                    "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getConditionalConfigValue.sqf",
                syntaxes: [
                    {
                        outline:
                            "[_conditionalConfig, _property, _isBool] call `KISKA_fnc_getConditionalConfigValue`",
                        parameters: [
                            {
                                name: "_conditionalConfig",
                                description:
                                    "*(CONFIG)* - Default: `configNull` - The config path to parse dynamic data from",
                            },
                            {
                                name: "_property",
                                description:
                                    '*(STRING)* - Default: `""` - The config path to parse dynamic data from',
                            },
                            {
                                name: "_isBool",
                                description:
                                    "*(BOOL)* - Default: `false` - Will convert a number value into a `BOOL`. If the value is more than `0`, the it will be `true`. Any values `<= 0` will be `false`",
                            },
                        ],
                        returns:
                            "*(NUMBER | STRING | ARRAY | BOOL)* - The value for the given conditional config.\n `nil` in cases where config value is not found or no conditions are met.",
                    },
                ],
                examples: [
                    {
                        text: '```sqf\nprivate _value = [\n    missionConfigFile >> "KISKA_Bases" >> "MyBase" >> "Conditional",\n    "myProperty"\n] call KISKA_fnc_getConditionalConfigValue;\n```',
                    },
                ],
                description:
                    'Retrieves the conditional value located in a given config. This code will cache configs and their values after being run once within the `localNamespace`.\n\nThe syntax for a conditional config:\n\n```cpp\n// `_conditionalConfig` param would be the config path to `MyConditionalClass`\nclass MyConditionalClass\n{\n    class ExampleCondition_1\n    {\n        // A list of addon directories (names) as they would appear in getLoadedModsInfo (case-insensitive).\n        // All addons in the list must be loaded present.\n        addons[] = { "A3" };\n\n        // A list of CfgPatches classNames that need to be present.\n        patches[] = { "A3_Data_F"};\n\n        // Uncompiled code that must return a boolean value.\n        // `false` means the ExampleCondition_1\'s value will not be used\n            // Parameters:\n            // 0: <CONFIG> - The parent condition class (MyConditionalClass)\n            // 1: <CONFIG> - The current conditional class (MyConditionalClass >> ExampleCondition_1)\n            // 2: <STRING> - The property being searched for\n        condition = "hint str _this; true";\n\n        // A class filled with the properties that you can get\n        class properties\n        {\n            exampleProperty_1 = 1;\n        };\n    };\n\n    class ExampleCondition_2\n    {\n        class properties\n        {\n            exampleProperty_1 = 0;\n            exampleProperty_2 = 1;\n        };\n    };\n};\n```\n\n\nConfigs will be prioritized in the order that they are defined. Meaning in the example above, should both `ExampleCondition_1` and `ExampleCondition_2` be met, `ExampleCondition_1` will be used since it is defined higher.\n\nAnother important note, **only** the highest priority conditional classes\' values will be retrievable. Taking the example above again, the `ExampleCondition_1` class does not have `exampleProperty_2`\n defined. But assuming `ExampleCondition_1`\'s conditions are met and it is chosen, `KISKA_fnc_getConditionalConfigValue`\n will then return `nil` when searching in `MyConditionalClass` for a value at `exampleProperty_2`.\n\nShould any of the conditional properties (`addons`,`patches`,`condition`) be excluded, they will simply be treated as a `true` value. Meaning that if none of the properties are defined, the conditional class will always be valid.',
            },
            configuration: {
                label: "KISKA_fnc_getConditionalConfigValue",
                grammarType: "function",
            },
        },
        unparsed: {
            text: '/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_getConditionalConfigValue\n\nDescription:\n    Retrieves the conditional value located in a given config. This code will cache\n     configs and their values after being run once within the `localNamespace`.\n\n    The syntax for a conditional config:\n    (begin config example)\n        // `_conditionalConfig` param would be the config path to `MyConditionalClass`\n        class MyConditionalClass\n        {\n            class ExampleCondition_1\n            {\n                // A list of addon directories (names) as they would appear in getLoadedModsInfo (case-insensitive).\n                // All addons in the list must be loaded present.\n                addons[] = { "A3" };\n\n                // A list of CfgPatches classNames that need to be present.\n                patches[] = { "A3_Data_F"};\n\n                // Uncompiled code that must return a boolean value.\n                // `false` means the ExampleCondition_1\'s value will not be used\n                    // Parameters:\n                    // 0: <CONFIG> - The parent condition class (MyConditionalClass)\n                    // 1: <CONFIG> - The current conditional class (MyConditionalClass >> ExampleCondition_1)\n                    // 2: <STRING> - The property being searched for\n                condition = "hint str _this; true";\n\n                // A class filled with the properties that you can get\n                class properties\n                {\n                    exampleProperty_1 = 1;\n                };\n            };\n\n            class ExampleCondition_2\n            {\n                class properties\n                {\n                    exampleProperty_1 = 0;\n                    exampleProperty_2 = 1;\n                };\n            };\n        };\n    (end)\n\n    Configs will be prioritized in the order that they are defined. Meaning in the example above,\n     should both `ExampleCondition_1` and `ExampleCondition_2` be met, `ExampleCondition_1` will be used since it is\n     defined higher.\n\n    Another important note, **only** the highest priority conditional classes\' values will be\n     retrievable. Taking the example above again, the `ExampleCondition_1` class does not have `exampleProperty_2`\n     defined. But assuming `ExampleCondition_1`\'s conditions are met and it is chosen, `KISKA_fnc_getConditionalConfigValue`\n     will then return `nil` when searching in `MyConditionalClass` for a value at `exampleProperty_2`.\n    \n    Should any of the conditional properties (`addons`,`patches`,`condition`) be excluded, they will simply \n     be treated as a `true` value. Meaning that if none of the properties are defined, the conditional class\n     will always be valid.\n\nParameters:\n    0: _conditionalConfig <CONFIG> - Default: `configNull` - The config path to parse dynamic data from\n    1: _property <STRING> - Default: `""` - The config path to parse dynamic data from\n    2: _isBool <BOOL> - Default: `false` - Will convert a number value into a `BOOL`. If the value\n        is more than `0`, the it will be `true`. Any values `<= 0` will be `false`\n\nReturns:\n    <NUMBER | STRING | ARRAY | BOOL> - The value for the given conditional config.\n     `nil` in cases where config value is not found or no conditions are met.\n\nExamples:\n    (begin example)\n        private _value = [\n            missionConfigFile >> "KISKA_Bases" >> "MyBase" >> "Conditional",\n            "myProperty"\n        ] call KISKA_fnc_getConditionalConfigValue;\n    (end)\n\nAuthor:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName "KISKA_fnc_getConditionalConfigValue";\n\nparams [\n    ["_conditionalConfig",configNull,[configNull]],\n    ["_property","",[""]],\n    ["_isBool",false,[true]]\n];\n\n\nif (isNull _conditionalConfig) exitWith {\n    ["null config provided",false] call KISKA_fnc_log;\n    nil\n};\n\nprivate _modDirectoriesLowered = uiNamespace getVariable "KISKA_conditionalConfig_loadedMods";\nif (isNil "_modDirectoriesLowered") then {\n    private _loadedModsInfo = call KISKA_fnc_getLoadedModsInfo;\n    _modDirectoriesLowered = _loadedModsInfo apply { \n        private _modDirectoryName = _x select 1;\n        toLowerANSI _modDirectoryName   \n    };\n    uiNamespace setVariable ["KISKA_conditionalConfig_loadedMods",_modDirectoriesLowered];\n};\n\nprivate _conditionalClassesMap = localNamespace getVariable "KISKA_conditionalConfig_parsedConfigMap";\nif (isNil "_conditionalClassesMap") then {\n    _conditionalClassesMap = createHashMap;\n    localNamespace setVariable ["KISKA_conditionalConfig_parsedConfigMap",_conditionalClassesMap];\n};\n\nprivate _alreadyParsedConfigs = _conditionalClassesMap get _conditionalConfig;\nprivate _conditionArgs = [_conditionalConfig,configNull,_property];\nprivate "_propertyValue";\nif !(isNil "_alreadyParsedConfigs") exitWith {\n    _alreadyParsedConfigs apply {\n        _x params ["_conditionalClassConfig","_condition"];\n        _conditionArgs set [1,_conditionalClassConfig];\n\n        if (\n            (_condition isEqualTo {}) OR \n            {_conditionArgs call _condition}\n        ) then {\n            _propertyValue = [\n                _conditionalClassConfig >> "properties" >> _property,\n                _isBool\n            ] call KISKA_fnc_getConfigData;\n\n            break;\n        };\n    };\n\n    _propertyValue\n};\n\n\nprivate _conditionalConfigClasses = configProperties [_conditionalConfig,"isClass _x"];\n_alreadyParsedConfigs = [];\n_conditionalConfigClasses apply {\n    private _meetsStaticRequirements = true;\n\n    private _requiredPatches = getArray(_x >> "patches");\n    _requiredPatches apply {\n        if !([_x] call KISKA_fnc_isPatchLoaded) then { \n\t\t\t_meetsStaticRequirements = false;\n\t\t\tbreak;\n\t\t};\n    };\n    if !(_meetsStaticRequirements) then { continue };\n\n\n    private _requiredAddons = getArray(_x >> "addons");\n    _requiredAddons apply {\n        if !((toLowerANSI _x) in _modDirectoriesLowered) then { \n\t\t\t_meetsStaticRequirements = false;\n\t\t\tbreak;\n\t\t};\n    };\n    if !(_meetsStaticRequirements) then { continue };\n\n    \n    private _condition = compile (getText(_x >> "condition"));\n    _alreadyParsedConfigs pushBack [_x,_condition];\n\n\n    _conditionArgs set [1,_x];\n    if (\n        (isNil "_propertyValue") AND \n        {\n            (_condition isEqualTo {}) OR \n            {_conditionArgs call _condition}\n        }\n    ) then {\n        _propertyValue = [\n            _x >> "properties" >> _property,\n            _isBool\n        ] call KISKA_fnc_getConfigData;\n    };\n};\n\n_conditionalClassesMap set [_conditionalConfig,_alreadyParsedConfigs];\n\n\n_propertyValue\n',
            fileName: "fn_getConditionalConfigValue.sqf",
            documentationLink:
                "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Functions/Utilities/fn_getConditionalConfigValue.sqf",
        },
    },
];
