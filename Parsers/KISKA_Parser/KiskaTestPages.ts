import { SQFItemConfig } from "../../configuration/grammars/sqf.namespace";
import { UnparsedKiskaPage } from "./KiskaParser";

export const KiskaTestPages: { parsed: SQFItemConfig; unparsed: UnparsedKiskaPage }[] = [
    {
        parsed: {
            documentation: {
                documentationLink:
                    "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Timeline/fn_timeline_start.sqf",
                syntaxes: [
                    {
                        outline: "[_timeline, _onTimelineStopped] call `KISKA_fnc_timeline_start`",
                        parameters: [
                            {
                                name: "_timeline",
                                description:
                                    "*(ARRAY)* - An array of timeline events that will happen. See description above for formats",
                            },
                            {
                                name: "_onTimelineStopped",
                                description:
                                    "*(CODE, STRING, or ARRAY)* - (see KISKA_fnc_callBack), code that will be executed once a timeline is stopped.\n\n    Parameters:\n    - 0: *(ARRAY)* - The timeline array in the state when the stoppage actually happens.\n    - 1: *(HASHMAP)* - The Individual map defined for a specific timeline of the given ID",
                            },
                        ],
                        returns: "*(STRING)* - The id of the new timeline",
                    },
                ],
                examples: [
                    {
                        text: '```sqf\nprivate _timeline = [\n    [\n        {\n            hint "executed event #1";\n            time + 3 // return/send to next and current wait condition\n        },\n        {\n            params ["","","_eventReturn"];\n            private _timeAfterWait = _eventReturn;\n            time >= _timeAfterWait // wait until current time is more than time + 3\n        },\n    ],\n    [\n        {hint "executed event #2 ~3 seconds after event 1 completed"}, 2\n    ]\n];\nprivate _timelineId = [_timeline,{hint "timeline end"}] call KISKA_fnc_timeline_start;\n```',
                    },
                ],
                description:
                    'Creates a timeline of events that can happen. Waits/executes in an unscheduled environment.\n\nThere is a non-trivial amount of overhead to this, however, so do not use with the intention of needing precise events to happen but rather to not clog the scheduler or use a decent interface with smaller units of code.\n\n\n```sqf\n// A timeline is made up of events:\n[\n    [], // event 1\n    [] // event 2\n]\n```\n\n\n\n```sqf\n// Each event is made up of code to execute when the event comes up in the timeline,\n/// and what to wait for when executing the NEXT event in the timeline AFTER the \n/// current event completes:\n[\n    [\n        {\n            hint "executed event #1"\n        },\n        3 // wait 3 seconds AFTER current event to execute event 2\n    ],\n    [\n        {\n            hint "executed event #2 3 seconds after event 1 completed"\n        },\n        1 // wait 1 second to run _onTimelineStopped code\n    ]\n]\n```\n\n\n\n```sqf\n// Alternativeley, you can also wait for a condition before proceeeding to the next event:\nprivate _endTime = time + 10;\n[\n    [\n        {hint "executed event #1"},\n        3 // wait 3 seconds AFTER current event to execute event 1\n    ],\n    [\n        {hint "executed event #2 3 seconds after event 1 completed"},\n        [[_endTime],{\n            _thisArgs params ["_endTime"];\n            time >= (_endTime) // wait until current time is more than _endTime\n        }],\n        1 // check condition every second\n    ]\n]\n```\n\n\n\n```sqf\n// You can chain timeline events together by returning\n[\n    [\n        {\n            hint "executed event #1";\n            time + 3 // return/send to the next event and current wait condition\n        },\n        {\n            params ["","","","_eventReturn"];\n            private _timeAfterWait = _eventReturn;\n            time >= _timeAfterWait // wait until current time is more than time + 3\n        },\n    ],\n    [\n        {hint "executed event #2 ~3 seconds after event 1 completed"}\n    ]\n]\n```',
            },
            configuration: {
                label: "KISKA_fnc_timeline_start",
                grammarType: "function",
            },
        },
        unparsed: {
            text: '/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_start\n\nDescription:\n    Creates a timeline of events that can happen. Waits/executes in an unscheduled\n     environment. \n    \n    There is a non-trivial amount of overhead to this, however, so\n     do not use with the intention of needing precise events to happen but rather to\n     not clog the scheduler or use a decent interface with smaller units of code.\n\n    (begin example)\n        // A timeline is made up of events:\n        [\n            [], // event 1\n            [] // event 2\n        ]\n    (end)\n\n    (begin example)\n        // Each event is made up of code to execute when the event comes up in the timeline,\n        /// and what to wait for when executing the NEXT event in the timeline AFTER the \n        /// current event completes:\n        [\n            [\n                {\n                    hint "executed event #1"\n                },\n                3 // wait 3 seconds AFTER current event to execute event 2\n            ],\n            [\n                {\n                    hint "executed event #2 3 seconds after event 1 completed"\n                },\n                1 // wait 1 second to run _onTimelineStopped code\n            ]\n        ]\n    (end)\n    \n    (begin example)\n        // Alternativeley, you can also wait for a condition before proceeeding to the next event:\n        private _endTime = time + 10;\n        [\n            [\n                {hint "executed event #1"},\n                3 // wait 3 seconds AFTER current event to execute event 1\n            ],\n            [\n                {hint "executed event #2 3 seconds after event 1 completed"},\n                [[_endTime],{\n                    _thisArgs params ["_endTime"];\n                    time >= (_endTime) // wait until current time is more than _endTime\n                }],\n                1 // check condition every second\n            ]\n        ]\n    (end)\n\n    (begin example)\n        // You can chain timeline events together by returning\n        [\n            [\n                {\n                    hint "executed event #1";\n                    time + 3 // return/send to the next event and current wait condition\n                },\n                {\n                    params ["","","","_eventReturn"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint "executed event #2 ~3 seconds after event 1 completed"}\n            ]\n        ]\n    (end)\n\nParameters:\n    0: _timeline <ARRAY> - An array of timeline events that will happen. \n        See description above for formats\n    1: _onTimelineStopped <CODE, STRING, or ARRAY> - (see KISKA_fnc_callBack),\n        code that will be executed once a timeline is stopped. \n            \n        Parameters:\n        - 0: <ARRAY> - The timeline array in the state when the stoppage actually happens.\n        - 1: <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n\nReturns:\n    <STRING> - The id of the new timeline\n\nExamples:\n    (begin example)\n        private _timeline = [\n            [\n                {\n                    hint "executed event #1";\n                    time + 3 // return/send to next and current wait condition\n                },\n                {\n                    params ["","","_eventReturn"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint "executed event #2 ~3 seconds after event 1 completed"}, 2\n            ]\n        ];\n        private _timelineId = [_timeline,{hint "timeline end"}] call KISKA_fnc_timeline_start;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName "KISKA_fnc_timeline_start";\n\nparams [\n    ["_timeline",[],[[]]],\n    ["_onTimelineStopped",{},[[],{},""]]\n];\n\nif (_timeline isEqualTo []) exitWith {\n    ["Empty _timeline provided"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _timelineId = ["KISKA_timeline"] call KISKA_fnc_generateUniqueId;\n[_timelineId,true] call KISKA_fnc_timeline_setIsRunning;\n\nprivate _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\nprivate _timelineHashmap = createHashMap;\nprivate _timelineValues = [_timeline,_timelineHashmap];\nif (_onTimelineStopped isNotEqualTo {}) then {\n    _timelineValues pushBack _onTimelineStopped;\n};\n\n_overallTimelineMap set [_timelineId,_timelineValues];\n\n[\n    _timeline,\n    _timelineId,\n    _timelineHashmap\n] call KISKA_fnc_timeline_executeEvent;\n\n\n_timelineId\n',
            fileName: "fn_timeline_start.sqf",
            documentationLink:
                "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Timeline/fn_timeline_start.sqf",
        },
    },
    {
        parsed: {
            documentation: {
                documentationLink:
                    "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Supports/Support%20Framework/Functions/fn_callingForHelicopterCAS.sqf",
                syntaxes: [
                    {
                        outline:
                            "[_supportClass, _commMenuArgs, _count] call `KISKA_fnc_callingForHelicopterCAS`",
                        parameters: [
                            {
                                name: "_supportClass",
                                description:
                                    "*(STRING)* - The class as defined in the CfgCommunicationMenu",
                            },
                            {
                                name: "_commMenuArgs",
                                description:
                                    "*(ARRAY)* - The arguements passed by the CfgCommunicationMenu entry\n\n    - 0. _caller *(OBJECT)* - The player calling for support\n    - 1. _targetPosition *(ARRAY)* - The position (AGLS) at which the call is being made\n        (where the player is looking or if in the map, the position where their cursor is)\n    - 2. _target *(OBJECT)* - The cursorTarget object of the player\n    - 3. _is3d *(BOOL)* - False if in map, true if not\n    - 4. _commMenuId *(NUMBER)* - The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n    - 5. _supportType *(NUMBER)* - The Support Type ID",
                            },
                            {
                                name: "_count",
                                description:
                                    "*(NUMBER)* - Used for keeping track of how many of a count a support has left (such as rounds)",
                            },
                        ],
                        returns: "NOTHING",
                    },
                ],
                examples: [
                    {
                        text: "```sqf\n[] call KISKA_fnc_callingForHelicopterCAS;\n```",
                    },
                ],
                description:
                    'Used as a means of expanding on the "expression" property of the CfgCommunicationMenu.\n\nThis is essentially just another level of abrstraction to be able to more easily reuse code between similar supports and make things easier to read instead of fitting it all in the config.',
            },
            configuration: {
                label: "KISKA_fnc_callingForHelicopterCAS",
                grammarType: "function",
            },
        },
        unparsed: {
            text: '#include "..\\Headers\\Command Menu Macros.hpp"\n#include "..\\Headers\\Support Type IDs.hpp"\n/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_callingForHelicopterCAS\n\nDescription:\n    Used as a means of expanding on the "expression" property of the CfgCommunicationMenu.\n\n    This is essentially just another level of abrstraction to be able to more easily reuse\n     code between similar supports and make things easier to read instead of fitting it all\n     in the config.\n\nParameters:\n    0: _supportClass <STRING> - The class as defined in the CfgCommunicationMenu\n    1: _commMenuArgs <ARRAY> - The arguements passed by the CfgCommunicationMenu entry\n        \n        - 0. _caller <OBJECT> - The player calling for support\n        - 1. _targetPosition <ARRAY> - The position (AGLS) at which the call is being made\n            (where the player is looking or if in the map, the position where their cursor is)\n        - 2. _target <OBJECT> - The cursorTarget object of the player\n        - 3. _is3d <BOOL> - False if in map, true if not\n        - 4. _commMenuId <NUMBER> - The ID number of the Comm Menu added by BIS_fnc_addCommMenuItem\n        - 5. _supportType <NUMBER> - The Support Type ID\n\n    2: _count <NUMBER> - Used for keeping track of how many of a count a support has left (such as rounds)\n\nReturns:\n    NOTHING\n\nExamples:\n    (begin example)\n        [] call KISKA_fnc_callingForHelicopterCAS;\n    (end)\n\nAuthors:\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName "KISKA_fnc_callingForHelicopterCAS";\n\n#define MIN_RADIUS 200\n#define SPEED_LIMIT 10\n\nparams [\n    "_supportClass",\n    "_commMenuArgs",\n    ["_useCount",-1]\n];\n\n\nprivate _supportConfig = [["CfgCommunicationMenu",_supportClass]] call KISKA_fnc_findConfigAny;\nif (isNull _supportConfig) exitWith {\n    [["Could not find class: ",_supportClass," in any config!"],true] call KISKA_fnc_log;\n    nil\n};\n\n\nprivate _menuPathArray = [];\nprivate _menuVariables = []; // keeps track of global variable names to set to nil when done\n\n// get use count from config if -1\nprivate _args = _this; // just for readability\nprivate _useCountConfig = _supportConfig >> "useCount";\nif (_useCount < 0 AND (isNumber _useCountConfig)) then {\n    _useCount = getNumber _useCountConfig;\n    _args set [2,_useCount];\n};\n\n/* ----------------------------------------------------------------------------\n    Vehicle Select Menu\n---------------------------------------------------------------------------- */\nprivate _vehicles = [_supportConfig >> "vehicleTypes"] call BIS_fnc_getCfgDataArray;\nif (_vehicles isEqualTo []) then {\n    _vehicles = [side (_commMenuArgs select 0),_commMenuArgs select 5] call KISKA_fnc_getSupportVehicleClasses;\n};\n\nprivate _vehicleMenu = [_vehicles] call KISKA_fnc_createVehicleSelectMenu;\nSAVE_AND_PUSH(VEHICLE_SELECT_MENU_STR,_vehicleMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Bearings Menu\n---------------------------------------------------------------------------- */\n_bearingsMenu = BEARING_MENU;\n\nSAVE_AND_PUSH(BEARING_MENU_STR,_bearingsMenu)\n\n\n/* ----------------------------------------------------------------------------\n    Radius Menu\n---------------------------------------------------------------------------- */\nprivate _selectableRadiuses = [_supportConfig >> "radiuses"] call BIS_fnc_getCfgDataArray;\nif (_selectableRadiuses isEqualTo []) then {\n    _selectableRadiuses = missionNamespace getVariable ["KISKA_CBA_supp_radiuses_arr",[]];\n\n    if (_selectableRadiuses isEqualTo []) then {\n        _selectableRadiuses = [200];\n    };\n};\n\nprivate _radiusMenu = [\n    ["Engagment Area",false]\n];\nprivate _keyCode = 0;\nprivate _pushedMinRadius = false;\nprivate _lasUsedIndex = 0;\n{\n    private _isMinRadius = _x <= MIN_RADIUS;\n    if (_pushedMinRadius AND _isMinRadius) then {\n        continue;\n    };\n\n    if (_lasUsedIndex <= MAX_KEYS) then {\n        // key codes are offset by 2 (1 on the number bar is key code 2)\n        _keyCode = _lasUsedIndex + 2;\n        _lasUsedIndex = _lasUsedIndex + 1;\n\n    } else {\n        // zero key code means that it has no key to press to activate it\n        _keyCode = 0;\n\n    };\n\n\n    if (_isMinRadius) then {\n        _pushedMinRadius = true;\n        _radiusMenu pushBack DISTANCE_LINE(MIN_RADIUS,_keyCode);\n        continue;\n    };\n\n    _radiusMenu pushBack DISTANCE_LINE(_x,_keyCode);\n\n} forEach _selectableRadiuses;\nSAVE_AND_PUSH(RADIUS_MENU_STR,_radiusMenu)\n\n\n/* ----------------------------------------------------------------------------\n    flyInHeight Menu\n---------------------------------------------------------------------------- */\nprivate _flyInHeights = [_supportConfig >> "flyinHeights"] call BIS_fnc_getCfgDataArray;\nif (_flyInHeights isEqualTo []) then {\n    _flyInHeights = missionNamespace getVariable ["KISKA_CBA_supp_flyInHeights_arr",[]];\n\n    if (_flyInHeights isEqualTo []) then {\n        _flyInHeights = [50];\n    };\n};\n\nprivate _flyInHeightMenu = [\n    ["Altitude",false]\n];\n{\n    _flyInHeightMenu pushBackUnique DISTANCE_LINE(_x,0);\n} forEach _flyInHeights;\nSAVE_AND_PUSH(FLYIN_HEIGHT_MENU_STR,_flyInHeightMenu)\n\n\n\n\n/* ----------------------------------------------------------------------------\n    Create Menu Path\n---------------------------------------------------------------------------- */\n_args pushBack _menuVariables;\n\nprivate _timeOnStation = [_supportConfig >> "timeOnStation"] call BIS_fnc_getCfgData;\n_args pushBack _timeOnStation;\n\n[\n    _menuPathArray,\n    [_args, {\n        params ["_vehicleClass","_approachBearing","_attackRadius","_flyinHeight"];\n\n        private _useCount = _thisArgs select 2;\n        // if a ctrl key is held and one left clicks to select the support while in the map, they can call in an infinite number of the support\n        if (\n            visibleMap AND\n            (missionNamespace getVariable ["KISKA_ctrlDown",false])\n        ) exitWith {\n            ["You can\'t call in a support while holding down a crtl key and in the map. It causes a bug with the support menu."] call KISKA_fnc_errorNotification;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        private _commMenuArgs = _thisArgs select 1;\n        private _targetPosition = _commMenuArgs select 1;\n        private _timeOnStation = _thisArgs select 4;\n        [\n            _targetPosition,\n            _attackRadius,\n            _vehicleClass,\n            _timeOnStation,\n            SPEED_LIMIT,\n            _flyinHeight,\n            _approachBearing,\n            side (_commMenuArgs select 0) // caller side\n        ] spawn KISKA_fnc_helicopterGunner;\n\n        [SUPPORT_TYPE_HELI_CAS] call KISKA_fnc_supportNotification;\n\n        // if support still has uses left\n        if (_useCount > 1) then {\n            _useCount = _useCount - 1;\n            ADD_SUPPORT_BACK(_useCount)\n        };\n\n        UNLOAD_GLOBALS\n    }],\n    [_args, {\n        ADD_SUPPORT_BACK(_thisArgs select 2)\n        UNLOAD_GLOBALS\n    }]\n] spawn KISKA_fnc_commandMenuTree;\n\n\nnil\n',
            fileName: "fn_callingForHelicopterCAS.sqf",
            documentationLink:
                "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Supports/Support Framework/Functions/fn_callingForHelicopterCAS.sqf",
        },
    },
];
