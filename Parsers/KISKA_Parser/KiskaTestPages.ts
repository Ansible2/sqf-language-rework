import { SQFItemConfig } from "../../configuration/grammars/sqf.namespace";
import { UnparsedKiskaPage } from "./KiskaParser";

export const KiskaTestPages: { parsed: SQFItemConfig; unparsed: UnparsedKiskaPage }[] = [
    {
        parsed: {
            documentation: {
                documentationLink:
                    "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Timeline/fn_timeline_start.sqf",
                syntaxes: [
                    {
                        outline: "[_timeline, _onTimelineStopped] call `KISKA_fnc_timeline_start`",
                        parameters: [
                            {
                                name: "_timeline",
                                description:
                                    "*(ARRAY)* - An array of timeline events that will happen. See description above for formats",
                            },
                            {
                                name: "_onTimelineStopped",
                                description:
                                    "*(CODE, STRING, or ARRAY)* - (see KISKA_fnc_callBack), code that will be executed once a timeline is stopped. \n \n    Parameters:\n    - 0: *(ARRAY)* - The timeline array in the state when the stoppage actually happens.\n    - 1: *(HASHMAP)* - The Individual map defined for a specific timeline of the given ID",
                            },
                        ],
                        returns: "*(STRING)* - The id of the new timeline",
                    },
                ],
                examples: [
                    {
                        text: '```sqf\nprivate _timeline = [\n    [\n        {\n            hint "executed event #1";\n            time + 3 // return/send to next and current wait condition\n        },\n        {\n            params ["","","_eventReturn"];\n            private _timeAfterWait = _eventReturn;\n            time >= _timeAfterWait // wait until current time is more than time + 3\n        },\n    ],\n    [\n        {hint "executed event #2 ~3 seconds after event 1 completed"}, 2\n    ]\n];\nprivate _timelineId = [_timeline,{hint "timeline end"}] call KISKA_fnc_timeline_start;\n```',
                    },
                ],
                description:
                    'Creates a timeline of events that can happen. Waits/executes in an unscheduled environment. \n \nThere is a non-trivial amount of overhead to this, however, so do not use with the intention of needing precise events to happen but rather to not clog the scheduler or use a decent interface with smaller units of code.\n\n\n```sqf\n// A timeline is made up of events:\n[\n    [], // event 1\n    [] // event 2\n]\n```\n\n\n\n```sqf\n// Each event is made up of code to execute when the event comes up in the timeline,\n/// and what to wait for when executing the NEXT event in the timeline AFTER the \n/// current event completes:\n[\n    [\n        {\n            hint "executed event #1"\n        },\n        3 // wait 3 seconds AFTER current event to execute event 2\n    ],\n    [\n        {\n            hint "executed event #2 3 seconds after event 1 completed"\n        },\n        1 // wait 1 second to run _onTimelineStopped code\n    ]\n]\n```\n\n \n\n```sqf\n// Alternativeley, you can also wait for a condition before proceeeding to the next event:\nprivate _endTime = time + 10;\n[\n    [\n        {hint "executed event #1"},\n        3 // wait 3 seconds AFTER current event to execute event 1\n    ],\n    [\n        {hint "executed event #2 3 seconds after event 1 completed"},\n        [[_endTime],{\n            _thisArgs params ["_endTime"];\n            time >= (_endTime) // wait until current time is more than _endTime\n        }],\n        1 // check condition every second\n    ]\n]\n```\n\n\n\n```sqf\n// You can chain timeline events together by returning\n[\n    [\n        {\n            hint "executed event #1";\n            time + 3 // return/send to the next event and current wait condition\n        },\n        {\n            params ["","","","_eventReturn"];\n            private _timeAfterWait = _eventReturn;\n            time >= _timeAfterWait // wait until current time is more than time + 3\n        },\n    ],\n    [\n        {hint "executed event #2 ~3 seconds after event 1 completed"}\n    ]\n]\n```',
            },
            configuration: {
                label: "KISKA_fnc_timeline_start",
                grammarType: "function",
            },
        },
        unparsed: {
            text: '/* ----------------------------------------------------------------------------\nFunction: KISKA_fnc_timeline_start\n\nDescription:\n    Creates a timeline of events that can happen. Waits/executes in an unscheduled\n     environment. \n    \n    There is a non-trivial amount of overhead to this, however, so\n     do not use with the intention of needing precise events to happen but rather to\n     not clog the scheduler or use a decent interface with smaller units of code.\n\n    (begin example)\n        // A timeline is made up of events:\n        [\n            [], // event 1\n            [] // event 2\n        ]\n    (end)\n\n    (begin example)\n        // Each event is made up of code to execute when the event comes up in the timeline,\n        /// and what to wait for when executing the NEXT event in the timeline AFTER the \n        /// current event completes:\n        [\n            [\n                {\n                    hint "executed event #1"\n                },\n                3 // wait 3 seconds AFTER current event to execute event 2\n            ],\n            [\n                {\n                    hint "executed event #2 3 seconds after event 1 completed"\n                },\n                1 // wait 1 second to run _onTimelineStopped code\n            ]\n        ]\n    (end)\n    \n    (begin example)\n        // Alternativeley, you can also wait for a condition before proceeeding to the next event:\n        private _endTime = time + 10;\n        [\n            [\n                {hint "executed event #1"},\n                3 // wait 3 seconds AFTER current event to execute event 1\n            ],\n            [\n                {hint "executed event #2 3 seconds after event 1 completed"},\n                [[_endTime],{\n                    _thisArgs params ["_endTime"];\n                    time >= (_endTime) // wait until current time is more than _endTime\n                }],\n                1 // check condition every second\n            ]\n        ]\n    (end)\n\n    (begin example)\n        // You can chain timeline events together by returning\n        [\n            [\n                {\n                    hint "executed event #1";\n                    time + 3 // return/send to the next event and current wait condition\n                },\n                {\n                    params ["","","","_eventReturn"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint "executed event #2 ~3 seconds after event 1 completed"}\n            ]\n        ]\n    (end)\n\nParameters:\n    0: _timeline <ARRAY> - An array of timeline events that will happen. \n        See description above for formats\n    1: _onTimelineStopped <CODE, STRING, or ARRAY> - (see KISKA_fnc_callBack),\n        code that will be executed once a timeline is stopped. \n            \n        Parameters:\n        - 0: <ARRAY> - The timeline array in the state when the stoppage actually happens.\n        - 1: <HASHMAP> - The Individual map defined for a specific timeline of the given ID\n\nReturns:\n    <STRING> - The id of the new timeline\n\nExamples:\n    (begin example)\n        private _timeline = [\n            [\n                {\n                    hint "executed event #1";\n                    time + 3 // return/send to next and current wait condition\n                },\n                {\n                    params ["","","_eventReturn"];\n                    private _timeAfterWait = _eventReturn;\n                    time >= _timeAfterWait // wait until current time is more than time + 3\n                },\n            ],\n            [\n                {hint "executed event #2 ~3 seconds after event 1 completed"}, 2\n            ]\n        ];\n        private _timelineId = [_timeline,{hint "timeline end"}] call KISKA_fnc_timeline_start;\n    (end)\n\nAuthor(s):\n    Ansible2\n---------------------------------------------------------------------------- */\nscriptName "KISKA_fnc_timeline_start";\n\nparams [\n    ["_timeline",[],[[]]],\n    ["_onTimelineStopped",{},[[],{},""]]\n];\n\nif (_timeline isEqualTo []) exitWith {\n    ["Empty _timeline provided"] call KISKA_fnc_log;\n    nil\n};\n\nprivate _timelineId = ["KISKA_timeline"] call KISKA_fnc_generateUniqueId;\n[_timelineId,true] call KISKA_fnc_timeline_setIsRunning;\n\nprivate _overallTimelineMap = call KISKA_fnc_timeline_getMainMap;\nprivate _timelineHashmap = createHashMap;\nprivate _timelineValues = [_timeline,_timelineHashmap];\nif (_onTimelineStopped isNotEqualTo {}) then {\n    _timelineValues pushBack _onTimelineStopped;\n};\n\n_overallTimelineMap set [_timelineId,_timelineValues];\n\n[\n    _timeline,\n    _timelineId,\n    _timelineHashmap\n] call KISKA_fnc_timeline_executeEvent;\n\n\n_timelineId\n',
            fileName: "fn_timeline_start.sqf",
            documentationLink:
                "https://github.com/Ansible2/Kiska-Function-Library/blob/master/addons/Kiska_Functions/Timeline/fn_timeline_start.sqf",
        },
    },
];
